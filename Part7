  04:54:13.836  ----- [2534] ServerScriptService.Library.Give -----  -  Editar
  04:54:13.836  --[[        
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Give | SERVER
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local Give = {}

local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Saving = require(script.Parent.Saving)
local Settings = require(script.Parent.Settings)
local Directory = require(Library.Directory)
local Shared = require(Library.Shared)

function Give.Currency(player, amountGiving, currencyType, softGive)
	amountGiving = tonumber(amountGiving)
	currencyType = tostring(currencyType)
	
	local save = Saving.Get(player)
	if (not save) then 
		return 
	end
	
	if not amountGiving or amountGiving ~= amountGiving then
		return warn("Prevented possible NaN for giving coins")
	end
	
	currencyType = currencyType or "Coins"
	amountGiving = math.round(amountGiving or 0)
	
	local playerCurrency = currencyType ~= 'Diamonds' and (Shared.IsHardcore and save.HardcoreCurrency[currencyType]) or save[currencyType]
	if playerCurrency == -1 then
		playerCurrency = 0
		save[currencyType] = 0
	end
    
    if Shared.IsHardcore and currencyType ~= "Diamonds" then
        save.HardcoreCurrency[currencyType] = softGive and save.HardcoreCurrency[currencyType] + amountGiving or math.clamp(save.HardcoreCurrency[currencyType] + amountGiving,0,Directory.Currency[currencyType].Limit) 
    else
        save[currencyType] = softGive and save[currencyType] + amountGiving or math.clamp(save[currencyType] + amountGiving,0,Directory.Currency[currencyType].Limit) 
    end
    
    local currencySubbed = save[currencyType] - playerCurrency
	
	return currencySubbed ~= playerCurrency, currencySubbed
end

function Give.GiveCurrency(player, currency, amount, type)
	amount =  math.round(tonumber(amount) or 0)
	currency = tostring(currency) or "Coins"
	
	local save = Saving.Get(player)
	if (not save) then 
		return 
	end

	if not amount or amount ~= amount then
		return warn("Prevented possible NaN for giving coins")
	end
	
	local playerCurrency = Shared.IsHardcore and save.HardcoreCurrency[currency] or save[currency]
	if playerCurrency == -1 then
		playerCurrency = 0
		save[currency] = 0
	end
	
	if Shared.IsHardcore then
		save.HardcoreCurrency[currency] = math.clamp(save.HardcoreCurrency[currency] + amount,0,Directory.Currency[currency].Limit) 
	else
		save[currency] = math.clamp(save[currency] + amount,0,Directory.Currency[currency].Limit) 
	end
	
	local currencySubbed = save[currency] - playerCurrency

	return currencySubbed ~= playerCurrency, currencySubbed
end

function Give.Slots(player, amount)
	local save = Saving.Get(player)
	if (not save) then
		return
	end
	
	amount = math.round(amount or 0)
	save.MaxSlots = math.clamp(save.MaxSlots + amount, 1, Settings.MaxSlots)
	return save.MaxSlots ~= save.MaxSlots
end

function Give.GetCurrency(player, currency)
	if currency == "Diamonds" then
		return Saving.Get(player).Diamonds
	else
		if not Directory.Currency[currency] then
			return 0
		end
		
		if require(game.ReplicatedStorage.Library.Shared).IsHardcore then
			return Saving.Get(player).HardcoreCurrency[currency]
		else
			return Saving.Get(player)[currency]
		end
	end
end

return Give
  -  Editar
  04:54:13.836    -  Editar
  04:54:13.836  ----- [2535] ServerScriptService.Library.LootBags -----  -  Editar
  04:54:13.836  --[[
    UPDATE: huge nerf with diamond mine
--]]

local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Settings = require(script.Parent.Settings)
local Saving = require(script.Parent.Saving)
local Directory = require(Library.Directory)
local Pets = require(script.Parent.Pets)
local Shared = require(Library.Shared)
local Mastery = require(script.Parent.Mastery)
local Boosts = require(script.Parent.Boosts)
local CalculateReward = require(script.Parent.CalculateReward)
local Achievements = require(script.Parent.Achievements)
local Orbs = require(script.Parent.Orbs)

local u2 = {};
local u3 = Random.new();
local u4 = {}
u4 = {
	Claim = function(p1, p2, p3)
		local v1 = Saving.Get(p1);
		if not v1 then
			return;
		end;
		local v2 = u2[p2];
		if not v2 or not p3 or u2[p2].claimed then
			return;
		end;
		if p1 ~= v2.player or v1.World ~= v2.world then
			warn("Lootbag collection may be cheats (" .. p1.Name .. ")");
			return;
		end;
		u2[p2].claimed = true;
		local v3 = Directory.Lootbags[v2.type];
		local v4, v5, v6 = unpack(v2.reward);
		local v7 = u3:NextInteger(unpack(v3.orbs));
		if v4 == "Diamonds" or v4 == "Gingerbread" then
			local v8 = math.max(math.round(v5 / v7), 1);

			if Shared.IsHardcore then
				v8 = v8 / Shared.HardcorePetMult
			else
				v8 = v8
			end

			for v9 = 1, v7 do
				Orbs.Add(p1, p3, v4, v8, {
					BlastRadius = 1.5
				});
				Functions.Wait(u3:NextNumber(0, math.clamp(v9 / 250, 0.02, 0.05)));
			end;
		elseif v4 == "Coins" then
			local v10 = math.max(math.round(v5 / v7), 1);
			for v11 = 1, v7 do
				Orbs.Add(p1, p3, v6, v10, {
					BlastRadius = 1.5
				});
				Functions.Wait(u3:NextNumber(0, math.clamp(v11 / 250, 0.02, 0.05)));
			end;
		elseif v4 == "Boost" then
			Boosts.Give(p1, v6, v5);
		end;
		Achievements.Add(p1, "Lootbags", 1);
		Mastery.Progress(p1, "Lootbags", v3.masteryXP);
		u4.Remove(p2);
		return true;
	end
};
local l__Lootbags__5 = Directory.Lootbags;
local u6 = {};
local l__LootbagCoinsMult__7 = Settings.LootbagCoinsMult;
local l__LootbagDiamondsMult__8 = Settings.LootbagDiamondsMult;
local l__LootbagBoostDrops__9 = Settings.LootbagBoostDrops;
function u4.Add(p4, p5, p6, disableMagnet, disableDiamond)
	local v12 = nil;
	local v13 = Saving.Get(p4);
	if not v13 then
		return;
	end;
	local l__World__14 = Shared.IsHardcore and v13.Hardcore.World or v13.World;
	local v15 = {};
	for v16, v17 in pairs(l__Lootbags__5) do
		local v18 = v17.weight;
		if v18 > 0 and (v16 ~= "Mini Giftbox" or Mastery.HasPerk(p4, "Lootbags", 4)) or (v17.diamondMine and l__World__14=="Diamond Mine") then
			if Mastery.HasPerk(p4, "Lootbags", 2) and v17.isRare then
				v18 = v18 * 1.65;
			end;
			if l__World__14 == "Diamond Mine" and not disableDiamond then
				if v17.diamondMine == true then
					table.insert(v15, { v16, v18 });
				end	
			elseif not v17.diamondMine then
				table.insert(v15, { v16, v18 });
			end
		end;
	end;

	if l__World__14 == "Diamond Mine" then
		for i, v in ipairs(v15) do
			if v[2] == 0 then
				if v[1] == "Diamond Bag Tier 1" then
					v15[i][2] = 95
				elseif v[1] == "Diamond Bag Tier 2" then
					v15[i][2] = 75
				elseif v[1] == "Diamond Bag Tier 3" then
					v15[i][2] = 35
				elseif v[1] == "Diamond Bag Tier 4" then
					v15[i][2] = 10	
				elseif v[1] == "Diamond Bag Tier 5" then
					v15[i][2] = 1 
				end
			end
		end
	end

	local v19 = Functions.Lottery(v15);

	if not Directory.Lootbags[v19] then
		return false
	end
	local v20 = {};
	for v21, v22 in ipairs(Directory.Lootbags[v19].rewards) do
		table.insert(v20, { { v22[1], v22[3] }, v22[2] });
	end;
	local v23, v24 = unpack((Functions.Lottery(v20)));
	local v25 = 1;
	if Mastery.HasPerk(p4, "Lootbags", 1) and v23 == "Coins" then
		v25 = 1.25;
	elseif Mastery.HasPerk(p4, "Lootbags", 3) and v23 == "Diamonds" then
		v25 = 1.35;
	end;
	v12 = Pets.GetEquipped(p4, true);
	local v26 = 0;
	local v27 = nil;
	if v23 == "Coins" then
		local l__mainCurrency__28 = Directory.Worlds[l__World__14].mainCurrency;
		v26 = math.max(math.round(CalculateReward(p4, u6[p4].needed * 10 * 10 * 10, l__mainCurrency__28, v12) * (v24 * (l__LootbagCoinsMult__7 * v25)) * u3:NextNumber(0.8, 1.2)), 1);
		v27 = l__mainCurrency__28;
	elseif v23 == "Diamonds" then
		if l__World__14 == "Diamond Mine" then
			v26 = math.max(math.round(CalculateReward(p4, u6[p4].needed, "Diamonds", v12, {
				disableScaling = true
			}) * v24), 1)
		else
			v26 = math.max(math.round(CalculateReward(p4, u6[p4].needed, "Diamonds", v12, {
				disableScaling = true
			}) * (v24 * (l__LootbagDiamondsMult__8 * v25) * 10 * 10)), 1)
		end
	elseif v23 == "Boost" then
		v26 = 1 * v24;
		v27 = Functions.Lottery(l__LootbagBoostDrops__9);
	elseif v23 == "Gingerbread" then
		v26 = math.max(math.round(CalculateReward(p4, u6[p4].needed, "Gingerbread", v12, {}) * (v24 * l__LootbagCoinsMult__7 * 10 * 10)), 1);
	end;
	local a = 1
	if l__World__14 == "Diamond Mine" and not disableDiamond then
		a = math.random(1,4)
	end
	if a > 1 then
		for i = 1, a do

		end	
	else
		local v29 = Functions.GenerateUID();
		u2[v29] = {
			player = p4, 
			type = v19, 
			world = l__World__14, 
			reward = { v23, v26, v27 }, 
			position = p5, 
			claimed = false,
			disableMagnet = l__World__14 == "Diamond Mine" or false
		};
		Network.Fire("Spawn Lootbag", p4, v29, u2[v29]);
		return v29;
	end
	Signal.Fire("Hacker Portal Progress", p4, 2, 1);
end;
function u4.Remove(p7, p8)
	if u2[p8] then
		u2[p8] = nil;
		Network.Fire("Remove Lootbag", p7, p8);
	end;
end;
function u4.Progress(p9, p10, p11)
	--warn(p9, p10, p11)
	if not u6[p9] then
		UpdateProgressThreshold(p9);
	end;
	local u10 = u6[p9];
	local u11 = p10;
	coroutine.wrap(function()
		for v30 = 0, 20, 1 do
			local test = (u10.needed <= u10.progress + u11)
			if not test then
				break
			end
			u11 = u11 - math.min(u11, u10.needed - u10.progress);
			u10.progress = 0;

			if Mastery.HasPerk(p9, "Lootbags", 5) and u3:NextNumber() <= 0.1 then
				u4.Add(p9, p11);
			end;
			u4.Add(p9, p11);

			if Settings.ChristmasEvent then
				if u3:NextNumber() <= 0.045 then
					Functions.Wait(u3:NextNumber(0, 0.06));
					u4.Add(p9, p11, "Christmas Gift");
				elseif u3:NextNumber() <= 0.4 then
					Functions.Wait(u3:NextNumber(0, 0.06));
					u4.Add(p9, p11, "Christmas Bag");
				end;
			end;

			--print("------------------------")
			UpdateProgressThreshold(p9);
			--print("------------------------")
			Functions.Wait(u3:NextNumber(0, math.min(v30 / 20, 0.15)));
		end
		u10.progress = u10.progress + u11;
	end)();
end;
local l__LootbagProgressDeviation__12 = Settings.LootbagProgressDeviation;
function UpdateProgressThreshold(p12)    
	local v31 = nil;
	local v32 = Pets.GetEquipped(game.Players:GetPlayerByUserId(p12.UserId));
	if not v32 then
		return;
	end;
	local v33 = 0;
	for v37, v38 in ipairs(v32) do
		local stat = Shared.ComputePetStrength(v38)
		if Shared.IsHardcore then
			stat = stat / Shared.HardcorePetMult
		end

		v33 = v33 + stat;	
	end;
	if #v32 < 3 then
		v33 = v33 * (4 - #v32);
	end;
	v31 = v33 * 3 * Settings.LootbagProgressMult * u3:NextNumber(unpack(l__LootbagProgressDeviation__12)) + 30000;
	local save = Saving.Get(game.Players:GetPlayerByUserId(p12.UserId))
	if not save then
		return
	end
	if save.World   == "Diamond Mine" or save.Hardcore.World == "Diamond Mine" then
		v31 = v31 + 10000 -- BAHHAHAHHAH
	end
	if not u6[p12] then
		u6[p12] = {
			needed = v31, 
			progress = 0
		};
		return;
	end;

	u6[p12].needed = v31;
	if v31 <= u6[p12].progress then
		u6[p12].progress = 0;
	end;
end;
function ClearProgress(p13)
	if not u6[p13] then
		u6[p13] = nil;
	end;
end;
game.Players.PlayerRemoving:Connect(function(p14)
	ClearProgress(p14);
end);
Network.Fired("Collect Lootbag"):Connect(function(p15, p16, p17)
	u4.Claim(p15, p16, p17);
end);
Signal.Fired("Player Added"):Connect(function(p18)
	UpdateProgressThreshold(p18);
end);
Signal.Fired("Pet Equipped"):Connect(function(p19, p20)
	UpdateProgressThreshold(p20);
end);
Signal.Fired("Pet Unequipped"):Connect(function(p21, p22)
	UpdateProgressThreshold(p22);
end);
return u4;
  -  Editar
  04:54:13.836    -  Editar
  04:54:13.836  ----- [2536] ServerScriptService.Library.Mastery -----  -  Editar
  04:54:13.836  --[[     
         ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Mastery | SERVER
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local Mastery = {}


local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)
local Saving = require(script.Parent.Saving)
local Directory = require(Library.Directory)
local Shared = require(Library.Shared)


function Mastery.Get(plyr, m)
    local save = Saving.Get(plyr)
    if not save then
		return 1
    end
    
    local mXp = save.Mastery[m]
    if not mXp then
		return 1
    end
    
    return Shared.MasteryXPToLevel(mXp)
end

function Mastery.HasPerk(plyr, m, perk)
    if (not Directory.Mastery[m]) then 
        return false
    end
	
    local dir = Directory.Mastery[m].perks[perk]
    
    local level = Mastery.Get(plyr, m)
    if not level then
        return false
    end
    
    if not dir or not (dir.level <= level) then
		return false
	end
	return true
end

function Mastery.IsMaxed(plyr, m)
    return Directory.Mastery[m].maxLvl <= Mastery.Get(plyr, m)
end

function Mastery.Progress(plyr, m, xpM)
	local save = Saving.Get(plyr)
	if not save then
		return
    end
    
	local dir = Directory.Mastery[m]
	local exp = save.Mastery[m]
	if not save.MasteryUnlocked or not exp or not dir.enabled then
		return
    end
    
    xpM = xpM * dir.xpMult
    
    local lev = Shared.MasteryXPToLevel(exp + xpM)
    
	if dir.maxLvl <= lev then
		save.Mastery[m] = Shared.MasteryLevelToXP(dir.maxLvl)
	else
        save.Mastery[m] = save.Mastery[m] + xpM
    end
    
	if Shared.MasteryXPToLevel(exp) < lev then
		Mastery.LeveledUp(plyr, m, lev)
    end
    
	return true
end

function Mastery.LeveledUp(plyr, m, lvl)
    Network.Fire("Mastery Leveled Up", plyr, m, lvl)
    
    local dir = Directory.Mastery[m]
	if dir.maxLvl <= lvl then
		Network.FireAll("Chat Msg", plyr.DisplayName .. " reached " .. dir.title .. " Mastery MAX Level " .. lvl .. "!", Color3.fromRGB(185, 246, 255))
        return
    end
    
	if lvl >= 25 or lvl % 5 == 0 then
		Network.FireAll("Chat Msg", plyr.DisplayName .. " reached " .. dir.title .. " Mastery Level " .. lvl .. "!", Color3.fromRGB(185, 246, 255))
	end
end

function Mastery.Setup(plyr)
	local save = Saving.Get(plyr)
	if not save then
		return
    end
    
	if save.MasteryUnlocked then
		for i, v in pairs(Directory.Mastery) do
			if v.enabled and not save.Mastery[i] then
				save.Mastery[i] = 0
			end
		end
	end
end

function Mastery.Unlock(plyr)
	local save = Saving.Get(plyr)
	if not save then
		return
    end
    
	if not save.MasteryUnlocked then
		save.MasteryUnlocked = true
		Mastery.Setup(plyr)
	end
end

Signal.Fired("Player Added"):Connect(function(plyr)
	Mastery.Unlock(plyr)
end)

return Mastery
  -  Editar
  04:54:13.837    -  Editar
  04:54:13.837  ----- [2537] ServerScriptService.Library.Orbs -----  -  Editar
  04:54:13.837  local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Functions = require(Library.Functions)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Saving = require(script.Parent.Saving)
local RunService = game:GetService("RunService")
local Heartbeat = function(p1) -- Heartbeat (Line: 90)
	for index1 = 1, p1 or 1 do
		RunService.Heartbeat:Wait();
	end
end
local Give = require(script.Parent.Give)
local Achievements = require(script.Parent.Achievements)


local allOrbs = {};
local u3 = {}
u3 = {
	Add = function(p1, p2, p3, p4, p5)
		local v1 = Functions.GenerateUID();
		if typeof(p2) == "CFrame" then
			p2 = p2.p2;
		end;
		local v2 = {
			plr = p1, 
			type = p3, 
			am = p4, 
			pos = p2,
			reach = p5,
		};
		allOrbs[v1] = v2;
		coroutine.wrap(function()
			wait(1200);
			u3.Remove(p1, v1);
		end)();
		coroutine.wrap(function()
			Network.Fire("Orb Added", p1, v1, v2);
		end)();
		return v1;
	end, 
	Claim = function(p5, p6)
		if not Saving.Get(p5) then
			return;
		end;
		local v3 = u3.Get(p6);
		if not v3 then
			return warn("Cannot claim orb, doesn't exist (" .. p5.Name .. ")");
		end;
		Give.Currency(p5, v3.am, v3.type, false);
		Achievements.Add(p5, "Orbs", 1);
		u3.Remove(p5, p6);
	end, 
	Remove = function(p7, p8)
		if allOrbs[p8] then
			allOrbs[p8] = nil;
			coroutine.wrap(function()
				Network.Fire("Orb Removed", p7, p8);
			end)();
		end;
	end, 
	Get = function(p9)
		return allOrbs[p9];
	end
};
Network.Fired("Claim Orb"):Connect(function(p10, p11)
	u3.Claim(p10, p11);
end);
Network.Fired("Claim Orbs"):Connect(function(p12, p13)
	for v4, v5 in pairs(p13) do
		u3.Claim(p12, v5);
	end;
end);
game.Players.PlayerRemoving:Connect(function(p14)
	local v6 = 0;
	for v10, v11 in pairs(allOrbs) do
		if (v6 + 1) % 200 == 0 then
			Heartbeat();
		end;
		if v11.plr == p14 then
			u3.Remove(p14, v10);
		end;
	end
end);
return u3;
  -  Editar
  04:54:13.837    -  Editar
  04:54:13.837  ----- [2538] ServerScriptService.Library.Pets -----  -  Editar
  04:54:13.838  --[[        
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Pets 
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local Pets = {}

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Signal = require(Library.Signal)
local Shared = require(Library.Shared)
local Directory = require(Library.Directory)
local Saving = require(ServerLibrary.Saving)
local Functions = require(Library.Functions)
local Settings = require(ServerLibrary.Settings)
local Network = require(ServerLibrary.Network)
local petsModule = require(Modules.Pets)

local IsHardcore = Shared.IsHardcore
local RNG = Random.new()

function Pets.Track(...)
	Signal.Fire("Track Pet", ...)
end

function Pets.Create(player, id, data, checkStorage, disableRarityStats, disableTracking, disableEquip, noTrack) --(player, id, data, applyMaxStorage, d, disableRarityStats, disableTracking, disableEquip, notTrack)
	--warn("PET CREATED PATH:  ", debug.traceback())

	local save = Saving.Get(player)
	if not save then
		return
	end

	local dir = Directory.Pets[id]
	if not dir then
		warn("id", id, "Doesnt exist!")
		return
	end

	local pets = save.Pets
	if save.MaxSlots <= #pets and not checkStorage then
		warn("Max storage", save.MaxSlots, "<=",#pets)
		return
	end

	local GeneratedTimeUID = Pets.GenerateTimeUID(player)
	if not GeneratedTimeUID then
		warn("Failed to generate time UID")
		return
	end

	local newUID = data and data.uid or "id" .. Functions.GenerateUID()

	local strengthMin = dir.strengthMin or 0
	local strengthMax = dir.strengthMax or 0

	local petData = {
		id = id, 
		uid = newUID, 
		idt = GeneratedTimeUID, 
		s = math.round(RNG:NextNumber(strengthMin, strengthMax)), 
		nk = Pets.GenerateNickname(),
		l = false,
		hc = false,
		["h"] = {
			["l"] = {},
			["n"] = 0
		}
	}

	-- JELLY CHANCES
	if dir.jelly then
		if id == "2123" or id == "2124" or id == "2188" or id == "2192" then
			local rep = Functions.Lottery({{ 
				1, --[[Coin]] 50 --%
			},{
				2, --[[Diamonds]] 20 --%
			},{
				3, --[[Chest]] 15 --%
			},{
				4, --[[LuckyBlock]] 10 --%
			},{
				5, --[[Maskot]] 5 --%
			}})

			if rep then
				petData.rep = {rep}
			end
		elseif id == "3016" or id == "3031" then
			local rep = Functions.Lottery({{ 
				1, --[[Coin]] 50 --%
			},{
				2, --[[Diamonds]] 20 --%
			},{
				3, --[[Chest]] 15 --%
			},{
				4, --[[LuckyBlock]] 10 --%
			},{
				5, --[[Maskot]] 4 --%
			},{
				6, --[[Preston]] 1 --%
			}})

			if rep then
				petData.rep = {rep}
			end
		end
	end

	if dir.huge or dir.titanic then
		if not game:GetService("RunService"):IsStudio() then
			petData.l = true
		end	
	end

	save.InventoryNotifications = save.InventoryNotifications + 1

	if data and not dir["isGift"] then
		for v7, v8 in pairs(data) do
			if v7 ~= "g" and v7 ~= "r" or v8 then
				petData[v7] = v8
			end
		end
	end

	if dir.colorVariants then -- idk
		local colorVariants = dir.colorVariants
		local drops = {}
		for i, v in pairs(colorVariants) do
			table.insert(drops, {i, v.Weight})
		end
		local cv = Functions.Lottery(drops)
		if cv then
			petData.cv = cv
		end
	end
	
	local vertexColorGenerator = dir.vertexColorGenerator
	if vertexColorGenerator then
		local randomColor = vertexColorGenerator(RNG)
		local vc = randomColor
		if type(randomColor)~="table" then
			if type(randomColor)=="vector" then
				vc = {randomColor.X,randomColor.Y,randomColor.Z}
			end
		end
		petData.vc = vc
	end

	if (not petData.powers) and not dir["isGift"] then
		if dir.titanic then
			petData.powers = Pets.RollPowers("Titanic")		
		elseif dir.huge then
			if not dir.disableBestFriend then
				petData.powers = Pets.RollPowers("Huge")
			end	
		elseif dir.companionEnchantLevel then
			petData.powers = Pets.RollPowers("Exclusive", nil, dir.companionEnchantLevel)
		elseif dir.rarity == "Mythical" or dir.rarity == "Secret" then
			petData.powers = Pets.RollPowers("Rare")
		elseif dir.rarity == "Legendary" and not dir.isPremium then
			petData.powers = Pets.RollPowers()
		end
	end

	if petData.s and petData.s < 0 and not dir["isGift"] then 
		petData.s = 1 
	end

	if not (data and data.s) then 
		if not disableRarityStats and not dir["isGift"] then
			if petData.g then
				petData.s = petData.s * Shared.PetTypeMult.Golden
			elseif petData.r then
				petData.s = petData.s * Shared.PetTypeMult.Rainbow
			elseif petData.dm then
				petData.s = petData.s * Shared.PetTypeMult["Dark Matter"]
			end
			if petData.sh then
				petData.s = petData.s * Shared.PetTypeMult.Shiny
			end
		end
	end	

	if not petData.s then
		petData.s = 1
	end

	pets[#pets+1] = petData

	Signal.Fire("Pet Added", player, newUID)
	coroutine.wrap(function() 
		Network.FireAll("Pet Added", player, petData) 
	end)()
	if not noTrack and not dir["isGift"] then
		Pets.Track(player, id, newUID)
	end

	if not disableEquip and not dir["isGift"] then
		Pets.Equip(tostring(newUID))
	end	

	petsModule.AddOwner(player.UserId, nil, petData)

	return newUID, petData
end

local allPets = {}
function Pets.Get(petUid)
	if not petUid then
		return
	end

	local petData = allPets[petUid]
	if petData then
		local owner = petData[1]
		local save = Saving.Get(owner, false)

		if save then
			local petDat = save.Pets[petData[2]]

			if petDat and petDat.uid == petUid then
				return petDat, owner
			end
		end
	end

	for i, plyr in ipairs(game.Players:GetPlayers()) do
		local save = Saving.Get(plyr, false)

		if save then
			for x, z in ipairs(save.Pets) do
				if z.uid == petUid then
					allPets[petUid] = { plyr, x }
					return z, plyr
				end
			end
		end
	end

	allPets[petUid] = nil
end

function Pets.Equip(uid)
	local petData, plyr = Pets.Get(uid)

	local save = Saving.Get(plyr)
	if not petData or not plyr or not save then
		warn("Failed to equip")
		return
	end

	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped  
	for i, v in pairs(PetsEquipped) do
		if i == petData.uid then
			return
		end
	end 

	local plyrMaxEquipped = save.InfPetsEnabled and #save.Pets or Shared.GetMaxEquippedSlots(save)  
	if plyrMaxEquipped <= Functions.DictionaryLength(PetsEquipped) then
		return false, "Can't equip any more pets! (Max " .. plyrMaxEquipped .. "/" .. plyrMaxEquipped .. " pets)"
	end

	PetsEquipped[tostring(uid)] = petData

	if Functions.DictionaryLength(PetsEquipped) > plyrMaxEquipped then
		PetsEquipped[tostring(uid)] = nil
		return false, "Can't equip any more pets! (Max " .. plyrMaxEquipped .. "/" .. plyrMaxEquipped .. " pets)"
	end

	Network.Fire("Pet Equip Changed", plyr, petData.uid, true)
	Signal.Fire("Pet Equipped", uid, plyr)
	return true
end

function Pets.Unequip(p8)
	local petData, plyr = Pets.Get(p8)

	if not petData then
		return
	end

	local save = Saving.Get(plyr)
	if not save then
		return
	end

	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped

	PetsEquipped[tostring(petData.uid)] = nil

	Network.Fire("Pet Equip Changed", plyr, petData.uid, false)
	Signal.Fire("Pet Unequipped", p8, plyr)
	return true
end

function Pets.IsEquipped(player, uid)
	local save = Saving.Get(player)
	if not save then return end
	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped

	for puid, pet in pairs(PetsEquipped) do
		if puid == uid then 
			return true
		end
	end

	return false
end

function Pets.Delete(petUid, ignore)
	local dat, plyr = Pets.Get(petUid)
	local save = Saving.Get(plyr)

	if not dat or not plyr or not save then
		warn("Failed")
		return
	end

	local pets = save.Pets
	if #pets <= 1 and not ignore then
		warn("Trying to delete last pet -- " .. plyr.Name)
		return
	end

	for i, v in ipairs(pets) do
		if v.uid == petUid then
			Pets.Unequip(v.uid)
			table.remove(save.Pets, i)
			Signal.Fire("Pet Deleted", petUid, plyr)
			coroutine.wrap(function()
				Network.FireAll("Pet Removed", plyr, petUid) 
			end)()
			return true, plyr
		end
	end

	warn("Couldn't find pet -- " .. plyr.Name)
end

function Pets.GetEquipped(plyr, is)
	local save = Saving.Get(plyr)
	if not save then
		return
	end

	local returningEquipped = {}

	local PetsEquipped = IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped
	for uid, pet in pairs(PetsEquipped) do
		if is then
			table.insert(returningEquipped, uid)
		else
			table.insert(returningEquipped, pet)
		end
	end

	return returningEquipped
end

function Pets.GenerateTimeUID(player)
	local save = Saving.Get(player)
	if not save then
		return
	end

	local idt = 0
	for _, pet in ipairs(save.Pets) do
		idt = math.max(idt, pet.idt)
	end

	return idt + 1
end

function Pets.GenerateNickname()
	local Nicknames = Shared.Nicknames

	return Nicknames[RNG:NextInteger(1, #Nicknames)]
end

function Pets.RollRandomPower(is, am)
	am = am or 1

	local powersLottery = {}

	for i, v in pairs(Directory.Powers) do
		if v.canDrop and (is and v.isUnique or not is) then
			for y, x in pairs(v.tiers) do
				table.insert(powersLottery, { { i, y }, v.dropWeight / y })
			end
		end
	end

	local lottery = Functions.Lottery(powersLottery)
	return unpack(lottery)
end

function Pets.RollPowers(name, am, val)
	local powers = {}

	local genRandomPowers = function(is)
		local power = nil
		local value = nil

		local attempt = 0
		while (not power) do 
			attempt += 1
			power, value = Pets.RollRandomPower(is, am)

			for i, v in ipairs(powers) do
				if v[1] == power then
					power = nil
				end
			end

			game:GetService("RunService").Heartbeat:Wait()
		end

		table.insert(powers, { power, value })
	end

	if name == "Rare" then
		for i = 1, 3 do
			genRandomPowers(i==1)
		end

		return powers
	end

	if name == "Titanic" then
		table.insert(powers, { "Titanic", 1 })
		genRandomPowers()
		return powers
	end

	if name == "Huge" then
		table.insert(powers, { "Best Friend", 1 })
		genRandomPowers()
		return powers
	end

	if name == "Exclusive" then
		table.insert(powers, { "Companion", val or 1 })
		genRandomPowers()
		return powers
	end

	genRandomPowers()

	if RNG:NextNumber() <= Settings.DoublePowerChance then
		genRandomPowers()
	end

	return powers
end

function Pets.GetNFTPet(player, name, serial)
	local save = Saving.Get(player)
	if not save then
		return
	end

	for _, pet in ipairs(save.Pets) do
		local nftData = pet.nftData

		if nftData and nftData.name == name and nftData.serial == serial then
			return pet.uid, pet
		end
	end
end

game.Players.PlayerRemoving:Connect(function(player)
	for i, pet in pairs(allPets) do
		if not pet or not pet[1] or pet[1] == player then
			allPets[i] = nil
		end
	end
end)

coroutine.wrap(function()
	while wait(600) do
		allPets = {}	
	end
end)()

return Pets  -  Editar
  04:54:13.838    -  Editar
  04:54:13.838  ----- [2539] ServerScriptService.Library.Ranks -----  -  Editar
  04:54:13.839  local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Saving = require(script.Parent.Saving)
local Gamepasses = require(script.Parent.Gamepasses)


local Directory = require(Library.Directory)
local Give = require(script.Parent.Give)
local Shared = require(Library.Shared)
local Boosts = require(script.Parent.Boosts)

local v1 = {};
function v1.Reward(p1)
	local v2 = Saving.Get(p1);
	if not v2 then
		return;
	end;
	local v3 = Directory.Ranks[v2.Rank];
	if #v3.rewards == 0 or os.time() - v2.RankTimer < v3.rewardCooldown then
		return;
	end;
	v2.RankTimer = os.time();
	for  v8, v9 in ipairs(v3.rewards) do
		local v7 = nil;
		local v10 = nil;
		v10, v7 = unpack(v9);
		if v10 == "Triple Coins Boost" then
			Boosts.Give(p1, "Triple Coins", v7);
		elseif v10 == "Super Lucky Boost" then
			Boosts.Give(p1, "Super Lucky", v7);
		elseif v10 == "Ultra Lucky Boost" then
			Boosts.Give(p1, "Ultra Lucky", v7);	
		elseif v10 == "Triple Damage Boost" then
			Boosts.Give(p1, "Triple Damage", v7);
		else
			Give.Currency(p1, v7, v10, false);
		end;	
	end;
	coroutine.wrap(function()
		Network.Fire("Rewards Redeemed", p1, v3.rewards);
	end)();
	return true;
end;
function v1.Give(p2, p3)
	local v11 = Saving.Get(p2);
	if not v11 then
		return;
	end;
	if v11.Rank ~= p3 then
		v11.Rank = p3;
		v11.RankProgress = 0;
		v11.RankTimer = 0;
		coroutine.wrap(function()
			Network.FireAll("Rank Changed", p2, p3);
		end)();
		v1.Reward(p2);
	end;
end;
local l__ID__2 = Directory.Gamepasses.VIP.ID;
local u3 = {};
function v1.Progress(p4, p5)
	local v12 = Saving.Get(p4);
	if not v12 then
		return;
	end;
	if Gamepasses.Owns(p4, l__ID__2) then
		p5 = p5 * 2;
	end;
	if v12.IsFollowingOnTwitter then
		p5 = p5 * 1.5;
	end;
	if not u3[p4] then
		u3[p4] = p5;
		return;
	end;
	u3[p4] = u3[p4] + p5;
end;
function v1.GetNextRank(p6)
	local v13 = Saving.Get(p6);
	if not v13 then
		return;
	end;
	for v14, v15 in ipairs(Shared.RankChart) do
		if v15 == v13.Rank then
			return Shared.RankChart[v14 + 1];
		end;
	end;
end;
function v1.GetRankNumber(p7)
	local v16 = Saving.Get(p7);
	if not v16 then
		return;
	end;
	local l__RankChart__17 = Shared.RankChart;
	for v18, v19 in ipairs(l__RankChart__17) do
		if v19 == v16.Rank then
			return v18;
		end;
	end;
	return #l__RankChart__17;
end;
function ApplyProgress(p8)
	local v20 = Saving.Get(p8);
	local v21 = u3[p8];
	if v21 then
		if v20 then
			u3[p8] = nil;
			v20.RankProgress = v20.RankProgress + v21;
			if Directory.Ranks[v20.Rank].needed <= v20.RankProgress then
				local v22 = v1.GetNextRank(p8);
				if v22 then
					v1.Give(p8, v22);
				end;
			end;
		end;
	end;
end;
coroutine.wrap(function()
	while true do
		for v23, v24 in ipairs(game.Players:GetPlayers()) do
			ApplyProgress(v24);
		end;
		wait(0.5);	
	end;
end)();
game.Players.PlayerRemoving:Connect(function(p9)
	if u3[p9] then
		u3[p9] = nil;
	end;
end);
Network.Invoked("Redeem Rank Rewards").OnInvoke = function(p10)
	return v1.Reward(p10);
end;
return v1;
  -  Editar
  04:54:13.839    -  Editar
  04:54:13.839  ----- [2540] ServerScriptService.Library.Upgrades -----  -  Editar
  04:54:13.839  local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Saving = require(script.Parent.Saving)
local Directory = require(Library.Directory)
local Achievements = require(script.Parent.Achievements)
local Settings = require(script.Parent.Settings)

local v1 = {};
function v1.Get(p1, p2)
	local v2 = Saving.Get(p1);
	if not v2 then
		return;
	end;
	return v2.Upgrades[p2] or 0;
end;
function v1.Give(p3, p4, p5)
	local v3 = Saving.Get(p3);
	if not v3 then
		return;
	end;
	v3.Upgrades[p4] = p5;
	coroutine.wrap(function()
		Signal.Fire("Upgrade Bought", p3, p4, p5);
		Network.Fire("Upgrade Bought", p3, p4, p5);
	end)();
end;
function v1.Buy(p6, p7)
	local v4 = Saving.Get(p6);
	if not v4 then
		return;
	end;
	local v5 = Directory.Upgrades[p7];
	if not v5 then
		return;
	end;
	local v6 = v4.Upgrades[p7] or 0;
	if v6 == 5 then
		return false, "Already fully upgraded.";
	end;
	if v5.isHalloweenEvent and (not Settings.HalloweenEvent) then
		return false, 'The halloween event is not active.'
	end
	local v7 = v5.prices[v6 + 1];
	if not (v7 <= v4[v5.currency]) then
		return false, "Not enough " .. v5.currency;
	end;
	local l__currency__8 = v5.currency;
	v4[l__currency__8] = v4[l__currency__8] - v7;
	v1.Give(p6, p7, v6 + 1);
	if not v5.isHalloweenEvent then
		Achievements.Add(p6, "Upgrades", 1);
	end;
	coroutine.wrap(function()
		if v5.isHalloweenEvent then
			Network.FireAll("Spooky Upgrade Animation", p6);
			return;
		end;
		Network.FireAll("Upgrade Station Animation", p6);
	end)();
	return true;
end;
Network.Invoked("Buy Upgrade").OnInvoke = function(p8, p9)
	return v1.Buy(p8, p9);
end;
return v1;
  -  Editar
  04:54:13.840    -  Editar
  04:54:13.840  ----- [2541] ServerScriptService.Library.Worlds -----  -  Editar
  04:54:13.841  --[[   
         ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Worlds | SERVER
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Saving = require(script.Parent.Saving)
local Directory = require(Library.Directory)
local Shared = require(Library.Shared)
local Achievements = require(script.Parent.Achievements)

local __WORLDS = game.ServerStorage:WaitForChild("__WORLDS")

local Worlds = {}

function Worlds.HasAccess(player, world)
	if not Saving.Get(player) then
		return false
	end
	
	local Dir = Directory.Worlds[world]
	if (not Dir) then return false end
	
	local requiredArea = Dir.requiredArea
	if requiredArea and not Worlds.HasArea(player, requiredArea) then
		return false
	end
	
	return true
end

function Worlds.Load(player, world)
	if player then
		local save = Saving.Get(player)
		local PlayerGui = player:FindFirstChild("PlayerGui")
		if save and PlayerGui then
			local Dir = Directory.Worlds[world]
			
			if not Dir or Dir.disabled then
				warn("Tried to load world " .. world .. ", doesn't exist")
				world = "Spawn"
			end
			
			if not Shared.IsTradingPlaza and world == "Trading Plaza" then
				world = "Spawn"
			elseif Shared.IsTradingPlaza then
				world = "Trading Plaza"
			end
			
			if not Worlds.HasAccess(player, world) then
				print("Changing " .. player.Name .. "'s world to Spawn because requested world is locked")
				world = "Spawn"
			end
			
			if world == "Void" and not save.HackerPortalUnlocked then
				print("Changing " .. player.Name .. "'s world to Spawn because he does not have the hacker portal unlocked")
				world = "Spawn"
			end
			
			if world == "Yeet" and not game:GetService("RunService"):IsServer() then
				world = "Spawn"
				Network.Fire("Message", player, "This is disabled.")
			end			
			
			if world == "Fantasy" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Enchanted Forest") then
						Worlds.GiveArea(player, "Enchanted Forest")
						Worlds.GiveArea(player, "Fantasy Shop")
						Achievements.Add(player, "Unlock Fantasy", 1)
					end
				end)()
			elseif world == "Tech" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Tech City") then
						Worlds.GiveArea(player, "Tech City")
						Worlds.GiveArea(player, "Tech Shop")
						Achievements.Add(player, "Unlock Tech", 1)
					end
				end)()	
			elseif world == "Trading Plaza" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Plaza Presents") then
						Worlds.GiveArea(player, "Plaza Presents")
						Achievements.Add(player, "Join Trading Plaza", 1)
					end
				end)()		
			elseif world == "Void" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "The Void") then
						Worlds.GiveArea(player, "The Void")
						Achievements.Add(player, "Unlock Void", 1)
					end
				end)()	
			elseif world == "Axolotl Ocean" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Axolotl Ocean") then
						Worlds.GiveArea(player, "Axolotl Ocean")
						Achievements.Add(player, "Unlock Axolotl Ocean", 1)
					end
				end)()	
			elseif world == "Pixel" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Pixel Forest") then
						Worlds.GiveArea(player, "Pixel Forest")
						Achievements.Add(player, "Unlock Pixel World", 1)
					end
				end)()	
			elseif world == "Secret House" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Secret House") then
						Worlds.GiveArea(player, "Secret House")
						Achievements.Add(player, "Unlock Secret House", 1)
					end
				end)()	
			elseif world == "Secret Cave" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Secret Cave") then
						Worlds.GiveArea(player, "Secret Cave")
						Achievements.Add(player, "Unlock Secret Cave", 1)
					end
				end)()	
			elseif world == "Cat" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Cat Paradise") then
						Worlds.GiveArea(player, "Cat Paradise")
						Achievements.Add(player, "Unlock Cat World", 1)
					end
				end)()	
			elseif world == "Limbo" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Limbo") then
						Worlds.GiveArea(player, "Limbo")
						Achievements.Add(player, "Unlock Limbo", 1)
					end
				end)()	
			elseif world == "Doodle" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Doodle Shop") then
						Worlds.GiveArea(player, "Doodle Meadow")
						Worlds.GiveArea(player, "Doodle Shop")
						Achievements.Add(player, "Unlock Doodle World", 1)
					end
				end)()	
			elseif world == "Kawaii" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Kawaii Tokyo") then
						Worlds.GiveArea(player, "Kawaii Tokyo")
						Achievements.Add(player, "Unlock Kawaii World", 1)
					end
				end)()	
			elseif world == "Diamond Mine" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Diamond Mine") then
						Worlds.GiveArea(player, "Diamond Mine")
						Achievements.Add(player, "Unlock Diamond Mine", 1)
					end
				end)()	
			elseif world == "Dog" then
				coroutine.wrap(function()
					wait(3)
					if not Worlds.HasArea(player, "Dog Park") then
						Worlds.GiveArea(player, "Dog Park")
						Achievements.Add(player, "Unlock Dog World", 1)
					end
				end)()		
			end
			
			local map = __WORLDS:FindFirstChild(world):Clone()
			map.Name = "__MAP"
			map.Parent = PlayerGui
			
			if Shared.IsHardcore then
				save.Hardcore.World = world
			else
				save.World = world
			end
			
			Signal.Fire("World Changed", player, world)
			
			
			return true
		end
	else
		return false
	end
end

function Worlds.GetNetworkList(world)
	local plyrs = {}
	
	for i, player in ipairs(game.Players:GetPlayers()) do
		local save = Saving.Get(player)
		if save then
			local playerWorld = Shared.IsHardcore and save.Hardcore.World or save.World
			if playerWorld == world then
				table.insert(plyrs, player)
			end	
		end
	end
	
	return plyrs
end

function Worlds.HasArea(player, area)
	local save = Saving.Get(player)
	
	if not save then 
		return false
	end
	
	local areasUnlocked = Shared.IsHardcore and save.Hardcore.AreasUnlocked or save.AreasUnlocked
	
	if Functions.SearchDictionary(areasUnlocked, area) then
		return true
	end
	
	return false
end

function Worlds.GiveArea(player, area)
	local save = Saving.Get(player)
	
	if not save or not (not Worlds.HasArea(player, area)) then
		return
	end
	
	local areasUnlocked = Shared.IsHardcore and save.Hardcore.AreasUnlocked or save.AreasUnlocked
	
	table.insert(areasUnlocked, area)
	
	return true
end

Network.Invoked("Request World").OnInvoke = function(...)
	return Worlds.Load(...)
end 

return Worlds
  -  Editar
  04:54:13.841    -  Editar
  04:54:13.841  ----- [2542] ServerScriptService.Library.ServerBoosts -----  -  Editar
  04:54:13.841  --[[   
                                                                         ,,╓╓╥╗╗@@@╣╢
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.ServerBoosts 
	===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Network = require(ServerLibrary.Network)
local Saving = require(ServerLibrary.Saving)
local Signal = require(Library.Signal)
local Shared = require(Library.Shared)
local Functions = require(Library.Functions)

--------|       Top       |--------
local ServerBoosts = {}

--------|     Setting     |--------
local ServerEventTime = {900,1200} 
local EventBoosts = {"Super Breaker", "Insane Luck", "Triple Coins", "Triple Damage", "Super Lucky"}

--------|    Reference    |--------

--------|    Variables    |--------
local activeServerBoosts = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

ServerBoosts.IsActive = function(plyr, sb)
    return activeServerBoosts[sb] ~= nil
end

ServerBoosts.Activate = function(plyr, sb)
    local save = Saving.Get(plyr)
    if not save then
        return
    end
    
    local boostInv = save.BoostsInventory[sb]
    if not boostInv or boostInv < 20 then
        return
    end
    
    save.BoostsInventory[sb] = save.BoostsInventory[sb] - 20
    if  save.BoostsInventory[sb] <= 20 then
        save.BoostsInventory[sb] = nil
    end
    
    local time = 900 / #game.Players:GetPlayers()
    for i, v in ipairs(game.Players:GetPlayers()) do
        Signal.Fire("Activate Server Boost", v, sb, time, plyr)
    end
    
    coroutine.wrap(function()
        Network.FireAll("Server Boost Activated", plyr, sb, time)
        
        Network.FireAll("Notification", "Server " .. sb .. " Boost activated by " .. plyr.DisplayName .. "!", {
            color = Color3.fromRGB(105, 255, 168), 
            sound = "rbxassetid://11603330584"
        })
    end)()
    
    return true
end

function ActivatedBoost(plyr, sb, time, bster)
	if not activeServerBoosts[sb] then
		if not plyr then
			local boosters = activeServerBoosts[sb] and activeServerBoosts[sb].boosters and activeServerBoosts[sb].boosters or {}
			activeServerBoosts[sb] = {totalTimeLeft = time, boosters = boosters}
			return
		end
		activeServerBoosts[sb] = {totalTimeLeft = time, boosters = { {name = bster.Name, userId = bster.UserId, endTime = os.clock() + (time * #game.Players:GetPlayers())} }}
	else
		if not plyr then
			activeServerBoosts[sb].totalTimeLeft = activeServerBoosts[sb].totalTimeLeft + time
			return
		end

		activeServerBoosts[sb].totalTimeLeft = activeServerBoosts[sb].totalTimeLeft + time

		local is = nil
		for i, v in ipairs(activeServerBoosts[sb].boosters) do
			if v.userId == bster.UserId then
				v.endTime = v.endTime + (time * #game.Players:GetPlayers())
				return
			end
		end

		table.insert(activeServerBoosts[sb].boosters, {
			name = bster.Name, userId = bster.UserId, endTime = os.clock() + (time * #game.Players:GetPlayers())
		})
	end
end

function ServerBoosts.StartEvent()
	local rn = math.random(1,#EventBoosts)
	local Boost = EventBoosts[rn]

	local time = (rn == 1 or rn == 2) and 600 or 900
	ActivatedBoost(nil, Boost, time)

	coroutine.wrap(function()
		Network.FireAll("Server Boost Activated", nil, Boost, time)
		Network.FireAll("Notification", "Server Event " .. Boost .. " has started for " .. time / 60 .. " minutes!" , {
			color = Color3.fromRGB(105, 255, 168), 
			sound = "rbxassetid://11603330584"
		})
	end)()
end

Signal.Fired("Activate Server Boost"):Connect(ActivatedBoost)

Network.Fired("Activate Server Boost"):Connect(function(plyr, sb)
    ServerBoosts.Activate(plyr, sb)
end)

coroutine.wrap(function()
    while wait(1) do
        for i, _ in pairs(activeServerBoosts) do
            
            if activeServerBoosts[i].totalTimeLeft < 1 then
                activeServerBoosts[i] = nil
                Network.FireAll("Server Boost Ended", i)
                Network.FireAll("Notification", "Server " .. i .. " Boost has ended!", {
                    color = Color3.fromRGB(255, 46, 46), 
                    sound = "rbxassetid://7047600380"
                })
            else
                activeServerBoosts[i].totalTimeLeft = activeServerBoosts[i].totalTimeLeft - 1
            end
            Network.FireAll("Server Boost Update", activeServerBoosts)

            
            if activeServerBoosts[i] and activeServerBoosts[i].boosters then
                for x, y in pairs(activeServerBoosts[i].boosters) do
                    if y.endTime <= os.clock() then
                        table.remove(activeServerBoosts[i].boosters, x)
                    end
                end 
            end
        end
    end
end)()

-- SERVER Boost events
coroutine.wrap(function()
	while task.wait(math.random(unpack(ServerEventTime))) do
		ServerBoosts.StartEvent()
	end
end)()

Signal.Fired("Player Added"):Connect(function(player)
	for sboost,data in pairs(ServerBoosts) do
		local dir = Shared.ServerBoostsInfo[sboost]
		if dir then
			if dir.loginAnnounce then
				--Network.FireAll("Server Boost Activated", nil, Boost, time)

				local msg = Shared.ServerBoostsInfo[sboost].msg			
				
				Network.Fire("Chat Msg", player, "Server Event " .. sboost .. " is currently active! "..msg, Color3.fromRGB(46, 255, 63))
				Network.Fire("Notification", player, "Server Event " .. sboost .. " is currently active!" , {
					color = Color3.fromRGB(105, 255, 168), 
					sound = "rbxassetid://11603330584"
				})
			end
		end
	end
end)

return ServerBoosts
  -  Editar
  04:54:13.841    -  Editar
  04:54:13.841  ----- [2543] ServerScriptService.Library.FreeGifts -----  -  Editar
  04:54:13.841  local FreeGifts = {}

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Directory = require(Library.Directory)
local Signal = require(Library.Signal)
local Network = require(ServerLibrary.Network)
local Settings = require(ServerLibrary.Settings)
local Saving = require(ServerLibrary.Saving)
local Pets = require(ServerLibrary.Pets)
local Give = require(ServerLibrary.Give)
local Shared = require(Library.Shared)
local Functions = require(Library.Functions)
local Mastery = require(ServerLibrary.Mastery)
local LootBags = require(ServerLibrary.LootBags)
local Pets = require(ServerLibrary.Pets)
local Player = require(Library.Player)

local RNG = Random.new()
function FreeGifts.Redeem(plyr, id)
    local save = Saving.Get(plyr)
    if not save or Shared.IsTradingPlaza then
        return
    end
    
    local dir = Directory.FreeGifts[id]
    if not (dir and (save.FreeGiftsTime or 0) > dir.waitTime) then
        return false, "You cannot claim this gift yet."
    end
    
    if Functions.SearchArray(save.FreeGiftsRedeemed, id) then
        return false, "You have already claimed this gift."
    end
    
    if not (plyr.Character and plyr.Character:FindFirstChild("Head") and plyr.Character:IsDescendantOf(workspace) and plyr and plyr.Parent) then
        return false, "Could not locate pos"
    end

    local headpos;
    pcall(function()
        headpos = plyr.Character.Head.Position + Vector3.new(0, 1.5, 0)
    end)

    if not (headpos and typeof(headpos) == "Vector3") then
        return false, "???"
    end

    coroutine.wrap(function()
        for i = 1, RNG:NextInteger(unpack(dir.rewardNum)) do
            local reward = Functions.Lottery(dir.rewards)
            if reward == "HugePet" then
                Pets.Create(plyr, "2068", {})
                Network.FireAll("Chat Msg", plyr.DisplayName .. " open an EXCLUSIVE Huge Peacock pet! CONGRATS", Color3.fromRGB(213, 115, 255))
                --
                local torso = Player.UpperTorso(plyr)
                if torso then
                    Network.Fire("RewardImage", plyr, torso.CFrame.p, "+1 Huge Peacock", Directory.Pets["2068"].thumbnail, {
                        time = 6
                    })
                end
                --
                Network.Fire("Notification", plyr, "You got an Exclusive Huge Peacock!", {
                    color = Color3.fromRGB(93, 255, 255), 
                    sound = "rbxassetid://8176818052"
                })
			else
				if reward == "Coins" then
					reward = "FreeGiftsCoins"
				elseif reward == "Diamonds" then
					reward = "FreeGiftsDiamonds"
				elseif reward == "Boosts" then
					reward = "Giftbox"
				end
				
                LootBags.Add(plyr, headpos, reward, nil, true)
            end     
        end
    end)()

    table.insert(save.FreeGiftsRedeemed, id)
    Mastery.Progress(plyr, "Free Gifts", dir.masteryXP)
    return true
end

Signal.Fired("Player Added"):Connect(function(plyr)
    coroutine.wrap(function()
        while wait(1) do
            if not plyr or not plyr.Parent or Shared.IsTradingPlaza then
                break
            end
            
            local save = Saving.Get(plyr)
            if not save then
                return
            end
            
            if os.time() > save.FreeGiftsResetTime then
                save.FreeGiftsResetTime = os.time() + 43200
                save.FreeGiftsTime = 0
                save.FreeGiftsRedeemed = {}
            else
                save.FreeGiftsTime = save.FreeGiftsTime + 1
            end
        end
    end)()
end)

Network.Invoked("Redeem Free Gift").OnInvoke = function(plyr, id)
    return FreeGifts.Redeem(plyr, id)
end


return FreeGifts
  -  Editar
  04:54:13.841    -  Editar
  04:54:13.841  ----- [2544] ServerScriptService.Library.Fruit -----  -  Editar
  04:54:13.841  local Fruit = { Directory = require(game.ReplicatedStorage.Library.Directory).Fruits }

local Signal = require(game.ReplicatedStorage.Library.Signal)
local Network = require(script.Parent.Network)
local Saving = require(script.Parent.Saving)
local Directory = require(game.ReplicatedStorage.Library.Directory)
local fruitModule = require(game.ReplicatedStorage.Library.Types.Fruits)
local Shared = require(game.ReplicatedStorage.Library.Shared)

function HasPerk(p1, p2)
	local v6 = Saving.Get(p1);
	local v7
	if not v6 then
		v7 = 0;
	else
		assert(v6);
		if not v6 then
			v7 = 1;
		else
			assert(v6);
			local l__Fruits__8 = v6.Mastery.Fruits;
			if l__Fruits__8 then
				v7 = Shared.MasteryXPToLevel(l__Fruits__8);
			else
				v7 = 1;
			end;
		end;
	end;
	local v9 = Directory.Mastery.Fruits.perks[p2];
	if v9 then
		if v9.level <= v7 then
			return true;
		end;
	end;
	return false;
end;

function Fruit.Get(p1, p2) 
    assert(Fruit.Directory[p2.Name] == p2);
     
    local v1 = Saving.Get(p1);
    if not v1 then
        return 0;
    end
    assert(v1);
    local v2 = v1.Fruits[p2.Name];
    if not v2 then
        return 0;
    end
	assert(v2);
	local v12 = 1;
	if HasPerk(p1, 1) then
		v12 = 1.2;
	elseif HasPerk(p1, 2) then
		v12 = 1.5;
	end;
	return fruitModule.Compute(p2, v2, Shared.ComputeSaveAge(v1), v12);
end

function Fruit.GetBonus(p5, p6)
	local v13 = 1;
	if HasPerk(p5, 3) then
		v13 = 1.3;
	end;
	return p6.Bonus((math.ceil((Fruit.Get(p5, p6))))) * v13;
end;

function Fruit.Give(player, fruit, amount)
	local save = Saving.Get(player)
	if not save then
		return
	end
	
	local v = save.Fruits[fruit]
	if not v then
		save.Fruits[fruit] = {
			Amount = math.clamp(amount,0,200),
			LastUpdated = Shared.ComputeSaveAge(save)
		}
	end
	
	v.Amount = math.clamp(v.Amount + amount,0,200)  --amount
end

Signal.Fired("Update: Fruit"):Connect(function(plyr, fruit, data)
    local save = Saving.Get(plyr)
    if not save then
        return
	end
	
	if data.Amount >= 200 then
		data.Amount = 200
	end
    
    save.Fruits[fruit] = data -- debug
end)

return Fruit
  -  Editar
  04:54:13.841    -  Editar
  04:54:13.841  ----- [2545] ServerScriptService.Library.Network -----  -  Editar
  04:54:13.841  -- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Library = ReplicatedStorage:WaitForChild("Library")
local ClientLibrary = Library:WaitForChild("Client")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Network = require(Library.Network)

-----------------------------------------------------------------------------------------------------

return Network  -  Editar
  04:54:13.841    -  Editar
  04:54:13.841  ----- [2546] ServerScriptService.Library.RAP -----  -  Editar
  04:54:13.841  -- !strict

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Network = require(ServerLibrary.Network)
local RAPShared = require(Library.RAPShared)
local Datastore = require(ServerLibrary.Datastore)
local Settings = require(ServerLibrary.Settings)

--------|       Top       |--------
local RAP = {}

--------|     Setting     |--------
local key = tostring(Settings.StatsVersion)
warn(key)

--------|    Reference    |--------
local httpService = game:GetService("HttpService")

--------|    Variables    |--------
local globalrap = {} 
local rapDS = game:GetService("DataStoreService"):GetDataStore("RAP")

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function RAP.Get(petData)
	local key = RAPShared.CreateKey(petData).encoded
	local pet = globalrap[key]
	if pet then
		return pet.val
	end
	return nil
end

function calculateRapMath(old, new)
	if new < old then
		return math.ceil(old-(new * 0.35))
	end
	math.ceil(old+(new * 0.35))
end

function RAP.Update(petData, rap)
	assert(type(rap) == "number")
	
	local key = RAPShared.CreateKey(petData).encoded
	local pet = globalrap[key]
	local petRap = pet and pet.val or 1
	
	local newRap = calculateRapMath(petRap, rap) --math.ceil(petRap+(rap * 0.35))
	updateGlobalRAP({
		[key] = {
			["val"] = newRap;
		}
	})
	globalrap[key] = newRap
end

Network.Invoked("RAP: Get").OnInvoke = function()
	print(globalrap)
	return globalrap
end

function getGlobalRAP()
	--return pcall(function()
	--	local a = rapDS:GetAsync(key)
	--	return httpService:JSONDecode(a)
	--end)
	local s, r = pcall(function()
		return rapDS:GetAsync(key)
	end)
	
	if r then  r = httpService:JSONDecode(r)  end
	
	return s, r
end

function updateGlobalRAP(new, firstTime)
	if firstTime then
		--return pcall(function()
		--	rapDS:SetAsync(key, httpService:JSONEncode({}))
		--end)
		pcall(function()
			rapDS:SetAsync(key, httpService:JSONEncode({}))
		end)
		return
	end
	--return pcall(function()
	pcall(function()
		rapDS:UpdateAsync(key, function(old)
			old = httpService:JSONDecode(old)
			for key, value in pairs(new) do
				old[key] = value
			end
			return httpService:JSONEncode(old)
		end)
	end)	
	warn(new)
	--end)
end

coroutine.wrap(function()
	--local success, globalRAP = getGlobalRAP()
	--warn(success, globalRAP)
	--if globalRAP == nil then
	--	updateGlobalRAP(nil, true)
	--	globalrap = {}
	--	success = true
	--elseif success then
	--	globalrap = globalRAP
	--end
	--
	--if success then
	--	task.spawn(function()
	--		while true do
	--			success, globalRAP = getGlobalRAP()
	--			
	--			globalrap = globalRAP or {}
	--			task.wait(30)
	--		end
	--	end)
	--else
	--	warn("Failed to get live RAP.")
	--end
	local s, r = getGlobalRAP()
	warn(s, r)
	if not s then
		warn("Failed to get live RAP | _L.RAP")
		return
	end
	
	if r == nil then
		r = {}
		globalrap = {}
		updateGlobalRAP(nil, true)
	else
		globalrap = r
	end
	
	task.spawn(function()
		while wait(30) do
			s, globalrap = getGlobalRAP()
		end
	end)
end)()

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


return RAP  -  Editar
  04:54:13.842    -  Editar
  04:54:13.842  ----- [2547] ServerScriptService.Library.FFlags -----  -  Editar
  04:54:13.842  -- !strict

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Functions = require(Library.Functions)
local Signal = require(Library.Signal)
local Network = require(ServerLibrary.Network)
local Datastore = require(ServerLibrary.Datastore)

local l__ServerScriptService__2 = game:GetService("ServerScriptService");
local l__MessagingService__3 = game:GetService("MessagingService");
local v4 = require(Modules.FFlags);
local v5 = {
	Options = v4.Options, 
	Keys = v4.Keys
};
local u2 = require(script.HTTPUtil);
local u3 = {};
function v5.Get(p1, p2)
	if typeof(p1) ~= "string" then
		error(string.format("Key must be string (was '%s')", (typeof(p1))));
	end;
	local v6 = v5.Options[p1];
	if not v6 then
		error(string.format("Missing key: %s", p1));
	end;
	local v7 = (p2 or u3)[p1];
	if v7 == nil and not v6.Nullable then
		v7 = v6.Default;
	end;
	return v7;
end;
function v5.Set(p3, p4)
	if typeof(p3) ~= "string" then
		error(string.format("Key must be string (was '%s')", (typeof(p3))));
	end;
	local v8 = v5.Options[p3];
	if not v8 then
		error(string.format("Missing key: %s", p3));
	end;
	if v8.Nullable then
		local v9 = true;
		if p4 ~= nil then
			v9 = typeof(p4) == v8.Type;
		end;
		assert(v9);
	else
		assert(typeof(p4) == v8.Type);
		if p4 == v8.Default then
			p4 = nil;
		end;
	end;
	if v8.Type == "number" and p4 and v8.Min then
		assert(v8.Min <= p4);
	end;
	if v8.Type == "number" and p4 and v8.Max then
		assert(p4 <= v8.Max);
	end;
	u3[p3] = p4;
end;
local u4 = {};
function v5.CanBypass(p5)
	local v10 = false;
	if typeof(p5) == "Instance" then
		v10 = p5:IsA("Player");
	end;
	assert(v10);
	local v11 = u4[p5];
	if v11 ~= nil then
		return v11;
	end;
	local u5 = false;
	pcall(function() 
		if p5.UserId == 4437812925 then
			u5 = true;
		end;
		u4[p5] = u5;
	end);
	return false;
end;
function grabAllOptions()
	local v12 = {};
	for v16, v17 in pairs(v5.Options) do
		local v18 = v5.Get(v16);
		if not v17.Nullable then
			if v18 ~= v17.Default then
				v12[v16] = v18;
			end;
		else
			v12[v16] = v18;
		end;	
	end;
	return v12;
end;
local u6 = {};
local u7 = -1;
function setData(p6, p7, p8, p9)
	local v19 = {
		Changes = {}, 
		Developer = p9 and p9.Name or nil, 
		ExperienceID = game.GameId
	};
	local l__Options__20 = v5.Options;
	local v21 = nil;
	local v22 = nil;
	for v23, v24 in v5.Options do
		local v25 = v5.Get(v23, u3);
		local v26 = v5.Get(v23, u6);
		if v26 ~= v25 then
			v19.Changes[v23] = {
				Name = v24.Name, 
				Type = v24.Type, 
				OldValue = v26, 
				UpdatedValue = v25, 
				Important = v24.Important or false
			};
		end;	
	end;
	p6 = Functions.DeepCopyUnsafe(p6);
	u3 = Functions.DeepCopyUnsafe(p6);
	u7 = p7;
	u6 = Functions.DeepCopyUnsafe(p6);
	task.spawn(function()
		Signal.Fire("FFlags Changed", Functions.DeepCopyUnsafe(p6));
	end);
	task.spawn(function()
		Network.FireAll("FFlags Changed", p6);
	end);
	if p8 then
		task.spawn(function()
			l__MessagingService__3:PublishAsync("FFlags/Updated", {
				Data = p6, 
				Version = p7
			});
		end);
		task.spawn(function()
			u2.HttpRequest("POST", "commit_fflags", {}, v19);
		end);
	end;
end;
function trySetData(p10, p11, p12, p13)
	if p11 <= u7 then
		return false;
	end;
	setData(p10, p11, p12, p13);
	return true;
end;
function getVersion(p14)
	if p14 then
		local l__Version__27 = p14:GetMetadata().Version;
		if l__Version__27 then
			return l__Version__27;
		end;
	end;
	return -1;
end;
function v5.Commit(p15)
	if Functions.DeepEqualsUnsafe(u3, u6) then
		return true;
	end;
	local u8 = false;
	local v28, v29, v30 = Datastore.Update("FFlags", "v1", function(p16, p17)
		local v31 = p16 or {};
		if trySetData(v31, (getVersion(p17))) then
			return nil;
		end;
		if Functions.DeepEqualsUnsafe(v31, u3) then
			u6 = Functions.DeepCopyUnsafe(u3);
			return nil;
		end;
		u8 = true;
		return Functions.DeepCopyUnsafe(u3), nil, {
			Version = u7 + 1
		};
	end);
	if not u8 then
		return true;
	end;
	if v28 then
		trySetData(v29 or {}, getVersion(v30), true, p15);
	end;
	return v28;
end;
function v5.Pull()
	local v32, v33, v34 = Datastore.Get("FFlags", "v1");
	if not v33 then
		return false;
	end;
	trySetData(v32 or {}, (getVersion(v34)));
	return true;
end;
task.spawn(function()
	while not v5.Pull() do
		task.wait(math.random() * 15 + 15);	
	end;
	while true do
		task.wait(math.random() * 600 + 300);
		v5.Pull();	
	end;
end);
task.spawn(function()
	l__MessagingService__3:SubscribeAsync("FFlags/Updated", function(p18)
		local l__Data__35 = p18.Data;
		assert(typeof(l__Data__35) == "table");
		local l__Data__36 = l__Data__35.Data;
		local l__Version__37 = l__Data__35.Version;
		assert(typeof(l__Data__36) == "table");
		assert(typeof(l__Version__37) == "number");
		trySetData(l__Data__36, l__Version__37);
	end);
end);
game.Players.PlayerAdded:Connect(function(p19)
	local u9 = Functions.DeepCopyUnsafe(u6);
	task.spawn(function()
		Network.Fire("FFlags Changed", p19, u9);
	end);
end);
return v5;
  -  Editar
  04:54:13.842    -  Editar
  04:54:13.842  ----- [2548] ServerScriptService.Library.FFlags.HTTPUtil -----  -  Editar
  04:54:13.842  -- !strict

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Functions = require(Library.Functions)

local RunService = game:GetService("RunService");
local HttpService = game:GetService("HttpService");
local _ = require(script:WaitForChild("Encryption"));
local m_Authentication = require(script:WaitForChild("Authentication"));
local table1 = {
	LOCAL_TEST = false,
	LOCAL_TEST_URL = "http://127.0.0.1:3000/"
};
if table1.LOCAL_TEST and not RunService:IsStudio() then
	table1.LOCAL_TEST = false;
end
function decodeJson(p1) -- Line: 41
	--[[
		Upvalues:
			[1] = HttpService
	--]]
	if p1 then
		local success, pcall_ret2 = pcall(function() -- Line: 43
			--[[
				Upvalues:
					[1] = HttpService
					[2] = p1
			--]]
			return HttpService:JSONDecode(p1);
		end);
		if success then
			if typeof(pcall_ret2) == "table" then
				return true, pcall_ret2;
			end
			return false, nil, "Invalid JSON Body";
		end
		return false, nil, "Malformed JSON Body";
	end
	return false, nil, "No JSON Body";
end
function decodeResponse(p2) -- Line: 71
	local function formatResponse(p7) -- Line: 73
		--[[
			Upvalues:
				[1] = p2
		--]]
		if p7 then
			return string.format("%d %s: %s", p2.StatusCode, p2.StatusMessage, p7);
		end
		return string.format("%d %s", p2.StatusCode, p2.StatusMessage);
	end
	if p2.StatusCode == 405 then
		local decodeJson_ret1_2, decodeJson_ret2_2, decodeJson_ret3_2 = decodeJson(p2.Body);
		if decodeJson_ret1_2 then
			if decodeJson_ret2_2.err ~= nil then
				if typeof(decodeJson_ret2_2.err) == "string" then
					return false, nil, decodeJson_ret2_2.err;
				end
				return false, nil, formatResponse("Malformed JSON Body Error");
			end
			return false, nil, formatResponse("No JSON Body Error");
		end
		return false, nil, formatResponse(decodeJson_ret3_2);
	end
	if p2.StatusCode == 400 then
		return false, nil, formatResponse();
	end
	if p2.StatusCode == 401 then
		return false, nil, formatResponse();
	end
	if p2.StatusCode == 200 then
		local decodeJson_ret1, decodeJson_ret2, decodeJson_ret3 = decodeJson(p2.Body);
		if decodeJson_ret1 then
			return true, decodeJson_ret2;
		end
		return false, nil, formatResponse(decodeJson_ret3);
	end
	return false, nil, formatResponse();
end
local table2 = {
	GET = true,
	POST = true
};
function table1.HttpRequest(p3, p4, p5, p6) -- Line: 125
	--[[
		Upvalues:
			[1] = table2
			[2] = m_Authentication
			[3] = HttpService
			[4] = table1
			[5] = m_Library
	--]]
	assert(table2[p3]);
	local table3 = {};
	if p5 then
		for key1, val1 in pairs(p5) do
			assert(typeof(key1) == "string");
			assert(typeof(val1) == "string" and true or typeof(val1) == "number" and true or typeof(val1) == "boolean");
			table3[key1] = tostring(val1);
		end
	end
	local v2 = p6 and table.clone(p6) or {};
	local AuthParameters = m_Authentication.getAuthParameters();
	local table_clone_ret = table.clone(AuthParameters);
	if p3 == "GET" or p5 and next(p5) then
		for key2, val2 in pairs(table3) do
			table_clone_ret[key2] = val2;
		end
		for key3, val3 in pairs(AuthParameters) do
			table3[key3] = tostring(val3);
		end
	end
	local str1 = nil;
	local JSONEncode_ret = nil;
	if p3 == "POST" then
		for key4, val4 in pairs(v2) do
			assert(typeof(key4) == "string");
			if typeof(val4) ~= "string" and typeof(val4) ~= "number" and typeof(val4) ~= "boolean" then continue end
			table_clone_ret[key4] = tostring(val4);
		end
		for key5, val5 in pairs(AuthParameters) do
			v2[key5] = tostring(val5);
		end
		str1 = "application/json";
		JSONEncode_ret = HttpService:JSONEncode(v2);
	end
	local v3 = table1.LOCAL_TEST and table1.LOCAL_TEST_URL or m_Authentication.API_URL;
	local v4 = v3 .. p4 .. Functions.BuildQueryString(table3);
	local table4 = {
		Url = v4,
		Method = p3,
		Headers = {Authorization = m_Authentication.EncodeAuthenticationString(table_clone_ret)}
	};
	if str1 then
		table4.Headers["Content-Type"] = str1;
	end
	if JSONEncode_ret then
		table4.Body = JSONEncode_ret;
	end
	local success2, pcall_ret2_2 = pcall(function() -- Line: 205
		--[[
			Upvalues:
				[1] = HttpService
				[2] = table4
		--]]
		return HttpService:RequestAsync(table4);
	end);
	local v5;
	if success2 then
		v5 = pcall_ret2_2;
	else
		local table5 = {
			Success = false,
			StatusCode = 400,
			StatusMessage = tostring(pcall_ret2_2),
			Headers = {}
		};
		v5 = table5;
	end
	local table6 = {};
	if v5.Body then
		local JSONDecode_ret = HttpService:JSONDecode(table6);
		local _ = typeof(JSONDecode_ret) == "table";
	end
	return decodeResponse(v5);
end
return table1;
  -  Editar
  04:54:13.842    -  Editar
  04:54:13.842  ----- [2549] ServerScriptService.Library.FFlags.HTTPUtil.Encryption -----  -  Editar
  04:54:13.843  --[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

TG_Ftc7TTb74vanBj here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked to port it to Roblox in a way that doesn't overcomplicate it with support of unreachable
cases. Then, howmanysmall did some final optimizations that really squeeze out all the performance possible.
It's gotten stupid fast, thanks to her!

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {};
	[256] = sha2_H_hi;
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {};
	[512] = sha2_H_lo;
}, {
	[384] = {};
	[512] = sha2_H_hi;
}

local md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}
local md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3)) + bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10)) + W[j - 7] + W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7)) + bit32_band(e, f) + bit32_band(-1 - e, g) + h + K[j] + W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z + bit32_band(d, c) + bit32_band(a, bit32_bxor(d, c)) + bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 34, 160, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31), bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24), bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)) % 4294967296 +
				bit32_bxor(bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13), bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29), bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)) % 4294967296 +
				W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31), bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24), bit32_rshift(a_hi, 7)) +
				bit32_bxor(bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13), bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29), bit32_rshift(b_hi, 6)) +
				W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18), bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14), bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)) % 4294967296 +
				(bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 +
				h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18), bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14), bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)) +
				bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) +
				h_hi + K_hi[j] + W[jj - 1] +
				(tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo + (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296 + bit32_bxor(bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4), bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2), bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)) % 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi + (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi))) + bit32_bxor(bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4), bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2), bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)) + (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 25
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 27
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 28
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 26
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi = lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5], lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10], lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15], lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20], lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)), bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)), bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)), bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)), bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)), bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)), bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)), bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)), bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)), bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)), bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)), bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)), bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)), bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)), bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)), bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)), bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)), bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)), bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)), bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)), bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)), bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)), bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)), bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)), bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)), bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)), bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)), bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)), bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)), bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)), bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)), bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)), bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)), bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)), bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)), bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)), bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)), bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)), bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)), bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)), bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0, 0, 1
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1, 2)
				local _, delta = mul(R, mul(R, R, 1, 4), -1, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1, 2)
					_, delta = mul(R, R, -1, 2)
					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor
					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				local tailLength = #tail
				if tail ~= "" and tailLength + partLength >= 64 then
					offs = 64 - tailLength
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)

	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi = 0, "", table.pack(table.unpack(sha2_H_ext512_lo[width])), not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296) .. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)

	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)
				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)
				tail = nil

				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(lanes_lo, lanes_hi, tail .. string.sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail .. (#tail + 1 == block_size_in_bytes and string.char(gap_start + 128) or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128")
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296) .. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(table.concat(qwords, "", 1, qwords_qty), "(..)(..)(..)(..)(..)(..)(..)(..)", "%8%7%6%5%4%3%2%1"), qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end

			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62, ["-"] = 62, [62] = "+";
	["/"] = 63, ["_"] = 63, [63] = "/";
	["="] = -1, ["."] = -1, [-1] = "=";
}

local symbol_index = 0
for j, pair in ipairs{"AZ", "az", "09"} do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local stringLength = #binary_string
	local result = table.create(math.ceil(stringLength / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. '\0', 1, -1)
		length = length + 1
		result[length] =
			base64_symbols[math.floor(c1 / 4)] ..
			base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)] ..
			base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1] ..
			base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
--local function pad_and_xor(str, result_length, byte_for_xor)
--	return string.gsub(str, ".", function(c)
--		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
--	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
--end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	local KeyLength = #key
	if KeyLength > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		KeyLength = #key
	end

	local append = hash_func()(string.gsub(key, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), 0x36))
	end) .. string.rep("6", block_size - KeyLength)) -- 6 = string.char(0x36)

	local result

	local function partial(message_part)
		if not message_part then
			result = result or hash_func(
				string.gsub(key, ".", function(c)
					return string.char(bit32_bxor(string.byte(c), 0x5c))
				end) .. string.rep("\\", block_size - KeyLength) -- \ = string.char(0x5c)
					.. (string.gsub(append(), "%x%x", HexToBinFunction))
			)

			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end;

	sha256 = function(message)
		return sha256ext(256, message)
	end;

	sha512_224 = function(message)
		return sha512ext(224, message)
	end;

	sha512_256 = function(message)
		return sha512ext(256, message)
	end;

	sha384 = function(message)
		return sha512ext(384, message)
	end;

	sha512 = function(message)
		return sha512ext(512, message)
	end;

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end;

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end;

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end;

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end;

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end;

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end;

	-- misc utilities:
	hmac = hmac; -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin; -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin; -- converts base64 representation to binary string
	bin_to_base64 = bin2base64; -- converts binary string to base64 representation
	base64_encode = Base64.Encode;
	base64_decode = Base64.Decode;
}

block_size_for_HMAC = {
	[sha.md5] = 64;
	[sha.sha1] = 64;
	[sha.sha224] = 64;
	[sha.sha256] = 64;
	[sha.sha512_224] = 128;
	[sha.sha512_256] = 128;
	[sha.sha384] = 128;
	[sha.sha512] = 128;
	[sha.sha3_224] = (1600 - 2 * 224) / 8;
	[sha.sha3_256] = (1600 - 2 * 256) / 8;
	[sha.sha3_384] = (1600 - 2 * 384) / 8;
	[sha.sha3_512] = (1600 - 2 * 512) / 8;
}

return sha  -  Editar
  04:54:13.843    -  Editar
  04:54:13.843  ----- [2550] ServerScriptService.Library.FFlags.HTTPUtil.Encryption.Base64 -----  -  Editar
  04:54:13.844  -- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
			))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
			))
	end

	return table.concat(NewOutput)
end

return Base64  -  Editar
  04:54:13.844    -  Editar
  04:54:13.844  ----- [2551] ServerScriptService.Library.FFlags.HTTPUtil.Encryption.HashLib.spec -----  -  Editar
  04:54:13.844  local function describe(phrase, callback) end
local function it(phrase, callback) end
local function expect(value) end

return function()
	local HashLib = require(script.Parent)
	local sha256 = HashLib.sha256

	describe("HashLib.sha256", function()
		it("should properly encode strings", function()
			expect(sha256("abc").to.equal("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"))
			expect(sha256("The quick brown fox jumps over the lazy dog").to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592"))
			expect(sha256("123456").to.equal("8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92"))
		end)

		it("should create a private closure that works", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)

		it("should allow the private closure to work if called twice", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			AppendNextChunk()
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)
	end)
end  -  Editar
  04:54:13.844    -  Editar
  04:54:13.844  ----- [2552] ServerScriptService.Library.FFlags.HTTPUtil.Authentication -----  -  Editar
  04:54:13.844  local Authentication = {}
local Encrypt = require(script.Parent:WaitForChild("Encryption"))

-- ======== AUTHENTICATION SPECIFICATION ========
-- Write requests require a few things.  First, each request must contain the
-- following fields: "TS" (timestamp), "baseURL" and "PBLC" (the public access key).
-- each request requires an 'Authentication' header, which can be built as follows:
-- MAKE_AUTH_STRING(query):
--   assert(query contains TS, baseURL, PBLC)
--   let alph = empty string
--   for key, value in alphabeticalSorted(query):
--     append (key + "=" + value + "&") to alph
--   remove trailing '&' from alph
--   let signingKey = KEY_PUBLIC + KEY_PRIVATE
--   let encrypted = HMAC_SHA256(key=signingKey, message=alph)
--   let finalAuthenticationString = "OAuth " + encrypted
-- 
-- The function Authentication.EncodeAuthenticationString implements
-- the pseudocode listed above.

-- ======== PUBLIC AND PRIVATE WRITE KEYS ========
-- protect these bad boys at all cost.  it's okay if the public key gets out, but
-- if the private key is released, anybody will be able to write data.  there is
-- an entirely different set of keys used for reading, which should never be
-- placed inside of a ROBLOX script for security purposes.  if these keys are released,
-- our data is still protected.  worst case scenario, somebody can write some junk
-- data that we can delete later.  but again, that can only happen if this source
-- code is leaked, and some neferious guy actually knows what to do w/ these keys.
-- If these are discovered, we can easily swap them out for a new set of keys.

Authentication.API_URL           =  script:WaitForChild("API_URL").Value;
Authentication.API_KEY_PUBLIC    = script:WaitForChild("API_KEY_PUBLIC").Value;
Authentication.API_KEY_PRIVATE   = script:WaitForChild("API_KEY_PRIVATE").Value;

function Authentication.getAuthParameters()  
	local auth = {
		baseURL = Authentication.API_URL,
		TS = tostring((math.floor((os.time())))),
		PBLC = Authentication.API_KEY_PUBLIC
	}

	return auth
end

function Authentication.EncodeAuthenticationString(queryParams)

	local alph = {}
	for k, v in pairs(queryParams) do
		if typeof(k) == "string" and typeof(v) == "string" then
			table.insert(alph, {k, v})
		end	
	end

	table.sort(alph, function(a, b)
		return a[1] < b[1]
	end)

	local sigBase = ""
	for _, tuple in ipairs(alph) do
		sigBase = sigBase .. tuple[1] .. "=" .. tuple[2] .. "&"
	end
	sigBase = sigBase:sub(1, sigBase:len() - 1)

	local signingKey = Authentication.API_KEY_PUBLIC .. Authentication.API_KEY_PRIVATE
	local encrypted = Encrypt.hmac(Encrypt.sha256, signingKey, sigBase)

	local authString = "OAuth " .. encrypted
	return authString

end

return Authentication
  -  Editar
  04:54:13.844    -  Editar
  04:54:13.844  ----- [2553] ServerScriptService.__DataStoreService -----  -  Editar
  04:54:13.844  --[[

	MongoStore is an alternative to DataStoreService
	which uses the Rongo module as an interface to
	MongoDB.
	
	MongoStore includes quite a few of the functions
	which DataStoreService has and it aims to make the
	transition from DataStoreService as smooth as possible
	
	You will need a MongoDB account to use MongoStore
	
	Version: 1.0.0
	License: MIT License
	Contributors:
		- Starnamics (Creator)

--]]

MONGOSTORE_CLUSTER = "Cluster0"
IS_USING_RONGO = true

local DSS = game:GetService("DataStoreService")

local warn = function(...) return warn("[MongoStore]",...) end
local print = function(...) return print("[MongoStore]",...) end

local Rongo = require(script:WaitForChild("Rongo"))
local Client = nil	
local isOffline = false

local MongoStore = {}

local MongoDataStore = {}
MongoDataStore.__index = MongoDataStore

local function to_base64(data)
	local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	return ((data:gsub('.', function(x) 
		local r,b='',x:byte()
		for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end
		return r;
	end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)
		if (#x < 6) then return '' end
		local c=0
		for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end
		return b:sub(c+1,c+1)
	end)..({ '', '==', '=' })[#data%3+1])
end

function from_base64(data)
	local b = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	data = string.gsub(data, '[^'..b..'=]', '')
	return (data:gsub('.', function(x)
		if (x == '=') then return '' end
		local r,f='',(b:find(x)-1)
		for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
		return r;
	end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
		if (#x ~= 8) then return '' end
		local c=0
		for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
		return string.char(c)
	end))
end

local function encodeProfile(profile)
	local jsonData = game:GetService("HttpService"):JSONEncode(profile)
	local base = to_base64(jsonData)
	base = string.reverse(base)
	
	return base
end

local function decodeProfile(base)
	base = string.reverse(base)
	
	local jsonData = from_base64(base)
	local profile = game:GetService("HttpService"):JSONDecode(jsonData)
	
	return profile
end

function TransformKey(Name,Scope,Key)
	local NewKey = Name
	if Scope then
		NewKey = Name.."'"..Scope
	end
	NewKey = NewKey.."'"..Key
	return NewKey
end

local function checkIsOffline()
	local success, message = pcall(function()
		DSS.GetDataStore("__DS").SetAsync("__DS", os.time());
	end)

	local noInternetAccess = success == false and string.find(message, "ConnectFail", 1, true) ~= nil
	if noInternetAccess then
		warn("No internet access - check your network connection")
	end

	if (success == false) then
		warn("Offline!")
		isOffline = true
	end
end

function MongoStore:Authorize(API_ID:string,API_KEY:string,Cluster: string?): boolean?
	if Cluster then MONGOSTORE_CLUSTER = Cluster end
	
	checkIsOffline()
	Client = Rongo.new(API_ID,API_KEY)
	return true
end

function MongoStore:GetDataStore(Name: string,Scope: string)
	if not Client then repeat task.wait() until Client end
	local DataStore = {}
	setmetatable(DataStore,MongoDataStore)
	DataStore.Name = Name
	DataStore.Scope = Scope
	
	if not isOffline then
		DataStore.DSS = DSS:GetDataStore(Name,Scope)
	end
	return DataStore
end

function MongoDataStore:GetAsync(Key: string): {[string]: any?}?
	local Data = ((not isOffline) and self.DSS:GetAsync(Key) or nil)
	
	if not Data then
		local Collection = Client:GetCluster(MONGOSTORE_CLUSTER):GetDatabase("Datastore"):GetCollection("PlayerData")
		Key = TransformKey(self.Name,self.Scope,Key)
		local Document = Collection:FindOne({["key"] = Key})
		if Document then Data = Document["data"] else Data = nil end
	end
	
	local realData = Data ~= nil and decodeProfile(Data) or nil
	return realData
end

function MongoDataStore:RemoveAsync(Key: string): boolean
	if not isOffline then
		self.DSS:RemoveAsync(Key)
	end
	
	local Collection = Client:GetCluster(MONGOSTORE_CLUSTER):GetDatabase("Datastore"):GetCollection("PlayerData")
	Key = TransformKey(self.Name,self.Scope,Key)
	local Result = Collection:DeleteOne({["key"] = Key})
	if not Result or Result == 0 then return false end
	return true
end

function MongoDataStore:SetAsync(Key: string,Value: any): boolean
	Value = encodeProfile(Value)
	
	if not isOffline then
		self.DSS:SetAsync(Key,Value)
	end
	
	spawn(function()
		local Collection = Client:GetCluster(MONGOSTORE_CLUSTER):GetDatabase("Datastore"):GetCollection("PlayerData")
		Key = TransformKey(self.Name,self.Scope,Key)
		local Result = Collection:ReplaceOne({["key"] = Key},{["key"] = Key,["data"] = Value},true)
		if not Result or Result.modifiedCount == 0 then return false end
	end)
	return Value
end

function MongoDataStore:UpdateAsync(Key: string,Value: any): boolean
	local OldData = self:GetAsync(Key)
	local NewData = Value(OldData)
	self:SetAsync(Key,NewData)
	return NewData
end

local mockDB = require(script:WaitForChild("MockDataStoreService"))
function MongoStore:GetOrderedDataStore(Name,Scope)
	if not isOffline then
		return game:GetService("DataStoreService"):GetOrderedDataStore(Name,Scope)
	end
	
	return mockDB:GetOrderedDataStore(Name,Scope)
end

if not IS_USING_RONGO then
	checkIsOffline()
	
	if not isOffline then
		return game:GetService("DataStoreService")
	end
	
	return mockDB
end

MongoStore:Authorize(" "," ")
return MongoStore
  -  Editar
  04:54:13.846    -  Editar
  04:54:13.846  ----- [2554] ServerScriptService.__DataStoreService.MockDataStoreService -----  -  Editar
  04:54:13.846  --[[
	MockDataStoreService.lua
	This module implements the API and functionality of Roblox's DataStoreService class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStoreService = {}

local MockDataStoreManager = require(script.MockDataStoreManager)
local MockGlobalDataStore = require(script.MockGlobalDataStore)
local MockOrderedDataStore = require(script.MockOrderedDataStore)
local Utils = require(script.MockDataStoreUtils)
local Constants = require(script.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode

local function makeGetWrapper(methodName, getObject, isGlobal) -- Helper function to reduce amount of redundant code
	return function(_, name, scope)
		if not game:GetService("RunService"):IsServer() then
			error("DataStore can't be accessed from client", 2)
		end

		if isGlobal then
			return getObject()
		else
			if type(name) ~= "string" then
				error(("bad argument #1 to '%s' (string expected, got %s)")
					:format(methodName, typeof(name)), 2)
			elseif scope ~= nil and type(scope) ~= "string" then
				error(("bad argument #2 to '%s' (string expected, got %s)")
					:format(methodName, typeof(scope)), 2)
			elseif #name == 0 then
				error(("bad argument #1 to '%s' (name can't be empty string)")
					:format(methodName), 2)
			elseif #name > Constants.MAX_LENGTH_NAME then
				error(("bad argument #1 to '%s' (name exceeds %d character limit)")
					:format(methodName, Constants.MAX_LENGTH_NAME), 2)
			elseif scope and #scope == 0 then
				error(("bad argument #2 to '%s' (scope can't be empty string)")
					:format(methodName), 2)
			elseif scope and #scope > Constants.MAX_LENGTH_SCOPE then
				error(("bad argument #2 to '%s' (scope exceeds %d character limit)")
					:format(methodName, Constants.MAX_LENGTH_SCOPE), 2)
			end
			return getObject(name, scope or "global")
		end

	end
end

MockDataStoreService.GetGlobalDataStore = makeGetWrapper(
	"GetGlobalDataStore",
    function()
        local data = MockDataStoreManager.GetGlobalData()

        local interface = MockDataStoreManager.GetDataInterface(data)
        if interface then
            return interface
        end

        local value = {
			__type = "GlobalDataStore";
            __data = data; -- Mapping from <key> to <value>
            __event = Instance.new("BindableEvent"); -- For OnUpdate
			__writeCache = {};
			__writeLock = {};
			__getCache = {};
        }
        interface = setmetatable(value, MockGlobalDataStore)
		MockDataStoreManager.SetDataInterface(data, interface)

		return interface
	end,
	true -- This is the global datastore, no name/scope needed
)

MockDataStoreService.GetDataStore = makeGetWrapper(
	"GetDataStore",
	function(name, scope)
        local data = MockDataStoreManager.GetData(name, scope)

        local interface = MockDataStoreManager.GetDataInterface(data)
        if interface then
            return interface
        end

        local value = {
			__type = "GlobalDataStore";
            __name = name;
            __scope = scope;
            __data = data; -- Mapping from <key> to <value>
            __event = Instance.new("BindableEvent"); -- For OnUpdate
			__writeCache = {};
			__writeLock = {};
			__getCache = {};
        }
        interface = setmetatable(value, MockGlobalDataStore)
		MockDataStoreManager.SetDataInterface(data, interface)

        return interface
	end
)

MockDataStoreService.GetOrderedDataStore = makeGetWrapper(
	"GetOrderedDataStore",
	function(name, scope)
        local data = MockDataStoreManager.GetOrderedData(name, scope)

        local interface = MockDataStoreManager.GetDataInterface(data)
        if interface then
            return interface
        end

        local value = {
			__type = "OrderedDataStore";
            __name = name;
            __scope = scope;
            __data = data; -- Mapping from <key> to <value>
            __sorted = {}; -- List of {Key = <key>, Value = <value>} pairs
            __ref = {}; -- Mapping from <key> to corresponding {Key = <key>, Value = <value>} entry in __sorted
            __changed = false; -- Whether __sorted is guaranteed sorted at the moment
            __event = Instance.new("BindableEvent"); -- For OnUpdate
			__writeCache = {};
			__writeLock = {};
			__getCache = {};
        }
        interface = setmetatable(value, MockOrderedDataStore)
		MockDataStoreManager.SetDataInterface(data, interface)

		return interface
	end
)

local DataStoreRequestTypes = {}

for _, Enumerator in ipairs(Enum.DataStoreRequestType:GetEnumItems()) do
	DataStoreRequestTypes[Enumerator] = Enumerator
	DataStoreRequestTypes[Enumerator.Name] = Enumerator
	DataStoreRequestTypes[Enumerator.Value] = Enumerator
end

function MockDataStoreService:GetRequestBudgetForRequestType(requestType) -- luacheck: ignore self
	if not DataStoreRequestTypes[requestType] then
		error(("bad argument #1 to 'GetRequestBudgetForRequestType' (unable to cast '%s' of type %s to DataStoreRequestType)")
			:format(tostring(requestType), typeof(requestType)), 2)
	end

	return MockDataStoreManager.GetBudget(DataStoreRequestTypes[requestType])
end

function MockDataStoreService:ImportFromJSON(json, verbose) -- luacheck: ignore self
	local content
	if type(json) == "string" then
		local parsed, value = pcall(function() return HttpService:JSONDecode(json) end)
		if not parsed then
			error("bad argument #1 to 'ImportFromJSON' (string is not valid json)", 2)
		end
		content = value
	elseif type(json) == "table" then
		content = Utils.deepcopy(json)
	else
		error(("bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)"):format(typeof(json)), 2)
	end
	if verbose ~= nil and type(verbose) ~= "boolean" then
		error(("bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)"):format(typeof(verbose)), 2)
	end

	return MockDataStoreManager.ImportFromJSON(content, verbose)
end

function MockDataStoreService:ExportToJSON() -- luacheck: ignore self
	return MockDataStoreManager.ExportToJSON()
end

return MockDataStoreService
  -  Editar
  04:54:13.846    -  Editar
  04:54:13.846  ----- [2555] ServerScriptService.__DataStoreService.MockDataStoreService.MockDataStoreConstants -----  -  Editar
  04:54:13.846  --[[
    MockDataStoreConstants.lua
    Contains all constants used by the entirety of MockDataStoreService and its sub-classes.

    This module is licensed under APLv2, refer to the LICENSE file or:
    https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

return {

    LOGGING_ENABLED = true;        -- Verbose logging of transactions to output
    LOGGING_FUNCTION = warn;        -- Function for logging messages

    MAX_LENGTH_KEY = 50;            -- Max number of chars in key string
    MAX_LENGTH_NAME = 50;           -- Max number of chars in name string
    MAX_LENGTH_SCOPE = 50;          -- Max number of chars in scope string
    MAX_LENGTH_DATA = 4194301;      -- Max number of chars in (encoded) data strings

    MAX_PAGE_SIZE = 100;            -- Max page size for GetSortedAsync

    YIELD_TIME_MIN = 0.2;           -- Random yield time values for set/get/update/remove/getsorted
    YIELD_TIME_MAX = 0.5;

    YIELD_TIME_UPDATE_MIN = 0.2;    -- Random yield times from events from OnUpdate
    YIELD_TIME_UPDATE_MAX = 0.5;

    WRITE_COOLDOWN = 6.0;           -- Amount of cooldown time between writes on the same key in a particular datastore

    GET_COOLDOWN = 5.0;             -- Amount of cooldown time that a recent interaction with a key is considered fresh

    THROTTLE_QUEUE_SIZE = 30;       -- Amount of requests that can be throttled at once (additional requests will error)

    SIMULATE_ERROR_RATE = 0;        -- Rate at which requests will throw errors for testing (0 = never, 1 = always)

    BUDGETING_ENABLED = true;       -- Whether budgets are enforced and calculated

    BUDGET_GETASYNC = {             -- Budget constant storing structure
        START = 100;                    -- Starting budget
        RATE = 60;                      -- Added budget per minute
        RATE_PLR = 10;                  -- Additional added budget per minute per player
        MAX_FACTOR = 3;                 -- The maximum budget as a factor of (rate + rate_plr * #players)
    };

    BUDGET_GETSORTEDASYNC = {
        START = 10;
        RATE = 5;
        RATE_PLR = 2;
        MAX_FACTOR = 3;
    };

    BUDGET_ONUPDATE = {
        START = 30;
        RATE = 30;
        RATE_PLR = 5;
        MAX_FACTOR = 1;
    };

    BUDGET_SETINCREMENTASYNC = {
        START = 100;
        RATE = 60;
        RATE_PLR = 10;
        MAX_FACTOR = 3;
    };

    BUDGET_SETINCREMENTSORTEDASYNC = {
        START = 50;
        RATE = 30;
        RATE_PLR = 5;
        MAX_FACTOR = 3;
    };

    BUDGET_BASE = 60;               -- Modifiers used for budget increases on OnClose
    BUDGET_ONCLOSE_BASE = 150;

    BUDGET_UPDATE_INTERVAL = 1.0;   -- Time interval in seconds at which budgets are updated (do not put too low)

}
  -  Editar
  04:54:13.846    -  Editar
  04:54:13.846  ----- [2556] ServerScriptService.__DataStoreService.MockDataStoreService.MockDataStoreManager -----  -  Editar
  04:54:13.846  --[[
	MockDataStoreManager.lua
	This module does bookkeeping of data, interfaces and request limits used by MockDataStoreService and its sub-classes.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStoreManager = {}

local Utils = require(script.Parent.MockDataStoreUtils)
local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode
local Players = game:GetService("Players") -- for restoring budgets
local RunService = game:GetService("RunService") -- for checking if running context is on server

local ConstantsMapping = {
	[Enum.DataStoreRequestType.GetAsync] = Constants.BUDGET_GETASYNC;
	[Enum.DataStoreRequestType.GetSortedAsync] = Constants.BUDGET_GETSORTEDASYNC;
	[Enum.DataStoreRequestType.OnUpdate] = Constants.BUDGET_ONUPDATE;
	[Enum.DataStoreRequestType.SetIncrementAsync] = Constants.BUDGET_SETINCREMENTASYNC;
	[Enum.DataStoreRequestType.SetIncrementSortedAsync] = Constants.BUDGET_SETINCREMENTSORTEDASYNC;
}

-- Bookkeeping of all data:
local Data = {
	GlobalDataStore = {};
	DataStore = {};
	OrderedDataStore = {};
}

-- Bookkeeping of all active GlobalDataStore/OrderedDataStore interfaces indexed by data table:
local Interfaces = {}

-- Request limit bookkeeping:
local Budgets = {}

local budgetRequestQueues = {
	[Enum.DataStoreRequestType.GetAsync] = {};
	[Enum.DataStoreRequestType.GetSortedAsync] = {};
	[Enum.DataStoreRequestType.OnUpdate] = {};
	[Enum.DataStoreRequestType.SetIncrementAsync] = {};
	[Enum.DataStoreRequestType.SetIncrementSortedAsync] = {};
}

local function initBudget()
	for requestType, const in pairs(ConstantsMapping) do
		Budgets[requestType] = const.START
	end
	Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
		Budgets[Enum.DataStoreRequestType.GetAsync],
		Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
	)
end

local function updateBudget(req, const, dt, n)
	if not Constants.BUDGETING_ENABLED then
		return
	end
	local rate = const.RATE + n * const.RATE_PLR
	Budgets[req] = math.min(
		Budgets[req] + dt * rate,
		const.MAX_FACTOR * rate
	)
end

local function stealBudget(budget)
	if not Constants.BUDGETING_ENABLED then
		return
	end
	for _, requestType in pairs(budget) do
		if Budgets[requestType] then
			Budgets[requestType] = math.max(0, Budgets[requestType] - 1)
		end
	end
	Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
		Budgets[Enum.DataStoreRequestType.GetAsync],
		Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
	)
end

local function checkBudget(budget)
	if not Constants.BUDGETING_ENABLED then
		return true
	end
	for _, requestType in pairs(budget) do
		if Budgets[requestType] and Budgets[requestType] < 1 then
			return false
		end
	end
	return true
end

local isFrozen = false

if RunService:IsServer() then
	-- Only do budget/throttle updating on server (in case package required on client)

	initBudget()

	task.spawn(function() -- Thread that increases budgets and de-throttles requests periodically
		local lastCheck = tick()
		while task.wait(Constants.BUDGET_UPDATE_INTERVAL) do
			local now = tick()
			local dt = (now - lastCheck) / 60
			lastCheck = now
			local n = #Players:GetPlayers()

			if not isFrozen then
				for requestType, const in pairs(ConstantsMapping) do
					updateBudget(requestType, const, dt, n)
				end
				Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
					Budgets[Enum.DataStoreRequestType.GetAsync],
					Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
				)
			end

			for _, budgetRequestQueue in pairs(budgetRequestQueues) do
				for i = #budgetRequestQueue, 1, -1 do
					local request = budgetRequestQueue[i]

					local thread = request.Thread
					local budget = request.Budget
					local key = request.Key
					local lock = request.Lock
					local cache = request.Cache

					if not (lock and (lock[key] or tick() - (cache[key] or 0) < Constants.WRITE_COOLDOWN)) and checkBudget(budget) then
						table.remove(budgetRequestQueue, i)
						stealBudget(budget)
						coroutine.resume(thread)
					end
				end
			end
		end
	end)

	game:BindToClose(function()
		for requestType, const in pairs(ConstantsMapping) do
			Budgets[requestType] = math.max(
				Budgets[requestType],
				Constants.BUDGET_ONCLOSE_BASE * (const.RATE / Constants.BUDGET_BASE)
			)
		end
		Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
			Budgets[Enum.DataStoreRequestType.GetAsync],
			Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
				)
		--	end
		--end)
	end)
end

function MockDataStoreManager.GetGlobalData()
	return Data.GlobalDataStore
end

function MockDataStoreManager.GetData(name, scope)
	assert(type(name) == "string")
	assert(type(scope) == "string")

	if not Data.DataStore[name] then
		Data.DataStore[name] = {}
	end
	if not Data.DataStore[name][scope] then
		Data.DataStore[name][scope] = {}
	end

	return Data.DataStore[name][scope]
end

function MockDataStoreManager.GetOrderedData(name, scope)
	assert(type(name) == "string")
	assert(type(scope) == "string")

	if not Data.OrderedDataStore[name] then
		Data.OrderedDataStore[name] = {}
	end
	if not Data.OrderedDataStore[name][scope] then
		Data.OrderedDataStore[name][scope] = {}
	end

	return Data.OrderedDataStore[name][scope]
end

function MockDataStoreManager.GetDataInterface(data)
	return Interfaces[data]
end

function MockDataStoreManager.SetDataInterface(data, interface)
	assert(type(data) == "table")
	assert(type(interface) == "table")

	Interfaces[data] = interface
end

function MockDataStoreManager.GetBudget(requestType)
	if Constants.BUDGETING_ENABLED then
		return math.floor(Budgets[requestType] or 0)
	else
		return math.huge
	end
end

function MockDataStoreManager.SetBudget(requestType, budget)
	assert(type(budget) == "number")
	budget = math.max(budget, 0)

	if requestType == Enum.DataStoreRequestType.UpdateAsync then
		Budgets[Enum.DataStoreRequestType.SetIncrementAsync] = budget
		Budgets[Enum.DataStoreRequestType.GetAsync] = budget
	end

	if Budgets[requestType] then
		Budgets[requestType] = budget
	end
end

function MockDataStoreManager.ResetBudget()
	initBudget()
end

function MockDataStoreManager.FreezeBudgetUpdates()
	isFrozen = true
end

function MockDataStoreManager.ThawBudgetUpdates()
	isFrozen = false
end

function MockDataStoreManager.YieldForWriteLockAndBudget(callback, key, writeLock, writeCache, budget)
	assert(type(callback) == "function")
	assert(type(key) == "string")
	assert(type(writeLock) == "table")
	assert(type(writeCache) == "table")
	assert(#budget > 0)

	local mainRequestType = budget[1]

	if #budgetRequestQueues[mainRequestType] >= Constants.THROTTLE_QUEUE_SIZE then
		return false -- no room in throttle queue
	end

	callback() -- would i.e. trigger a warning in output

	table.insert(budgetRequestQueues[mainRequestType], 1, {
		Key = key;
		Lock = writeLock;
		Cache = writeCache;
		Thread = coroutine.running();
		Budget = budget;
	})
	coroutine.yield()

	return true
end

function MockDataStoreManager.YieldForBudget(callback, budget)
	assert(type(callback) == "function")
	assert(#budget > 0)

	local mainRequestType = budget[1]

	if checkBudget(budget) then
		stealBudget(budget)
	elseif #budgetRequestQueues[mainRequestType] >= Constants.THROTTLE_QUEUE_SIZE then
		return false -- no room in throttle queue
	else
		callback() -- would i.e. trigger a warning in output

		table.insert(budgetRequestQueues[mainRequestType], 1, {
			After = 0; -- no write lock
			Thread = coroutine.running();
			Budget = budget;
		})
		coroutine.yield()
	end

	return true
end

function MockDataStoreManager.ExportToJSON()
	local export = {}

	if next(Data.GlobalDataStore) ~= nil then -- GlobalDataStore not empty
		export.GlobalDataStore = Data.GlobalDataStore
	end
	export.DataStore = Utils.prepareDataStoresForExport(Data.DataStore) -- can be nil
	export.OrderedDataStore = Utils.prepareDataStoresForExport(Data.OrderedDataStore) -- can be nil

	return HttpService:JSONEncode(export)
end

-- Import into an entire datastore type:
local function importDataStoresFromTable(origin, destination, warnFunc, methodName, prefix, isOrdered)
	for name, scopes in pairs(origin) do
		if type(name) ~= "string" then
			warnFunc(("%s: ignored %s > %q (name is not a string, but a %s)")
				:format(methodName, prefix, tostring(name), typeof(name)))
		elseif type(scopes) ~= "table" then
			warnFunc(("%s: ignored %s > %q (scope list is not a table, but a %s)")
				:format(methodName, prefix, name, typeof(scopes)))
		elseif #name == 0 then
			warnFunc(("%s: ignored %s > %q (name is an empty string)")
				:format(methodName, prefix, name))
		elseif #name > Constants.MAX_LENGTH_NAME then
			warnFunc(("%s: ignored %s > %q (name exceeds %d character limit)")
				:format(methodName, prefix, name, Constants.MAX_LENGTH_NAME))
		else
			for scope, data in pairs(scopes) do
				if type(scope) ~= "string" then
					warnFunc(("%s: ignored %s > %q > %q (scope is not a string, but a %s)")
						:format(methodName, prefix, name, tostring(scope), typeof(scope)))
				elseif type(data) ~= "table" then
					warnFunc(("%s: ignored %s > %q > %q (data list is not a table, but a %s)")
						:format(methodName, prefix, name, scope, typeof(data)))
				elseif #scope == 0 then
					warnFunc(("%s: ignored %s > %q > %q (scope is an empty string)")
						:format(methodName, prefix, name, scope))
				elseif #scope > Constants.MAX_LENGTH_SCOPE then
					warnFunc(("%s: ignored %s > %q > %q (scope exceeds %d character limit)")
						:format(methodName, prefix, name, scope, Constants.MAX_LENGTH_SCOPE))
				else
					if not destination[name] then
						destination[name] = {}
					end
					if not destination[name][scope] then
						destination[name][scope] = {}
					end
					Utils.importPairsFromTable(
						data,
						destination[name][scope],
						Interfaces[destination[name][scope]],
						warnFunc,
						methodName,
						("%s > %q > %q"):format(prefix, name, scope),
						isOrdered
					)
				end
			end
		end
	end
end

function MockDataStoreManager.ImportFromJSON(content, verbose)
	assert(type(content) == "table")
	assert(verbose == nil or type(verbose) == "boolean")

	local warnFunc = warn -- assume verbose as default
	if verbose == false then -- intentional formatting
		warnFunc = function() end
	end

	if type(content.GlobalDataStore) == "table" then
		Utils.importPairsFromTable(
			content.GlobalDataStore,
			Data.GlobalDataStore,
			Interfaces[Data.GlobalDataStore],
			warnFunc,
			"ImportFromJSON",
			"GlobalDataStore",
			false
		)
	end
	if type(content.DataStore) == "table" then
		importDataStoresFromTable(
			content.DataStore,
			Data.DataStore,
			warnFunc,
			"ImportFromJSON",
			"DataStore",
			false
		)
	end
	if type(content.OrderedDataStore) == "table" then
		importDataStoresFromTable(
			content.OrderedDataStore,
			Data.OrderedDataStore,
			warnFunc,
			"ImportFromJSON",
			"OrderedDataStore",
			true
		)
	end
end

local function clearTable(t)
	for i,_ in pairs(t) do
		t[i] = nil
	end
end

function MockDataStoreManager.ResetData()
	for _, interface in pairs(Interfaces) do
		for key, _ in pairs(interface.__data) do
			interface.__data[key] = nil
			interface.__event:Fire(key, nil)
		end
		interface.__getCache = {}
		interface.__writeCache = {}
		interface.__writeLock = {}
		if interface.__sorted then
			interface.__sorted = {};
            interface.__ref = {};
            interface.__changed = false;
		end
	end

	clearTable(Data.GlobalDataStore)

	for _, scopes in pairs(Data.DataStore) do
		for _, data in pairs(scopes) do
			clearTable(data)
		end
	end

	for _, scopes in pairs(Data.OrderedDataStore) do
		for _, data in pairs(scopes) do
			clearTable(data)
		end
	end
end

return MockDataStoreManager
  -  Editar
  04:54:13.846    -  Editar
  04:54:13.846  ----- [2557] ServerScriptService.__DataStoreService.MockDataStoreService.MockDataStorePages -----  -  Editar
  04:54:13.847  --[[
	MockDataStorePages.lua
	This module implements the API and functionality of Roblox's DataStorePages class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStorePages = {}
MockDataStorePages.__index = MockDataStorePages

local MockDataStoreManager = require(script.Parent.MockDataStoreManager)
local Utils = require(script.Parent.MockDataStoreUtils)

function MockDataStorePages:GetCurrentPage()
	local retValue = {}

	local minimumIndex = math.max(1, (self.__currentPage - 1) * self.__pageSize + 1)
	local maximumIndex = math.min(self.__currentPage * self.__pageSize, #self.__results)
	for i = minimumIndex, maximumIndex do
		table.insert(retValue, {key = self.__results[i].key, value = self.__results[i].value})
	end

	return retValue
end

function MockDataStorePages:AdvanceToNextPageAsync()
	if self.IsFinished then
		error("AdvanceToNextPageAsync rejected with error (no pages to advance to)", 2)
	end

	Utils.simulateErrorCheck("AdvanceToNextPageAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn("AdvanceToNextPageAsync request was throttled due to lack of budget. Try sending fewer requests.")
		end,
		{Enum.DataStoreRequestType.GetAsync}
	)

	if not success then
		error("AdvanceToNextPageAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	Utils.simulateYield()

	if #self.__results > self.__currentPage * self.__pageSize then
		self.__currentPage = self.__currentPage + 1
	end
	self.IsFinished = #self.__results <= self.__currentPage * self.__pageSize

	Utils.logMethod(self.__datastore, "AdvanceToNextPageAsync")

end

return MockDataStorePages
  -  Editar
  04:54:13.847    -  Editar
  04:54:13.847  ----- [2558] ServerScriptService.__DataStoreService.MockDataStoreService.MockDataStoreUtils -----  -  Editar
  04:54:13.847  --[[
	MockDataStoreUtils.lua
	Contains helper and utility functions used by other classes.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStoreUtils = {}

local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode
local RunService = game:GetService("RunService")

local rand = Random.new()

local function shorten(s, num)
	if #s > num then
		return s:sub(1,num-2) .. ".."
	end
	return s
end

--[[
	[DataStore] [Name/Scope] [GetAsync] KEY
	[DataStore] [Name/Scope] [UpdateAsync] KEY => VALUE
	[DataStore] [Name/Scope] [SetAsync] KEY => VALUE
	[DataStore] [Name/Scope] [IncrementAsync] KEY by INCR => VALUE
	[DataStore] [Name/Scope] [RemoveAsync] KEY =/> VALUE
	[DataStore] [Name/Scope] [OnUpdate] KEY
	[DataStore] [Name/Scope] [GetSortedAsync]

	[OrderedDataStore] [Name/Scope] [GetAsync] KEY
	[OrderedDataStore] [Name/Scope] [UpdateAsync] KEY => VALUE
	[OrderedDataStore] [Name/Scope] [SetAsync] KEY => VALUE
	[OrderedDataStore] [Name/Scope] [IncrementAsync] KEY + INCR => VALUE
	[OrderedDataStore] [Name/Scope] [RemoveAsync] KEY =/> VALUE
	[OrderedDataStore] [Name/Scope] [OnUpdate] KEY
	[OrderedDataStore] [Name/Scope] [GetSortedAsync]

	[OrderedDataStore] [Name/Scope] [AdvanceToNextPageAsync]
]]

local function logMethod(self, method, key, value, increment)
	if not Constants.LOGGING_ENABLED or type(Constants.LOGGING_FUNCTION) ~= "function" then
		return
	end

	local name = self.__name
	local scope = self.__scope

	local prefix
	if not name then
		prefix = ("[GlobalDataStore] [%s]"):format(method)
	elseif not scope then
		prefix = ("[%s] [%s] [%s]"):format(self.__type, shorten(name, 20), method)
	else
		prefix = ("[%s] [%s/%s] [%s]"):format(self.__type, shorten(name, 15), shorten(scope, 15), method)
	end

	local message
	if value and increment then
		message = key .. " + " .. tostring(increment) .. " => " .. tostring(value)
	elseif increment then
		message = key .. " + " .. tostring(increment)
	elseif value then
		if method == "RemoveAsync" then
			message = key .. " =/> " .. tostring(value)
		else
			message = key .. " => " .. tostring(value)
		end
	else
		message = "key"
	end

	Constants.LOGGING_FUNCTION(prefix .. " " .. message)

end

local function deepcopy(t)
	if type(t) == "table" then
		local n = {}
		for i,v in pairs(t) do
			n[i] = deepcopy(v)
		end
		return n
	else
		return t
	end
end

local function scanValidity(tbl, passed, path) -- Credit to Corecii (edited)
	if type(tbl) ~= "table" then
		return scanValidity({input = tbl}, {}, {})
	end
	passed, path = passed or {}, path or {"root"}
	passed[tbl] = true
	local tblType
	do
		local key = next(tbl)
		if type(key) == "number" then
			tblType = "Array"
		else
			tblType = "Dictionary"
		end
	end
	local last = 0
	for key, value in next, tbl do
		path[#path + 1] = tostring(key)
		if type(key) == "number" then
			if tblType == "Dictionary" then
				return false, path, "cannot store mixed tables"
			elseif key % 1 ~= 0 then
				return false, path, "cannot store tables with non-integer indices"
			elseif key == math.huge or key == -math.huge then
				return false, path, "cannot store tables with (-)infinity indices"
			end
		elseif type(key) ~= "string" then
			return false, path, "dictionaries cannot have keys of type " .. typeof(key)
		elseif tblType == "Array" then
			return false, path, "cannot store mixed tables"
		elseif not utf8.len(key) then
			return false, path, "dictionary has key that is invalid UTF-8"
		end
		if tblType == "Array" then
			if last ~= key - 1 then
				return false, path, "array has non-sequential indices"
			end
			last = key
		end
		if type(value) == "userdata" or type(value) == "function" or type(value) == "thread" then
			return false, path, "cannot store value '" .. tostring(value) .. "' of type " .. typeof(value)
		elseif type(value) == "string" and not utf8.len(value) then
			return false, path, "cannot store strings that are invalid UTF-8"
		end
		if type(value) == "table" then
			if passed[value] then
				return false, path, "cannot store cyclic tables"
			end
			local isValid, keyPath, reason = scanValidity(value, passed, path)
			if not isValid then
				return isValid, keyPath, reason
			end
		end
		path[#path] = nil
	end
	passed[tbl] = nil
	return true
end

local function getStringPath(path)
	return table.concat(path, '.')
end

-- Import into a single datastore:
local function importPairsFromTable(origin, destination, interface, warnFunc, methodName, prefix, isOrdered)
	for key, value in pairs(origin) do
		if type(key) ~= "string" then
			warnFunc(("%s: ignored %s > '%s' (key is not a string, but a %s)")
				:format(methodName, prefix, tostring(key), typeof(key)))
		elseif not utf8.len(key) then
			warnFunc(("%s: ignored %s > '%s' (key is not valid UTF-8)")
				:format(methodName, prefix, tostring(key)))
		elseif #key > Constants.MAX_LENGTH_KEY then
			warnFunc(("%s: ignored %s > '%s' (key exceeds %d character limit)")
				:format(methodName, prefix, key, Constants.MAX_LENGTH_KEY))
		elseif type(value) == "string" and #value > Constants.MAX_LENGTH_DATA then
			warnFunc(("%s: ignored %s > '%s' (length of value exceeds %d character limit)")
				:format(methodName, prefix, key, Constants.MAX_LENGTH_DATA))
		elseif type(value) == "table" and #HttpService:JSONEncode(value) > Constants.MAX_LENGTH_DATA then
			warnFunc(("%s: ignored %s > '%s' (length of encoded value exceeds %d character limit)")
				:format(methodName, prefix, key, Constants.MAX_LENGTH_DATA))
		elseif type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
			warnFunc(("%s: ignored %s > '%s' (cannot store value '%s' of type %s)")
				:format(methodName, prefix, key, tostring(value), type(value)))
		elseif isOrdered and type(value) ~= "number" then
			warnFunc(("%s: ignored %s > '%s' (cannot store value '%s' of type %s in OrderedDataStore)")
				:format(methodName, prefix, key, tostring(value), type(value)))
		elseif isOrdered and value % 1 ~= 0 then
			warnFunc(("%s: ignored %s > '%s' (cannot store non-integer value '%s' in OrderedDataStore)")
				:format(methodName, prefix, key, tostring(value)))
		elseif type(value) == "string" and not utf8.len(value) then
			warnFunc(("%s: ignored %s > '%s' (string value is not valid UTF-8)")
				:format(methodName, prefix, key, tostring(value), type(value)))
		else
			local isValid = true
			local keyPath, reason
			if type(value) == "table" then
				isValid, keyPath, reason = scanValidity(value)
			end
			if isOrdered then
				value = math.floor(value + .5)
			end
			if isValid then
				local old = destination[key]
				destination[key] = value
				if interface and old ~= value then -- hacky block to fire OnUpdate signals
					if isOrdered and interface then -- hacky block to populate internal structures for OrderedDataStores
						if interface.__ref[key] then
							interface.__ref[key].Value = value
							interface.__changed = true
						else
							interface.__ref[key] = {Key = key, Value = interface.__data[key]}
							table.insert(interface.__sorted, interface.__ref[key])
							interface.__changed = true
						end
					end
					interface.__event:Fire(key, value)
				end
			else
				warnFunc(("%s: ignored %s > '%s' (table has invalid entry at <%s>: %s)")
					:format(methodName, prefix, key, getStringPath(keyPath), reason))
			end
		end
	end
end

-- Trim empty datastores and scopes from an entire datastore type:
local function prepareDataStoresForExport(origin)
	local dataPrepared = {}

	for name, scopes in pairs(origin) do
		local exportScopes = {}
		for scope, data in pairs(scopes) do
			local exportData = {}
			for key, value in pairs(data) do
				exportData[key] = value
			end
			if next(exportData) ~= nil then -- Only export datastore when non-empty
				exportScopes[scope] = exportData
			end
		end
		if next(exportScopes) ~= nil then -- Only export scope list when non-empty
			dataPrepared[name] = exportScopes
		end
	end

	if next(dataPrepared) ~= nil then -- Only return datastore type when non-empty
		return dataPrepared
	end
end

local function preprocessKey(key)
	if type(key) == "number" then
		if key ~= key then
			return "NAN"
		elseif key >= math.huge then
			return "INF"
		elseif key <= -math.huge then
			return "-INF"
		end
		return tostring(key)
	end
	return key
end

local function simulateYield()
	if Constants.YIELD_TIME_MAX > 0 then
		task.wait(rand:NextNumber(Constants.YIELD_TIME_MIN, Constants.YIELD_TIME_MAX))
	end
end

local function simulateErrorCheck(method)
	if Constants.SIMULATE_ERROR_RATE > 0 and rand:NextNumber() <= Constants.SIMULATE_ERROR_RATE then
		simulateYield()
		error(method .. " rejected with error (simulated error)", 3)
	end
end

-- Setting these here so the functions above can self-reference just by name:
MockDataStoreUtils.logMethod = logMethod
MockDataStoreUtils.deepcopy = deepcopy
MockDataStoreUtils.scanValidity = scanValidity
MockDataStoreUtils.getStringPath = getStringPath
MockDataStoreUtils.importPairsFromTable = importPairsFromTable
MockDataStoreUtils.prepareDataStoresForExport = prepareDataStoresForExport
MockDataStoreUtils.preprocessKey = preprocessKey
MockDataStoreUtils.simulateYield = simulateYield
MockDataStoreUtils.simulateErrorCheck = simulateErrorCheck

return MockDataStoreUtils
  -  Editar
  04:54:13.847    -  Editar
  04:54:13.847  ----- [2559] ServerScriptService.__DataStoreService.MockDataStoreService.MockGlobalDataStore -----  -  Editar
  04:54:13.847  --[[
	MockGlobalDataStore.lua
	This module implements the API and functionality of Roblox's GlobalDataStore class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockGlobalDataStore = {}
MockGlobalDataStore.__index = MockGlobalDataStore

local MockDataStoreManager = require(script.Parent.MockDataStoreManager)
local Utils = require(script.Parent.MockDataStoreUtils)
local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode

local rand = Random.new()

function MockGlobalDataStore:OnUpdate(key, callback)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'OnUpdate' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(callback) ~= "function" then
		error(("bad argument #2 to 'OnUpdate' (function expected, got %s)"):format(typeof(callback)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'OnUpdate' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'OnUpdate' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("OnUpdate")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("OnUpdate request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.OnUpdate}
	)

	if not success then
		error("OnUpdate rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	Utils.logMethod(self, "OnUpdate", key)

	return self.__event.Event:Connect(function(k, v)
		if k == key then
			if Constants.YIELD_TIME_UPDATE_MAX > 0 then
				task.wait(rand:NextNumber(Constants.YIELD_TIME_UPDATE_MIN, Constants.YIELD_TIME_UPDATE_MAX))
			end
			callback(v) -- v was implicitly deep-copied
		end
	end)
end

function MockGlobalDataStore:GetAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'GetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'GetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'GetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
		return Utils.deepcopy(self.__data[key])
	end

	Utils.simulateErrorCheck("GetAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("GetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.GetAsync}
	)

	if not success then
		error("GetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__getCache[key] = tick()

	local retValue = Utils.deepcopy(self.__data[key])

	Utils.simulateYield()

	Utils.logMethod(self, "GetAsync", key)

	return retValue
end

function MockGlobalDataStore:IncrementAsync(key, delta)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'IncrementAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif delta ~= nil and type(delta) ~= "number" then
		error(("bad argument #2 to 'IncrementAsync' (number expected, got %s)"):format(typeof(delta)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'IncrementAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'IncrementAsync' (key name exceeds %d character limit)")
			:format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("IncrementAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("IncrementAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("IncrementAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("IncrementAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local old = self.__data[key]

	if old ~= nil and (type(old) ~= "number" or old % 1 ~= 0) then
		Utils.simulateYield()
		error("IncrementAsync rejected with error (cannot increment non-integer value)", 2)
	end

	self.__writeLock[key] = true

	delta = delta and math.floor(delta + .5) or 1

	self.__data[key] = (old or 0) + delta

	if old == nil or delta ~= 0 then
		self.__event:Fire(key, self.__data[key])
	end

	local retValue = self.__data[key]

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "IncrementAsync", key, retValue, delta)

	return retValue
end

function MockGlobalDataStore:RemoveAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'RemoveAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'RemoveAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'RemoveAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("RemoveAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("RemoveAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("RemoveAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("RemoveAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	local value = Utils.deepcopy(self.__data[key])
	self.__data[key] = nil

	if value ~= nil then
		self.__event:Fire(key, nil)
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "RemoveAsync", key, value)

	return value
end

function MockGlobalDataStore:SetAsync(key, value)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'SetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'SetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'SetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	elseif value == nil or type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
		error(("bad argument #2 to 'SetAsync' (cannot store value '%s' of type %s)")
			:format(tostring(value), typeof(value)), 2)
	end

	if type(value) == "table" then
		local isValid, keyPath, reason = Utils.scanValidity(value)
		if not isValid then
			error(("bad argument #2 to 'SetAsync' (table has invalid entry at <%s>: %s)")
				:format(Utils.getStringPath(keyPath), reason), 2)
		end
		local pass, content = pcall(function() return HttpService:JSONEncode(value) end)
		if not pass then
			error("bad argument #2 to 'SetAsync' (table could not be encoded to json)", 2)
		elseif #content > Constants.MAX_LENGTH_DATA then
			error(("bad argument #2 to 'SetAsync' (encoded data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		end
	elseif type(value) == "string" then
		if #value > Constants.MAX_LENGTH_DATA then
			error(("bad argument #2 to 'SetAsync' (data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		elseif not utf8.len(value) then
			error("bad argument #2 to 'SetAsync' (string value is not valid UTF-8)", 2)
		end
	end

	Utils.simulateErrorCheck("SetAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("SetAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("SetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("SetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	if type(value) == "table" or value ~= self.__data[key] then
		self.__data[key] = Utils.deepcopy(value)
		self.__event:Fire(key, self.__data[key])
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "SetAsync", key, self.__data[key])

end

function MockGlobalDataStore:UpdateAsync(key, transformFunction)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'UpdateAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(transformFunction) ~= "function" then
		error(("bad argument #2 to 'UpdateAsync' (function expected, got %s)"):format(typeof(transformFunction)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'UpdateAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'UpdateAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("UpdateAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("UpdateAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		local budget
		if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
			budget = {Enum.DataStoreRequestType.SetIncrementAsync}
		else
			budget = {Enum.DataStoreRequestType.GetAsync, Enum.DataStoreRequestType.SetIncrementAsync}
		end
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("UpdateAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			budget
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("UpdateAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local value = transformFunction(Utils.deepcopy(self.__data[key]))

	if value == nil then -- cancel update after remote call
		Utils.simulateYield()
		return nil -- this is what datastores do even though it should be old value
	end

	if type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
		error(("UpdateAsync rejected with error (resulting value '%s' is of type %s that cannot be stored)")
			:format(tostring(value), typeof(value)), 2)
	end

	if type(value) == "table" then
		local isValid, keyPath, reason = Utils.scanValidity(value)
		if not isValid then
			error(("UpdateAsync rejected with error (resulting table has invalid entry at <%s>: %s)")
				:format(Utils.getStringPath(keyPath), reason), 2)
		end
		local pass, content = pcall(function() return HttpService:JSONEncode(value) end)
		if not pass then
			error("UpdateAsync rejected with error (resulting table could not be encoded to json)", 2)
		elseif #content > Constants.MAX_LENGTH_DATA then
			error(("UpdateAsync rejected with error (resulting encoded data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		end
	elseif type(value) == "string" then
		if #value > Constants.MAX_LENGTH_DATA then
			error(("UpdateAsync rejected with error (resulting data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		elseif not utf8.len(value) then
			error("UpdateAsync rejected with error (string value is not valid UTF-8)", 2)
		end
	end

	self.__writeLock[key] = true

	if type(value) == "table" or value ~= self.__data[key] then
		self.__data[key] = Utils.deepcopy(value)
		self.__event:Fire(key, self.__data[key])
	end

	local retValue = Utils.deepcopy(value)

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "UpdateAsync", key, retValue)

	return retValue
end

function MockGlobalDataStore:ExportToJSON()
	return HttpService:JSONEncode(self.__data)
end

function MockGlobalDataStore:ImportFromJSON(json, verbose)
	local content
	if type(json) == "string" then
		local parsed, value = pcall(function() return HttpService:JSONDecode(json) end)
		if not parsed then
			error("bad argument #1 to 'ImportFromJSON' (string is not valid json)", 2)
		end
		content = value
	elseif type(json) == "table" then
		content = Utils.deepcopy(json)
	else
		error(("bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)"):format(typeof(json)), 2)
	end

	if verbose ~= nil and type(verbose) ~= "boolean" then
		error(("bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)"):format(typeof(verbose)), 2)
	end

	Utils.importPairsFromTable(
		content,
		self.__data,
		MockDataStoreManager.GetDataInterface(self.__data),
		(verbose == false and function() end or warn),
		"ImportFromJSON",
		((type(self.__name) == "string" and type(self.__scope) == "string")
			and ("DataStore > %s > %s"):format(self.__name, self.__scope)
			or "GlobalDataStore"),
		false
	)
end

return MockGlobalDataStore
  -  Editar
  04:54:13.847    -  Editar
  04:54:13.847  ----- [2560] ServerScriptService.__DataStoreService.MockDataStoreService.MockOrderedDataStore -----  -  Editar
  04:54:13.847  --[[
	MockOrderedDataStore.lua
	This module implements the API and functionality of Roblox's OrderedDataStore class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockOrderedDataStore = {}
MockOrderedDataStore.__index = MockOrderedDataStore

local MockDataStoreManager = require(script.Parent.MockDataStoreManager)
local MockDataStorePages = require(script.Parent.MockDataStorePages)
local Utils = require(script.Parent.MockDataStoreUtils)
local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode

local rand = Random.new()

function MockOrderedDataStore:OnUpdate(key, callback)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'OnUpdate' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(callback) ~= "function" then
		error(("bad argument #2 to 'OnUpdate' (function expected, got %s)"):format(typeof(callback)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'OnUpdate' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'OnUpdate' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("OnUpdate")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("OnUpdate request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.OnUpdate}
	)

	if not success then
		error("OnUpdate rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	Utils.logMethod(self, "OnUpdate", key)

	return self.__event.Event:Connect(function(k, v)
		if k == key then
			if Constants.YIELD_TIME_UPDATE_MAX > 0 then
				task.wait(rand:NextNumber(Constants.YIELD_TIME_UPDATE_MIN, Constants.YIELD_TIME_UPDATE_MAX))
			end
			callback(v) -- v was implicitly deep-copied
		end
	end)
end

function MockOrderedDataStore:GetAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'GetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'GetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'GetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
		return self.__data[key]
	end

	Utils.simulateErrorCheck("GetAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("GetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.GetAsync}
	)

	if not success then
		error("GetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local retValue = self.__data[key]

	Utils.simulateYield()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "GetAsync", key)

	return retValue
end

function MockOrderedDataStore:IncrementAsync(key, delta)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'IncrementAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif delta ~= nil and type(delta) ~= "number" then
		error(("bad argument #2 to 'IncrementAsync' (number expected, got %s)"):format(typeof(delta)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'IncrementAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'IncrementAsync' (key name exceeds %d character limit)")
			:format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("IncrementAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("IncrementAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("IncrementAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("IncrementAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local old = self.__data[key]

	if old ~= nil and (type(old) ~= "number" or old % 1 ~= 0) then
		Utils.simulateYield()
		error("IncrementAsync rejected with error (cannot increment non-integer value)", 2)
	end

	self.__writeLock[key] = true

	delta = delta and math.floor(delta + .5) or 1

	if old == nil then
		self.__data[key] = delta
		self.__ref[key] = {Key = key, Value = self.__data[key]}
		table.insert(self.__sorted, self.__ref[key])
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	elseif delta ~= 0 then
		self.__data[key] = self.__data[key] + delta
		self.__ref[key].Value = self.__data[key]
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	end

	local retValue = self.__data[key]

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "IncrementAsync", key, retValue, delta)

	return retValue
end

function MockOrderedDataStore:RemoveAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'RemoveAsync' (string expected, got %s)"):format(type(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'RemoveAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'RemoveAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("RemoveAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("RemoveAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("RemoveAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("RemoveAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	local value = self.__data[key]

	if value ~= nil then
		self.__data[key] = nil
		self.__ref[key] = nil
		for i,v in pairs(self.__sorted) do
			if v.Key == key then
				table.remove(self.__sorted, i)
				break
			end
		end
		self.__event:Fire(key, nil)
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "RemoveAsync", key, value)

	return value
end

function MockOrderedDataStore:SetAsync(key, value)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'SetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'SetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'SetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	elseif type(value) ~= "number" then
		error(("bad argument #2 to 'SetAsync' (number expected, got %s)"):format(typeof(value)), 2)
	elseif value % 1 ~= 0 then
		error("bad argument #2 to 'SetAsync' (cannot store non-integer values in OrderedDataStore)", 2)
	end

	Utils.simulateErrorCheck("SetAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("SetAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("SetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("SetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	local old = self.__data[key]

	if old == nil then
		self.__data[key] = value
		self.__ref[key] = {Key = key, Value = value}
		table.insert(self.__sorted, self.__ref[key])
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	elseif old ~= value then
		self.__data[key] = value
		self.__ref[key].Value = value
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "SetAsync", key, self.__data[key])

	return value
end

function MockOrderedDataStore:UpdateAsync(key, transformFunction)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'UpdateAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(transformFunction) ~= "function" then
		error(("bad argument #2 to 'UpdateAsync' (function expected, got %s)"):format(typeof(transformFunction)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'UpdateAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'UpdateAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("UpdateAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("UpdateAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		local budget
		if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
			budget = {Enum.DataStoreRequestType.SetIncrementSortedAsync}
		else
			budget = {Enum.DataStoreRequestType.GetAsync, Enum.DataStoreRequestType.SetIncrementSortedAsync}
		end
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("UpdateAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			budget
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("UpdateAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local value = transformFunction(self.__data[key])

	if value == nil then -- cancel update after remote call
		Utils.simulateYield()
		return nil -- this is what datastores do even though it should be old value
	end

	if type(value) ~= "number" or value % 1 ~= 0 then
		error("UpdateAsync rejected with error (resulting non-integer value can't be stored in OrderedDataStore)", 2)
	end

	self.__writeLock[key] = true

	local old = self.__data[key]

	if old == nil then
		self.__data[key] = value
		self.__ref[key] = {Key = key, Value = value}
		table.insert(self.__sorted, self.__ref[key])
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	elseif old ~= value then
		self.__data[key] = value
		self.__ref[key].Value = value
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "UpdateAsync", key, value)

	return value
end

function MockOrderedDataStore:GetSortedAsync(ascending, pageSize, minValue, maxValue)
	if type(ascending) ~= "boolean" then
		error(("bad argument #1 to 'GetSortedAsync' (boolean expected, got %s)"):format(typeof(ascending)), 2)
	elseif type(pageSize) ~= "number" then
		error(("bad argument #2 to 'GetSortedAsync' (number expected, got %s)"):format(typeof(pageSize)), 2)
	end

	pageSize = math.floor(pageSize + .5)
	if pageSize <= 0 or pageSize > Constants.MAX_PAGE_SIZE then
		error(("bad argument #2 to 'GetSortedAsync' (page size must be an integer above 0 and below or equal to %d)")
			:format(Constants.MAX_PAGE_SIZE), 2)
	end

	if minValue ~= nil then
		if type(minValue) ~= "number" then
			error(("bad argument #3 to 'GetSortedAsync' (number expected, got %s)"):format(typeof(minValue)), 2)
		elseif minValue % 1 ~= 0 then
			error("bad argument #3 to 'GetSortedAsync' (minimum threshold must be an integer)", 2)
		end
	else
		minValue = -math.huge
	end

	if maxValue ~= nil then
		if type(maxValue) ~= "number" then
			error(("bad argument #4 to 'GetSortedAsync' (number expected, got %s)"):format(typeof(maxValue)), 2)
		elseif maxValue % 1 ~= 0 then
			error("bad argument #4 to 'GetSortedAsync' (maximum threshold must be an integer)", 2)
		end
	else
		maxValue = math.huge
	end

	Utils.simulateErrorCheck("GetSortedAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn("GetSortedAsync request was throttled due to lack of budget. Try sending fewer requests.")
		end,
		{Enum.DataStoreRequestType.GetSortedAsync}
	)

	if not success then
		error("GetSortedAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	if minValue > maxValue then
		Utils.simulateYield()
		error("GetSortedAsync rejected with error (minimum threshold is higher than maximum threshold)", 2)
	end

	if self.__changed then
		table.sort(self.__sorted, function(a,b) return a.Value < b.Value end)
		self.__changed = false
	end

	local results = {}

	if ascending then
		local i = 1
		while self.__sorted[i] and self.__sorted[i].Value < minValue do
			i = i + 1
		end
		while self.__sorted[i] and self.__sorted[i].Value <= maxValue do
			table.insert(results, {key = self.__sorted[i].Key, value = self.__sorted[i].Value})
			i = i + 1
		end
	else
		local i = #self.__sorted
		while i > 0 and self.__sorted[i].Value > maxValue do
			i = i - 1
		end
		while i > 0 and self.__sorted[i].Value >= minValue do
			table.insert(results, {key = self.__sorted[i].Key, value = self.__sorted[i].Value})
			i = i - 1
		end
	end

	Utils.simulateYield()

	Utils.logMethod(self, "GetSortedAsync")

	return setmetatable({
		__datastore = self;
		__currentPage = 1;
		__pageSize = pageSize;
		__results = results;
		IsFinished = (#results <= pageSize);
	}, MockDataStorePages)
end

function MockOrderedDataStore:ExportToJSON()
	return HttpService:JSONEncode(self.__data)
end

function MockOrderedDataStore:ImportFromJSON(json, verbose)
	local content
	if type(json) == "string" then
		local parsed, value = pcall(function() return HttpService:JSONDecode(json) end)
		if not parsed then
			error("bad argument #1 to 'ImportFromJSON' (string is not valid json)", 2)
		end
		content = value
	elseif type(json) == "table" then
		content = json -- No need to deepcopy, OrderedDataStore only contains numbers which are passed by value
	else
		error(("bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)"):format(typeof(json)), 2)
	end

	if verbose ~= nil and type(verbose) ~= "boolean" then
		error(("bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)"):format(typeof(verbose)), 2)
	end

	Utils.importPairsFromTable(
		content,
		self.__data,
		MockDataStoreManager.GetDataInterface(self.__data),
		(verbose == false and function() end or warn),
		"ImportFromJSON",
		("OrderedDataStore > %s > %s"):format(self.__name, self.__scope),
		true
	)
end

return MockOrderedDataStore
  -  Editar
  04:54:13.848    -  Editar
  04:54:13.848  ----- [2561] ServerScriptService.__DataStoreService.Rongo -----  -  Editar
  04:54:13.848  --[[

	Rongo - MongoDB API Wrapper for Roblox
	
	Rongo gives developers easy access to MongoDBs web APIs
	so they're able to use MongoDB directly in their games
	
	Rongo is a bare-bones module, meaning it contains only
	the essentials, which can be used standalone or to
	develop modules which use Rongo at its core. 
	
	Some modules which use Rongo can be found on the Rongo
	DevForum post!
	
	Rongo uses MongoDB's Data API, which is disabled by
	default so you must enable it in your Atlas settings
	
	Version: 1.0.0
	License: MIT License
	Contributors:
		- Starnamics (Creator)
	TG_Ftc7TTb74vanBj: https://devforum.roblox.com/t/rongo/1755615	

--]]

local HttpService = game:GetService("HttpService")

local URI = "https://data.mongodb-api.com/app/%s/endpoint/data/v1"

local ENDPOINTS = {
	POST = {
		["FindOne"] = "/action/findOne",
		["FindMany"] = "/action/find",
		["InsertOne"] = "/action/insertOne",
		["InsertMany"] = "/action/insertMany",
		["UpdateOne"] = "/action/updateOne",
		["UpdateMany"] = "/action/updateMany",
		["ReplaceOne"] = "/action/replaceOne",
		["DeleteOne"] = "/action/deleteOne",
		["DeleteMany"] = "/action/deleteMany",
	}
}

local Rongo = {}

local RongoClient = {}
RongoClient.__index = RongoClient

local RongoCluster = {}
RongoCluster.__index = RongoCluster

local RongoDatabase = {}
RongoDatabase.__index = RongoDatabase

local RongoCollection = {}
RongoCollection.__index = RongoCollection

local RongoDocument = {}
RongoDocument.__index = RongoDocument

function Rongo.new(AppId: string,Key: string)
	local Client = {}
	setmetatable(Client,RongoClient)
	
	Client["AppId"] = AppId
	Client["Key"] = Key
	
	return Client
end

function RongoClient:GetCluster(Name: string)
	local Cluster = {}
	setmetatable(Cluster,RongoCluster)
	
	Cluster["Client"] = self
	Cluster["Name"] = Name
	
	return Cluster
end

function RongoCluster:GetDatabase(Name: string)
	local Database = {}
	setmetatable(Database,RongoDatabase)
	
	Database["Client"] = self["Client"]
	Database["Cluster"] = self
	Database["Name"] = Name
	
	return Database
end

function RongoDatabase:GetCollection(Name: string)
	local Collection = {}
	setmetatable(Collection,RongoCollection)
	
	Collection["Client"] = self["Client"]
	Collection["Cluster"] = self["Cluster"]
	Collection["Database"] = self
	Collection["Name"] = Name
	
	return Collection
end

function RongoCollection:FindOne(Filter: {[string]: string | {[string]: string}}?): {[string]: any?}?
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["filter"] = Filter or nil,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.FindOne,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	if not Response["document"] then return nil end
	return Response["document"]
end

function RongoCollection:FindMany(Filter: {[string]: string | {[string]: string}}?,Limit: number?,Sort: {any?}?,Skip: number?): {[number]: {[string]: any?}}?
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["filter"] = Filter or nil,
		["limit"] = Limit or nil,
		["sort"] = Sort or nil,
		["skip"] = Skip or nil,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.FindMany,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	if not Response["documents"] then return nil end
	return Response["documents"]
end

function RongoCollection:InsertOne(Document: {[string]: any?}): string?
	if not Document then warn("[RONGO] Document argument cannot be empty") return nil end
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["document"] = Document,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.InsertOne,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	if not Response["insertedId"] then return nil end
	return Response["insertedId"]
end

function RongoCollection:InsertMany(Documents: {[number]: {[string]: any?}}): {[number]: string}?
	if not Documents then warn("[RONGO] Documents argument cannot be empty") return nil end
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["documents"] = Documents,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.InsertMany,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	if not Response["insertedIds"] then return nil end
	return Response["insertedIds"]
end

function RongoCollection:UpdateOne(Filter: string,Update: {[string]: any?},Upsert: boolean?): {["matchedCount"]: number,["modifiedCount"]: number,["upsertedId"]: string?}?
	if not Filter then warn("[RONGO] Filter argument cannot be empty") return nil end
	if not Update then warn("[RONGO] Update argument cannot be empty") return nil end
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["filter"] = Filter or nil,
		["update"] = Update or nil,
		["upsert"] = Upsert or nil,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.UpdateOne,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	return Response
end

function RongoCollection:UpdateMany(Filter: string,Update: {[string]: any?},Upsert: boolean?): {["matchedCount"]: number,["modifiedCount"]: number,["upsertedId"]: string?}?
	if not Filter then warn("[RONGO] Filter argument cannot be empty") return nil end
	if not Update then warn("[RONGO] Update argument cannot be empty") return nil end
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["filter"] = Filter or nil,
		["update"] = Update or nil,
		["upsert"] = Upsert or nil,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.UpdateMany,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	return Response
end

function RongoCollection:ReplaceOne(Filter: string,Replacement: {[string]: any?},Upsert: boolean?): {["matchedCount"]: number,["modifiedCount"]: number,["upsertedId"]: string?}?
	if not Filter then warn("[RONGO] Filter argument cannot be empty") return nil end
	if not Replacement then warn("[RONGO] Update argument cannot be empty") return nil end
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["filter"] = Filter or nil,
		["replacement"] = Replacement,
		["upsert"] = Upsert
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.ReplaceOne,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	return Response
end

function RongoCollection:DeleteOne(Filter: string): number?
	if not Filter then warn("[RONGO] Filter argument cannot be empty") return nil end
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["filter"] = Filter or nil,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.DeleteOne,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	if not Response["deletedCount"] then return 0 end
	return Response["deletedCount"]
end

function RongoCollection:DeleteMany(Filter: string): number?
	if not Filter then warn("[RONGO] Filter argument cannot be empty") return nil end
	local RequestData = {
		["dataSource"] = self["Cluster"]["Name"],
		["database"] = self["Database"]["Name"],
		["collection"] = self["Name"],
		["filter"] = Filter or nil,
	}
	local RequestHeaders = {
		["Access-Control-Request-Headers"] = "*",
		["api-key"] = self["Client"]["Key"]
	}
	RequestData = HttpService:JSONEncode(RequestData)
	local Success,Response = pcall(function() return HttpService:PostAsync(string.format(URI,self["Client"]["AppId"])..ENDPOINTS.POST.DeleteMany,RequestData,Enum.HttpContentType.ApplicationJson,false,RequestHeaders) end)
	if not Success then warn("[RONGO] Request Failed:",Response) return end
	Response = HttpService:JSONDecode(Response)
	if not Response["deletedCount"] then return 0 end
	return Response["deletedCount"]
end

return Rongo  -  Editar
  04:54:13.848    -  Editar
  04:54:13.848  ----- [2562] ServerScriptService.__FIREBASE -----  -  Editar
  04:54:13.849  local defaultDatabase = "https://bee-games-dub-default-rtdb.firebaseio.com/"; -- Set your database link
local authenticationToken = "Pp6xFqeMwt9ZEele7BfERZu7dFIwiifMpeZ5eZDk"; -- Authentication Token
local HttpService = game:GetService("HttpService");
local DataStoreService = game:GetService("DataStoreService");

local FirebaseService = {};
local UseFirebase = true;    
--== Script;
--[[**
	Sets whether Firebase's data can be updated from server. Data can still be read from realtime Database regardless.
	@param value bool Using Firebase
**--]]
function FirebaseService:SetUseFirebase(value)
	UseFirebase = value and true or false;
end

--[[**
	Sets whether Firebase's data can be updated from server. Data can still be read from realtime Database regardless.
	@param name string Given name of a JSON Object in the Realtime Database.
	@param scope string Optional scope.
	@returns FirebaseService FirebaseService
**--]]
function FirebaseService:GetOrderedDataStore(name)
	local datastore = DataStoreService:GetOrderedDataStore(name);
	return datastore
end
function FirebaseService:GetDataStore(name, database)
	database = database or defaultDatabase;	
	local datastore = DataStoreService:GetDataStore(name);

	local databaseName = database..HttpService:UrlEncode(name);
	local authentication = ".json?auth="..authenticationToken;

	local Firebase = {};

	--[[**
		A method to get a datastore with the same name and scope.
		@returns GlobalDataStore GlobalDataStore
	**--]]
	function Firebase.GetDatastore()
		return datastore;
	end

	--[[**
		Returns the value of the entry in the database JSON Object with the given key.
		@param directory string Directory of the value that you are look for. E.g. "PlayerSaves" or "PlayerSaves/Stats".
		@returns FirebaseService FirebaseService
	**--]]
	function Firebase:GetAsync(directory)
		local data = nil;

		--== Firebase Get;
		local getTick = tick();
		local tries = 0; repeat until pcall(function() tries = tries +1;
			data = HttpService:GetAsync(databaseName..HttpService:UrlEncode(directory and "/"..directory or "")..authentication, true);
		end) or tries > 2;
		if type(data) == "string" then
			if data:sub(1,1) == '"' then
				return data:sub(2, data:len()-1);
			elseif data:len() <= 0 then
				return nil;
			end
		end
		return tonumber(data) or data ~= "null" and data or nil;
	end

	--[[**
		Sets the value of the key. This overwrites any existing data stored in the key.
		@param directory string Directory of the value that you are look for. E.g. "PlayerSaves" or "PlayerSaves/Stats".
		@param value variant Value can be any basic data types. It's recommened you HttpService:JSONEncode() your values before passing it through.
		@param header table Optional HTTPRequest Header overwrite. Default is {["X-HTTP-Method-Override"]="PUT"}.
	**--]]
	function Firebase:SetAsync(directory, value, header)
		if not UseFirebase then return end
		if value == "[]" then self:RemoveAsync(directory); return end;

		--== Firebase Set;
		header = header or {["X-HTTP-Method-Override"]="PUT"};
		local replyJson = "";
		if type(value) == "string" and value:len() >= 1 and value:sub(1,1) ~= "{" and value:sub(1,1) ~= "[" then
			value = '"'..value..'"';
		end
		local success, errorMessage = pcall(function()
			replyJson = HttpService:PostAsync(databaseName..HttpService:UrlEncode(directory and "/"..directory or "")..authentication, value,
				Enum.HttpContentType.ApplicationUrlEncoded, false, header);
		end);
		if not success then
			warn("FirebaseService>> [ERROR] "..errorMessage);
			pcall(function()
				replyJson = HttpService:JSONDecode(replyJson or "[]");
			end)
		end
	end

	--[[**
		Removes the given key from the data store and returns the value associated with that key.
		@param directory string Directory of the value that you are look for. E.g. "PlayerSaves" or "PlayerSaves/Stats".
	**--]]
	function Firebase:RemoveAsync(directory)
		if not UseFirebase then return end
		self:SetAsync(directory, "", {["X-HTTP-Method-Override"]="DELETE"});
	end

	--[[**
		Increments the value of a particular key and returns the incremented value.
		@param directory string Directory of the value that you are look for. E.g. "PlayerSaves" or "PlayerSaves/Stats".
		@param delta number The incrementation rate.
	**--]]
	function Firebase:IncrementAsync(directory, delta)
		delta = delta or 1;
		if type(delta) ~= "number" then warn("FirebaseService>> increment delta is not a number for key ("..directory.."), delta(",delta,")"); return end;
		local data = self:GetAsync(directory) or 0;
		if data and type(data) == "number" then
			data = data+delta;
			self:SetAsync(directory, data);
		else
			warn("FirebaseService>> Invalid data type to increment for key ("..directory..")");
		end
		return data;
	end

	--[[**
		Retrieves the value of a key from a data store and updates it with a new value.
		@param directory string Directory of the value that you are look for. E.g. "PlayerSaves" or "PlayerSaves/Stats".
		@param callback function Works similarly to Roblox's GlobalDatastore:UpdateAsync().
	**--]]
	function Firebase:UpdateAsync(directory, callback)
		local data = self:GetAsync(directory);
		local callbackData = callback(data);
		if callbackData then
			self:SetAsync(directory, callbackData);
		end
	end

	return Firebase;
end

return FirebaseService;  -  Editar
  04:54:13.849    -  Editar
  04:54:13.849  ----- [2563] ServerScriptService.__FirebaseService -----  -  Editar
  04:54:13.849  local FirebaseDS = {}

local FirebaseService = require(script:WaitForChild("FirebaseService"))("https://bee-games-dub-default-rtdb.firebaseio.com/")
function FirebaseDS:GetDataStore(Name,Scope)
	local datastore = {}
	if Scope and Scope ~= "global" then
		Name = Name.."-"..Scope
	end
	local ds = FirebaseService:GetFirebase(Name)
	function datastore:GetAsync(key)
		return ds:GetAsync(key)
	end
	function datastore:SetAsync(key,value)
		--pcall(function()
		--	value = game:GetService("HttpService"):JSONEncode()
		--end)
		return ds:SetAsync(key,value)
	end
	function datastore:RemoveAsync(key)
		return ds:RemoveAsync(key)
	end
	function datastore:UpdateAsync(key,callback)
		return ds:UpdateAsync(key,callback)
	end
	function datastore:IncrementAsync(key,delta)
		return ds:IncrementAsync(key,delta)
	end
	return datastore
end

function FirebaseDS:GetOrderedDataStore(Name,Scope)
	return require(game:GetService("ServerScriptService"):WaitForChild("__MockDataStoreService")):GetOrderedDataStore(Name,Scope)
end

return FirebaseDS  -  Editar
  04:54:13.849    -  Editar
  04:54:13.849  ----- [2564] ServerScriptService.__FirebaseService.FirebaseService -----  -  Editar
  04:54:13.849  --[[
	RBLX-Firebase; A wrapper designed for Firebase's Realtime Database RESTful API services.

	RBLX-Firebase was made to emulate the native DataStoreService such that all methods, bar Update methods, are alike.
		As stated, Update methods are different, and this difference is the added #snapshot# argument to their methods.
		The #snapshot# argument is optional and does not need to be supplied, however, when supplied, will prevent the module
		from re-downloading from your database and will instead use the data supplied.

	All methods have appropriate source-docs and will also be documented on the Github:

]]

local HttpService = game:GetService("HttpService")

--	RobloxFirebase module
--	@module

local RobloxFirebase = { }
RobloxFirebase.DefaultScope = ""
RobloxFirebase.AuthenticationToken = "Pp6xFqeMwt9ZEele7BfERZu7dFIwiifMpeZ5eZDk"
RobloxFirebase.__index = RobloxFirebase

--[[ GetFirebase
	@tparam <string> <name> The name of the firebase being fetched
	@tparam[opt=RobloxFirebase.DefaultScope] <string> <scope> The scope being accessed, optional if DefaultScope is set

	Will setup a Firebase object for use, this method is similar to DataStoreService:GetDataStore(name, scope)
	If called with name="" it will simply create a Firebase at the entry to the Real-time Database, allowing you to access top-level data points
		for example, if you had multiple containers within the top-level of the database and wanted to act upon them and not their descendants this would
		be the way to do it.
			Database:[
				PlayerInformation:[
					Player1:[
						Data: true
					]
				],
				ServerInformation:[
					Data: true
				]
			]
		Running RobloxFirebase:GetFirebase("") would give you a Firebase object located at/from 'Database' in this example.

	@treturn <Firebase> <Firebase> A firebase object
]]
function RobloxFirebase:GetFirebase(name, scope)
	assert(self.AuthenticationToken~=nil, "AuthenticationToken expected, got nil")
	assert(scope~=nil or self.DefaultScope~=nil, "DefaultScope or Scope expected, got nil")

	scope = scope or self.DefaultScope
	local path = scope .. HttpService:UrlEncode(name)
	local auth = ".json?auth=" .. self.AuthenticationToken

	-- Firebase object
	-- @Object=Firebase
	local Firebase = { }

	--[[ GetAsync
		@tparam <string> <key> The data point / key being accessed and retrieved

		This method is used to fetch data from your database using a key, this method is similar to DataStoreService:GetAsync(key)
		Will return nil upon error or no data found.
		
		This method will be attempted 3 times before failing.

		@treturn <Dictionary | null> <Response.Body> The data retrieved from the GET request
	]]
	function Firebase:GetAsync(key)
		key = tostring(key)
		--assert(type(key) == "string", "Roblox-Firebase GetAsync: Bad Argument #1, string expected got '"..tostring(type(key)).."'")
		key = key:sub(1,1)~="/" and "/"..key or key --> Ensures key is correct form
		local dir = path .. "/" .. HttpService:UrlEncode(string.sub(key,2)) .. auth
		local request = {}
		request.Url = dir
		request.Method = "GET"

		local attempts = 0
		local responseInfo

		repeat
			attempts += 1
			local success, error = pcall(function()
				responseInfo = HttpService:RequestAsync(request)
			end)
			if not success then
				print("Roblox-Firebase GetAsync failed: " .. tostring(error))
				wait(3)
			end
		until attempts>=3 or (responseInfo~=nil and responseInfo.Success~=false)

		if responseInfo == nil then
			print("Roblox-Firebase GetAsync failed to fetch data")
			return nil
		end
		return HttpService:JSONDecode(responseInfo.Body)
	end

	--[[ SetAsync
		@tparam <string> <key> The data point / key being modified/set
		@tparam <Variant> <value>
		@tparam[opt="PUT"] <string> <method>

		Akin to DataStoreService:SetAsync(key, value) however, this method takes a third, optional paramater 'method' for use by other methods.
			This paramater will default to "PUT".

		@treturn <boolean> <success> Returns wether or not the SetAsync operation succeeded.
		@treturn <Dictionary> <responseInfo> Returns the ResponseInfo dictionary from HttpService:RequestAsync() useful for debugging/logging.
	]]
	function Firebase:SetAsync(key, value, method)
		key = tostring(key)
		--assert(type(key) == "string", "Roblox-Firebase SetAsync: Bad Argument #1, string expected got '"..tostring(type(key)).."'")

		method = method or "PUT"

		key = key:sub(1,1)~="/" and "/"..key or key --> Ensures key is correct form
		local dir = path .. HttpService:UrlEncode(key) .. auth --> Database path to act on
		local responseInfo
		local encoded = HttpService:JSONEncode(value)

		local requestOptions = { }
		requestOptions.Url = dir
		requestOptions.Method = method
		requestOptions.Headers = { }
		requestOptions.Headers["Content-Type"] = "application/x-www-form-urlencoded"
		requestOptions.Body = encoded

		local success, err = pcall(function() 
			local response = HttpService:RequestAsync(requestOptions)
			if response == nil or not response.Success then
				warn("Roblox-Firebase SetAsync Operation Failure: " .. response.StatusMessage .. " ("..response.StatusCode..")")
				if method == "PATCH" then -- UpdateAsync Request
					print("Retrying Update Request until success...")
					self:SetAsync(key, value, method)
				end
			else
				responseInfo = response
			end
		end)

		return success, responseInfo --> did it work, what was the response
	end

	--[[ DeleteAsync
		@tparam <string> <key> The data point / key being deleted

		Will delete the given data point / key from the Database, !!USE WITH CAUTION!!

		@treturn <boolean> <success> Returns wether or not the SetAsync operation succeeded.
		@treturn <Dictionary> <responseInfo> Returns the ResponseInfo dictionary from HttpService:RequestAsync() useful for debugging/logging.
	]]
	function Firebase:DeleteAsync(key)
		assert(type(key) == "string", "Roblox-Firebase DeleteAsync: Bad Argument #1, string expected got '"..tostring(type(key)).."'")
		return self:SetAsync(key, "", "DELETE")
	end

	--[[ IncrementAsync
		
		@tparam <string> <key> The data point / key being modified
		@tparam[opt=1] <number> The change in value, must be a number or will default to 1, will default when nil too

		Increments the data at the given key by the provided delta (or 1 if null/NaN)
		If the data at the given Key is NaN this method will throw a warning and won't perform any SetAsync operation

		@treturn <boolean> <success> Returns wether or not the SetAsync operation succeeded.
		@treturn <Dictionary> <responseInfo> Returns the ResponseInfo dictionary from HttpService:RequestAsync() useful for debugging/logging.
		@treturn <null> Will return nil upon a failed operation (Data being NaN)
	]]
	function Firebase:IncrementAsync(key, delta)
		assert(type(key) == "string", "Roblox-Firebase IncrementAsync: Bad Argument #1, string expected got '"..tostring(type(key)).."'")

		local data = self:GetAsync(key) or 0
		delta = type(delta)=="number" and delta or 1

		if type(data) == "number" then
			data += delta
			return self:SetAsync(key, data)
		else
			warn("RobloxFirebase: Data at key ["..key.."] is not a number, cannot update data at key ["..key.."]")
			return nil
		end
	end

	--[[ UpdateAsync
		@tparam <string> <key> The data point / key being updated
		@tparam <function> <callback> The callback function used to update the key's values
		@tparam[opt=GetAsync(key)] <Dictionary> The snapshot to be used and referred to for old data instead of acquiring the database again
			used primarily for caching and saving on Data Downloads
		
		This method will simply update the values at the given keys using the provided callback function and will use either the snapshot or 
			GetAsync(key) as a referencing for the old data to update.

		@treturn <boolean> <success> Returns wether or not the SetAsync operation succeeded.
		@treturn <Dictionary> <responseInfo> Returns the ResponseInfo dictionary from HttpService:RequestAsync() useful for debugging/logging.
	]]
	function Firebase:UpdateAsync(key, callback, snapshot)
		--assert(type(key) == "string", "Roblox-Firebase UpdateAsync: Bad Argument #1, string expected got '"..tostring(type(key)).."'")
		assert(type(callback) == "function", "Roblox-Firebase UpdateAsync: Callback must be a function")
		local data = snapshot or self:GetAsync(key) --> Use the snapshot of data supplied instead or Download the database again

		local updated = callback(data)
		if updated then
			return self:SetAsync(key, updated, "PATCH")
		end
	end

	--[[ BatchUpdateAsync
		@tparam <string> <baseKey> The 'parent' key of the keys being modified. From our previous example this could be "PlayerInformation"
		
		@tparam <Dictionary> <keyValues> A dictionary of keys with their respective, current/new values. Player1:[Data=false], for example.
			The value located here isn't used in updating the data and is more-so a personal structure preference of mine.
		@tparam <{[string]=function}> A map of functions with string keys representing the key the function acts upon, "Player1" acts on "Player1" from keyValues
		
			@tparam[opt=GetAsync(key)] <Dictionary> <snapshot> The snapshot to be used and referred to for old data instead of acquiring the database again
			used primarily for caching and saving on Data Downloads. The keys of this dictionary must match the keys of keyValues dictionary


		@treturn <boolean> <success> Returns wether or not the SetAsync operation succeeded.
		@treturn <Dictionary> <responseInfo> Returns the ResponseInfo dictionary from HttpService:RequestAsync() useful for debugging/logging.
	]]
	function Firebase:BatchUpdateAsync(baseKey, keyValues, callbacks, snapshot)
		assert(type(baseKey) == "string", "Roblox-Firebase BatchUpdateAsync: Bad Argument #1, string expected got '"..tostring(type(baseKey)).."'")
		assert(type(keyValues)=="table", "Roblox-Firebase BatchUpdateAsync: Bad Argument #2, table expected got '"..tostring(type(keyValues)).."'")
		assert(type(callbacks)=="table", "Roblox-Firebase BatchUpdateAsync: Bad Argument #3, table expected got '"..tostring(type(callbacks)).."'")

		local updatedKeyValues = { }

		for key, value in pairs(keyValues) do
			-- make sure that the key has a valid and defined callback method
			assert(callbacks[key] ~= nil, "Roblox-Firebase BatchUpdateAsync: Key does not have a callback method, inspect callbacks table")
			assert(type(callbacks[key])=="function", "Roblox-Firebase BatchUpdateAsync: Callback for key ("..key..") is not function, got "..tostring(type(callbacks[key])))

			local data = snapshot[key] or self:GetAsync(key)
			updatedKeyValues[key] = callbacks[key](data)
		end

		if #updatedKeyValues == #keyValues then -- flimsy fail safe
			return self:SetAsync(baseKey, updatedKeyValues, "PATCH")
		end
	end

	return Firebase
end

return (function(dbUrl, authToken)
	local self = setmetatable({}, RobloxFirebase)
	self.DefaultScope = dbUrl
	self.AuthenticationToken = authToken
	return self
end)  -  Editar
  04:54:13.849    -  Editar
  04:54:13.849  ----- [2565] ServerScriptService.__MockDataStoreService -----  -  Editar
  04:54:13.849  --[[
	DataStoreService.lua
	This module decides whether to use actual datastores or mock datastores depending on the environment.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStoreServiceModule = script.MockDataStoreService

local shouldUseMock = false
if game.GameId == 0 then -- Local place file
	shouldUseMock = true
elseif game:GetService("RunService"):IsStudio() then -- Published file in Studio
	local status, message = pcall(function()
		-- This will error if current instance has no Studio API access:
		game:GetService("DataStoreService"):GetDataStore("__TEST"):SetAsync("__TEST", "__TEST_" .. os.time())
	end)
	if not status and message:find("403", 1, true) then -- HACK
		-- Can connect to datastores, but no API access
		shouldUseMock = true
	end
end

-- Return the mock or actual service depending on environment:
if shouldUseMock then
	warn("INFO: Using MockDataStoreService instead of DataStoreService")
	return require(MockDataStoreServiceModule)
else
	return game:GetService("DataStoreService")
end
  -  Editar
  04:54:13.849    -  Editar
  04:54:13.849  ----- [2566] ServerScriptService.__MockDataStoreService.MockDataStoreService -----  -  Editar
  04:54:13.849  --[[
	MockDataStoreService.lua
	This module implements the API and functionality of Roblox's DataStoreService class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStoreService = {}

local MockDataStoreManager = require(script.MockDataStoreManager)
local MockGlobalDataStore = require(script.MockGlobalDataStore)
local MockOrderedDataStore = require(script.MockOrderedDataStore)
local Utils = require(script.MockDataStoreUtils)
local Constants = require(script.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode

local function makeGetWrapper(methodName, getObject, isGlobal) -- Helper function to reduce amount of redundant code
	return function(_, name, scope)
		if not game:GetService("RunService"):IsServer() then
			error("DataStore can't be accessed from client", 2)
		end

		if isGlobal then
			return getObject()
		else
			if type(name) ~= "string" then
				error(("bad argument #1 to '%s' (string expected, got %s)")
					:format(methodName, typeof(name)), 2)
			elseif scope ~= nil and type(scope) ~= "string" then
				error(("bad argument #2 to '%s' (string expected, got %s)")
					:format(methodName, typeof(scope)), 2)
			elseif #name == 0 then
				error(("bad argument #1 to '%s' (name can't be empty string)")
					:format(methodName), 2)
			elseif #name > Constants.MAX_LENGTH_NAME then
				error(("bad argument #1 to '%s' (name exceeds %d character limit)")
					:format(methodName, Constants.MAX_LENGTH_NAME), 2)
			elseif scope and #scope == 0 then
				error(("bad argument #2 to '%s' (scope can't be empty string)")
					:format(methodName), 2)
			elseif scope and #scope > Constants.MAX_LENGTH_SCOPE then
				error(("bad argument #2 to '%s' (scope exceeds %d character limit)")
					:format(methodName, Constants.MAX_LENGTH_SCOPE), 2)
			end
			return getObject(name, scope or "global")
		end

	end
end

MockDataStoreService.GetGlobalDataStore = makeGetWrapper(
	"GetGlobalDataStore",
    function()
        local data = MockDataStoreManager.GetGlobalData()

        local interface = MockDataStoreManager.GetDataInterface(data)
        if interface then
            return interface
        end

        local value = {
			__type = "GlobalDataStore";
            __data = data; -- Mapping from <key> to <value>
            __event = Instance.new("BindableEvent"); -- For OnUpdate
			__writeCache = {};
			__writeLock = {};
			__getCache = {};
        }
        interface = setmetatable(value, MockGlobalDataStore)
		MockDataStoreManager.SetDataInterface(data, interface)

		return interface
	end,
	true -- This is the global datastore, no name/scope needed
)

MockDataStoreService.GetDataStore = makeGetWrapper(
	"GetDataStore",
	function(name, scope)
        local data = MockDataStoreManager.GetData(name, scope)

        local interface = MockDataStoreManager.GetDataInterface(data)
        if interface then
            return interface
        end

        local value = {
			__type = "GlobalDataStore";
            __name = name;
            __scope = scope;
            __data = data; -- Mapping from <key> to <value>
            __event = Instance.new("BindableEvent"); -- For OnUpdate
			__writeCache = {};
			__writeLock = {};
			__getCache = {};
        }
        interface = setmetatable(value, MockGlobalDataStore)
		MockDataStoreManager.SetDataInterface(data, interface)

        return interface
	end
)

MockDataStoreService.GetOrderedDataStore = makeGetWrapper(
	"GetOrderedDataStore",
	function(name, scope)
        local data = MockDataStoreManager.GetOrderedData(name, scope)

        local interface = MockDataStoreManager.GetDataInterface(data)
        if interface then
            return interface
        end

        local value = {
			__type = "OrderedDataStore";
            __name = name;
            __scope = scope;
            __data = data; -- Mapping from <key> to <value>
            __sorted = {}; -- List of {Key = <key>, Value = <value>} pairs
            __ref = {}; -- Mapping from <key> to corresponding {Key = <key>, Value = <value>} entry in __sorted
            __changed = false; -- Whether __sorted is guaranteed sorted at the moment
            __event = Instance.new("BindableEvent"); -- For OnUpdate
			__writeCache = {};
			__writeLock = {};
			__getCache = {};
        }
        interface = setmetatable(value, MockOrderedDataStore)
		MockDataStoreManager.SetDataInterface(data, interface)

		return interface
	end
)

local DataStoreRequestTypes = {}

for _, Enumerator in ipairs(Enum.DataStoreRequestType:GetEnumItems()) do
	DataStoreRequestTypes[Enumerator] = Enumerator
	DataStoreRequestTypes[Enumerator.Name] = Enumerator
	DataStoreRequestTypes[Enumerator.Value] = Enumerator
end

function MockDataStoreService:GetRequestBudgetForRequestType(requestType) -- luacheck: ignore self
	if not DataStoreRequestTypes[requestType] then
		error(("bad argument #1 to 'GetRequestBudgetForRequestType' (unable to cast '%s' of type %s to DataStoreRequestType)")
			:format(tostring(requestType), typeof(requestType)), 2)
	end

	return MockDataStoreManager.GetBudget(DataStoreRequestTypes[requestType])
end

function MockDataStoreService:ImportFromJSON(json, verbose) -- luacheck: ignore self
	local content
	if type(json) == "string" then
		local parsed, value = pcall(function() return HttpService:JSONDecode(json) end)
		if not parsed then
			error("bad argument #1 to 'ImportFromJSON' (string is not valid json)", 2)
		end
		content = value
	elseif type(json) == "table" then
		content = Utils.deepcopy(json)
	else
		error(("bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)"):format(typeof(json)), 2)
	end
	if verbose ~= nil and type(verbose) ~= "boolean" then
		error(("bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)"):format(typeof(verbose)), 2)
	end

	return MockDataStoreManager.ImportFromJSON(content, verbose)
end

function MockDataStoreService:ExportToJSON() -- luacheck: ignore self
	return MockDataStoreManager.ExportToJSON()
end

return MockDataStoreService
  -  Editar
  04:54:13.850    -  Editar
  04:54:13.850  ----- [2567] ServerScriptService.__MockDataStoreService.MockDataStoreService.MockDataStoreConstants -----  -  Editar
  04:54:13.850  --[[
    MockDataStoreConstants.lua
    Contains all constants used by the entirety of MockDataStoreService and its sub-classes.

    This module is licensed under APLv2, refer to the LICENSE file or:
    https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

return {

    LOGGING_ENABLED = false;        -- Verbose logging of transactions to output
    LOGGING_FUNCTION = warn;        -- Function for logging messages

    MAX_LENGTH_KEY = 50;            -- Max number of chars in key string
    MAX_LENGTH_NAME = 50;           -- Max number of chars in name string
    MAX_LENGTH_SCOPE = 50;          -- Max number of chars in scope string
    MAX_LENGTH_DATA = 4194301;      -- Max number of chars in (encoded) data strings

    MAX_PAGE_SIZE = 100;            -- Max page size for GetSortedAsync

    YIELD_TIME_MIN = 0.2;           -- Random yield time values for set/get/update/remove/getsorted
    YIELD_TIME_MAX = 0.5;

    YIELD_TIME_UPDATE_MIN = 0.2;    -- Random yield times from events from OnUpdate
    YIELD_TIME_UPDATE_MAX = 0.5;

    WRITE_COOLDOWN = 6.0;           -- Amount of cooldown time between writes on the same key in a particular datastore

    GET_COOLDOWN = 5.0;             -- Amount of cooldown time that a recent interaction with a key is considered fresh

    THROTTLE_QUEUE_SIZE = 30;       -- Amount of requests that can be throttled at once (additional requests will error)

    SIMULATE_ERROR_RATE = 0;        -- Rate at which requests will throw errors for testing (0 = never, 1 = always)

    BUDGETING_ENABLED = true;       -- Whether budgets are enforced and calculated

    BUDGET_GETASYNC = {             -- Budget constant storing structure
        START = 100;                    -- Starting budget
        RATE = 60;                      -- Added budget per minute
        RATE_PLR = 10;                  -- Additional added budget per minute per player
        MAX_FACTOR = 3;                 -- The maximum budget as a factor of (rate + rate_plr * #players)
    };

    BUDGET_GETSORTEDASYNC = {
        START = 10;
        RATE = 5;
        RATE_PLR = 2;
        MAX_FACTOR = 3;
    };

    BUDGET_ONUPDATE = {
        START = 30;
        RATE = 30;
        RATE_PLR = 5;
        MAX_FACTOR = 1;
    };

    BUDGET_SETINCREMENTASYNC = {
        START = 100;
        RATE = 60;
        RATE_PLR = 10;
        MAX_FACTOR = 3;
    };

    BUDGET_SETINCREMENTSORTEDASYNC = {
        START = 50;
        RATE = 30;
        RATE_PLR = 5;
        MAX_FACTOR = 3;
    };

    BUDGET_BASE = 60;               -- Modifiers used for budget increases on OnClose
    BUDGET_ONCLOSE_BASE = 150;

    BUDGET_UPDATE_INTERVAL = 1.0;   -- Time interval in seconds at which budgets are updated (do not put too low)

}
  -  Editar
  04:54:13.850    -  Editar
  04:54:13.850  ----- [2568] ServerScriptService.__MockDataStoreService.MockDataStoreService.MockDataStoreManager -----  -  Editar
  04:54:13.850  --[[
	MockDataStoreManager.lua
	This module does bookkeeping of data, interfaces and request limits used by MockDataStoreService and its sub-classes.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStoreManager = {}

local Utils = require(script.Parent.MockDataStoreUtils)
local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode
local Players = game:GetService("Players") -- for restoring budgets
local RunService = game:GetService("RunService") -- for checking if running context is on server

local ConstantsMapping = {
	[Enum.DataStoreRequestType.GetAsync] = Constants.BUDGET_GETASYNC;
	[Enum.DataStoreRequestType.GetSortedAsync] = Constants.BUDGET_GETSORTEDASYNC;
	[Enum.DataStoreRequestType.OnUpdate] = Constants.BUDGET_ONUPDATE;
	[Enum.DataStoreRequestType.SetIncrementAsync] = Constants.BUDGET_SETINCREMENTASYNC;
	[Enum.DataStoreRequestType.SetIncrementSortedAsync] = Constants.BUDGET_SETINCREMENTSORTEDASYNC;
}

-- Bookkeeping of all data:
local Data = {
	GlobalDataStore = {};
	DataStore = {};
	OrderedDataStore = {};
}

-- Bookkeeping of all active GlobalDataStore/OrderedDataStore interfaces indexed by data table:
local Interfaces = {}

-- Request limit bookkeeping:
local Budgets = {}

local budgetRequestQueues = {
	[Enum.DataStoreRequestType.GetAsync] = {};
	[Enum.DataStoreRequestType.GetSortedAsync] = {};
	[Enum.DataStoreRequestType.OnUpdate] = {};
	[Enum.DataStoreRequestType.SetIncrementAsync] = {};
	[Enum.DataStoreRequestType.SetIncrementSortedAsync] = {};
}

local function initBudget()
	for requestType, const in pairs(ConstantsMapping) do
		Budgets[requestType] = const.START
	end
	Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
		Budgets[Enum.DataStoreRequestType.GetAsync],
		Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
	)
end

local function updateBudget(req, const, dt, n)
	if not Constants.BUDGETING_ENABLED then
		return
	end
	local rate = const.RATE + n * const.RATE_PLR
	Budgets[req] = math.min(
		Budgets[req] + dt * rate,
		const.MAX_FACTOR * rate
	)
end

local function stealBudget(budget)
	if not Constants.BUDGETING_ENABLED then
		return
	end
	for _, requestType in pairs(budget) do
		if Budgets[requestType] then
			Budgets[requestType] = math.max(0, Budgets[requestType] - 1)
		end
	end
	Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
		Budgets[Enum.DataStoreRequestType.GetAsync],
		Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
	)
end

local function checkBudget(budget)
	if not Constants.BUDGETING_ENABLED then
		return true
	end
	for _, requestType in pairs(budget) do
		if Budgets[requestType] and Budgets[requestType] < 1 then
			return false
		end
	end
	return true
end

local isFrozen = false

if RunService:IsServer() then
	-- Only do budget/throttle updating on server (in case package required on client)

	initBudget()

	task.spawn(function() -- Thread that increases budgets and de-throttles requests periodically
		local lastCheck = tick()
		while task.wait(Constants.BUDGET_UPDATE_INTERVAL) do
			local now = tick()
			local dt = (now - lastCheck) / 60
			lastCheck = now
			local n = #Players:GetPlayers()

			if not isFrozen then
				for requestType, const in pairs(ConstantsMapping) do
					updateBudget(requestType, const, dt, n)
				end
				Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
					Budgets[Enum.DataStoreRequestType.GetAsync],
					Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
				)
			end

			for _, budgetRequestQueue in pairs(budgetRequestQueues) do
				for i = #budgetRequestQueue, 1, -1 do
					local request = budgetRequestQueue[i]

					local thread = request.Thread
					local budget = request.Budget
					local key = request.Key
					local lock = request.Lock
					local cache = request.Cache

					if not (lock and (lock[key] or tick() - (cache[key] or 0) < Constants.WRITE_COOLDOWN)) and checkBudget(budget) then
						table.remove(budgetRequestQueue, i)
						stealBudget(budget)
						coroutine.resume(thread)
					end
				end
			end
		end
	end)

	game:BindToClose(function()
		for requestType, const in pairs(ConstantsMapping) do
			Budgets[requestType] = math.max(
				Budgets[requestType],
				Constants.BUDGET_ONCLOSE_BASE * (const.RATE / Constants.BUDGET_BASE)
			)
		end
		Budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
			Budgets[Enum.DataStoreRequestType.GetAsync],
			Budgets[Enum.DataStoreRequestType.SetIncrementAsync]
		)
	end)

end

function MockDataStoreManager.GetGlobalData()
	return Data.GlobalDataStore
end

function MockDataStoreManager.GetData(name, scope)
	assert(type(name) == "string")
	assert(type(scope) == "string")

	if not Data.DataStore[name] then
		Data.DataStore[name] = {}
	end
	if not Data.DataStore[name][scope] then
		Data.DataStore[name][scope] = {}
	end

	return Data.DataStore[name][scope]
end

function MockDataStoreManager.GetOrderedData(name, scope)
	assert(type(name) == "string")
	assert(type(scope) == "string")

	if not Data.OrderedDataStore[name] then
		Data.OrderedDataStore[name] = {}
	end
	if not Data.OrderedDataStore[name][scope] then
		Data.OrderedDataStore[name][scope] = {}
	end

	return Data.OrderedDataStore[name][scope]
end

function MockDataStoreManager.GetDataInterface(data)
	return Interfaces[data]
end

function MockDataStoreManager.SetDataInterface(data, interface)
	assert(type(data) == "table")
	assert(type(interface) == "table")

	Interfaces[data] = interface
end

function MockDataStoreManager.GetBudget(requestType)
	if Constants.BUDGETING_ENABLED then
		return math.floor(Budgets[requestType] or 0)
	else
		return math.huge
	end
end

function MockDataStoreManager.SetBudget(requestType, budget)
	assert(type(budget) == "number")
	budget = math.max(budget, 0)

	if requestType == Enum.DataStoreRequestType.UpdateAsync then
		Budgets[Enum.DataStoreRequestType.SetIncrementAsync] = budget
		Budgets[Enum.DataStoreRequestType.GetAsync] = budget
	end

	if Budgets[requestType] then
		Budgets[requestType] = budget
	end
end

function MockDataStoreManager.ResetBudget()
	initBudget()
end

function MockDataStoreManager.FreezeBudgetUpdates()
	isFrozen = true
end

function MockDataStoreManager.ThawBudgetUpdates()
	isFrozen = false
end

function MockDataStoreManager.YieldForWriteLockAndBudget(callback, key, writeLock, writeCache, budget)
	assert(type(callback) == "function")
	assert(type(key) == "string")
	assert(type(writeLock) == "table")
	assert(type(writeCache) == "table")
	assert(#budget > 0)

	local mainRequestType = budget[1]

	if #budgetRequestQueues[mainRequestType] >= Constants.THROTTLE_QUEUE_SIZE then
		return false -- no room in throttle queue
	end

	callback() -- would i.e. trigger a warning in output

	table.insert(budgetRequestQueues[mainRequestType], 1, {
		Key = key;
		Lock = writeLock;
		Cache = writeCache;
		Thread = coroutine.running();
		Budget = budget;
	})
	coroutine.yield()

	return true
end

function MockDataStoreManager.YieldForBudget(callback, budget)
	assert(type(callback) == "function")
	assert(#budget > 0)

	local mainRequestType = budget[1]

	if checkBudget(budget) then
		stealBudget(budget)
	elseif #budgetRequestQueues[mainRequestType] >= Constants.THROTTLE_QUEUE_SIZE then
		return false -- no room in throttle queue
	else
		callback() -- would i.e. trigger a warning in output

		table.insert(budgetRequestQueues[mainRequestType], 1, {
			After = 0; -- no write lock
			Thread = coroutine.running();
			Budget = budget;
		})
		coroutine.yield()
	end

	return true
end

function MockDataStoreManager.ExportToJSON()
	local export = {}

	if next(Data.GlobalDataStore) ~= nil then -- GlobalDataStore not empty
		export.GlobalDataStore = Data.GlobalDataStore
	end
	export.DataStore = Utils.prepareDataStoresForExport(Data.DataStore) -- can be nil
	export.OrderedDataStore = Utils.prepareDataStoresForExport(Data.OrderedDataStore) -- can be nil

	return HttpService:JSONEncode(export)
end

-- Import into an entire datastore type:
local function importDataStoresFromTable(origin, destination, warnFunc, methodName, prefix, isOrdered)
	for name, scopes in pairs(origin) do
		if type(name) ~= "string" then
			warnFunc(("%s: ignored %s > %q (name is not a string, but a %s)")
				:format(methodName, prefix, tostring(name), typeof(name)))
		elseif type(scopes) ~= "table" then
			warnFunc(("%s: ignored %s > %q (scope list is not a table, but a %s)")
				:format(methodName, prefix, name, typeof(scopes)))
		elseif #name == 0 then
			warnFunc(("%s: ignored %s > %q (name is an empty string)")
				:format(methodName, prefix, name))
		elseif #name > Constants.MAX_LENGTH_NAME then
			warnFunc(("%s: ignored %s > %q (name exceeds %d character limit)")
				:format(methodName, prefix, name, Constants.MAX_LENGTH_NAME))
		else
			for scope, data in pairs(scopes) do
				if type(scope) ~= "string" then
					warnFunc(("%s: ignored %s > %q > %q (scope is not a string, but a %s)")
						:format(methodName, prefix, name, tostring(scope), typeof(scope)))
				elseif type(data) ~= "table" then
					warnFunc(("%s: ignored %s > %q > %q (data list is not a table, but a %s)")
						:format(methodName, prefix, name, scope, typeof(data)))
				elseif #scope == 0 then
					warnFunc(("%s: ignored %s > %q > %q (scope is an empty string)")
						:format(methodName, prefix, name, scope))
				elseif #scope > Constants.MAX_LENGTH_SCOPE then
					warnFunc(("%s: ignored %s > %q > %q (scope exceeds %d character limit)")
						:format(methodName, prefix, name, scope, Constants.MAX_LENGTH_SCOPE))
				else
					if not destination[name] then
						destination[name] = {}
					end
					if not destination[name][scope] then
						destination[name][scope] = {}
					end
					Utils.importPairsFromTable(
						data,
						destination[name][scope],
						Interfaces[destination[name][scope]],
						warnFunc,
						methodName,
						("%s > %q > %q"):format(prefix, name, scope),
						isOrdered
					)
				end
			end
		end
	end
end

function MockDataStoreManager.ImportFromJSON(content, verbose)
	assert(type(content) == "table")
	assert(verbose == nil or type(verbose) == "boolean")

	local warnFunc = warn -- assume verbose as default
	if verbose == false then -- intentional formatting
		warnFunc = function() end
	end

	if type(content.GlobalDataStore) == "table" then
		Utils.importPairsFromTable(
			content.GlobalDataStore,
			Data.GlobalDataStore,
			Interfaces[Data.GlobalDataStore],
			warnFunc,
			"ImportFromJSON",
			"GlobalDataStore",
			false
		)
	end
	if type(content.DataStore) == "table" then
		importDataStoresFromTable(
			content.DataStore,
			Data.DataStore,
			warnFunc,
			"ImportFromJSON",
			"DataStore",
			false
		)
	end
	if type(content.OrderedDataStore) == "table" then
		importDataStoresFromTable(
			content.OrderedDataStore,
			Data.OrderedDataStore,
			warnFunc,
			"ImportFromJSON",
			"OrderedDataStore",
			true
		)
	end
end

local function clearTable(t)
	for i,_ in pairs(t) do
		t[i] = nil
	end
end

function MockDataStoreManager.ResetData()
	for _, interface in pairs(Interfaces) do
		for key, _ in pairs(interface.__data) do
			interface.__data[key] = nil
			interface.__event:Fire(key, nil)
		end
		interface.__getCache = {}
		interface.__writeCache = {}
		interface.__writeLock = {}
		if interface.__sorted then
			interface.__sorted = {};
            interface.__ref = {};
            interface.__changed = false;
		end
	end

	clearTable(Data.GlobalDataStore)

	for _, scopes in pairs(Data.DataStore) do
		for _, data in pairs(scopes) do
			clearTable(data)
		end
	end

	for _, scopes in pairs(Data.OrderedDataStore) do
		for _, data in pairs(scopes) do
			clearTable(data)
		end
	end
end

return MockDataStoreManager
  -  Editar
  04:54:13.850    -  Editar
  04:54:13.850  ----- [2569] ServerScriptService.__MockDataStoreService.MockDataStoreService.MockDataStorePages -----  -  Editar
  04:54:13.851  --[[
	MockDataStorePages.lua
	This module implements the API and functionality of Roblox's DataStorePages class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStorePages = {}
MockDataStorePages.__index = MockDataStorePages

local MockDataStoreManager = require(script.Parent.MockDataStoreManager)
local Utils = require(script.Parent.MockDataStoreUtils)

function MockDataStorePages:GetCurrentPage()
	local retValue = {}

	local minimumIndex = math.max(1, (self.__currentPage - 1) * self.__pageSize + 1)
	local maximumIndex = math.min(self.__currentPage * self.__pageSize, #self.__results)
	for i = minimumIndex, maximumIndex do
		table.insert(retValue, {key = self.__results[i].key, value = self.__results[i].value})
	end

	return retValue
end

function MockDataStorePages:AdvanceToNextPageAsync()
	if self.IsFinished then
		error("AdvanceToNextPageAsync rejected with error (no pages to advance to)", 2)
	end

	Utils.simulateErrorCheck("AdvanceToNextPageAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn("AdvanceToNextPageAsync request was throttled due to lack of budget. Try sending fewer requests.")
		end,
		{Enum.DataStoreRequestType.GetAsync}
	)

	if not success then
		error("AdvanceToNextPageAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	Utils.simulateYield()

	if #self.__results > self.__currentPage * self.__pageSize then
		self.__currentPage = self.__currentPage + 1
	end
	self.IsFinished = #self.__results <= self.__currentPage * self.__pageSize

	Utils.logMethod(self.__datastore, "AdvanceToNextPageAsync")

end

return MockDataStorePages
  -  Editar
  04:54:13.851    -  Editar
  04:54:13.851  ----- [2570] ServerScriptService.__MockDataStoreService.MockDataStoreService.MockDataStoreUtils -----  -  Editar
  04:54:13.851  --[[
	MockDataStoreUtils.lua
	Contains helper and utility functions used by other classes.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockDataStoreUtils = {}

local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode
local RunService = game:GetService("RunService")

local rand = Random.new()

local function shorten(s, num)
	if #s > num then
		return s:sub(1,num-2) .. ".."
	end
	return s
end

--[[
	[DataStore] [Name/Scope] [GetAsync] KEY
	[DataStore] [Name/Scope] [UpdateAsync] KEY => VALUE
	[DataStore] [Name/Scope] [SetAsync] KEY => VALUE
	[DataStore] [Name/Scope] [IncrementAsync] KEY by INCR => VALUE
	[DataStore] [Name/Scope] [RemoveAsync] KEY =/> VALUE
	[DataStore] [Name/Scope] [OnUpdate] KEY
	[DataStore] [Name/Scope] [GetSortedAsync]

	[OrderedDataStore] [Name/Scope] [GetAsync] KEY
	[OrderedDataStore] [Name/Scope] [UpdateAsync] KEY => VALUE
	[OrderedDataStore] [Name/Scope] [SetAsync] KEY => VALUE
	[OrderedDataStore] [Name/Scope] [IncrementAsync] KEY + INCR => VALUE
	[OrderedDataStore] [Name/Scope] [RemoveAsync] KEY =/> VALUE
	[OrderedDataStore] [Name/Scope] [OnUpdate] KEY
	[OrderedDataStore] [Name/Scope] [GetSortedAsync]

	[OrderedDataStore] [Name/Scope] [AdvanceToNextPageAsync]
]]

local function logMethod(self, method, key, value, increment)
	if not Constants.LOGGING_ENABLED or type(Constants.LOGGING_FUNCTION) ~= "function" then
		return
	end

	local name = self.__name
	local scope = self.__scope

	local prefix
	if not name then
		prefix = ("[GlobalDataStore] [%s]"):format(method)
	elseif not scope then
		prefix = ("[%s] [%s] [%s]"):format(self.__type, shorten(name, 20), method)
	else
		prefix = ("[%s] [%s/%s] [%s]"):format(self.__type, shorten(name, 15), shorten(scope, 15), method)
	end

	local message
	if value and increment then
		message = key .. " + " .. tostring(increment) .. " => " .. tostring(value)
	elseif increment then
		message = key .. " + " .. tostring(increment)
	elseif value then
		if method == "RemoveAsync" then
			message = key .. " =/> " .. tostring(value)
		else
			message = key .. " => " .. tostring(value)
		end
	else
		message = "key"
	end

	Constants.LOGGING_FUNCTION(prefix .. " " .. message)

end

local function deepcopy(t)
	if type(t) == "table" then
		local n = {}
		for i,v in pairs(t) do
			n[i] = deepcopy(v)
		end
		return n
	else
		return t
	end
end

local function scanValidity(tbl, passed, path) -- Credit to Corecii (edited)
	if type(tbl) ~= "table" then
		return scanValidity({input = tbl}, {}, {})
	end
	passed, path = passed or {}, path or {"root"}
	passed[tbl] = true
	local tblType
	do
		local key = next(tbl)
		if type(key) == "number" then
			tblType = "Array"
		else
			tblType = "Dictionary"
		end
	end
	local last = 0
	for key, value in next, tbl do
		path[#path + 1] = tostring(key)
		if type(key) == "number" then
			if tblType == "Dictionary" then
				return false, path, "cannot store mixed tables"
			elseif key % 1 ~= 0 then
				return false, path, "cannot store tables with non-integer indices"
			elseif key == math.huge or key == -math.huge then
				return false, path, "cannot store tables with (-)infinity indices"
			end
		elseif type(key) ~= "string" then
			return false, path, "dictionaries cannot have keys of type " .. typeof(key)
		elseif tblType == "Array" then
			return false, path, "cannot store mixed tables"
		elseif not utf8.len(key) then
			return false, path, "dictionary has key that is invalid UTF-8"
		end
		if tblType == "Array" then
			if last ~= key - 1 then
				return false, path, "array has non-sequential indices"
			end
			last = key
		end
		if type(value) == "userdata" or type(value) == "function" or type(value) == "thread" then
			return false, path, "cannot store value '" .. tostring(value) .. "' of type " .. typeof(value)
		elseif type(value) == "string" and not utf8.len(value) then
			return false, path, "cannot store strings that are invalid UTF-8"
		end
		if type(value) == "table" then
			if passed[value] then
				return false, path, "cannot store cyclic tables"
			end
			local isValid, keyPath, reason = scanValidity(value, passed, path)
			if not isValid then
				return isValid, keyPath, reason
			end
		end
		path[#path] = nil
	end
	passed[tbl] = nil
	return true
end

local function getStringPath(path)
	return table.concat(path, '.')
end

-- Import into a single datastore:
local function importPairsFromTable(origin, destination, interface, warnFunc, methodName, prefix, isOrdered)
	for key, value in pairs(origin) do
		if type(key) ~= "string" then
			warnFunc(("%s: ignored %s > '%s' (key is not a string, but a %s)")
				:format(methodName, prefix, tostring(key), typeof(key)))
		elseif not utf8.len(key) then
			warnFunc(("%s: ignored %s > '%s' (key is not valid UTF-8)")
				:format(methodName, prefix, tostring(key)))
		elseif #key > Constants.MAX_LENGTH_KEY then
			warnFunc(("%s: ignored %s > '%s' (key exceeds %d character limit)")
				:format(methodName, prefix, key, Constants.MAX_LENGTH_KEY))
		elseif type(value) == "string" and #value > Constants.MAX_LENGTH_DATA then
			warnFunc(("%s: ignored %s > '%s' (length of value exceeds %d character limit)")
				:format(methodName, prefix, key, Constants.MAX_LENGTH_DATA))
		elseif type(value) == "table" and #HttpService:JSONEncode(value) > Constants.MAX_LENGTH_DATA then
			warnFunc(("%s: ignored %s > '%s' (length of encoded value exceeds %d character limit)")
				:format(methodName, prefix, key, Constants.MAX_LENGTH_DATA))
		elseif type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
			warnFunc(("%s: ignored %s > '%s' (cannot store value '%s' of type %s)")
				:format(methodName, prefix, key, tostring(value), type(value)))
		elseif isOrdered and type(value) ~= "number" then
			warnFunc(("%s: ignored %s > '%s' (cannot store value '%s' of type %s in OrderedDataStore)")
				:format(methodName, prefix, key, tostring(value), type(value)))
		elseif isOrdered and value % 1 ~= 0 then
			warnFunc(("%s: ignored %s > '%s' (cannot store non-integer value '%s' in OrderedDataStore)")
				:format(methodName, prefix, key, tostring(value)))
		elseif type(value) == "string" and not utf8.len(value) then
			warnFunc(("%s: ignored %s > '%s' (string value is not valid UTF-8)")
				:format(methodName, prefix, key, tostring(value), type(value)))
		else
			local isValid = true
			local keyPath, reason
			if type(value) == "table" then
				isValid, keyPath, reason = scanValidity(value)
			end
			if isOrdered then
				value = math.floor(value + .5)
			end
			if isValid then
				local old = destination[key]
				destination[key] = value
				if interface and old ~= value then -- hacky block to fire OnUpdate signals
					if isOrdered and interface then -- hacky block to populate internal structures for OrderedDataStores
						if interface.__ref[key] then
							interface.__ref[key].Value = value
							interface.__changed = true
						else
							interface.__ref[key] = {Key = key, Value = interface.__data[key]}
							table.insert(interface.__sorted, interface.__ref[key])
							interface.__changed = true
						end
					end
					interface.__event:Fire(key, value)
				end
			else
				warnFunc(("%s: ignored %s > '%s' (table has invalid entry at <%s>: %s)")
					:format(methodName, prefix, key, getStringPath(keyPath), reason))
			end
		end
	end
end

-- Trim empty datastores and scopes from an entire datastore type:
local function prepareDataStoresForExport(origin)
	local dataPrepared = {}

	for name, scopes in pairs(origin) do
		local exportScopes = {}
		for scope, data in pairs(scopes) do
			local exportData = {}
			for key, value in pairs(data) do
				exportData[key] = value
			end
			if next(exportData) ~= nil then -- Only export datastore when non-empty
				exportScopes[scope] = exportData
			end
		end
		if next(exportScopes) ~= nil then -- Only export scope list when non-empty
			dataPrepared[name] = exportScopes
		end
	end

	if next(dataPrepared) ~= nil then -- Only return datastore type when non-empty
		return dataPrepared
	end
end

local function preprocessKey(key)
	if type(key) == "number" then
		if key ~= key then
			return "NAN"
		elseif key >= math.huge then
			return "INF"
		elseif key <= -math.huge then
			return "-INF"
		end
		return tostring(key)
	end
	return key
end

local function simulateYield()
	if Constants.YIELD_TIME_MAX > 0 then
		task.wait(rand:NextNumber(Constants.YIELD_TIME_MIN, Constants.YIELD_TIME_MAX))
	end
end

local function simulateErrorCheck(method)
	if Constants.SIMULATE_ERROR_RATE > 0 and rand:NextNumber() <= Constants.SIMULATE_ERROR_RATE then
		simulateYield()
		error(method .. " rejected with error (simulated error)", 3)
	end
end

-- Setting these here so the functions above can self-reference just by name:
MockDataStoreUtils.logMethod = logMethod
MockDataStoreUtils.deepcopy = deepcopy
MockDataStoreUtils.scanValidity = scanValidity
MockDataStoreUtils.getStringPath = getStringPath
MockDataStoreUtils.importPairsFromTable = importPairsFromTable
MockDataStoreUtils.prepareDataStoresForExport = prepareDataStoresForExport
MockDataStoreUtils.preprocessKey = preprocessKey
MockDataStoreUtils.simulateYield = simulateYield
MockDataStoreUtils.simulateErrorCheck = simulateErrorCheck

return MockDataStoreUtils
  -  Editar
  04:54:13.851    -  Editar
  04:54:13.851  ----- [2571] ServerScriptService.__MockDataStoreService.MockDataStoreService.MockGlobalDataStore -----  -  Editar
  04:54:13.851  --[[
	MockGlobalDataStore.lua
	This module implements the API and functionality of Roblox's GlobalDataStore class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockGlobalDataStore = {}
MockGlobalDataStore.__index = MockGlobalDataStore

local MockDataStoreManager = require(script.Parent.MockDataStoreManager)
local Utils = require(script.Parent.MockDataStoreUtils)
local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode

local rand = Random.new()

function MockGlobalDataStore:OnUpdate(key, callback)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'OnUpdate' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(callback) ~= "function" then
		error(("bad argument #2 to 'OnUpdate' (function expected, got %s)"):format(typeof(callback)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'OnUpdate' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'OnUpdate' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("OnUpdate")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("OnUpdate request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.OnUpdate}
	)

	if not success then
		error("OnUpdate rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	Utils.logMethod(self, "OnUpdate", key)

	return self.__event.Event:Connect(function(k, v)
		if k == key then
			if Constants.YIELD_TIME_UPDATE_MAX > 0 then
				task.wait(rand:NextNumber(Constants.YIELD_TIME_UPDATE_MIN, Constants.YIELD_TIME_UPDATE_MAX))
			end
			callback(v) -- v was implicitly deep-copied
		end
	end)
end

function MockGlobalDataStore:GetAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'GetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'GetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'GetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
		return Utils.deepcopy(self.__data[key])
	end

	Utils.simulateErrorCheck("GetAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("GetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.GetAsync}
	)

	if not success then
		error("GetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__getCache[key] = tick()

	local retValue = Utils.deepcopy(self.__data[key])

	Utils.simulateYield()

	Utils.logMethod(self, "GetAsync", key)

	return retValue
end

function MockGlobalDataStore:IncrementAsync(key, delta)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'IncrementAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif delta ~= nil and type(delta) ~= "number" then
		error(("bad argument #2 to 'IncrementAsync' (number expected, got %s)"):format(typeof(delta)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'IncrementAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'IncrementAsync' (key name exceeds %d character limit)")
			:format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("IncrementAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("IncrementAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("IncrementAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("IncrementAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local old = self.__data[key]

	if old ~= nil and (type(old) ~= "number" or old % 1 ~= 0) then
		Utils.simulateYield()
		error("IncrementAsync rejected with error (cannot increment non-integer value)", 2)
	end

	self.__writeLock[key] = true

	delta = delta and math.floor(delta + .5) or 1

	self.__data[key] = (old or 0) + delta

	if old == nil or delta ~= 0 then
		self.__event:Fire(key, self.__data[key])
	end

	local retValue = self.__data[key]

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "IncrementAsync", key, retValue, delta)

	return retValue
end

function MockGlobalDataStore:RemoveAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'RemoveAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'RemoveAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'RemoveAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("RemoveAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("RemoveAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("RemoveAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("RemoveAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	local value = Utils.deepcopy(self.__data[key])
	self.__data[key] = nil

	if value ~= nil then
		self.__event:Fire(key, nil)
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "RemoveAsync", key, value)

	return value
end

function MockGlobalDataStore:SetAsync(key, value)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'SetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'SetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'SetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	elseif value == nil or type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
		error(("bad argument #2 to 'SetAsync' (cannot store value '%s' of type %s)")
			:format(tostring(value), typeof(value)), 2)
	end

	if type(value) == "table" then
		local isValid, keyPath, reason = Utils.scanValidity(value)
		if not isValid then
			error(("bad argument #2 to 'SetAsync' (table has invalid entry at <%s>: %s)")
				:format(Utils.getStringPath(keyPath), reason), 2)
		end
		local pass, content = pcall(function() return HttpService:JSONEncode(value) end)
		if not pass then
			error("bad argument #2 to 'SetAsync' (table could not be encoded to json)", 2)
		elseif #content > Constants.MAX_LENGTH_DATA then
			error(("bad argument #2 to 'SetAsync' (encoded data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		end
	elseif type(value) == "string" then
		if #value > Constants.MAX_LENGTH_DATA then
			error(("bad argument #2 to 'SetAsync' (data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		elseif not utf8.len(value) then
			error("bad argument #2 to 'SetAsync' (string value is not valid UTF-8)", 2)
		end
	end

	Utils.simulateErrorCheck("SetAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("SetAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("SetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("SetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	if type(value) == "table" or value ~= self.__data[key] then
		self.__data[key] = Utils.deepcopy(value)
		self.__event:Fire(key, self.__data[key])
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "SetAsync", key, self.__data[key])

end

function MockGlobalDataStore:UpdateAsync(key, transformFunction)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'UpdateAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(transformFunction) ~= "function" then
		error(("bad argument #2 to 'UpdateAsync' (function expected, got %s)"):format(typeof(transformFunction)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'UpdateAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'UpdateAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("UpdateAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("UpdateAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementAsync}
		)
	else
		self.__writeLock[key] = true
		local budget
		if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
			budget = {Enum.DataStoreRequestType.SetIncrementAsync}
		else
			budget = {Enum.DataStoreRequestType.GetAsync, Enum.DataStoreRequestType.SetIncrementAsync}
		end
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("UpdateAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			budget
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("UpdateAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local value = transformFunction(Utils.deepcopy(self.__data[key]))

	if value == nil then -- cancel update after remote call
		Utils.simulateYield()
		return nil -- this is what datastores do even though it should be old value
	end

	if type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
		error(("UpdateAsync rejected with error (resulting value '%s' is of type %s that cannot be stored)")
			:format(tostring(value), typeof(value)), 2)
	end

	if type(value) == "table" then
		local isValid, keyPath, reason = Utils.scanValidity(value)
		if not isValid then
			error(("UpdateAsync rejected with error (resulting table has invalid entry at <%s>: %s)")
				:format(Utils.getStringPath(keyPath), reason), 2)
		end
		local pass, content = pcall(function() return HttpService:JSONEncode(value) end)
		if not pass then
			error("UpdateAsync rejected with error (resulting table could not be encoded to json)", 2)
		elseif #content > Constants.MAX_LENGTH_DATA then
			error(("UpdateAsync rejected with error (resulting encoded data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		end
	elseif type(value) == "string" then
		if #value > Constants.MAX_LENGTH_DATA then
			error(("UpdateAsync rejected with error (resulting data length exceeds %d character limit)")
				:format(Constants.MAX_LENGTH_DATA), 2)
		elseif not utf8.len(value) then
			error("UpdateAsync rejected with error (string value is not valid UTF-8)", 2)
		end
	end

	self.__writeLock[key] = true

	if type(value) == "table" or value ~= self.__data[key] then
		self.__data[key] = Utils.deepcopy(value)
		self.__event:Fire(key, self.__data[key])
	end

	local retValue = Utils.deepcopy(value)

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "UpdateAsync", key, retValue)

	return retValue
end

function MockGlobalDataStore:ExportToJSON()
	return HttpService:JSONEncode(self.__data)
end

function MockGlobalDataStore:ImportFromJSON(json, verbose)
	local content
	if type(json) == "string" then
		local parsed, value = pcall(function() return HttpService:JSONDecode(json) end)
		if not parsed then
			error("bad argument #1 to 'ImportFromJSON' (string is not valid json)", 2)
		end
		content = value
	elseif type(json) == "table" then
		content = Utils.deepcopy(json)
	else
		error(("bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)"):format(typeof(json)), 2)
	end

	if verbose ~= nil and type(verbose) ~= "boolean" then
		error(("bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)"):format(typeof(verbose)), 2)
	end

	Utils.importPairsFromTable(
		content,
		self.__data,
		MockDataStoreManager.GetDataInterface(self.__data),
		(verbose == false and function() end or warn),
		"ImportFromJSON",
		((type(self.__name) == "string" and type(self.__scope) == "string")
			and ("DataStore > %s > %s"):format(self.__name, self.__scope)
			or "GlobalDataStore"),
		false
	)
end

return MockGlobalDataStore
  -  Editar
  04:54:13.851    -  Editar
  04:54:13.851  ----- [2572] ServerScriptService.__MockDataStoreService.MockDataStoreService.MockOrderedDataStore -----  -  Editar
  04:54:13.851  --[[
	MockOrderedDataStore.lua
	This module implements the API and functionality of Roblox's OrderedDataStore class.

	This module is licensed under APLv2, refer to the LICENSE file or:
	https://github.com/buildthomas/MockDataStoreService/blob/master/LICENSE
]]

local MockOrderedDataStore = {}
MockOrderedDataStore.__index = MockOrderedDataStore

local MockDataStoreManager = require(script.Parent.MockDataStoreManager)
local MockDataStorePages = require(script.Parent.MockDataStorePages)
local Utils = require(script.Parent.MockDataStoreUtils)
local Constants = require(script.Parent.MockDataStoreConstants)
local HttpService = game:GetService("HttpService") -- for json encode/decode

local rand = Random.new()

function MockOrderedDataStore:OnUpdate(key, callback)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'OnUpdate' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(callback) ~= "function" then
		error(("bad argument #2 to 'OnUpdate' (function expected, got %s)"):format(typeof(callback)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'OnUpdate' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'OnUpdate' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("OnUpdate")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("OnUpdate request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.OnUpdate}
	)

	if not success then
		error("OnUpdate rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	Utils.logMethod(self, "OnUpdate", key)

	return self.__event.Event:Connect(function(k, v)
		if k == key then
			if Constants.YIELD_TIME_UPDATE_MAX > 0 then
				task.wait(rand:NextNumber(Constants.YIELD_TIME_UPDATE_MIN, Constants.YIELD_TIME_UPDATE_MAX))
			end
			callback(v) -- v was implicitly deep-copied
		end
	end)
end

function MockOrderedDataStore:GetAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'GetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'GetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'GetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
		return self.__data[key]
	end

	Utils.simulateErrorCheck("GetAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn(("GetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s"):format(key))
		end,
		{Enum.DataStoreRequestType.GetAsync}
	)

	if not success then
		error("GetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local retValue = self.__data[key]

	Utils.simulateYield()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "GetAsync", key)

	return retValue
end

function MockOrderedDataStore:IncrementAsync(key, delta)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'IncrementAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif delta ~= nil and type(delta) ~= "number" then
		error(("bad argument #2 to 'IncrementAsync' (number expected, got %s)"):format(typeof(delta)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'IncrementAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'IncrementAsync' (key name exceeds %d character limit)")
			:format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("IncrementAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("IncrementAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("IncrementAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("IncrementAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local old = self.__data[key]

	if old ~= nil and (type(old) ~= "number" or old % 1 ~= 0) then
		Utils.simulateYield()
		error("IncrementAsync rejected with error (cannot increment non-integer value)", 2)
	end

	self.__writeLock[key] = true

	delta = delta and math.floor(delta + .5) or 1

	if old == nil then
		self.__data[key] = delta
		self.__ref[key] = {Key = key, Value = self.__data[key]}
		table.insert(self.__sorted, self.__ref[key])
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	elseif delta ~= 0 then
		self.__data[key] = self.__data[key] + delta
		self.__ref[key].Value = self.__data[key]
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	end

	local retValue = self.__data[key]

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "IncrementAsync", key, retValue, delta)

	return retValue
end

function MockOrderedDataStore:RemoveAsync(key)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'RemoveAsync' (string expected, got %s)"):format(type(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'RemoveAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'RemoveAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("RemoveAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("RemoveAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("RemoveAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("RemoveAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	local value = self.__data[key]

	if value ~= nil then
		self.__data[key] = nil
		self.__ref[key] = nil
		for i,v in pairs(self.__sorted) do
			if v.Key == key then
				table.remove(self.__sorted, i)
				break
			end
		end
		self.__event:Fire(key, nil)
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "RemoveAsync", key, value)

	return value
end

function MockOrderedDataStore:SetAsync(key, value)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'SetAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'SetAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'SetAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	elseif type(value) ~= "number" then
		error(("bad argument #2 to 'SetAsync' (number expected, got %s)"):format(typeof(value)), 2)
	elseif value % 1 ~= 0 then
		error("bad argument #2 to 'SetAsync' (cannot store non-integer values in OrderedDataStore)", 2)
	end

	Utils.simulateErrorCheck("SetAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("SetAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("SetAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("SetAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	self.__writeLock[key] = true

	local old = self.__data[key]

	if old == nil then
		self.__data[key] = value
		self.__ref[key] = {Key = key, Value = value}
		table.insert(self.__sorted, self.__ref[key])
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	elseif old ~= value then
		self.__data[key] = value
		self.__ref[key].Value = value
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	Utils.logMethod(self, "SetAsync", key, self.__data[key])

	return value
end

function MockOrderedDataStore:UpdateAsync(key, transformFunction)
	key = Utils.preprocessKey(key)
	if type(key) ~= "string" then
		error(("bad argument #1 to 'UpdateAsync' (string expected, got %s)"):format(typeof(key)), 2)
	elseif type(transformFunction) ~= "function" then
		error(("bad argument #2 to 'UpdateAsync' (function expected, got %s)"):format(typeof(transformFunction)), 2)
	elseif #key == 0 then
		error("bad argument #1 to 'UpdateAsync' (key name can't be empty)", 2)
	elseif #key > Constants.MAX_LENGTH_KEY then
		error(("bad argument #1 to 'UpdateAsync' (key name exceeds %d character limit)"):format(Constants.MAX_LENGTH_KEY), 2)
	end

	Utils.simulateErrorCheck("UpdateAsync")

	local success

	if self.__writeLock[key] or tick() - (self.__writeCache[key] or 0) < Constants.WRITE_COOLDOWN then
		success = MockDataStoreManager.YieldForWriteLockAndBudget(
			function()
				warn(("UpdateAsync request was throttled, a key can only be written to once every %d seconds. Key = %s")
					:format(Constants.WRITE_COOLDOWN, key))
			end,
			key,
			self.__writeLock,
			self.__writeCache,
			{Enum.DataStoreRequestType.SetIncrementSortedAsync}
		)
	else
		self.__writeLock[key] = true
		local budget
		if self.__getCache[key] and tick() - self.__getCache[key] < Constants.GET_COOLDOWN then
			budget = {Enum.DataStoreRequestType.SetIncrementSortedAsync}
		else
			budget = {Enum.DataStoreRequestType.GetAsync, Enum.DataStoreRequestType.SetIncrementSortedAsync}
		end
		success = MockDataStoreManager.YieldForBudget(
			function()
				warn(("UpdateAsync request was throttled due to lack of budget. Try sending fewer requests. Key = %s")
					:format(key))
			end,
			budget
		)
		self.__writeLock[key] = nil
	end

	if not success then
		error("UpdateAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	local value = transformFunction(self.__data[key])

	if value == nil then -- cancel update after remote call
		Utils.simulateYield()
		return nil -- this is what datastores do even though it should be old value
	end

	if type(value) ~= "number" or value % 1 ~= 0 then
		error("UpdateAsync rejected with error (resulting non-integer value can't be stored in OrderedDataStore)", 2)
	end

	self.__writeLock[key] = true

	local old = self.__data[key]

	if old == nil then
		self.__data[key] = value
		self.__ref[key] = {Key = key, Value = value}
		table.insert(self.__sorted, self.__ref[key])
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	elseif old ~= value then
		self.__data[key] = value
		self.__ref[key].Value = value
		self.__changed = true
		self.__event:Fire(key, self.__data[key])
	end

	Utils.simulateYield()

	self.__writeLock[key] = nil
	self.__writeCache[key] = tick()

	self.__getCache[key] = tick()

	Utils.logMethod(self, "UpdateAsync", key, value)

	return value
end

function MockOrderedDataStore:GetSortedAsync(ascending, pageSize, minValue, maxValue)
	if type(ascending) ~= "boolean" then
		error(("bad argument #1 to 'GetSortedAsync' (boolean expected, got %s)"):format(typeof(ascending)), 2)
	elseif type(pageSize) ~= "number" then
		error(("bad argument #2 to 'GetSortedAsync' (number expected, got %s)"):format(typeof(pageSize)), 2)
	end

	pageSize = math.floor(pageSize + .5)
	if pageSize <= 0 or pageSize > Constants.MAX_PAGE_SIZE then
		error(("bad argument #2 to 'GetSortedAsync' (page size must be an integer above 0 and below or equal to %d)")
			:format(Constants.MAX_PAGE_SIZE), 2)
	end

	if minValue ~= nil then
		if type(minValue) ~= "number" then
			error(("bad argument #3 to 'GetSortedAsync' (number expected, got %s)"):format(typeof(minValue)), 2)
		elseif minValue % 1 ~= 0 then
			error("bad argument #3 to 'GetSortedAsync' (minimum threshold must be an integer)", 2)
		end
	else
		minValue = -math.huge
	end

	if maxValue ~= nil then
		if type(maxValue) ~= "number" then
			error(("bad argument #4 to 'GetSortedAsync' (number expected, got %s)"):format(typeof(maxValue)), 2)
		elseif maxValue % 1 ~= 0 then
			error("bad argument #4 to 'GetSortedAsync' (maximum threshold must be an integer)", 2)
		end
	else
		maxValue = math.huge
	end

	Utils.simulateErrorCheck("GetSortedAsync")

	local success = MockDataStoreManager.YieldForBudget(
		function()
			warn("GetSortedAsync request was throttled due to lack of budget. Try sending fewer requests.")
		end,
		{Enum.DataStoreRequestType.GetSortedAsync}
	)

	if not success then
		error("GetSortedAsync rejected with error (request was throttled, but throttled queue was full)", 2)
	end

	if minValue > maxValue then
		Utils.simulateYield()
		error("GetSortedAsync rejected with error (minimum threshold is higher than maximum threshold)", 2)
	end

	if self.__changed then
		table.sort(self.__sorted, function(a,b) return a.Value < b.Value end)
		self.__changed = false
	end

	local results = {}

	if ascending then
		local i = 1
		while self.__sorted[i] and self.__sorted[i].Value < minValue do
			i = i + 1
		end
		while self.__sorted[i] and self.__sorted[i].Value <= maxValue do
			table.insert(results, {key = self.__sorted[i].Key, value = self.__sorted[i].Value})
			i = i + 1
		end
	else
		local i = #self.__sorted
		while i > 0 and self.__sorted[i].Value > maxValue do
			i = i - 1
		end
		while i > 0 and self.__sorted[i].Value >= minValue do
			table.insert(results, {key = self.__sorted[i].Key, value = self.__sorted[i].Value})
			i = i - 1
		end
	end

	Utils.simulateYield()

	Utils.logMethod(self, "GetSortedAsync")

	return setmetatable({
		__datastore = self;
		__currentPage = 1;
		__pageSize = pageSize;
		__results = results;
		IsFinished = (#results <= pageSize);
	}, MockDataStorePages)
end

function MockOrderedDataStore:ExportToJSON()
	return HttpService:JSONEncode(self.__data)
end

function MockOrderedDataStore:ImportFromJSON(json, verbose)
	local content
	if type(json) == "string" then
		local parsed, value = pcall(function() return HttpService:JSONDecode(json) end)
		if not parsed then
			error("bad argument #1 to 'ImportFromJSON' (string is not valid json)", 2)
		end
		content = value
	elseif type(json) == "table" then
		content = json -- No need to deepcopy, OrderedDataStore only contains numbers which are passed by value
	else
		error(("bad argument #1 to 'ImportFromJSON' (string or table expected, got %s)"):format(typeof(json)), 2)
	end

	if verbose ~= nil and type(verbose) ~= "boolean" then
		error(("bad argument #2 to 'ImportFromJSON' (boolean expected, got %s)"):format(typeof(verbose)), 2)
	end

	Utils.importPairsFromTable(
		content,
		self.__data,
		MockDataStoreManager.GetDataInterface(self.__data),
		(verbose == false and function() end or warn),
		"ImportFromJSON",
		("OrderedDataStore > %s > %s"):format(self.__name, self.__scope),
		true
	)
end

return MockOrderedDataStore
  -  Editar
  04:54:13.851    -  Editar
  04:54:13.852  ----- [2573] ServerScriptService.FFlags -----  -  Editar
  04:54:13.852  -- !strict

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Functions = require(Library.Functions)
local Signal = require(Library.Signal)
local Network = require(ServerLibrary.Network)
local Datastore = require(ServerLibrary.Datastore)

local MessagingService = game:GetService("MessagingService");
local m_SharedFFlags = require(Modules.FFlags);
local m_HTTPUtil = require(script.HTTPUtil);
local table1 = {
	Options = m_SharedFFlags.Options,
	Keys = m_SharedFFlags.Keys
};
local u1 = -2;
local u2 = {};
local u3 = {};
local function sendToDiscordBot(p1) -- Line: 52
	--[[
		Upvalues:
			[1] = m_HTTPUtil
	--]]
	m_HTTPUtil.HttpRequest("POST", "commit_fflags", {}, p1);
end
function table1.Get(p2, p3) -- Line: 56
	--[[
		Upvalues:
			[1] = table1
			[2] = u2
	--]]
	if typeof(p2) ~= "string" then
		error(string.format("Key must be string (was '%s')", (typeof(p2))));
	end
	local v1 = table1.Options[p2];
	if not v1 then
		error(string.format("Missing key: %s", p2));
	end
	local v2 = (p3 or u2)[p2];
	if v2 == nil and not v1.Nullable then
		v2 = v1.Default;
	end
	return v2;
end
function table1.Set(p4, p5) -- Line: 72
	--[[
		Upvalues:
			[1] = table1
			[2] = u2
	--]]
	if typeof(p4) ~= "string" then
		error(string.format("Key must be string (was '%s')", (typeof(p4))));
	end
	local v3 = table1.Options[p4];
	if not v3 then
		error(string.format("Missing key: %s", p4));
	end
	if v3.Nullable then
		assert(p5 == nil and true or typeof(p5) == v3.Type);
	else
		assert(typeof(p5) == v3.Type);
		if p5 == v3.Default then
			p5 = nil;
		end
	end
	if v3.Type == "number" and p5 and v3.Min then
		assert(v3.Min <= p5);
	end
	if v3.Type == "number" and p5 and v3.Max then
		assert(p5 <= v3.Max);
	end
	u2[p4] = p5;
end
local table2 = {};
function table1.CanBypass(p6) -- Line: 98
	--[[
		Upvalues:
			[1] = table2
	--]]
	assert(typeof(p6) == "Instance" and p6:IsA("Player") or false);
	local v4 = table2[p6];
	if v4 ~= nil then
		return v4;
	end
	local bool1 = false;
	pcall(function() -- Line: 105
		--[[
			Upvalues:
				[1] = p6
				[2] = bool1
				[3] = table2
		--]]
		--if p6.UserId == 19717956 or p6.UserId == 653248807 or p6.UserId == 660900011 then
		--	bool1 = true;
		--end
		--if p6.UserId == 2882755487 or p6.UserId == 2213470865 or p6.UserId == 2878290231 or p6.UserId == 13365322 or p6.UserId == 1210210 or p6.UserId == 3687735502 or p6.UserId == 3983340648 then
		--	bool1 = true;
		--end
		if p6.UserId == 4437812925 then
			bool1 = true;
		end
		table2[p6] = bool1;
	end);
	return bool1;
end
function grabAllOptions() -- Line: 121
	--[[
		Upvalues:
			[1] = table1
	--]]
	local table3 = {};
	for key1, val1 in pairs(table1.Options) do
		local v15 = table1.Get(key1);
		if not val1.Nullable and v15 == val1.Default then continue end
		table3[key1] = v15;
	end
	return table3;
end
function setData(p7, p8, p9, p10) -- Line: 132
	--[[
		Upvalues:
			[1] = table1
			[2] = u2
			[3] = u3
			[4] = m_Library
			[5] = u1
			[6] = MessagingService
			[7] = m_HTTPUtil
	--]]
	local table4 = {
		Changes = {},
		Developer = p10 and p10.Name or nil,
		ExperienceID = game.GameId
	};
	for v5, v6 in table1.Options do
		local v16 = table1.Get(v5, u2);
		local v17 = table1.Get(v5, u3);
		if v17 == v16 then continue end
		table4.Changes[v5] = {
			Name = v6.Name,
			Type = v6.Type,
			OldValue = v17,
			UpdatedValue = v16,
			Important = v6.Important or false
		};
	end
	p7 = Functions.DeepCopyUnsafe(p7);
	local v7 = Functions.DeepCopyUnsafe(p7);
	u3 = Functions.DeepCopyUnsafe(p7);
	u2 = v7;
	u1 = p8;
	task.spawn(function() -- Line: 155
		--[[
			Upvalues:
				[1] = m_Library
				[2] = p7
		--]]
		Signal.Fire("FFlags Changed", Functions.DeepCopyUnsafe(p7));
	end);
	task.spawn(function() -- Line: 158
		--[[
			Upvalues:
				[1] = m_Library
				[2] = p7
		--]]
		Network.FireAll("FFlags Changed", p7);
	end);
	if p9 then
		task.spawn(function() -- Line: 163
			--[[
				Upvalues:
					[1] = p7
					[2] = p8
					[3] = MessagingService
			--]]
			local table5 = {
				Data = p7,
				Version = p8
			};
			MessagingService:PublishAsync("FFlags/Updated", table5);
		end);
		task.spawn(function() -- Line: 173
			--[[
				Upvalues:
					[1] = table4
					[2] = m_HTTPUtil
			--]]
			m_HTTPUtil.HttpRequest("POST", "commit_fflags", {}, table4);
		end);
	end
end
function trySetData(p11, p12, p13, p14) -- Line: 179
	--[[
		Upvalues:
			[1] = u1
	--]]
	if p12 < u1 then
	--if p12 < u1 then
		return false;
	end
	setData(p11, p12, p13, p14);
	return true;
end
function getVersion(p15) -- Line: 187
	if p15 then
		local t_Version = p15:GetMetadata().Version;
		if t_Version then
			return t_Version;
		end
	end
	return -1;
end
function table1.Commit(p16) -- Line: 198
	--[[
		Upvalues:
			[1] = m_Library
			[2] = u2
			[3] = u3
			[4] = u1
	--]]
	if Functions.DeepEqualsUnsafe(u2, u3) then
		return true;
	end
	local bool2 = false;
	local v8, v9, v10 = Datastore.Update("FFlags", "v1", function(p19, p20) -- Line: 208
		--[[
			Upvalues:
				[1] = m_Library
				[2] = u2
				[3] = u3
				[4] = bool2
				[5] = u1
		--]]
		local v19 = p19 or {};
		local Version = getVersion(p20);
		if trySetData(v19, Version) then
			return nil;
		end
		if Functions.DeepEqualsUnsafe(v19, u2) then
			u3 = Functions.DeepCopyUnsafe(u2);
			return nil;
		end
		bool2 = true;
		local table6 = {Version = u1 + 1};
		return Functions.DeepCopyUnsafe(u2), nil, table6;
	end);
	if not bool2 then
		return true;
	end
	if v8 then
		local v18 = v9 or {};
		local Version2 = getVersion(v10);
		trySetData(v18, Version2, true, p16);
	end
	return v8;
end
function table1.Pull() -- Line: 240
	--[[
		Upvalues:
			[1] = m_Library
	--]]
	local v11, v12, v13 = Datastore.Get("FFlags", "v1");
	if not v12 then
		return false;
	end
	local v14 = v11 or {};
	local Version3 = getVersion(v13);
	trySetData(v14, Version3);
	return true;
end 
task.spawn(function() -- Line: 253
	--[[
		Upvalues:
			[1] = table1
	--]]
	while not table1.Pull() do
		task.wait(math.random() * 15 + 15);
	end
	while true do
		task.wait(math.random() * 600 + 300);
		table1.Pull();
	end
end);
task.spawn(function() -- Line: 265
	--[[
		Upvalues:
			[1] = MessagingService
	--]]
	MessagingService:SubscribeAsync("FFlags/Updated", function(p18) -- Line: 266
		local t_Data = p18.Data;
		assert(typeof(t_Data) == "table");
		local t_Data2 = t_Data.Data;
		local t_Version2 = t_Data.Version;
		assert(typeof(t_Data2) == "table");
		assert(typeof(t_Version2) == "number");
		trySetData(t_Data2, t_Version2);
	end);
end);
--game.Players.PlayerAdded:Connect(function(p17) -- Line: 282
Signal.Fired("Player Added"):Connect(function(p17)
	--[[
		Upvalues:
			[1] = m_Library
			[2] = u3
	--]]
	_G.HasLoaded(p17)
	local u4 = Functions.DeepCopyUnsafe(u3);
	task.spawn(function() -- Line: 284
		--[[
			Upvalues:
				[1] = m_Library
				[2] = p17
				[3] = u4
		--]]
		Network.Fire("FFlags Changed", p17, u4);
	end);
end);
return table1;
  -  Editar
  04:54:13.852    -  Editar
  04:54:13.852  ----- [2574] ServerScriptService.FFlags.HTTPUtil -----  -  Editar
  04:54:13.852  -- !strict

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Functions = require(Library.Functions)

local RunService = game:GetService("RunService");
local HttpService = game:GetService("HttpService");
local _ = require(script:WaitForChild("Encryption"));
local m_Authentication = require(script:WaitForChild("Authentication"));
local table1 = {
	LOCAL_TEST = false,
	LOCAL_TEST_URL = "http://127.0.0.1:3000/"
};
if table1.LOCAL_TEST and not RunService:IsStudio() then
	table1.LOCAL_TEST = false;
end
function decodeJson(p1) -- Line: 41
	--[[
		Upvalues:
			[1] = HttpService
	--]]
	if p1 then
		local success, pcall_ret2 = pcall(function() -- Line: 43
			--[[
				Upvalues:
					[1] = HttpService
					[2] = p1
			--]]
			return HttpService:JSONDecode(p1);
		end);
		if success then
			if typeof(pcall_ret2) == "table" then
				return true, pcall_ret2;
			end
			return false, nil, "Invalid JSON Body";
		end
		return false, nil, "Malformed JSON Body";
	end
	return false, nil, "No JSON Body";
end
function decodeResponse(p2) -- Line: 71
	local function formatResponse(p7) -- Line: 73
		--[[
			Upvalues:
				[1] = p2
		--]]
		if p7 then
			return string.format("%d %s: %s", p2.StatusCode, p2.StatusMessage, p7);
		end
		return string.format("%d %s", p2.StatusCode, p2.StatusMessage);
	end
	if p2.StatusCode == 405 then
		local decodeJson_ret1_2, decodeJson_ret2_2, decodeJson_ret3_2 = decodeJson(p2.Body);
		if decodeJson_ret1_2 then
			if decodeJson_ret2_2.err ~= nil then
				if typeof(decodeJson_ret2_2.err) == "string" then
					return false, nil, decodeJson_ret2_2.err;
				end
				return false, nil, formatResponse("Malformed JSON Body Error");
			end
			return false, nil, formatResponse("No JSON Body Error");
		end
		return false, nil, formatResponse(decodeJson_ret3_2);
	end
	if p2.StatusCode == 400 then
		return false, nil, formatResponse();
	end
	if p2.StatusCode == 401 then
		return false, nil, formatResponse();
	end
	if p2.StatusCode == 200 then
		local decodeJson_ret1, decodeJson_ret2, decodeJson_ret3 = decodeJson(p2.Body);
		if decodeJson_ret1 then
			return true, decodeJson_ret2;
		end
		return false, nil, formatResponse(decodeJson_ret3);
	end
	return false, nil, formatResponse();
end
local table2 = {
	GET = true,
	POST = true
};
function table1.HttpRequest(p3, p4, p5, p6) -- Line: 125
	--[[
		Upvalues:
			[1] = table2
			[2] = m_Authentication
			[3] = HttpService
			[4] = table1
			[5] = m_Library
	--]]
	assert(table2[p3]);
	local table3 = {};
	if p5 then
		for key1, val1 in pairs(p5) do
			assert(typeof(key1) == "string");
			assert(typeof(val1) == "string" and true or typeof(val1) == "number" and true or typeof(val1) == "boolean");
			table3[key1] = tostring(val1);
		end
	end
	local v2 = p6 and table.clone(p6) or {};
	local AuthParameters = m_Authentication.getAuthParameters();
	local table_clone_ret = table.clone(AuthParameters);
	if p3 == "GET" or p5 and next(p5) then
		for key2, val2 in pairs(table3) do
			table_clone_ret[key2] = val2;
		end
		for key3, val3 in pairs(AuthParameters) do
			table3[key3] = tostring(val3);
		end
	end
	local str1 = nil;
	local JSONEncode_ret = nil;
	if p3 == "POST" then
		for key4, val4 in pairs(v2) do
			assert(typeof(key4) == "string");
			if typeof(val4) ~= "string" and typeof(val4) ~= "number" and typeof(val4) ~= "boolean" then continue end
			table_clone_ret[key4] = tostring(val4);
		end
		for key5, val5 in pairs(AuthParameters) do
			v2[key5] = tostring(val5);
		end
		str1 = "application/json";
		JSONEncode_ret = HttpService:JSONEncode(v2);
	end
	local v3 = table1.LOCAL_TEST and table1.LOCAL_TEST_URL or m_Authentication.API_URL;
	local v4 = v3 .. p4 .. Functions.BuildQueryString(table3);
	local table4 = {
		Url = v4,
		Method = p3,
		Headers = {Authorization = m_Authentication.EncodeAuthenticationString(table_clone_ret)}
	};
	if str1 then
		table4.Headers["Content-Type"] = str1;
	end
	if JSONEncode_ret then
		table4.Body = JSONEncode_ret;
	end
	local success2, pcall_ret2_2 = pcall(function() -- Line: 205
		--[[
			Upvalues:
				[1] = HttpService
				[2] = table4
		--]]
		return HttpService:RequestAsync(table4);
	end);
	local v5;
	if success2 then
		v5 = pcall_ret2_2;
	else
		local table5 = {
			Success = false,
			StatusCode = 400,
			StatusMessage = tostring(pcall_ret2_2),
			Headers = {}
		};
		v5 = table5;
	end
	local table6 = {};
	if v5.Body then
		local JSONDecode_ret = HttpService:JSONDecode(table6);
		local _ = typeof(JSONDecode_ret) == "table";
	end
	return decodeResponse(v5);
end
return table1;
  -  Editar
  04:54:13.852    -  Editar
  04:54:13.852  ----- [2575] ServerScriptService.FFlags.HTTPUtil.Encryption -----  -  Editar
  04:54:13.853  --[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

TG_Ftc7TTb74vanBj here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked to port it to Roblox in a way that doesn't overcomplicate it with support of unreachable
cases. Then, howmanysmall did some final optimizations that really squeeze out all the performance possible.
It's gotten stupid fast, thanks to her!

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {};
	[256] = sha2_H_hi;
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {};
	[512] = sha2_H_lo;
}, {
	[384] = {};
	[512] = sha2_H_hi;
}

local md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}
local md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3)) + bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10)) + W[j - 7] + W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7)) + bit32_band(e, f) + bit32_band(-1 - e, g) + h + K[j] + W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z + bit32_band(d, c) + bit32_band(a, bit32_bxor(d, c)) + bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 34, 160, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31), bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24), bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)) % 4294967296 +
				bit32_bxor(bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13), bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29), bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)) % 4294967296 +
				W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31), bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24), bit32_rshift(a_hi, 7)) +
				bit32_bxor(bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13), bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29), bit32_rshift(b_hi, 6)) +
				W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18), bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14), bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)) % 4294967296 +
				(bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 +
				h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18), bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14), bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)) +
				bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) +
				h_hi + K_hi[j] + W[jj - 1] +
				(tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo + (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296 + bit32_bxor(bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4), bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2), bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)) % 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi + (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi))) + bit32_bxor(bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4), bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2), bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)) + (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 25
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 27
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 28
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 26
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi = lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5], lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10], lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15], lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20], lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)), bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)), bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)), bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)), bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)), bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)), bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)), bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)), bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)), bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)), bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)), bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)), bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)), bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)), bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)), bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)), bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)), bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)), bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)), bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)), bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)), bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)), bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)), bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)), bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)), bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)), bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)), bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)), bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)), bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)), bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)), bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)), bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)), bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)), bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)), bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)), bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)), bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)), bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)), bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)), bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0, 0, 1
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1, 2)
				local _, delta = mul(R, mul(R, R, 1, 4), -1, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1, 2)
					_, delta = mul(R, R, -1, 2)
					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor
					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				local tailLength = #tail
				if tail ~= "" and tailLength + partLength >= 64 then
					offs = 64 - tailLength
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)

	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi = 0, "", table.pack(table.unpack(sha2_H_ext512_lo[width])), not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296) .. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)

	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)
				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)
				tail = nil

				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(lanes_lo, lanes_hi, tail .. string.sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail .. (#tail + 1 == block_size_in_bytes and string.char(gap_start + 128) or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128")
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296) .. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(table.concat(qwords, "", 1, qwords_qty), "(..)(..)(..)(..)(..)(..)(..)(..)", "%8%7%6%5%4%3%2%1"), qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end

			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62, ["-"] = 62, [62] = "+";
	["/"] = 63, ["_"] = 63, [63] = "/";
	["="] = -1, ["."] = -1, [-1] = "=";
}

local symbol_index = 0
for j, pair in ipairs{"AZ", "az", "09"} do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local stringLength = #binary_string
	local result = table.create(math.ceil(stringLength / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. '\0', 1, -1)
		length = length + 1
		result[length] =
			base64_symbols[math.floor(c1 / 4)] ..
			base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)] ..
			base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1] ..
			base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
--local function pad_and_xor(str, result_length, byte_for_xor)
--	return string.gsub(str, ".", function(c)
--		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
--	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
--end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	local KeyLength = #key
	if KeyLength > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		KeyLength = #key
	end

	local append = hash_func()(string.gsub(key, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), 0x36))
	end) .. string.rep("6", block_size - KeyLength)) -- 6 = string.char(0x36)

	local result

	local function partial(message_part)
		if not message_part then
			result = result or hash_func(
				string.gsub(key, ".", function(c)
					return string.char(bit32_bxor(string.byte(c), 0x5c))
				end) .. string.rep("\\", block_size - KeyLength) -- \ = string.char(0x5c)
					.. (string.gsub(append(), "%x%x", HexToBinFunction))
			)

			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end;

	sha256 = function(message)
		return sha256ext(256, message)
	end;

	sha512_224 = function(message)
		return sha512ext(224, message)
	end;

	sha512_256 = function(message)
		return sha512ext(256, message)
	end;

	sha384 = function(message)
		return sha512ext(384, message)
	end;

	sha512 = function(message)
		return sha512ext(512, message)
	end;

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end;

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end;

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end;

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end;

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end;

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end;

	-- misc utilities:
	hmac = hmac; -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin; -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin; -- converts base64 representation to binary string
	bin_to_base64 = bin2base64; -- converts binary string to base64 representation
	base64_encode = Base64.Encode;
	base64_decode = Base64.Decode;
}

block_size_for_HMAC = {
	[sha.md5] = 64;
	[sha.sha1] = 64;
	[sha.sha224] = 64;
	[sha.sha256] = 64;
	[sha.sha512_224] = 128;
	[sha.sha512_256] = 128;
	[sha.sha384] = 128;
	[sha.sha512] = 128;
	[sha.sha3_224] = (1600 - 2 * 224) / 8;
	[sha.sha3_256] = (1600 - 2 * 256) / 8;
	[sha.sha3_384] = (1600 - 2 * 384) / 8;
	[sha.sha3_512] = (1600 - 2 * 512) / 8;
}

return sha  -  Editar
  04:54:13.853    -  Editar
  04:54:13.853  ----- [2576] ServerScriptService.FFlags.HTTPUtil.Encryption.Base64 -----  -  Editar
  04:54:13.853  -- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
			))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
			))
	end

	return table.concat(NewOutput)
end

return Base64  -  Editar
  04:54:13.853    -  Editar
  04:54:13.853  ----- [2577] ServerScriptService.FFlags.HTTPUtil.Encryption.HashLib.spec -----  -  Editar
  04:54:13.853  local function describe(phrase, callback) end
local function it(phrase, callback) end
local function expect(value) end

return function()
	local HashLib = require(script.Parent)
	local sha256 = HashLib.sha256

	describe("HashLib.sha256", function()
		it("should properly encode strings", function()
			expect(sha256("abc").to.equal("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"))
			expect(sha256("The quick brown fox jumps over the lazy dog").to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592"))
			expect(sha256("123456").to.equal("8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92"))
		end)

		it("should create a private closure that works", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)

		it("should allow the private closure to work if called twice", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			AppendNextChunk()
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)
	end)
end  -  Editar
  04:54:13.853    -  Editar
  04:54:13.853  ----- [2578] ServerScriptService.FFlags.HTTPUtil.Authentication -----  -  Editar
  04:54:13.854  local Authentication = {}
local Encrypt = require(script.Parent:WaitForChild("Encryption"))

-- ======== AUTHENTICATION SPECIFICATION ========
-- Write requests require a few things.  First, each request must contain the
-- following fields: "TS" (timestamp), "baseURL" and "PBLC" (the public access key).
-- each request requires an 'Authentication' header, which can be built as follows:
-- MAKE_AUTH_STRING(query):
--   assert(query contains TS, baseURL, PBLC)
--   let alph = empty string
--   for key, value in alphabeticalSorted(query):
--     append (key + "=" + value + "&") to alph
--   remove trailing '&' from alph
--   let signingKey = KEY_PUBLIC + KEY_PRIVATE
--   let encrypted = HMAC_SHA256(key=signingKey, message=alph)
--   let finalAuthenticationString = "OAuth " + encrypted
-- 
-- The function Authentication.EncodeAuthenticationString implements
-- the pseudocode listed above.

-- ======== PUBLIC AND PRIVATE WRITE KEYS ========
-- protect these bad boys at all cost.  it's okay if the public key gets out, but
-- if the private key is released, anybody will be able to write data.  there is
-- an entirely different set of keys used for reading, which should never be
-- placed inside of a ROBLOX script for security purposes.  if these keys are released,
-- our data is still protected.  worst case scenario, somebody can write some junk
-- data that we can delete later.  but again, that can only happen if this source
-- code is leaked, and some neferious guy actually knows what to do w/ these keys.
-- If these are discovered, we can easily swap them out for a new set of keys.

Authentication.API_URL           =  script:WaitForChild("API_URL").Value;
Authentication.API_KEY_PUBLIC    = script:WaitForChild("API_KEY_PUBLIC").Value;
Authentication.API_KEY_PRIVATE   = script:WaitForChild("API_KEY_PRIVATE").Value;

function Authentication.getAuthParameters()  
	local auth = {
		baseURL = Authentication.API_URL,
		TS = tostring((math.floor((os.time())))),
		PBLC = Authentication.API_KEY_PUBLIC
	}

	return auth
end

function Authentication.EncodeAuthenticationString(queryParams)

	local alph = {}
	for k, v in pairs(queryParams) do
		if typeof(k) == "string" and typeof(v) == "string" then
			table.insert(alph, {k, v})
		end	
	end

	table.sort(alph, function(a, b)
		return a[1] < b[1]
	end)

	local sigBase = ""
	for _, tuple in ipairs(alph) do
		sigBase = sigBase .. tuple[1] .. "=" .. tuple[2] .. "&"
	end
	sigBase = sigBase:sub(1, sigBase:len() - 1)

	local signingKey = Authentication.API_KEY_PUBLIC .. Authentication.API_KEY_PRIVATE
	local encrypted = Encrypt.hmac(Encrypt.sha256, signingKey, sigBase)

	local authString = "OAuth " .. encrypted
	return authString

end

return Authentication
  -  Editar
  04:54:13.854    -  Editar
  04:54:13.854  ----- [2579] ServerStorage.__STORAGE.Unused Modules.Save -----  -  Editar
  04:54:13.854  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Save
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local Save = {};
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Players = game:GetService("Players");
local _ = game:GetService("ReplicatedFirst");
local Library = ReplicatedStorage:WaitForChild("Library");
local Modules = Library:WaitForChild("Modules");
local Client = Library:WaitForChild("Client");
local m_Signal = require(Library.Signal);
local m_Network = require(Client.Network);
local m_Settings = require(Client.Settings);
local m_Mutex = require(Modules.Mutex);
local test = require(Modules.DefaultStats);
local table2 = {};
local table3 = {};

Players.PlayerRemoving:Connect(function(p1) -- Line: 163
	--[[
		Upvalues:
			[1] = table3
	--]]
	local v1 = table3[p1];
	if v1 then
		table3[p1] = nil;
		--v1:destroy();
	end
end);
function Save.GetSaves() -- Line: 171
	--[[
		Upvalues:
			[1] = table2
	--]]
	return table2;
end

function Save.Get(p2,p3) --Save.Get(p2, p3) -- Line: 175
	--warn("OK",p2,p3)
	local v2 = p3 == nil and true or p3 == true;
	local u1 = p2 or Players.LocalPlayer;
		if not u1 or not u1.Parent then
		--warn("1")
		return nil;
	end
	if v2 then
		--warn("2",table2[u1])
		local test = table2[u1];
		--warn(test,"| SAVE DEBUG |",table2)
		return test  
	end
	local v3 = table3[u1];
	if not v3 then
		v3 = {}; --m_Mutex.new();
		table3[u1] = v3;
	end
	--[[return v3:run(function() -- Line: 202
		if not u1 or not u1.Parent then
			return nil;
		end
		if not Update(u1) and u1 and u1 == Players.LocalPlayer then
			repeat
				wait(1);
			until not u1 or not u1.Parent or Update(u1);
		end
		if not u1 then
			return nil;
		end
		return table2[u1];
	end);]]--
	--return function()
	coroutine.wrap(function()
		if not u1 or not u1.Parent then
			--warn("3")
			return nil;
		end
		if not Update(u1) and u1 and u1 == Players.LocalPlayer then
			repeat
				wait(1);
			until not u1 or not u1.Parent or Update(u1);
		end
		if not u1 then
			--warn("4")
			return nil;
		end
		--warn("5")
		return table2[u1];
	--end
	end)()
end
function Update(p4) -- Line: 222
	
	--[[
		Upvalues:
			[1] = Players
			[2] = m_Network
			[3] = m_Settings
			[4] = table2
			[5] = m_Signal
	--]]
	assert(typeof(p4) == "Instance" and p4:IsA("Player") or false);
	local t_UserId = p4.UserId;
	local v4 = p4 == Players.LocalPlayer;
	--warn('1')
	local success, pcall_ret2 = pcall(function() -- Line: 230
		return m_Network.Invoke("Get Stats", p4, v4);
	end);
	--warn('2')
	if not success then
		warn(string.format("[SAVE] Player '%d' save failed to load: '%s'", t_UserId, tostring(pcall_ret2)));
		return false;
	end
	if not p4 then
		warn(string.format("[SAVE] Player '%d' logged out while loading save", t_UserId));
		return false;
	end
	if not pcall_ret2 then
		return false;
	end
	if typeof(pcall_ret2) ~= "table" then
		warn(string.format("[SAVE] Player '%d' save was invalid type: '%s'", t_UserId, (typeof(pcall_ret2))));
		if v4 then
			p4.Character = nil;
			p4:Kick("Something went wrong. Please rejoin!");
		end
		return false;
	end
	for key2, val2 in pairs(pcall_ret2) do
		if typeof(val2) ~= "table" or m_Settings.StatsNoFreeze[key2] then continue end
		table.freeze(val2);
	end
	local v5 = table2[p4];
	if v5 then
		for key3, val3 in pairs(pcall_ret2) do
			v5[key3] = val3;
		end
		for key4, _ in pairs(v5) do
			v5[key4] = pcall_ret2[key4];
		end
	else
		table2[p4] = pcall_ret2;
	end
	if v4 then
		m_Signal.Fire("Loaded Stats", p4);
	else
		m_Signal.Fire("Loaded Other Stats", p4);
	end
	return true;
end
function ProcessChanges(p5,p6) --(p5, p6) -- Line: 296
	--[[
		Upvalues:
			[1] = table2
			[2] = m_Settings
			[3] = Players
			[4] = m_Signal
	--]]
	assert(typeof(p6) == "table");
	assert(typeof(p5) == "Instance" and p5:IsA("Player") or false);
	local v6 = table2[p5];
	if v6 then
		for key5, val5 in pairs(p6) do
			if typeof(val5) == "table" and not m_Settings.StatsNoFreeze[key5] then
				table.freeze(val5);
			end
			v6[key5] = val5;
		end
		local v8 = p5 == Players.LocalPlayer;
		for key6, _ in pairs(p6) do
			if v8 then
				m_Signal.Fire("Stat Changed", key6);
				continue;
			end
			m_Signal.Fire("Other Stat Changed", p5, key6);
		end
		if v8 then
			m_Signal.Fire("Stats Changed");
			return;
		end
		m_Signal.Fire("Other Stats Changed", p5);
	end
end
function Save.FetchPlayer(p7) -- Line: 327
	--[[
		Upvalues:
			[1] = table3
			[2] = m_Mutex
			[3] = table2
	--]]
	assert(typeof(p7) == "Instance" and p7:IsA("Player") or false);
	local v7 = table3[p7];
	if not v7 then
		v7 = {}; --m_Mutex.new();
		table3[p7] = v7;
	end
	--[[v7:run(function() -- Line: 334
		while p7 and not table2[p7] do
			Update(p7);
			if not p7 or table2[p7] then break end
			wait(0.5);
		end
	end);]]--
	coroutine.wrap(function()
		while p7 and not table2[p7] do
			Update(p7);
			if not p7 or table2[p7] then break end
			wait(0.5);
		end
	end)()
end
m_Network.Fired("New Stats"):Connect(function(p8, p9) -- Line: 345
	--[[
		Upvalues:
			[1] = Players
	--]]
	ProcessChanges(p9 or Players.LocalPlayer, p8);
end);
game.Players.PlayerAdded:Connect(function(p10) -- Line: 350
	--[[
		Upvalues:
			[1] = Save
	--]]
	task.spawn(Save.FetchPlayer, p10);
end);
game.Players.PlayerRemoving:Connect(function(p11) -- Line: 353
	--[[
		Upvalues:
			[1] = table2
			[2] = m_Signal
	--]]
	if table2[p11] then
		task.delay(5, function() -- Line: 358
			--[[
				Upvalues:
					[1] = table2
					[2] = p11
					[3] = m_Signal
			--]]
			table2[p11] = nil;
			m_Signal.Fire("Stats Removed", p11);
		end);
	end
end);
for _, val1 in ipairs(Players:GetPlayers()) do
	task.spawn(Save.FetchPlayer, val1);
end
return Save;
  -  Editar
  04:54:13.855    -  Editar
  04:54:13.855  ----- [2580] ServerStorage.__STORAGE.Unused Modules.GUI2 -----  -  Editar
  04:54:13.855  
--[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.GUI2
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local v1 = {};
local u2 = nil;
local u3 = game.Players.LocalPlayer.PlayerGui;
local Functions = require(game.ReplicatedStorage.Library.Functions)
function v1.ToggleMouseLock(p1)
	p1 = p1 ~= nil and p1 or false;
	if not u2 then
		local v2 = Instance.new("ScreenGui");
		v2.Name = "LockMouse";
		v2.Parent = u3;
		u2 = Instance.new("TextButton");
		u2.Visible = false;
		u2.BackgroundTransparency = 1;
		u2.Text = "";
		u2.BorderSizePixel = 0;
		u2.Size = UDim2.new(0, 1, 0, 1);
		u2.Parent = v2;
	end;
	u2.Modal = p1;
	u2.Visible = p1;
end;
function v1.ToggleCursor(p2)
	p2 = p2 ~= nil and p2 or false;
	game:GetService("UserInputService").MouseIconEnabled = p2;
end;
local u4 = { "ScreenGui", "Frame", "ScrollingFrame", "ViewportFrame", "ImageLabel", "TextButton", "ImageButton", "TextBox", "TextLabel", "UIListLayout", "UIGridLayout", "UIAspectRatioConstraint" };
local u5 = { "Freecam", "BubbleChat", "Chat" };
local function u6(p3, p4)
	local function v3(p5, p6)
		local v4 = 0;
		local v5 = p5;
		local v6 = 0;
		local v7 = p6;
		while true do
			v5 = v5.Parent;
			v4 = v4 + 1;
			if v5.Parent == u3 then
				break;
			end;		
		end;
		while true do
			v7 = v7.Parent;
			v6 = v6 + 1;
			if v7.Parent == u3 then
				break;
			end;		
		end;
		if v4 == v6 then
			for v8, v9 in ipairs(u4) do
				if v9 == p5.ClassName then
					v4 = v8;
				elseif v9 == p6.ClassName then
					v6 = v8;
				end;
			end;
		end;
		return v4 < v6 and p5 or p6;
	end;
	for v10, v11 in ipairs(p3:GetChildren()) do
		if v11.ClassName == "ScreenGui" and not Functions.SearchArray(u5, v11.Name) then
			v1[v11.Name:gsub("%s+", "")] = {
				Gui = v11
			};
			u6(v11, v11);
		elseif v11:IsA("GuiObject") and p4 then
			local v12 = v1[p4.Name:gsub("%s+", "")][v11.Name:gsub("%s+", "")];
			if not v12 or v12 and v3(v11, v12) == v11 then
				v1[p4.Name:gsub("%s+", "")][v11.Name:gsub("%s+", "")] = v11;
			end;
			u6(v11, p4);
		end;
	end;
end;
u6(u3);
u3.ChildAdded:Connect(function(p7)
	if p7.ClassName == "ScreenGui" and not Functions.SearchArray(u5, p7.Name) then
		v1[p7.Name:gsub("%s+", "")] = {
			Gui = p7
		};
		u6(p7, p7);
	end;
end);
return v1;
  -  Editar
  04:54:13.856    -  Editar
  04:54:13.856  ----- [2581] ServerStorage.__STORAGE.Unused Modules.Player -----  -  Editar
  04:54:13.856  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Player
	===========
	Handy references to player bodyparts & objects such as character, torso, root, camera, etc
	Custom timeout system prevents errors while keeping the functionality of WaitForChild
	===========
	 \\\ Get player instance
		Player.Player(
			playerInstance,			<-- 	    player                                              [defaults to: localPlayer]
		)
	 \\\ Get player chracter
		Player.Character(
			playerInstance,			<-- 	    player                                              [defaults to: localPlayer]
		)
	 
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------|       Top       |--------
local Player = {
	Optional = {},
}

--------|     Setting     |--------

--------|    Reference    |--------
local Players = game:GetService("Players")

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- Returns the Player object associated with the given parameter or the LocalPlayer if none is provided
function Player.Player(playerInstance)
	return playerInstance or Players.LocalPlayer
end

-- Returns the Character of the given player or the LocalPlayer's Character if none is provided
local function getCharacter(playerInstance)
	return Player.Player(playerInstance).Character
end
Player.Optional.Character = getCharacter

-- Returns the Character of the given player or waits for it to be available
function Player.Character(playerInstance)
	local player = Player.Player(playerInstance)
	return player.Character or player.CharacterAdded:Wait()
end

-- Returns the PrimaryPart of the given character if available
local function getPrimaryPart(character)
	return character and character.PrimaryPart
end
Player.Optional.PrimaryPart = getPrimaryPart

-- Returns the PrimaryPart of the given character or waits for it to be available
function Player.PrimaryPart(playerInstance)
	local character = Player.Character(playerInstance)
	local primaryPart = character.PrimaryPart
	if primaryPart then
		return primaryPart
	end
	character:WaitForChild("HumanoidRootPart", math.huge)
	local primaryPart2 = character.PrimaryPart
	assert(primaryPart2, "Character must have a PrimaryPart")
	return primaryPart2
end

-- Returns the Humanoid of the given character if available
local function getHumanoid(character)
	return character and character:FindFirstChildOfClass("Humanoid")
end
Player.Optional.Humanoid = getHumanoid

-- Returns the Humanoid of the given character or waits for it to be available
function Player.Humanoid(playerInstance)
	local character = Player.Character(playerInstance)
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		return humanoid
	end
	character:WaitForChild("Humanoid", math.huge)
	local humanoid2 = character:FindFirstChildOfClass("Humanoid")
	assert(humanoid2, "Character must have a Humanoid")
	return humanoid2
end

-- Returns a part with the given name from the character of the given player
local function getPart(playerInstance, partName)
	local character = Player.Character(playerInstance)
	return character:FindFirstChild(partName)
end
Player.Optional.Part = getPart

-- Returns a part with the given name from the character of the given player or waits for it to be available
function Player.Part(playerInstance, partName)
	local character = Player.Character(playerInstance)
	return character:WaitForChild(partName, math.huge)
end

-- Returns an embedded part with the given name from the character of the given player or nil if not found
local function getEmbeddedPart(playerInstance, partName, embeddedPartName)
	local part = Player.Part(playerInstance, partName)
	return part and part:FindFirstChild(embeddedPartName)
end
Player.Optional.EmbeddedPart = getEmbeddedPart

-- Returns an embedded part with the given name from the character of the given player or waits for it to be available
function Player.EmbeddedPart(playerInstance, partName, embeddedPartName)
	local part = Player.Part(playerInstance, partName)
	return part:WaitForChild(embeddedPartName, math.huge)
end

-- Convenience functions for common parts
function Player.Head(playerInstance)
	return Player.Optional.Part(playerInstance, "Head")
end
function Player.UpperTorso(playerInstance)
	return Player.Optional.Part(playerInstance, "UpperTorso")
end
function Player.LowerTorso(playerInstance)
	return Player.Optional.Part(playerInstance, "LowerTorso")
end
function Player.LeftFoot(playerInstance)
	return Player.Optional.Part(playerInstance, "LeftFoot")
end
-- ... Define the rest of the functions for other parts

-- Convenience function to get the PlayerGui of the given player
function Player.PlayerGui(playerInstance)
	return Player.Player(playerInstance):FindFirstChild("PlayerGui")
end

-- Convenience function to get the Mouse of the given player
function Player.Mouse(playerInstance)
	return Player.Player(playerInstance):GetMouse()
end

-- Convenience function to get the Camera
function Player.Camera()
	return workspace.CurrentCamera
end

-- Convenience function to get the name of the given player
function Player.Name(playerInstance)
	return Player.Player(playerInstance).Name
end

-- Convenience function to get the display name of the given player
function Player.DisplayName(playerInstance)
	return Player.Player(playerInstance).DisplayName
end

-- Returns the Animator or AnimationController of the given Humanoid if available
local function getAnimator(humanoid)
	if humanoid then
		local animator = humanoid:FindFirstChildOfClass("Animator")
		if animator then
			return animator
		end
		local animationController = humanoid:FindFirstChildOfClass("AnimationController")
		if animationController then
			return animationController
		end
		return humanoid
	end
	return nil
end
Player.Optional.Animator = getAnimator

-- Returns the Animator or AnimationController of the given player's Humanoid if available
function Player.Animator(playerInstance)
	local humanoid = Player.Humanoid(playerInstance)
	local animator = humanoid:FindFirstChildOfClass("Animator")
	if animator then
		return animator
	end
	local animationController = humanoid:FindFirstChildOfClass("AnimationController")
	if animationController then
		return animationController
	end
	return humanoid
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return Player  -  Editar
  04:54:13.860    -  Editar
  04:54:13.860  ----- [2582] ServerStorage.__STORAGE.Unused Modules.Dupes.PetCmds -----  -  Editar
  04:54:13.860  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Pets
	===========
	
	===========

	===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Library = ReplicatedStorage:WaitForChild("Library")
local ClientLibrary = Library:WaitForChild("Client")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Shared = require(Library.Shared)
local Signal = require(Library.Signal)
local Directory = require(Library.Directory)
local Functions = require(Library.Functions)
local Variables = require(Library.Variables)
local Audio = require(Library.Audio)
local Save = require(ClientLibrary.Save)
local Network = require(ClientLibrary.Network)
local GUIFX = require(ClientLibrary.GUIFX)
local WorldCmds = require(ClientLibrary.WorldCmds)
local Pets = require(Modules.Pets)
local DefaultStats = require(Modules.DefaultStats)

--------|       Top       |--------
local PetCmds = {}

--------|     Setting     |--------
local WalkSounds = { 6840608566, 6840608533, 6840608598, 6840608504 }

--------|    Reference    |--------
local Assets = ReplicatedStorage:WaitForChild("Assets")
local X = ReplicatedStorage:WaitForChild("X")
local Players = game:GetService("Players")
local debris = workspace:WaitForChild("__DEBRIS")


--------|    Variables    |--------
local LeftistHeap = require(X:WaitForChild("Util").LeftistHeap)
local rng = Random.new()
local Indices = {}
local Pets = {}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function PetCmds.GetIndices(_index, save) 
	local Indice = Indices[_index]
	if Indice then
		return Indice
	end
	
	local pd = {}
	for index, pet in ipairs(save.Pets) do
		pd[pet.uid] = index
		if Pets[pet.uid] then  
			Pets[pet.uid] = _index
		end
	end
	
	Indices[_index] = pd
	return pd
end

function PetCmds.DeleteIndices(_index) 
	if Indices[_index] then
		Indices[_index] = nil
	end
end

function GetIndex(player, save, uid)
	local indices = PetCmds.GetIndices(player, save)
	return indices[uid]
end

function PetCmds.GetFrom(player, save, uid) 
	local _index = PetCmds.GetIndex(player, save, uid)
	if not _index then
		return nil, 0
	end
	assert(_index)
	
	local pets = save.Pets[_index]
	if not pets then
		return nil, 0
	end
	assert(pets)
	
	if uid ~= pets.uid then
		warn("Pet mismatch:", uid, _index, pets and pets.uid or "nil")
		return nil, 0
	end
	
	return pets, _index
end

function PetCmds.Get(uid) 
	debug.profilebegin("PetCmds.Get")
	
	local pet = Pets[uid]
	if pet then
		local save = Save.Get(pet)
		if save then
			local pets, _index = PetCmds.GetFrom(pet, save, uid)
			if pets then
				debug.profileend()
				return pets, pet, _index
			end
		end
		Pets[uid] = nil
	end
	
	for index, val2 in pairs(Save.GetSaves()) do
		local pets, _index = PetCmds.GetFrom(index, val2, uid)
		if pets then	
			Pets[uid] = index
			debug.profileend()
			return pets, index, _index
		end	
	end
	
	debug.profileend()
	return nil, nil, 0
end

Signal.Fired("Stats Removed"):Connect(function(player) 
	PetCmds.DeleteIndices(player)
	for index, _player in pairs(Pets) do
		if _player == player then
			Pets[index] = nil
		end	
	end
end)

function PetCmds.GetEquipped(plr, getData, includeIndex)
	local player
	if not plr then
		player = Players.LocalPlayer
	else
		assert(typeof(plr) == "Instance" and plr:IsA("Player") or false)
		player = plr
	end
	
	debug.profilebegin("PetCmds.GetEquipped")
	
	local Equipped = {}
	local save = Save.Get(player, true)
	if save then
		local pets = Shared.IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped
		
		if includeIndex then
			if getData then
				for index, data in pairs(pets) do
					if data then 
						Equipped[index] = true
					end
				end
			else
				for index, data in pairs(pets) do
					if data then 
						local pd = PetCmds.GetFrom(player, save, index)
						if pd then 
							Equipped[index] = pd
						end
					end
				end
			end
		elseif getData then
			for index, data in pairs(pets) do
				if data then  
					table.insert(Equipped, index)
				end
			end
		else
			for index, data in pairs(pets) do
				if data then 
					local pd = PetCmds.GetFrom(pets, save, index)
					if pd then 
						table.insert(Equipped, pd)
					end	
				end
			end
		end
	end
	debug.profileend()

	return Equipped
end 

function PetCmds.LocalEquipPet(player, uid, equip)  
	local save = Save.Get(player)
	if save then
		local changed = false
		local pets = Shared.IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped
		if equip then
			if not pets[uid] then
				pets[uid] = true
				changed = true
			end
		elseif pets[uid] then
			pets[uid] = nil
			changed = true
		end
		if changed then
			if player == Players.LocalPlayer then
				Signal.Fire("Pet Equips Changed")
				return
			end
			Signal.Fire("Other Pet Equips Changed", player)
		end
	end
end

Network.Fired("Pet Added"):Connect(function(p18, p19) 
	local v6 = Save.Get(p18)
	if not v6 then
		return
	end
	assert(v6)
	local Indices = PetCmds.GetIndices(p18, v6)
	table.insert(v6.Pets, p19)
	local v7 = #v6.Pets
	Indices[p19.uid] = v7
	local v8 = p18 == Players.LocalPlayer
	if v8 then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", p18, "Pets")
	end
	if v8 then
		Signal.Fire("Stats Changed")
		return
	end
	Signal.Fire("Other Stats Changed", p18)
end)


Network.Fired("Pet Removed"):Connect(function(player, uid) 
	local save = Save.Get(player)
	if not save then
		return 
	end
	assert(save)
	local playerPets = PetCmds.GetIndices(player, save)
	local pet = playerPets[uid]
	if not pet then
		return
	end
	assert(pet)
	local _pet = save.Pets[pet]
	if not _pet then
		return
	end
	assert(_pet)
	if uid ~= _pet.uid then 
		return
	end
	table.remove(save.Pets, pet)
	playerPets[uid] = nil
	for index = pet, #save.Pets do
		local __pet = save.Pets[index]
		if __pet then
			playerPets[__pet.uid] = index
		end
	end
	local IsLocalPlayer = player == Players.LocalPlayer
	if IsLocalPlayer then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", player, "Pets")
	end
	if IsLocalPlayer then
		Signal.Fire("Stats Changed")
	else
		Signal.Fire("Other Stats Changed", player)
	end
	PetCmds.LocalEquipPet(player, uid, false)
end)

Network.Fired("Pet Update"):Connect(function(p22, p23) 
	local v13 = Save.Get(p22)
	if not v13 then
		return 
	end
	assert(v13)
	local Index2 = PetCmds.GetIndex(p22, v13, p23.uid)
	if not Index2 then
		return 
	end
	assert(Index2)
	local v14 = v13.Pets[Index2]
	if not v14 then 
		return 
	end
	assert(v14)
	if p23.uid ~= v14.uid then return end
	if Functions.DeepEqualsUnsafe(v14, p23) then return end
	v13.Pets[Index2] = p23
	local v15 = p22 == Players.LocalPlayer
	if v15 then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", p22, "Pets")
	end
	if v15 then
		Signal.Fire("Stats Changed")
		return
	end
	Signal.Fire("Other Stats Changed", p22)
end)
Network.Fired("Pet Equip Changed"):Connect(function(p24, p25, p26)
	PetCmds.LocalEquipPet(p24, p25, p26)
end)
function PetCmds.HasBestEquipped(p27)
	assert(p27 == nil and true or typeof(p27) == "Instance" and p27:IsA("Player") or false)
	debug.profilebegin("PetCmds.HasBestEquipped")
	local v16 = Save.Get(p27)
	if not v16 then
		debug.profileend()
		return false
	end
	assert(v16)
	local Equipped = PetCmds.GetEquipped(p27, true, true)
	local v17 = v16.InfPetsEnabled and #v16.Pets or Shared.GetMaxEquippedSlots(v16)
	local v18 = LeftistHeap.new(Shared.PetOrderBest)
	for _, val4 in ipairs(v16.Pets) do
		if Directory.Pets[val4.id].isGift then
			continue 
		end
		v18.insert(val4)
	end
	local bool2 = true
	for index2 = 1, v17 do
		local v42, v43 = v18.tryPop()
		if not v42 then break end
		if not Equipped[v43.uid] then
			bool2 = false
			break
		end
	end
	debug.profileend()
	return bool2
end
function PetCmds.Match(p28, p29) 
	assert(typeof(p28) == "table")
	if #p29 == 0 then
		return true
	end
	local v19 = Directory.Pets[p28.id]
	if not v19 then
		return false
	end
	local table7 = {}
	if v19.rarity then
		table.insert(table7, v19.rarity)
	end
	if p28.sh then
		table.insert(table7, "Shiny")
	end
	if v19.name then
		table.insert(table7, v19.name)
	end
	if p28.nk then
		table.insert(table7, p28.nk)
	end
	return true
end
function PetCmds.Scaler(p30)  
	local v20 = p30.scaler
	if not v20 then
		v20 = Functions.Scaler()
		p30.scaler = v20
	end
	assert(v20)
	return v20
end
function PetCmds.Spawn(p31, p32, p33) 
	assert(p31)
	assert(p32)
	local v21 = WorldCmds.Get()
	assert(v21)
	local v22 = Directory.Pets[p31.id]
	assert(v22)
	local v23 = p31.g == true
	local v24 = p31.r == true
	local v25 = p31.dm == true
	local v26 = p31.hc == true
	local v27 = p31.sh == true
	local Clone_ret = (v23 and v22.modelGold or v22.model):Clone()
	local table8 = {Clone_ret}
	for _, child5 in ipairs(Clone_ret:GetChildren()) do
		if not child5:IsA("BasePart") then continue end
		table.insert(table8, child5)
	end
	local SpecialMesh = Clone_ret:FindFirstChildOfClass("SpecialMesh")
	assert(SpecialMesh)
	local table9 = {SpecialMesh}
	for _, val6 in ipairs(table8) do
		local SpecialMesh2 = val6:FindFirstChildOfClass("SpecialMesh")
		if not SpecialMesh2 or SpecialMesh2 == SpecialMesh then continue end
		table.insert(table9, SpecialMesh2)
	end
	local center = Clone_ret:WaitForChild("center")
	local bottom = Clone_ret:WaitForChild("bottom")
	local mount = Clone_ret:FindFirstChild("mount")
	Clone_ret:SetAttribute("Owner", p32.Name)
	Clone_ret:SetAttribute("Dir", p31.id)
	Clone_ret:SetAttribute("ID", p31.uid)
	Clone_ret.Name = p31.uid
	local Attribute = SpecialMesh:GetAttribute("OriginalSize")
	if Attribute then
		Clone_ret.Size = Attribute * SpecialMesh.Scale
	end
	Clone_ret.Anchored = true
	for _, val7 in ipairs(table8) do
		val7.Massless = true
		val7.CanCollide = false
		val7.CanQuery = true
		val7.CanTouch = true
		val7.CastShadow = false
		if val7.Material == Enum.Material.SmoothPlastic then
			val7.Material = Enum.Material.Plastic
		end
		if not v22.weld then continue end
		val7.Anchored = true
	end
	for _, val8 in ipairs(table9) do
		if val8.VertexColor ~= Vector3.new(1, 1, 1) then continue end
		val8.VertexColor = Vector3.new(1.125, 1.125, 1.125)
	end
	local __HIGHLIGHT = nil
	if Variables.Desktop and p32 == Players.LocalPlayer then
		__HIGHLIGHT = Instance.new("Highlight")
		__HIGHLIGHT.Name = "__HIGHLIGHT"
		__HIGHLIGHT.FillTransparency = 1
		__HIGHLIGHT.OutlineColor = Color3.new(0, 0, 0)
		__HIGHLIGHT.FillColor = Color3.new(0, 0, 0)
		__HIGHLIGHT.DepthMode = Enum.HighlightDepthMode.Occluded
		__HIGHLIGHT.OutlineTransparency = 0.6
		__HIGHLIGHT.Parent = Clone_ret
	end
	if v23 then
		for _, val9 in ipairs(table9) do
			val9.VertexColor = Vector3.new(1.45, 1.45, 1.45)
		end
		local WaitForChild_ret = Assets.Particles:WaitForChild("Golden Pet")
		for _, child10 in ipairs(WaitForChild_ret:GetChildren()) do
			child10:Clone().Parent = Clone_ret
		end
	end
	local PetCmds0 = {}
	local PetCmds1 = {}
	if v24 then
		local Clone_ret5 = Assets.Particles:WaitForChild("Rainbow Pet"):WaitForChild("Sparkles"):Clone()
		Clone_ret5.Name = "__RAINBOWPARTICLES"
		Clone_ret5.Parent = Clone_ret
		table.insert(PetCmds1, Clone_ret5)
		for _, val11 in ipairs(table8) do
			local Clone_ret6 = Assets.Other:WaitForChild("Rainbow Pet"):WaitForChild("Decal"):Clone()
			Clone_ret6.Name = "__RAINBOWFX"
			Clone_ret6.Parent = val11
			table.insert(PetCmds0, Clone_ret6)
		end
		for _, val12 in ipairs(table9) do
			val12.VertexColor = Vector3.new(2, 2, 2)
		end
	end
	if v25 then
		for _, val13 in ipairs(table9) do
			if v26 then
				val13.VertexColor = Vector3.new(0.8, 20, 20)
				continue
			end
			val13.VertexColor = Vector3.new(20, 0.6, 20)
		end
	end
	local PetCmds2 = {}
	if v26 then
		local Children = Assets.Particles["Hardcore Pets"]:GetChildren()
		for _, val14 in ipairs(Children) do
			val14:Clone().Parent = center
		end
		if not v24 and not v25 then
			for _, _ in ipairs(table8) do
				local Clone_ret4 = Assets.Other:WaitForChild("Hardcore Pet"):WaitForChild("Decal"):Clone()
				Clone_ret4.Name = "__HARDCOREFX"
				Clone_ret4.Parent = Clone_ret
				table.insert(PetCmds2, Clone_ret4)
			end
		end
		Functions.Scaler()(Clone_ret, 1.25)
	end
	if p31.id == "294" then
		Functions.Scaler()(Clone_ret, math.random() * 1.3 + 0.2)
	end
	if v27 then
		local Clone_ret3
		if v22.titanic then
			Clone_ret3 = Assets.Particles.Shiny:WaitForChild("TitanicShinyParticle"):Clone()
			Functions.Scaler()(Clone_ret3, 3.25)
		elseif v22.huge then
			Clone_ret3 = Assets.Particles.Shiny:WaitForChild("HugeShinyParticle"):Clone()
			Functions.Scaler()(Clone_ret3, 1.5)
		else
			Clone_ret3 = Assets.Particles.Shiny:WaitForChild("ShinyParticle"):Clone()
		end
		Clone_ret3.Parent = center
		task.defer(function() 
			Clone_ret3:Emit(1)
		end)
	end
	local str1
	if string.find(v22.name, "Pixel") == nil then
		str1 = nil
	else
		str1 = "Pixel"
	end
	local Clone_ret2 = nil
	local v28 = nil
	if not p33 then
		Clone_ret2 = Assets.Billboards.Pet:Clone()
		Clone_ret2.Name = "__BILLBOARD"
		Clone_ret2.Nickname.Text = p31.nk or ""
		Clone_ret2.StudsOffset = Vector3.new(0, (center.Position - bottom.Position).Y * 2, 0)
		if p31.snk then
			v28 = GUIFX.Rainbow(Clone_ret2.Nickname, "TextColor3", 3)
		end
		if Shared.PetRarityNumbers[v22.rarity] >= 2 then
			local t_Rarity = Clone_ret2.Rarity
			t_Rarity.Text = v22.rarity
			Shared.ApplyRarityColor(t_Rarity, v22.rarity)
			t_Rarity.Visible = true
			Clone_ret2.StudsOffset = Clone_ret2.StudsOffset + Vector3.new(0, 1, 0)
		end
		Clone_ret2.Parent = Clone_ret
	end
	if v22.weld then
		for _, val15 in ipairs(table8) do
			local ToObjectSpace_ret = Clone_ret.CFrame:ToObjectSpace(val15.CFrame)
			val15:SetAttribute("LocalCFrame", ToObjectSpace_ret)
		end
	end
	task.defer(function()  
		Audio.Play("rbxassetid://7000720081", Clone_ret, rng:NextNumber(0.95, 1.05), 0.125, 125)
		local v54, v55 = Functions.Emit(Clone_ret, nil, Assets.Particles:WaitForChild("Pet Spawn"))
		for _, val20 in ipairs(v54) do
			Functions.AddDebris(val20, v55)
		end
	end)
	local PetCmds3 = {
		["id"] = p31.id,
		["uid"] = p31.uid,
		["golden"] = v23,
		["rainbow"] = v24,
		["darkMatter"] = v25,
		["shiny"] = v27,
		["hardcore"] = v26,
		["world"] = v21,
		["owner"] = p32,
		["part"] = Clone_ret,
		["mesh"] = SpecialMesh,
		["meshes"] = table9,
		["center"] = center,
		["bottom"] = bottom,
		["mount"] = mount,
		["highlight"] = __HIGHLIGHT,
		["rainbowParticles"] = PetCmds1,
		["rainbowDecals"] = PetCmds0,
		["hardcoreDecals"] = PetCmds2,
		["specialType"] = str1,
		["billboard"] = Clone_ret2,
		["signedAnimation"] = v28,
		["scale"] = 1,
		["moving"] = false,
		["movingTick"] = 0,
		["jumping"] = false,
		["riding"] = false
	}
	return PetCmds3
end
function PetCmds.Effects(p34, p35, p36, p37)  
	local v29 = Directory.Pets[p34.id]
	assert(v29)
	local t_part = p34.part
	local v30 = 1
	local v31 = p34.world == "Void"
	local v32 = p34.walkSoundTick or p36
	p34.walkSoundTick = v32
	local v33 = v31 and 0.65 or 0.3
	if p34.moving and not v29.fly and not p34.jumping and p34.movingTick % v33 <= 0.1 and p36 - v32 > 0.2 then
		p34.walkSoundTick = p36
		local v44 = v29.sounds.walk or WalkSounds
		if #v44 > 0 then
			local u1 = v44[math.random(1, #v44)]
			local u2 = rng:NextNumber(0.95, 1.2)
			local u3 = 0.01
			if p34.riding then
				u2 = u2 * 0.75
				u3 = u3 * 5
			end
			task.spawn(function()  
				Audio.Play(u1, t_part, u2, u3, 60)
			end)
		end
	end
	local v34 = p34.randomSoundTick or p36
	p34.randomSoundTick = v34
	if not p34.moving and rng:NextNumber() <= 0.001 and p36 - v34 >= 6 and Variables.PetSoundsEnabled then
		p34.randomSoundTick = p36
		local t_random = v29.sounds.random
		if #t_random > 0 then
			local u4 = t_random[math.random(1, #t_random)]
			task.spawn(function()  
				Audio.Play(u4, t_part, 1, 0.5, 140)
			end)
		end
	end
	local t_specialType = p34.specialType
	if t_specialType and t_specialType == "Pixel" and p34.moving and not v29.fly and rng:NextInteger(1, 10) == 1 then
		local function MakeCube()  
			debug.profilebegin("Pets.Tick.MakeCube")
			local pixelFX = Instance.new("Part")
			pixelFX.Anchored = true
			pixelFX.Massless = true
			pixelFX.CanCollide = false
			pixelFX.CastShadow = false
			pixelFX.Size = Vector3.new(1, 1, 1) * rng:NextNumber(0.4, 0.66)
			pixelFX.Color = Color3.fromRGB(255, 255, 255)
			pixelFX.CFrame = t_part.CFrame + Vector3.new(rng:NextNumber(-1, 1), p34.bottom.CFrame.Y + rng:NextNumber(-1, 1), rng:NextNumber(-1, 1))
			pixelFX.Name = "pixelFX"
			pixelFX.Parent = debris
			local NextNumber_ret = rng:NextNumber(0.33, 0.6)
			local v62 = pixelFX.Size * rng:NextNumber(0.25, 0.4)
			local v63 = pixelFX.CFrame * CFrame.new(0, 0, rng:NextNumber(1, 2)) + Vector3.new(0, rng:NextNumber(0.25, 1.5), 0)
			Functions.Tween(pixelFX, {
				Size = v62,
				CFrame = v63
			}, {
				NextNumber_ret,
				"Linear"
			})
			Functions.AddDebris(pixelFX, NextNumber_ret)
			debug.profileend()
		end
		MakeCube()
	end
	if p34.rainbow then
		local _ = p34.highlight
		local Color3_fromHSV_ret = Color3.fromHSV(p36 / 1.5 % 1, 1, 1)
		local ColorSequence_new_ret = ColorSequence.new(Color3_fromHSV_ret)
		for _, val16 in ipairs(p34.rainbowParticles) do
			val16.Color = ColorSequence_new_ret
		end
		for _, val17 in ipairs(p34.rainbowDecals) do
			val17.Color3 = Color3_fromHSV_ret
		end
	end
	if p34.darkMatter then
		local math_sin_ret = math.sin(p36)
		if p34.hardcore then
			local v58 = math_sin_ret * 0.2 + 0.8
			for _, val22 in ipairs(p34.meshes) do
				val22.VertexColor = Vector3.new(v58, math_sin_ret * 7 + 13, math_sin_ret * 5 + 15)
			end
		else
			local v59 = p34.shiny and math.sin(p36) * 0.2 + 0.75 or 0.6
			for _, val23 in ipairs(p34.meshes) do
				val23.VertexColor = Vector3.new(math_sin_ret * 5 + 15, v59, math_sin_ret * 7 + 13)
			end
		end
	end
	if p34.shiny then
		if p34.golden then
			local v60 = math.sin(p36) * 0.25
			for _, val24 in ipairs(p34.meshes) do
				val24.VertexColor = Vector3.new(v60 + 2.2, v60 + 2.2, v60 + 2.2)
			end
		elseif not p34.golden and not p34.rainbow and not p34.darkMatter then
			local v64 = math.sin(p36) * 0.2
			for _, val29 in ipairs(p34.meshes) do
				val29.VertexColor = Vector3.new(v64 + 1.8, v64 + 1.8, v64 + 1.8)
			end
		end
	end
	if p34.hardcore then
		local v46 = math.sin(p36 * 5) * 0.2 + 0.8
		for _, val18 in ipairs(p34.hardcoreDecals) do
			val18.Transparency = v46
		end
	end
	if v29.christmasLights then
		local v47 = math.floor(p36) % 2 == 0
		local LightsA = t_part:FindFirstChild("LightsA")
		local LightsB = t_part:FindFirstChild("LightsB")
		local v49
		local v48
		if p34.golden then
			v48 = v47 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v49 = v47 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		elseif p34.darkMatter then
			v48 = v47 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v49 = v47 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		else
			v48 = v47 and Color3.fromRGB(126, 255, 0) or Color3.fromRGB(255, 44, 26)
			v49 = v47 and Color3.fromRGB(255, 44, 26) or Color3.fromRGB(126, 255, 0)
		end
		LightsA.Color = v48
		LightsB.Color = v49
	end
	if p34.id == "402" then
		local Back = t_part:FindFirstChild("Back")
		if Back and Back:IsA("Attachment") then
			local Sparkles = Back:FindFirstChild("Sparkles")
			if Sparkles and Sparkles:IsA("ParticleEmitter") then
				Sparkles.Enabled = p34.moving
			end
		end
	end
	if v29.balloon then
		local v50 = (math.sin(p36 * ((v29.flySpeed or 1) * 4)) + 1) / 2
		v30 = v30 * Functions.Lerp(0.95, 1.05, v50)
	end
	if p34.scale ~= v30 then
		local _ = p34.scale / v30
		p34.scale = v30
		local v51 = p34.scaler
		if not v51 then
			v51 = Functions.Scaler()
			p34.scaler = v51
		end
		assert(v51)
		v51(t_part, v30)
	end
	local PropWeld = t_part:FindFirstChild("PropWeld")
	if PropWeld then
		PropWeld.C0 = CFrame.fromOrientation(0, math.pi * -2 * (v29.propSpeed or 1) * p36, 0)
	end
	local Prop = t_part:FindFirstChild("Prop")
	if Prop then
		local SpecialMesh3 = Prop:FindFirstChildOfClass("SpecialMesh")
		if SpecialMesh3 then
			local t_mesh2 = p34.mesh
			SpecialMesh3.Offset = t_mesh2.Offset
			SpecialMesh3.Scale = t_mesh2.Scale
		end
	end
	if p37 and v29.weld then
		for _, child19 in ipairs(t_part:GetChildren()) do
			if not child19:IsA("BasePart") then continue end
			local Attribute2 = child19:GetAttribute("LocalCFrame")
			if not Attribute2 then continue end
			child19.CFrame = t_part.CFrame * Attribute2
		end
	end
	if v29.flipbookAnimationSpeed then
		local v52 = p34.golden and v29.flipbookAnimationGold or v29.flipbookAnimation
		assert(v52)
		local v53 = v52[(math.floor(p36 / v29.flipbookAnimationSpeed) - 1) % #v52 + 1]
		local t_mesh = p34.mesh
		if t_mesh.TextureId ~= v53 then
			t_mesh.TextureId = v53
		end
	end
	local t_billboard = p34.billboard
	if t_billboard and p35 then
		t_billboard.Nickname.Text = p35.nk or ""
		if p35.snk and not p34.signedAnimation then
			local v61 = GUIFX.Rainbow(t_billboard.Nickname, "TextColor3", 3)
			p34.signedAnimation = v61
			return
		end
		if not p35.snk and p34.signedAnimation then
			p34.signedAnimation()
			p34.signedAnimation = nil
			t_billboard.Nickname.TextColor3 = Color3.new(1, 1, 1)
		end
	end
end
return PetCmds
  -  Editar
  04:54:13.860    -  Editar
  04:54:13.860  ----- [2583] ServerStorage.__STORAGE.Unused Modules.Dupes.PetCmds -----  -  Editar
  04:54:13.861  local v_u_1 = {}
local v_u_2 = {
	6840608566, 
	6840608533, 
	6840608598, 
	6840608504
}
local v3 = game:GetService("ReplicatedStorage")
local v_u_4 = game:GetService("Players")
local v5 = v3:WaitForChild("Library")
local v6 = v5:WaitForChild("Modules")
local v7 = v5:WaitForChild("Client")
local v_u_8 = v3:WaitForChild("Assets")
local v_u_9 = workspace:WaitForChild("__DEBRIS")
local v_u_10 = require(v5.Shared)
local v_u_11 = require(v5.Signal)
local v_u_12 = require(v5.Directory)
local v_u_13 = require(v5.Functions)
local v_u_14 = require(v5.Variables)
local v_u_15 = require(v5.Audio)
local v_u_16 = require(v7.Save)
local v17 = require(v7.Network)
local v_u_18 = require(v7.GUIFX)
local v_u_19 = require(v7.WorldCmds)
require(v6.Pets)
require(v6.DefaultStats)
local v_u_20 = require(v3:WaitForChild("X"):WaitForChild("Util").LeftistHeap)
local v_u_21 = Random.new()
local v_u_22 = {}
local v_u_23 = {}
function v_u_1.GetIndices(p24, p25)
	-- upvalues: (copy) v_u_22, (copy) v_u_23
	local v26 = v_u_22[p24]
	if v26 then
		return v26
	end
	local v27 = {}
	for v28, v29 in ipairs(p25.Pets) do
		v27[v29.uid] = v28
		if not v_u_23[v29.uid] then
			v_u_23[v29.uid] = p24
		end
	end
	v_u_22[p24] = v27
	return v27
end
function v_u_1.DeleteIndices(p30)
	-- upvalues: (copy) v_u_22
	if v_u_22[p30] then
		v_u_22[p30] = nil
	end
end
function v_u_1.GetIndex(p31, p32, p33)
	-- upvalues: (copy) v_u_1
	return v_u_1.GetIndices(p31, p32)[p33]
end
function v_u_1.GetFrom(p34, p35, p36)
	-- upvalues: (copy) v_u_1
	local v37 = v_u_1.GetIndex(p34, p35, p36)
	if not v37 then
		return nil, 0
	end
	assert(v37)
	local v38 = p35.Pets[v37]
	if not v38 then
		return nil, 0
	end
	assert(v38)
	if p36 == v38.uid then
		return v38, v37
	end
	warn("Pet mismatch:", p36, v37, v38 and v38.uid or "nil")
	return nil, 0
end
function v_u_1.Get(p39)
	-- upvalues: (copy) v_u_23, (copy) v_u_16, (copy) v_u_1
	debug.profilebegin("PetCmds.Get")
	local v40 = v_u_23[p39]
	if v40 then
		local v41 = v_u_16.Get(v40)
		if v41 then
			local v42, v43 = v_u_1.GetFrom(v40, v41, p39)
			if v42 then
				debug.profileend()
				return v42, v40, v43
			end
		end
		v_u_23[p39] = nil
	end
	for v44, v45 in pairs(v_u_16.GetSaves()) do
		local v46, v47 = v_u_1.GetFrom(v44, v45, p39)
		if v46 then
			v_u_23[p39] = v44
			debug.profileend()
			return v46, v44, v47
		end
	end
	debug.profileend()
	return nil, nil, 0
end
v_u_11.Fired("Stats Removed"):Connect(function(p48)
	-- upvalues: (copy) v_u_1, (copy) v_u_23
	v_u_1.DeleteIndices(p48)
	for v49, v50 in pairs(v_u_23) do
		if v50 == p48 then
			v_u_23[v49] = nil
		end
	end
end)
function v_u_1.GetEquipped(p51, p52, p53)
	-- upvalues: (copy) v_u_4, (copy) v_u_16, (copy) v_u_10, (copy) v_u_1
	if p51 == nil then
		p51 = v_u_4.LocalPlayer
	else
		local v54
		if typeof(p51) == "Instance" then
			v54 = p51:IsA("Player")
		else
			v54 = false
		end
		assert(v54)
	end
	debug.profilebegin("PetCmds.GetEquipped")
	local v55 = {}
	local v56 = v_u_16.Get(p51, true)
	if v56 then
		local v57 = v_u_10.IsHardcore and v56.HardcorePetsEquipped or v56.PetsEquipped
		if p53 then
			if p52 then
				for v58, v59 in pairs(v57) do
					if v59 then
						v55[v58] = true
					end
				end
			else
				for v60, v61 in pairs(v57) do
					local v62 = v61 and v_u_1.GetFrom(p51, v56, v60)
					if v62 then
						v55[v60] = v62
					end
				end
			end
		elseif p52 then
			for v63, v64 in pairs(v57) do
				if v64 then
					table.insert(v55, v63)
				end
			end
		else
			for v65, v66 in pairs(v57) do
				local v67 = v66 and v_u_1.GetFrom(p51, v56, v65)
				if v67 then
					table.insert(v55, v67)
				end
			end
		end
	end
	debug.profileend()
	return v55
end
function v_u_1.LocalEquipPet(p68, p69, p70)
	-- upvalues: (copy) v_u_16, (copy) v_u_10, (copy) v_u_4, (copy) v_u_11
	local v71 = v_u_16.Get(p68)
	if v71 then
		local v72 = false
		local v73 = v_u_10.IsHardcore and v71.HardcorePetsEquipped or v71.PetsEquipped
		if p70 then
			if not v73[p69] then
				v73[p69] = true
				v72 = true
			end
		elseif v73[p69] then
			v73[p69] = nil
			v72 = true
		end
		if v72 then
			if p68 == v_u_4.LocalPlayer then
				v_u_11.Fire("Pet Equips Changed")
				return
			end
			v_u_11.Fire("Other Pet Equips Changed", p68)
		end
	end
end
v17.Fired("Pet Added"):Connect(function(p74, p75)
	-- upvalues: (copy) v_u_16, (copy) v_u_1, (copy) v_u_4, (copy) v_u_11
	local v76 = v_u_16.Get(p74)
	if v76 then
		assert(v76)
		table.insert(v76.Pets, p75)
		v_u_1.GetIndices(p74, v76)[p75.uid] = #v76.Pets
		local v77 = p74 == v_u_4.LocalPlayer
		if v77 then
			v_u_11.Fire("Stat Changed", "Pets")
		else
			v_u_11.Fire("Other Stat Changed", p74, "Pets")
		end
		if v77 then
			v_u_11.Fire("Stats Changed")
		else
			v_u_11.Fire("Other Stats Changed", p74)
		end
	else
		return
	end
end)
v17.Fired("Pet Removed"):Connect(function(p78, p79)
	-- upvalues: (copy) v_u_16, (copy) v_u_1, (copy) v_u_4, (copy) v_u_11
	local v80 = v_u_16.Get(p78)
	if v80 then
		assert(v80)
		local v81 = v_u_1.GetIndices(p78, v80)
		local v82 = v81[p79]
		if v82 then
			assert(v82)
			local v83 = v80.Pets[v82]
			if v83 then
				assert(v83)
				if p79 == v83.uid then
					table.remove(v80.Pets, v82)
					v81[p79] = nil
					for v84 = v82, #v80.Pets do
						local v85 = v80.Pets[v84]
						if v85 then
							v81[v85.uid] = v84
						end
					end
					local v86 = p78 == v_u_4.LocalPlayer
					if v86 then
						v_u_11.Fire("Stat Changed", "Pets")
					else
						v_u_11.Fire("Other Stat Changed", p78, "Pets")
					end
					if v86 then
						v_u_11.Fire("Stats Changed")
					else
						v_u_11.Fire("Other Stats Changed", p78)
					end
					v_u_1.LocalEquipPet(p78, p79, false)
				end
			else
				return
			end
		else
			return
		end
	else
		return
	end
end)
v17.Fired("Pet Update"):Connect(function(p87, p88)
	-- upvalues: (copy) v_u_16, (copy) v_u_1, (copy) v_u_13, (copy) v_u_4, (copy) v_u_11
	local v89 = v_u_16.Get(p87)
	if v89 then
		assert(v89)
		local v90 = v_u_1.GetIndex(p87, v89, p88.uid)
		if v90 then
			assert(v90)
			local v91 = v89.Pets[v90]
			if v91 then
				assert(v91)
				if p88.uid == v91.uid then
					if v_u_13.DeepEqualsUnsafe(v91, p88) then
						return
					else
						v89.Pets[v90] = p88
						local v92 = p87 == v_u_4.LocalPlayer
						if v92 then
							v_u_11.Fire("Stat Changed", "Pets")
						else
							v_u_11.Fire("Other Stat Changed", p87, "Pets")
						end
						if v92 then
							v_u_11.Fire("Stats Changed")
						else
							v_u_11.Fire("Other Stats Changed", p87)
						end
					end
				else
					return
				end
			else
				return
			end
		else
			return
		end
	else
		return
	end
end)
v17.Fired("Pet Equip Changed"):Connect(function(p93, p94, p95)
	-- upvalues: (copy) v_u_1
	v_u_1.LocalEquipPet(p93, p94, p95)
end)
function v_u_1.HasBestEquipped(p96)
	-- upvalues: (copy) v_u_16, (copy) v_u_1, (copy) v_u_10, (copy) v_u_20, (copy) v_u_12
	local v97
	if p96 == nil then
		v97 = true
	elseif typeof(p96) == "Instance" then
		v97 = p96:IsA("Player")
	else
		v97 = false
	end
	assert(v97)
	debug.profilebegin("PetCmds.HasBestEquipped")
	local v98 = v_u_16.Get(p96)
	if not v98 then
		debug.profileend()
		return false
	end
	assert(v98)
	local v99 = v_u_1.GetEquipped(p96, true, true)
	local v100 = v98.InfPetsEnabled and #v98.Pets or v_u_10.GetMaxEquippedSlots(v98)
	local v101 = v_u_20.new(v_u_10.PetOrderBest)
	for _, v102 in ipairs(v98.Pets) do
		if not v_u_12.Pets[v102.id].isGift then
			v101.insert(v102)
		end
	end
	local v103 = true
	for _ = 1, v100 do
		local v104, v105 = v101.tryPop()
		if not v104 then
			break
		end
		if not v99[v105.uid] then
			v103 = false
			break
		end
	end
	debug.profileend()
	return v103
end
function v_u_1.Match(p106, p107)
	-- upvalues: (copy) v_u_12
	assert(typeof(p106) == "table")
	if #p107 == 0 then
		return true
	end
	local v108 = v_u_12.Pets[p106.id]
	if not v108 then
		return false
	end
	local v109 = {}
	if v108.rarity then
		table.insert(v109, v108.rarity)
	end
	if p106.sh then
		table.insert(v109, "Shiny")
	end
	if v108.name then
		table.insert(v109, v108.name)
	end
	if p106.nk then
		table.insert(v109, p106.nk)
	end
	return true
end
function v_u_1.Spawn(p110, p111, p112, p113)
	-- upvalues: (copy) v_u_19, (copy) v_u_12, (copy) v_u_8, (copy) v_u_13, (copy) v_u_18, (copy) v_u_10, (copy) v_u_15, (copy) v_u_21
	debug.profilebegin("PetCmds.Spawn")
	assert(p110)
	assert(p111)
	local v114 = v_u_19.Get()
	assert(v114)
	local v115 = v_u_12.Pets[p110.id]
	assert(v115)
	local v116 = p110.g == true
	local v117 = p110.r == true
	local v118 = p110.dm == true
	local v119 = p110.hc == true
	local v120 = p110.sh == true
	local v_u_121 = (v116 and v115.modelGold or v115.model):Clone()
	if v115.replacements and p110.rep then
		for _, v122 in ipairs(p110.rep) do
			local v123 = v115.replacements[v122]
			if v123 then
				local v124 = v123.dst:Clone()
				local v125 = v123.src
				local v126
				if v125 then
					local v127 = v_u_121:FindFirstChild(v125.Name)
					if v127 then
						v126 = v127.Parent or v_u_121
						if v127:IsA("PVInstance") and v124:IsA("PVInstance") then
							v124:PivotTo(v127:GetPivot())
						end
						v127:Destroy()
					else
						v126 = v_u_121
					end
				else
					v126 = v_u_121
				end
				v124.Parent = v126
			end
		end
	end
	local v128 = { v_u_121 }
	local v129 = {}
	for _, v130 in ipairs(v_u_121:GetDescendants()) do
		if v130:IsA("BasePart") then
			table.insert(v128, v130)
			table.insert(v129, v130)
		end
	end
	local v131 = v_u_121:FindFirstChildOfClass("SpecialMesh")
	assert(v131)
	local v132 = { v131 }
	for _, v133 in ipairs(v128) do
		local v134 = v133:FindFirstChildOfClass("SpecialMesh")
		if v134 and v134 ~= v131 then
			table.insert(v132, v134)
		end
	end
	local v135 = v_u_121:WaitForChild("center")
	local v136 = v_u_121:WaitForChild("bottom")
	local v137 = v_u_121:FindFirstChild("mount", true)
	local v138 = v_u_121:FindFirstChild("mount_character") or v137
	v_u_121:SetAttribute("Owner", p111.Name)
	v_u_121:SetAttribute("Dir", p110.id)
	v_u_121:SetAttribute("ID", p110.uid)
	v_u_121.Name = p110.uid
	local v139 = v131:GetAttribute("OriginalSize")
	if v139 then
		v_u_121.Size = v139 * v131.Scale
	end
	v_u_121.Anchored = true
	for _, v140 in ipairs(v128) do
		v140.Massless = true
		v140.CanCollide = false
		v140.CanQuery = true
		v140.CanTouch = true
		v140.CastShadow = false
		if v140.Material == Enum.Material.SmoothPlastic then
			v140.Material = Enum.Material.Plastic
			v140.MaterialVariant = ""
			if v115.balloon or p110.sh then
				v140.Material = Enum.Material.Metal
				v140.MaterialVariant = "MetalFineGold"
			end
			if v115.evolved then
				v140.Material = Enum.Material.SmoothPlastic
				v140.MaterialVariant = ""
			end
		end
		if v115.weld then
			v140.Anchored = true
		end
	end
	local v141 = p113 or Vector3.one
	local v142 = v131.Offset
	local v143 = v135.CFrame
	local v144 = CFrame.new(v142.X, v143.Y, v143.Z) * CFrame.fromOrientation(0, 1.5707963267948966, 0)
	v135.CFrame = v144
	local v145 = v136.CFrame
	local v146
	if v139 then
		v146 = CFrame.new(v144.X, -v_u_121.Size.Y / 2 + v142.Y, v144.Z)
	else
		v146 = CFrame.new(v144.X, v145.Y, v144.Z)
	end
	v136.CFrame = v146 * CFrame.fromOrientation(0, 1.5707963267948966, 0)
	for _, v147 in ipairs(v132) do
		if v147.VertexColor == Vector3.one then
			v147.VertexColor = Vector3.new(1.125, 1.125, 1.125)
		end
	end
	if v116 then
		for _, v148 in ipairs(v132) do
			v148.VertexColor = Vector3.new(1.45, 1.45, 1.45)
		end
		for _, v149 in ipairs(v_u_8.Particles:WaitForChild("Golden Pet"):GetChildren()) do
			v149:Clone().Parent = v_u_121
		end
	end
	local v150 = {}
	local v151 = {}
	if v117 then
		local v152 = v_u_8.Particles:WaitForChild("Rainbow Pet"):WaitForChild("Sparkles"):Clone()
		v152.Name = "__RAINBOWPARTICLES"
		v152.Parent = v_u_121
		table.insert(v151, v152)
		for _, v153 in ipairs(v128) do
			local v154 = v_u_8.Other:WaitForChild("Rainbow Pet"):WaitForChild("Decal"):Clone()
			v154.Name = "__RAINBOWFX"
			v154.Parent = v153
			table.insert(v150, v154)
		end
		for _, v155 in ipairs(v132) do
			v155.VertexColor = Vector3.new(2, 2, 2)
		end
	end
	if v118 then
		for _, v156 in ipairs(v132) do
			if v119 then
				v156.VertexColor = Vector3.new(0.8, 20, 20)
			else
				v156.VertexColor = Vector3.new(20, 0.6, 20)
			end
		end
	end
	local v157 = v115.colorVariants and p110.cv and v115.colorVariants[p110.cv]
	if v157 then
		local v158 = v157.Color
		local v159 = v_u_13.Map3(Vector3.new(v158.R, v158.G, v158.B) * v157.Magnitude, Vector3.zero, Vector3.one, Vector3.new(0.1, 0.1, 0.1), Vector3.one)
		for _, v160 in ipairs(v132) do
			v160.VertexColor = v159
		end
		local v_u_161 = {
			{
				["a"] = Color3.new(1, 1, 1), 
				["b"] = v158
			}
		}
		local function v165(p162)
			-- upvalues: (ref) v_u_13, (copy) v_u_161
			local v163 = {}
			for _, v164 in ipairs(p162.Keypoints) do
				table.insert(v163, ColorSequenceKeypoint.new(v164.Time, (v_u_13.Recolor(v164.Value, v_u_161))))
			end
			return ColorSequence.new(v163)
		end
		for _, v166 in ipairs(v_u_121:GetDescendants()) do
			if v166:IsA("ParticleEmitter") then
				v166.Color = v165(v166.Color)
			elseif v166:IsA("Trail") then
				v166.Color = v165(v166.Color)
			elseif v166:IsA("Light") then
				v166.Color = v_u_13.Recolor(v166.Color, v_u_161)
			end
		end
	end
	local v167 = nil
	if p110.vc then
		v167 = Vector3.new(table.unpack(p110.vc))
	elseif v115.vertexColor then
		v167 = v115.vertexColor
	end
	if v167 then
		local v_u_168 = Color3.new(v167.X, v167.Y, v167.Z)
		for _, v169 in ipairs(v132) do
			v169.VertexColor = v167
		end
		local function v174(p170)
			-- upvalues: (copy) v_u_168, (ref) v_u_13
			local v171 = {
				{
					["a"] = Color3.new(1, 1, 1), 
					["b"] = v_u_168
				}
			}
			local v172 = {}
			for _, v173 in ipairs(p170.Keypoints) do
				table.insert(v172, ColorSequenceKeypoint.new(v173.Time, (v_u_13.Recolor(v173.Value, v171))))
			end
			return ColorSequence.new(v172)
		end
		for _, v175 in ipairs(v_u_121:GetDescendants()) do
			if v175:IsA("ParticleEmitter") then
				v175.Color = v174(v175.Color)
			elseif v175:IsA("Trail") then
				v175.Color = v174(v175.Color)
			end
		end
	end
	local v176 = {}
	if v119 then
		for _, v177 in ipairs((v_u_8.Particles["Hardcore Pets"]:GetChildren())) do
			v177:Clone().Parent = v135
		end
		if not (v117 or v118) then
			for _, _ in ipairs(v128) do
				local v178 = v_u_8.Other:WaitForChild("Hardcore Pet"):WaitForChild("Decal"):Clone()
				v178.Name = "__HARDCOREFX"
				v178.Parent = v_u_121
				table.insert(v176, v178)
			end
		end
		v141 = v141 * 1.25
	end
	if p110.id == "294" then
		v141 = v141 * (0.2 + 1.3 * math.random())
	end
	if v120 then
		local v_u_179
		if v115.titanic then
			v_u_179 = v_u_8.Particles.Shiny:WaitForChild("TitanicShinyParticle"):Clone()
			v_u_13.Scaler()(v_u_179, 3.25)
		elseif v115.huge then
			v_u_179 = v_u_8.Particles.Shiny:WaitForChild("HugeShinyParticle"):Clone()
			v_u_13.Scaler()(v_u_179, 1.5)
		else
			v_u_179 = v_u_8.Particles.Shiny:WaitForChild("ShinyParticle"):Clone()
		end
		v_u_179.Parent = v135
		task.defer(function()
			-- upvalues: (ref) v_u_179
			v_u_179:Emit(1)
		end)
	end
	local v180 = string.find(v115.name, "Pixel") ~= nil and "Pixel" or nil
	local v181 = nil
	local v182
	if p112 then
		v182 = nil
	else
		v182 = v_u_8.Billboards.Pet:Clone()
		v182.Name = "__BILLBOARD"
		v182.Nickname.AutoLocalize = false
		v182.Nickname.Text = p110.nk or ""
		v182.StudsOffset = Vector3.new(0, (v135.Position - v136.Position).Y * 2, 0)
		if p110.snk then
			v181 = v_u_18.Rainbow(v182.Nickname, "TextColor3", 3)
		end
		if 2 <= v_u_10.PetRarityNumbers[v115.rarity] then
			local v183 = v182.Rarity
			v183.Text = v115.rarity
			v_u_10.ApplyRarityColor(v183, v115.rarity)
			v183.Visible = true
			v182.StudsOffset = v182.StudsOffset + Vector3.new(0, 1, 0)
		end
		v182.Parent = v_u_121
	end
	local v184 = {}
	if v115.weld then
		for _, v185 in ipairs(v129) do
			local v186 = v185:FindFirstAncestorWhichIsA("Model")
			local v187
			if v186 then
				v187 = v186.PrimaryPart
			else
				v187 = nil
			end
			local v188 = v187 or v185:FindFirstAncestorWhichIsA("BasePart") or v187 or v185.AssemblyRootPart or v_u_121
			assert(v188)
			local v189 = v188:GetPivot():ToObjectSpace(v185:GetPivot())
			local v190 = v185:GetAttribute("RotationRate")
			if v190 then
				v190 = v190 * math.pi / 180
			end
			v184[v185] = {
				["part"] = v185, 
				["root"] = v188, 
				["offset"] = v189, 
				["lastOffset"] = v189, 
				["scaling"] = not v188:GetAttribute("NoScale"), 
				["rotationRate"] = v190
			}
		end
	end
	task.defer(function()
		-- upvalues: (ref) v_u_15, (copy) v_u_121, (ref) v_u_21, (ref) v_u_13, (ref) v_u_8
		v_u_15.Play("rbxassetid://7000720081", v_u_121, v_u_21:NextNumber(0.95, 1.05), 0.125, 125)
		local v191, v192 = v_u_13.Emit(v_u_121, nil, v_u_8.Particles:WaitForChild("Pet Spawn"))
		for _, v193 in ipairs(v191) do
			v_u_13.AddDebris(v193, v192)
		end
	end)
	local v194 = Vector3.one
	local v195 = Vector3.one * v141
	local v196
	if v194 == v195 then
		v195 = v194
		v196 = nil
	else
		v196 = v_u_13.Scaler(nil, function(p197)
			return not p197:GetAttribute("NoScale")
		end)
		--v196 = v_u_13.Scaler(nil, not p197:GetAttribute("NoScale"))
		assert(v196)
		v196(v_u_121, v195)
	end
	debug.profileend()
	return {
		["id"] = p110.id, 
		["uid"] = p110.uid, 
		["golden"] = v116, 
		["rainbow"] = v117, 
		["darkMatter"] = v118, 
		["shiny"] = v120, 
		["hardcore"] = v119, 
		["world"] = v114, 
		["owner"] = p111, 
		["part"] = v_u_121, 
		["mesh"] = v131, 
		["meshes"] = v132, 
		["childParts"] = v129, 
		["scriptedWelds"] = v184, 
		["center"] = v135, 
		["bottom"] = v136, 
		["mount"] = v137, 
		["mountCharacter"] = v138, 
		["rainbowParticles"] = v151, 
		["rainbowDecals"] = v150, 
		["hardcoreDecals"] = v176, 
		["specialType"] = v180, 
		["billboard"] = v182, 
		["signedAnimation"] = v181, 
		["scale"] = v195, 
		["overrideScale"] = v141, 
		["scaler"] = v196, 
		["moving"] = false, 
		["farming"] = false, 
		["movingTick"] = 0, 
		["spinTick"] = 0, 
		["jumping"] = false, 
		["riding"] = false
	}
end
function v_u_1.BasketballBounce(p198, p199, p200, p201)
	local v202 = p198 % p199
	return (p200 - v202) * math.exp(-v202) * math.abs((math.sin(math.pi * p201 * p198)))
end
function v_u_1.Effects(p_u_203, p204, p205, p206, p207)
	-- upvalues: (copy) v_u_12, (copy) v_u_2, (copy) v_u_21, (copy) v_u_15, (copy) v_u_14, (copy) v_u_9, (copy) v_u_13, (copy) v_u_1, (copy) v_u_18
	debug.profilebegin("PetCmds.Effects")
	local v208 = v_u_12.Pets[p_u_203.id]
	assert(v208)
	local v_u_209 = p_u_203.part
	local v210 = Vector3.one
	local v211 = p_u_203.world == "Void"
	local v212 = p_u_203.walkSoundTick or p205
	p_u_203.walkSoundTick = v212
	local v213 = v211 and 0.65 or 0.3
	local v214 = 1
	if v211 then
		v214 = v214 * 0.4090909090909091
	end
	if v208.balloon then
		v214 = v214 * 0.5
	end
	if v208.jelly then
		v214 = v214 * 0.5
	end
	if p_u_203.moving and not v208.fly and not p_u_203.jumping and p_u_203.movingTick % v213 / v214 <= 0.1 and 0.2 < p205 - v212 then
		p_u_203.walkSoundTick = p205
		local v215 = v208.sounds.walk or v_u_2
		if 0 < #v215 then
			local v_u_216 = v215[math.random(1, #v215)]
			local v_u_217 = v_u_21:NextNumber(0.95, 1.2)
			local v_u_218 = 0.01
			if p_u_203.riding then
				v_u_217 = v_u_217 * 0.75
				v_u_218 = v_u_218 * 5
			end
			task.spawn(function()
				-- upvalues: (ref) v_u_15, (copy) v_u_216, (copy) v_u_209, (ref) v_u_217, (ref) v_u_218
				v_u_15.Play(v_u_216, v_u_209, v_u_217, v_u_218, 60)
			end)
		end
	end
	local v219 = p_u_203.randomSoundTick or p205
	p_u_203.randomSoundTick = v219
	if not p_u_203.moving and v_u_21:NextNumber() <= 0.001 and 6 <= p205 - v219 and v_u_14.PetSoundsEnabled then
		p_u_203.randomSoundTick = p205
		local v220 = v208.sounds.random
		if 0 < #v220 then
			local v_u_221 = v220[math.random(1, #v220)]
			task.spawn(function()
				-- upvalues: (ref) v_u_15, (copy) v_u_221, (copy) v_u_209
				v_u_15.Play(v_u_221, v_u_209, 1, 0.5, 140)
			end)
		end
	end
	local v222 = p_u_203.specialType
	if v222 and v222 == "Pixel" and p_u_203.moving and not v208.fly and v_u_21:NextInteger(1, 10) == 1 then
		(function()
			-- upvalues: (ref) v_u_21, (copy) v_u_209, (copy) p_u_203, (ref) v_u_9, (ref) v_u_13
			debug.profilebegin("Pets.Tick.MakeCube")
			local v223 = Instance.new("Part")
			v223.Anchored = true
			v223.Massless = true
			v223.CanCollide = false
			v223.CastShadow = false
			v223.Size = Vector3.one * v_u_21:NextNumber(0.4, 0.66)
			v223.Color = Color3.fromRGB(255, 255, 255)
			v223.CFrame = v_u_209.CFrame + Vector3.new(v_u_21:NextNumber(-1, 1), p_u_203.bottom.CFrame.Y + v_u_21:NextNumber(-1, 1), v_u_21:NextNumber(-1, 1))
			v223.Name = "pixelFX"
			v223.Parent = v_u_9
			local v224 = v_u_21:NextNumber(0.33, 0.6)
			v_u_13.Tween(v223, {
				["Size"] = v223.Size * v_u_21:NextNumber(0.25, 0.4), 
				["CFrame"] = v223.CFrame * CFrame.new(0, 0, v_u_21:NextNumber(1, 2)) + Vector3.new(0, v_u_21:NextNumber(0.25, 1.5), 0)
			}, { v224, "Linear" })
			v_u_13.AddDebris(v223, v224)
			debug.profileend()
		end)()
	end
	if p_u_203.rainbow then
		local _ = p_u_203.highlight
		local v225 = Color3.fromHSV(p205 / 1.5 % 1, 1, 1)
		local v226 = ColorSequence.new(v225)
		for _, v227 in ipairs(p_u_203.rainbowParticles) do
			v227.Color = v226
		end
		for _, v228 in ipairs(p_u_203.rainbowDecals) do
			v228.Color3 = v225
		end
	end
	if p_u_203.darkMatter then
		local v229 = math.sin(p205)
		if p_u_203.hardcore then
			local v230 = 0.8 + v229 * 0.2
			for _, v231 in ipairs(p_u_203.meshes) do
				v231.VertexColor = Vector3.new(v230, 13 + 7 * v229, 15 + 5 * v229)
			end
		else
			local v232 = not p_u_203.shiny and 0.6 or 0.75 + math.sin(p205) * 0.2
			for _, v233 in ipairs(p_u_203.meshes) do
				v233.VertexColor = Vector3.new(15 + 5 * v229, v232, 13 + 7 * v229)
			end
		end
	end
	if p_u_203.shiny then
		if p_u_203.golden then
			local v234 = math.sin(p205) * 0.25
			for _, v235 in ipairs(p_u_203.meshes) do
				v235.VertexColor = Vector3.new(2.2 + v234, 2.2 + v234, 2.2 + v234)
			end
		elseif not (p_u_203.golden or p_u_203.rainbow or p_u_203.darkMatter) then
			local v236 = math.sin(p205) * 0.2
			for _, v237 in ipairs(p_u_203.meshes) do
				v237.VertexColor = Vector3.new(1.8 + v236, 1.8 + v236, 1.8 + v236)
			end
		end
	end
	if p_u_203.hardcore then
		local v238 = math.sin(p205 * 5) * 0.2 + 0.8
		for _, v239 in ipairs(p_u_203.hardcoreDecals) do
			v239.Transparency = v238
		end
	end
	if v208.christmasLights then
		local v240 = math.floor(p205) % 2 == 0
		local v241 = v_u_209:FindFirstChild("LightsA")
		local v242 = v_u_209:FindFirstChild("LightsB")
		local v243, v244
		if p_u_203.golden then
			v243 = v240 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v244 = v240 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		elseif p_u_203.darkMatter then
			v243 = v240 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v244 = v240 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		else
			v243 = v240 and Color3.fromRGB(126, 255, 0) or Color3.fromRGB(255, 44, 26)
			v244 = v240 and Color3.fromRGB(255, 44, 26) or Color3.fromRGB(126, 255, 0)
		end
		v241.Color = v243
		v242.Color = v244
	end
	if p_u_203.id == "402" then
		local v245 = v_u_209:FindFirstChild("Back")
		if v245 and v245:IsA("Attachment") then
			local v246 = v245:FindFirstChild("Sparkles")
			if v246 and v246:IsA("ParticleEmitter") then
				v246.Enabled = p_u_203.moving
			end
		end
	end
	if v208.balloon then
		local v247 = v208.balloonScale or Vector3.one
		v210 = v210 * (v247 * v_u_13.Lerp(0.95, 1.05, (1 + math.sin(p205 * (v208.flySpeed or 1) * (v208.balloonSpeed or 1) * 4)) / 2) + Vector3.one - v247)
	end
	if v208.jelly then
		local v248 = 5.5 / 2 * math.pi * 2
		local v249, v250
		if p_u_203.moving or p_u_203.farming then
			v249 = 1
			v250 = 0.14285714285714285
		else
			v249 = 0
			v250 = 0.025
		end
		local v251 = 1 - math.pow(1 - v250, p206 * 60)
		local v252 = (p_u_203.jellyMoving or v249) * (1 - v251) + v249 * v251
		p_u_203.jellyMoving = v252
		local v253 = (p_u_203.jellyTick or 0) + p206 * (0.3 * (1 - v252) + v248 * v252)
		p_u_203.jellyTick = v253
		local v254 = 1 * (1 - v252) + 1.25 * v252
		local v255 = 2 * math.pi * v253
		local v256 = v_u_13.Map(math.sin(v255 + math.pi / 4), -1, 1, 0.9, 1.1) * v254
		v210 = v210 * Vector3.new(v256, v_u_13.Map(math.sin(v255), -1, 1, 0.8, 1.2) * v254, v256)
	end
	if p_u_203.id == "988" or p_u_203.id == "989" then
		local v257 = { "rbxassetid://13560436163", "rbxassetid://13560436029", "rbxassetid://13560435915" }
		if p_u_203.mesh.TextureId == "rbxassetid://13560728786" and math.random() < 0.01 then
			p_u_203.mesh.TextureId = v257[math.random(1, #v257)]
			task.delay(0.1, function()
				-- upvalues: (copy) p_u_203
				if p_u_203 and p_u_203.part.Parent and p_u_203.mesh then
					p_u_203.mesh.TextureId = "rbxassetid://13560728786"
				end
			end)
		end
	end
	local v258 = v210 * p_u_203.overrideScale
	if p_u_203.scale ~= v258 then
		p_u_203.scale = v258
		local v259 = p_u_203.scaler
		if not v259 then
			p_u_203.scaler = v_u_13.Scaler(nil, function(p260)
				return not p260:GetAttribute("NoScale")
			end)
			v259 = v_u_13.Scaler(nil, function(p260)
				return not p260:GetAttribute("NoScale")
			end)
		end
		assert(v259)
		v259(v_u_209, v258)
	end
	if p207 then
		for _, v261 in pairs(p_u_203.scriptedWelds) do
			local v262 = v261.part
			local v263 = v261.offset
			if v261.scaling then
				v263 = v263 - v263.Position + v263.Position * p_u_203.scale
			end
			local v264 = v261.rotationRate
			if v264 then
				local v265 = v264 * p205
				v263 = v263 * CFrame.fromOrientation(v265.X, v265.Y, v265.Z)
			end
			if p_u_203.id == "606" or p_u_203.id == "2148" then
				if v262.Name == "Basketball" then
					v263 = v263 + Vector3.new(0, v_u_1.BasketballBounce(p205, 3, p_u_203.id == "606" and 2 or 5, 2), 0) * p_u_203.scale
				end
			end
			if p_u_203.id == "630" or p_u_203.id == "631" then
				if v262.Name == "Beachball" then
					v263 = v263 + Vector3.new(0, v_u_1.BasketballBounce(p205, 3, (p_u_203.id == "630" or p_u_203.id == "631") and 2 or 5, 2), 0) * p_u_203.scale
				end
			end
			v262:PivotTo((v261.root:GetPivot():ToWorldSpace(v263)))
		end
	end
	if v208.flipbookAnimationSpeed then
		local v266
		if p_u_203.golden then
			v266 = v208.flipbookAnimationGold
		else
			v266 = v208.flipbookAnimation
		end
		assert(v266)
		local v267 = v266[1 + (math.floor(p205 / v208.flipbookAnimationSpeed) - 1) % #v266]
		local v268 = p_u_203.mesh
		if v268.TextureId ~= v267 then
			v268.TextureId = v267
		end
	end
	local v269 = p_u_203.billboard
	if v269 and p204 then
		if not p_u_203.nicknameUpdateTick or p_u_203.nicknameUpdateTick <= p205 then
			v269.Nickname.Text = p204.nk or ""
			p_u_203.nicknameUpdateTick = p205 + 2 + 2 * math.random()
		end
		if p204.snk and not p_u_203.signedAnimation then
			p_u_203.signedAnimation = v_u_18.Rainbow(v269.Nickname, "TextColor3", 3)
		elseif not p204.snk and p_u_203.signedAnimation then
			p_u_203.signedAnimation()
			p_u_203.signedAnimation = nil
			v269.Nickname.TextColor3 = Color3.new(1, 1, 1)
		end
	end
	debug.profileend()
end
return v_u_1   -  Editar
  04:54:13.861    -  Editar
  04:54:13.861  ----- [2584] ServerStorage.__STORAGE.Unused Modules.Dupes.PetCmds -----  -  Editar
  04:54:13.861  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local PetCmds = {}
local walkSounds = { 6840608566, 6840608533, 6840608598, 6840608504 }
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Library = ReplicatedStorage:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Client = Library:WaitForChild("Client")
local Assets = ReplicatedStorage:WaitForChild("Assets")
local __DEBRIS = workspace:WaitForChild("__DEBRIS")
local m_Shared = require(Library.Shared)
local m_Signal = require(Library.Signal)
local m_Directory = require(Library.Directory)
local m_Functions = require(Library.Functions)
local m_Variables = require(Library.Variables)
local m_Audio = require(Library.Audio)
local m_Save = require(Client.Save)
local m_Network = require(Client.Network)
local m_GUIFX = require(Client.GUIFX)
local m_WorldCmds = require(Client.WorldCmds)
local _ = require(Modules.Pets)
local _ = require(Modules.DefaultStats)
local X = ReplicatedStorage:WaitForChild("X")
local m_LeftistHeap = require(X:WaitForChild("Util").LeftistHeap)
local Random_new_ret = Random.new()
local u1 = {}
local table3 = {}
local table4 = {}
function PetCmds.GetIndices(p1, p2) -- Line: 48
	--[[
		Upvalues:
			[1] = table3
			[2] = table4
	--]]
	local v1 = u1[p1]
	if v1 then
		return v1
	end
	local table5 = {}
	for key1, val1 in ipairs(p2.Pets) do
		table5[val1.uid] = key1
		if table4[val1.uid] then continue end
		--table4[val1.uid] = p1
	end
	table3[p1] = table5
	return table5
end
function PetCmds.DeleteIndices(p3) -- Line: 64
	--[[
		Upvalues:
			[1] = table3
	--]]
	if table3[p3] then
		table3[p3] = nil;
	end
end
function PetCmds.GetIndex(p4, p5, p6) -- Line: 70
	--[[
		Upvalues:
			[1] = PetCmds
	--]]
	return PetCmds.GetIndices(p4, p5)[p6]
end
function PetCmds.GetFrom(p7, p8, p9) -- Line: 74
	--[[
		Upvalues:
			[1] = PetCmds
	--]]
	local Index = PetCmds.GetIndex(p7, p8, p9);
	if not Index then
		return nil, 0;
	end
	assert(Index);
	local FF = p8.Pets[Index];
	if not FF then
		return nil, 0;
	end
	assert(FF);
	if p9 ~= FF.uid then
		warn("Pet mismatch:", p9, Index, FF and FF.uid or "nil");
		return nil, 0;
	end
	return FF, Index;
end
function PetCmds.Get(p10) -- Line: 103
	--[[
		Upvalues:
			[1] = table4
			[2] = m_Save
			[3] = PetCmds
	--]]
	local tab = table4[p10];
	if tab then
		local player = tab[1];
		local playerSave = m_Save.Get(player);
		if playerSave then
			local pet = playerSave.Pets[tab[2]];
			if pet and pet.uid == p10 then
				local Test, Test2 = PetCmds.GetFrom(tab[1], playerSave, p10)
				return pet, player, Test2 --table5[p10];
			end;
		end;
	end;
	for i, player in ipairs(game.Players:GetPlayers()) do
		local playerSave = m_Save.Get(player);
		if playerSave then
			for i, x in ipairs(playerSave.Pets) do
				if x.uid == p10 then
					table4[p10] = { player, i };
					local Test,Test2 = PetCmds.GetFrom(i, playerSave, p10)
					return x, player, Test2;
				end;
			end;
		end;
	end;
	return nil, nil, 0
	--[[debug.profilebegin("PetCmds.Get")
	local v3 = table4[p10]
	if v3 then
		local v36 = m_Save.Get(v3)
		if v36 then
			local v56, v57 = PetCmds.GetFrom(v3, v36, p10)
			if v56 then
				debug.profileend()
				return v56, v3, v57
			end
		end
		table4[p10] = nil
	end
	for key2, val2 in pairs(m_Save.GetSaves()) do
		local v37, v38 = PetCmds.GetFrom(key2, val2, p10)
		if not v37 then continue end
		table4[p10] = key2
		debug.profileend()
		return v37, key2, v38
	end
	debug.profileend()
	return nil, nil, 0]]--
end
m_Signal.Fired("Stats Removed"):Connect(function(p11) -- Line: 137
	--[[
		Upvalues:
			[1] = PetCmds
			[2] = table4
	--]]
	PetCmds.DeleteIndices(p11)
	for key3, val3 in pairs(table4) do
		if val3 ~= p11 then continue end
		table4[key3] = nil
	end
end)
--[[function PetCmds.GetEquipped(p12, p13, p14) -- Line: 221

	local v35
	if p12 == nil then
		v35 = Players.LocalPlayer
	else
		assert(typeof(p12) == "Instance" and p12:IsA("Player") or false)
		v35 = p12
	end
	debug.profilebegin("PetCmds.GetEquipped")
	local table6 = {}
	local v4 = m_Save.Get(v35, true)
	if v4 then
		local v39 = m_Shared.IsHardcore and v4.HardcorePetsEquipped or v4.PetsEquipped
		if p14 then
			if p13 then
				for key25, val25 in pairs(v39) do
					if not val25 then continue end
					table6[key25] = true
				end
			else
				for key26, val26 in pairs(v39) do
					if not val26 then continue end
					local From2 = PetCmds.GetFrom(v35, v4, key26)
					if not From2 then continue end
					table6[key26] = From2
				end
			end
		elseif p13 then
			for key27, val27 in pairs(v39) do
				if not val27 then continue end
				table.insert(table6, key27)
			end
		else
			for key28, val28 in pairs(v39) do
				if not val28 then continue end
				local From = PetCmds.GetFrom(v35, v4, key28)
				if not From then continue end
				table.insert(table6, From)
			end
		end
	end
	debug.profileend()
	
	--if #table6 >= 1 then
	--	warn("PETCMDS.GetEquipped DEBUG:  ", table6, " |  ", #table6)
	--end
	
	return table6
end]]--

function PetCmds.GetEquipped(p11, p12,p14)
	local v35
	if p11 == nil then
		v35 = Players.LocalPlayer
	else
		assert(typeof(p11) == "Instance" and p11:IsA("Player") or false)
		v35 = p11
	end
	local v32 =  m_Save.Get(v35,true)

	local returningEquipped = {}
	
	if v32 then
		local PetsEquipped = m_Shared.IsHardcore and v32.HardcorePetsEquipped or v32.PetsEquipped

		for uid, pet in pairs(PetsEquipped) do
			if p14 then
				if p12 then
					returningEquipped[uid] = true
				else
					local t4est = PetCmds.GetFrom(v35, v32, uid)
					returningEquipped[uid] = t4est
				end
			elseif p12 then
				table.insert(returningEquipped, uid)
			else
				table.insert(returningEquipped, pet)
			end
		end
	end	
	
	--warn("PETS GOTTEN | CLIENT:  ",returningEquipped,m_Functions.DictionaryLength(returningEquipped),#returningEquipped)

	return returningEquipped
end
function PetCmds.LocalEquipPet(p15, p16, p17) -- Line: 278
	--[[
		Upvalues:
			[1] = m_Save
			[2] = m_Shared
			[3] = Players
			[4] = m_Signal
	--]]
	local v5 = m_Save.Get(p15)
	if v5 then
		local bool1 = false
		local v40 = m_Shared.IsHardcore and v5.HardcorePetsEquipped or v5.PetsEquipped
		if p17 then
			if not v40[p16] then
				v40[p16] = true
				bool1 = true
			end
		elseif v40[p16] then
			v40[p16] = nil
			bool1 = true
		end
		if bool1 then
			if p15 == Players.LocalPlayer then
				m_Signal.Fire("Pet Equips Changed")
				return
			end
			m_Signal.Fire("Other Pet Equips Changed", p15)
		end
	end
end
m_Network.Fired("Pet Added"):Connect(function(p18, p19) -- Line: 308
	--[[
		Upvalues:
			[1] = m_Save
			[2] = PetCmds
			[3] = Players
			[4] = m_Signal
	--]]
	local v6 = m_Save.Get(p18)
	if not v6 then return end
	assert(v6)
	local Indices = PetCmds.GetIndices(p18, v6)
	table.insert(v6.Pets, p19)
	local v7 = #v6.Pets
	Indices[p19.uid] = v7
	local v8 = p18 == Players.LocalPlayer
	if v8 then
		m_Signal.Fire("Stat Changed", "Pets")
	else
		m_Signal.Fire("Other Stat Changed", p18, "Pets")
	end
	if v8 then
		m_Signal.Fire("Stats Changed")
		return
	end
	m_Signal.Fire("Other Stats Changed", p18)
end)
m_Network.Fired("Pet Removed"):Connect(function(p20, p21) -- Line: 339
	--[[
		Upvalues:
			[1] = m_Save
			[2] = PetCmds
			[3] = Players
			[4] = m_Signal
	--]]
	local v9 = m_Save.Get(p20)
	if not v9 then return end
	assert(v9)
	local Indices2 = PetCmds.GetIndices(p20, v9)
	local v10 = Indices2[p21]
	if not v10 then return end
	assert(v10)
	local v11 = v9.Pets[v10]
	if not v11 then return end
	assert(v11)
	if p21 ~= v11.uid then return end
	table.remove(v9.Pets, v10)
	Indices2[p21] = nil
	for index1 = v10, #v9.Pets do
		local v41 = v9.Pets[index1]
		if v41 then
			Indices2[v41.uid] = index1
		end
	end
	local v12 = p20 == Players.LocalPlayer
	if v12 then
		m_Signal.Fire("Stat Changed", "Pets")
	else
		m_Signal.Fire("Other Stat Changed", p20, "Pets")
	end
	if v12 then
		m_Signal.Fire("Stats Changed")
	else
		m_Signal.Fire("Other Stats Changed", p20)
	end
	PetCmds.LocalEquipPet(p20, p21, false)
end)
m_Network.Fired("Pet Update"):Connect(function(p22, p23) -- Line: 399
	--[[
		Upvalues:
			[1] = m_Save
			[2] = PetCmds
			[3] = m_Functions
			[4] = Players
			[5] = m_Signal
	--]]
	local v13 = m_Save.Get(p22)
	if not v13 then return end
	assert(v13)
	local Index2 = PetCmds.GetIndex(p22, v13, p23.uid)
	if not Index2 then return end
	assert(Index2)
	local v14 = v13.Pets[Index2]
	if not v14 then return end
	assert(v14)
	if p23.uid ~= v14.uid then return end
	if m_Functions.DeepEqualsUnsafe(v14, p23) then return end
	v13.Pets[Index2] = p23
	local v15 = p22 == Players.LocalPlayer
	if v15 then
		m_Signal.Fire("Stat Changed", "Pets")
	else
		m_Signal.Fire("Other Stat Changed", p22, "Pets")
	end
	if v15 then
		m_Signal.Fire("Stats Changed")
		return
	end
	m_Signal.Fire("Other Stats Changed", p22)
end)
m_Network.Fired("Pet Equip Changed"):Connect(function(p24, p25, p26) -- Line: 451
	--[[
		Upvalues:
			[1] = PetCmds
	--]]
	PetCmds.LocalEquipPet(p24, p25, p26)
end)
function PetCmds.HasBestEquipped(p27) -- Line: 460
	--[[
		Upvalues:
			[1] = m_Save
			[2] = PetCmds
			[3] = m_Shared
			[4] = m_LeftistHeap
			[5] = m_Directory
	--]]
	assert(p27 == nil and true or typeof(p27) == "Instance" and p27:IsA("Player") or false)
	debug.profilebegin("PetCmds.HasBestEquipped")
	local v16 = m_Save.Get(p27)
	if not v16 then
		debug.profileend()
		return false
	end
	assert(v16)
	local Equipped = PetCmds.GetEquipped(p27, true, true)
	local v17 = v16.InfPetsEnabled and #v16.Pets or m_Shared.GetMaxEquippedSlots(v16)
	local v18 = m_LeftistHeap.new(m_Shared.PetOrderBest)
	for _, val4 in ipairs(v16.Pets) do
		if m_Directory.Pets[val4.id].isGift then continue end
		v18.insert(val4)
	end
	local bool2 = true
	for index2 = 1, v17 do
		local v42, v43 = v18.tryPop()
		if not v42 then break end
		if not Equipped[v43.uid] then
			bool2 = false
			break
		end
	end
	debug.profileend()
	return bool2
end
function PetCmds.Match(p28, p29) -- Line: 502
	--[[
		Upvalues:
			[1] = m_Directory
	--]]
	assert(typeof(p28) == "table")
	if #p29 == 0 then
		return true
	end
	local v19 = m_Directory.Pets[p28.id]
	if not v19 then
		return false
	end
	local table7 = {}
	if v19.rarity then
		table.insert(table7, v19.rarity)
	end
	if p28.sh then
		table.insert(table7, "Shiny")
	end
	if v19.name then
		table.insert(table7, v19.name)
	end
	if p28.nk then
		table.insert(table7, p28.nk)
	end
	return true
end
function PetCmds.Scaler(p30) -- Line: 531
	--[[
		Upvalues:
			[1] = m_Functions
	--]]
	local v20 = p30.scaler
	if not v20 then
		v20 = m_Functions.Scaler()
		p30.scaler = v20
	end
	assert(v20)
	return v20
end
function PetCmds.Spawn(p31, p32, p33) -- Line: 544
	--[[
		Upvalues:
			[1] = m_WorldCmds
			[2] = m_Directory
			[3] = m_Variables
			[4] = Players
			[5] = Assets
			[6] = m_Functions
			[7] = m_GUIFX
			[8] = m_Shared
			[9] = m_Audio
			[10] = Random_new_ret
	--]]
	assert(p31)
	assert(p32)
	local v21 = m_WorldCmds.Get()
	assert(v21)
	local v22 = m_Directory.Pets[p31.id]
	assert(v22)
	local v23 = p31.g == true
	local v24 = p31.r == true
	local v25 = p31.dm == true
	local v26 = p31.hc == true
	local v27 = p31.sh == true
	local Clone_ret = (v23 and v22.modelGold or v22.model):Clone()
	local table8 = {Clone_ret}
	for _, child5 in ipairs(Clone_ret:GetChildren()) do
		if not child5:IsA("BasePart") then continue end
		table.insert(table8, child5)
	end
	local SpecialMesh = Clone_ret:FindFirstChildOfClass("SpecialMesh")
	assert(SpecialMesh)
	local table9 = {SpecialMesh}
	for _, val6 in ipairs(table8) do
		local SpecialMesh2 = val6:FindFirstChildOfClass("SpecialMesh")
		if not SpecialMesh2 or SpecialMesh2 == SpecialMesh then continue end
		table.insert(table9, SpecialMesh2)
	end
	local center = Clone_ret:WaitForChild("center")
	local bottom = Clone_ret:WaitForChild("bottom")
	local mount = Clone_ret:FindFirstChild("mount")
	Clone_ret:SetAttribute("Owner", p32.Name)
	Clone_ret:SetAttribute("Dir", p31.id)
	Clone_ret:SetAttribute("ID", p31.uid)
	Clone_ret.Name = p31.uid
	local Attribute = SpecialMesh:GetAttribute("OriginalSize")
	if Attribute then
		Clone_ret.Size = Attribute * SpecialMesh.Scale
	end
	Clone_ret.Anchored = true
	for _, val7 in ipairs(table8) do
		val7.Massless = true
		val7.CanCollide = false
		val7.CanQuery = true
		val7.CanTouch = true
		val7.CastShadow = false
		if val7.Material == Enum.Material.SmoothPlastic then
			val7.Material = Enum.Material.Plastic
		end
		if not v22.weld then continue end
		val7.Anchored = true
	end
	for _, val8 in ipairs(table9) do
		if val8.VertexColor ~= Vector3.new(1, 1, 1) then continue end
		val8.VertexColor = Vector3.new(1.125, 1.125, 1.125)
	end
	local __HIGHLIGHT = nil
	if m_Variables.Desktop and p32 == Players.LocalPlayer then
		__HIGHLIGHT = Instance.new("Highlight")
		__HIGHLIGHT.Name = "__HIGHLIGHT"
		__HIGHLIGHT.FillTransparency = 1
		__HIGHLIGHT.OutlineColor = Color3.new(0, 0, 0)
		__HIGHLIGHT.FillColor = Color3.new(0, 0, 0)
		__HIGHLIGHT.DepthMode = Enum.HighlightDepthMode.Occluded
		__HIGHLIGHT.OutlineTransparency = 0.6
		__HIGHLIGHT.Parent = Clone_ret
	end
	if v23 then
		for _, val9 in ipairs(table9) do
			val9.VertexColor = Vector3.new(1.45, 1.45, 1.45)
		end
		local WaitForChild_ret = Assets.Particles:WaitForChild("Golden Pet")
		for _, child10 in ipairs(WaitForChild_ret:GetChildren()) do
			child10:Clone().Parent = Clone_ret
		end
	end
	local PetCmds0 = {}
	local PetCmds1 = {}
	if v24 then
		local Clone_ret5 = Assets.Particles:WaitForChild("Rainbow Pet"):WaitForChild("Sparkles"):Clone()
		Clone_ret5.Name = "__RAINBOWPARTICLES"
		Clone_ret5.Parent = Clone_ret
		table.insert(PetCmds1, Clone_ret5)
		for _, val11 in ipairs(table8) do
			local Clone_ret6 = Assets.Other:WaitForChild("Rainbow Pet"):WaitForChild("Decal"):Clone()
			Clone_ret6.Name = "__RAINBOWFX"
			Clone_ret6.Parent = val11
			table.insert(PetCmds0, Clone_ret6)
		end
		for _, val12 in ipairs(table9) do
			val12.VertexColor = Vector3.new(2, 2, 2)
		end
	end
	if v25 then
		for _, val13 in ipairs(table9) do
			if v26 then
				val13.VertexColor = Vector3.new(0.8, 20, 20)
				continue
			end
			val13.VertexColor = Vector3.new(20, 0.6, 20)
		end
	end
	local PetCmds2 = {}
	if v26 then
		local Children = Assets.Particles["Hardcore Pets"]:GetChildren()
		for _, val14 in ipairs(Children) do
			val14:Clone().Parent = center
		end
		if not v24 and not v25 then
			for _, _ in ipairs(table8) do
				local Clone_ret4 = Assets.Other:WaitForChild("Hardcore Pet"):WaitForChild("Decal"):Clone()
				Clone_ret4.Name = "__HARDCOREFX"
				Clone_ret4.Parent = Clone_ret
				table.insert(PetCmds2, Clone_ret4)
			end
		end
		m_Functions.Scaler()(Clone_ret, 1.25)
	end
	if p31.id == "294" then
		m_Functions.Scaler()(Clone_ret, math.random() * 1.3 + 0.2)
	end
	if v27 then
		local Clone_ret3
		if v22.titanic then
			Clone_ret3 = Assets.Particles.Shiny:WaitForChild("TitanicShinyParticle"):Clone()
			m_Functions.Scaler()(Clone_ret3, 3.25)
		elseif v22.huge then
			Clone_ret3 = Assets.Particles.Shiny:WaitForChild("HugeShinyParticle"):Clone()
			m_Functions.Scaler()(Clone_ret3, 1.5)
		else
			Clone_ret3 = Assets.Particles.Shiny:WaitForChild("ShinyParticle"):Clone()
		end
		Clone_ret3.Parent = center
		task.defer(function() -- Line: 742
			--[[
				Upvalues:
					[1] = Clone_ret3
			--]]
			Clone_ret3:Emit(1)
		end)
	end
	local str1
	if string.find(v22.name, "Pixel") == nil then
		str1 = nil
	else
		str1 = "Pixel"
	end
	local Clone_ret2 = nil
	local v28 = nil
	if not p33 then
		Clone_ret2 = Assets.Billboards.Pet:Clone()
		Clone_ret2.Name = "__BILLBOARD"
		Clone_ret2.Nickname.Text = p31.nk or ""
		Clone_ret2.StudsOffset = Vector3.new(0, (center.Position - bottom.Position).Y * 2, 0)
		if p31.snk then
			v28 = m_GUIFX.Rainbow(Clone_ret2.Nickname, "TextColor3", 3)
		end
		if m_Shared.PetRarityNumbers[v22.rarity] >= 2 then
			local t_Rarity = Clone_ret2.Rarity
			t_Rarity.Text = v22.rarity
			m_Shared.ApplyRarityColor(t_Rarity, v22.rarity)
			t_Rarity.Visible = true
			Clone_ret2.StudsOffset = Clone_ret2.StudsOffset + Vector3.new(0, 1, 0)
		end
		Clone_ret2.Parent = Clone_ret
	end
	if v22.weld then
		for _, val15 in ipairs(table8) do
			local ToObjectSpace_ret = Clone_ret.CFrame:ToObjectSpace(val15.CFrame)
			val15:SetAttribute("LocalCFrame", ToObjectSpace_ret)
		end
	end
	task.defer(function() -- Line: 786
		--[[
			Upvalues:
				[1] = m_Audio
				[2] = Clone_ret
				[3] = Random_new_ret
				[4] = m_Functions
				[5] = Assets
		--]]
		m_Audio.Play("rbxassetid://7000720081", Clone_ret, Random_new_ret:NextNumber(0.95, 1.05), 0.125, 125)
		local v54, v55 = m_Functions.Emit(Clone_ret, nil, Assets.Particles:WaitForChild("Pet Spawn"))
		for _, val20 in ipairs(v54) do
			m_Functions.AddDebris(val20, v55)
		end
	end)
	local PetCmds3 = {
		id = p31.id,
		uid = p31.uid,
		golden = v23,
		rainbow = v24,
		darkMatter = v25,
		shiny = v27,
		hardcore = v26,
		world = v21,
		owner = p32,
		part = Clone_ret,
		mesh = SpecialMesh,
		meshes = table9,
		center = center,
		bottom = bottom,
		mount = mount,
		highlight = __HIGHLIGHT,
		rainbowParticles = PetCmds1,
		rainbowDecals = PetCmds0,
		hardcoreDecals = PetCmds2,
		specialType = str1,
		billboard = Clone_ret2,
		signedAnimation = v28,
		scale = 1,
		moving = false,
		movingTick = 0,
		jumping = false,
		riding = false
	}
	return PetCmds3
end
function PetCmds.Effects(p34, p35, p36, p37) -- Line: 837
	--[[
		Upvalues:
			[1] = m_Directory
			[2] = walkSounds
			[3] = Random_new_ret
			[4] = m_Audio
			[5] = m_Variables
			[6] = __DEBRIS
			[7] = m_Functions
			[8] = m_GUIFX
	--]]
	local v29 = m_Directory.Pets[p34.id]
	assert(v29)
	local t_part = p34.part
	local v30 = 1
	local v31 = p34.world == "Void"
	local v32 = p34.walkSoundTick or p36
	p34.walkSoundTick = v32
	local v33 = v31 and 0.65 or 0.3
	if p34.moving and not v29.fly and not p34.jumping and p34.movingTick % v33 <= 0.1 and p36 - v32 > 0.2 then
		p34.walkSoundTick = p36
		local v44 = v29.sounds.walk or walkSounds
		if #v44 > 0 then
			local u1 = v44[math.random(1, #v44)]
			local u2 = Random_new_ret:NextNumber(0.95, 1.2)
			local u3 = 0.01
			if p34.riding then
				u2 = u2 * 0.75
				u3 = u3 * 5
			end
			task.spawn(function() -- Line: 869
				--[[
					Upvalues:
						[1] = m_Audio
						[2] = u1
						[3] = t_part
						[4] = u2
						[5] = u3
				--]]
				m_Audio.Play(u1, t_part, u2, u3, 60)
			end)
		end
	end
	local v34 = p34.randomSoundTick or p36
	p34.randomSoundTick = v34
	if not p34.moving and Random_new_ret:NextNumber() <= 0.001 and p36 - v34 >= 6 and m_Variables.PetSoundsEnabled then
		p34.randomSoundTick = p36
		local t_random = v29.sounds.random
		if #t_random > 0 then
			local u4 = t_random[math.random(1, #t_random)]
			task.spawn(function() -- Line: 883
				--[[
					Upvalues:
						[1] = m_Audio
						[2] = u4
						[3] = t_part
				--]]
				m_Audio.Play(u4, t_part, 1, 0.5, 140)
			end)
		end
	end
	local t_specialType = p34.specialType
	if t_specialType and t_specialType == "Pixel" and p34.moving and not v29.fly and Random_new_ret:NextInteger(1, 10) == 1 then
		local function MakeCube() -- Line: 895
			--[[
				Upvalues:
					[1] = Random_new_ret
					[2] = t_part
					[3] = p34
					[4] = __DEBRIS
					[5] = m_Functions
			--]]
			debug.profilebegin("Pets.Tick.MakeCube")
			local pixelFX = Instance.new("Part")
			pixelFX.Anchored = true
			pixelFX.Massless = true
			pixelFX.CanCollide = false
			pixelFX.CastShadow = false
			pixelFX.Size = Vector3.new(1, 1, 1) * Random_new_ret:NextNumber(0.4, 0.66)
			pixelFX.Color = Color3.fromRGB(255, 255, 255)
			pixelFX.CFrame = t_part.CFrame + Vector3.new(Random_new_ret:NextNumber(-1, 1), p34.bottom.CFrame.Y + Random_new_ret:NextNumber(-1, 1), Random_new_ret:NextNumber(-1, 1))
			pixelFX.Name = "pixelFX"
			pixelFX.Parent = __DEBRIS
			local NextNumber_ret = Random_new_ret:NextNumber(0.33, 0.6)
			local v62 = pixelFX.Size * Random_new_ret:NextNumber(0.25, 0.4)
			local v63 = pixelFX.CFrame * CFrame.new(0, 0, Random_new_ret:NextNumber(1, 2)) + Vector3.new(0, Random_new_ret:NextNumber(0.25, 1.5), 0)
			m_Functions.Tween(pixelFX, {
				Size = v62,
				CFrame = v63
			}, {
				NextNumber_ret,
				"Linear"
			})
			m_Functions.AddDebris(pixelFX, NextNumber_ret)
			debug.profileend()
		end
		MakeCube()
	end
	if p34.rainbow then
		local _ = p34.highlight
		local Color3_fromHSV_ret = Color3.fromHSV(p36 / 1.5 % 1, 1, 1)
		local ColorSequence_new_ret = ColorSequence.new(Color3_fromHSV_ret)
		for _, val16 in ipairs(p34.rainbowParticles) do
			val16.Color = ColorSequence_new_ret
		end
		for _, val17 in ipairs(p34.rainbowDecals) do
			val17.Color3 = Color3_fromHSV_ret
		end
	end
	if p34.darkMatter then
		local math_sin_ret = math.sin(p36)
		if p34.hardcore then
			local v58 = math_sin_ret * 0.2 + 0.8
			for _, val22 in ipairs(p34.meshes) do
				val22.VertexColor = Vector3.new(v58, math_sin_ret * 7 + 13, math_sin_ret * 5 + 15)
			end
		else
			local v59 = p34.shiny and math.sin(p36) * 0.2 + 0.75 or 0.6
			for _, val23 in ipairs(p34.meshes) do
				val23.VertexColor = Vector3.new(math_sin_ret * 5 + 15, v59, math_sin_ret * 7 + 13)
			end
		end
	end
	if p34.shiny then
		if p34.golden then
			local v60 = math.sin(p36) * 0.25
			for _, val24 in ipairs(p34.meshes) do
				val24.VertexColor = Vector3.new(v60 + 2.2, v60 + 2.2, v60 + 2.2)
			end
		elseif not p34.golden and not p34.rainbow and not p34.darkMatter then
			local v64 = math.sin(p36) * 0.2
			for _, val29 in ipairs(p34.meshes) do
				val29.VertexColor = Vector3.new(v64 + 1.8, v64 + 1.8, v64 + 1.8)
			end
		end
	end
	if p34.hardcore then
		local v46 = math.sin(p36 * 5) * 0.2 + 0.8
		for _, val18 in ipairs(p34.hardcoreDecals) do
			val18.Transparency = v46
		end
	end
	if v29.christmasLights then
		local v47 = math.floor(p36) % 2 == 0
		local LightsA = t_part:FindFirstChild("LightsA")
		local LightsB = t_part:FindFirstChild("LightsB")
		local v49
		local v48
		if p34.golden then
			v48 = v47 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v49 = v47 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		elseif p34.darkMatter then
			v48 = v47 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v49 = v47 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		else
			v48 = v47 and Color3.fromRGB(126, 255, 0) or Color3.fromRGB(255, 44, 26)
			v49 = v47 and Color3.fromRGB(255, 44, 26) or Color3.fromRGB(126, 255, 0)
		end
		LightsA.Color = v48
		LightsB.Color = v49
	end
	if p34.id == "402" then
		local Back = t_part:FindFirstChild("Back")
		if Back and Back:IsA("Attachment") then
			local Sparkles = Back:FindFirstChild("Sparkles")
			if Sparkles and Sparkles:IsA("ParticleEmitter") then
				Sparkles.Enabled = p34.moving
			end
		end
	end
	if v29.balloon then
		local v50 = (math.sin(p36 * ((v29.flySpeed or 1) * 4)) + 1) / 2
		v30 = v30 * m_Functions.Lerp(0.95, 1.05, v50)
	end
	if p34.scale ~= v30 then
		local _ = p34.scale / v30
		p34.scale = v30
		local v51 = p34.scaler
		if not v51 then
			v51 = m_Functions.Scaler()
			p34.scaler = v51
		end
		assert(v51)
		v51(t_part, v30)
	end
	local PropWeld = t_part:FindFirstChild("PropWeld")
	if PropWeld then
		PropWeld.C0 = CFrame.fromOrientation(0, math.pi * -2 * (v29.propSpeed or 1) * p36, 0)
	end
	local Prop = t_part:FindFirstChild("Prop")
	if Prop then
		local SpecialMesh3 = Prop:FindFirstChildOfClass("SpecialMesh")
		if SpecialMesh3 then
			local t_mesh2 = p34.mesh
			SpecialMesh3.Offset = t_mesh2.Offset
			SpecialMesh3.Scale = t_mesh2.Scale
		end
	end
	if p37 and v29.weld then
		for _, child19 in ipairs(t_part:GetChildren()) do
			if not child19:IsA("BasePart") then continue end
			local Attribute2 = child19:GetAttribute("LocalCFrame")
			if not Attribute2 then continue end
			child19.CFrame = t_part.CFrame * Attribute2
		end
	end
	if v29.flipbookAnimationSpeed then
		local v52 = p34.golden and v29.flipbookAnimationGold or v29.flipbookAnimation
		assert(v52)
		local v53 = v52[(math.floor(p36 / v29.flipbookAnimationSpeed) - 1) % #v52 + 1]
		local t_mesh = p34.mesh
		if t_mesh.TextureId ~= v53 then
			t_mesh.TextureId = v53
		end
	end
	local t_billboard = p34.billboard
	if t_billboard and p35 then
		t_billboard.Nickname.Text = p35.nk or ""
		if p35.snk and not p34.signedAnimation then
			local v61 = m_GUIFX.Rainbow(t_billboard.Nickname, "TextColor3", 3)
			p34.signedAnimation = v61
			return
		end
		if not p35.snk and p34.signedAnimation then
			p34.signedAnimation()
			p34.signedAnimation = nil
			t_billboard.Nickname.TextColor3 = Color3.new(1, 1, 1)
		end
	end
end
return PetCmds
  -  Editar
  04:54:13.862    -  Editar
  04:54:13.862  ----- [2585] ServerStorage.__STORAGE.Unused Modules.PetCmds -----  -  Editar
  04:54:13.862  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Pets
	===========
	TODO: Rescript the reset of this.
	===========

	===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Library = ReplicatedStorage:WaitForChild("Library")
local ClientLibrary = Library:WaitForChild("Client")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Shared = require(Library.Shared)
local Signal = require(Library.Signal)
local Directory = require(Library.Directory)
local Functions = require(Library.Functions)
local Variables = require(Library.Variables)
local Audio = require(Library.Audio)
local Save = require(ClientLibrary.Save)
local Network = require(ClientLibrary.Network)
local GUIFX = require(ClientLibrary.GUIFX)
local WorldCmds = require(ClientLibrary.WorldCmds)
local Pets = require(Modules.Pets)
local DefaultStats = require(Modules.DefaultStats)

--------|       Top       |--------
local PetCmds = {}

--------|     Setting     |--------
local WalkSounds = { 6840608566, 6840608533, 6840608598, 6840608504 }

--------|    Reference    |--------
local Assets = ReplicatedStorage:WaitForChild("Assets")
local X = ReplicatedStorage:WaitForChild("X")
local Players = game:GetService("Players")
local debris = workspace:WaitForChild("__DEBRIS")


--------|    Variables    |--------
local LeftistHeap = require(X:WaitForChild("Util").LeftistHeap)
local rng = Random.new()
local Indices = {}
local Pets = {}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function PetCmds.GetIndices(_index, save) 
	local Indice = Indices[_index]
	if Indice then
		return Indice
	end

	local pd = {}
	for index, pet in ipairs(save.Pets) do
		pd[pet.uid] = index
		if Pets[pet.uid] then  
			Pets[pet.uid] = _index
		end
	end

	Indices[_index] = pd
	return pd
end

function PetCmds.DeleteIndices(_index) 
	if Indices[_index] then
		Indices[_index] = nil
	end
end

function PetCmds.GetIndex(player, save, uid)
	local indices = PetCmds.GetIndices(player, save)
	return indices[uid]
end

function PetCmds.GetFrom(player, save, uid) 
	local _index = PetCmds.GetIndex(player, save, uid)
	if not _index then
		return nil, 0
	end
	assert(_index)

	local pets = save.Pets[_index]
	if not pets then
		return nil, 0
	end
	assert(pets)

	if uid ~= pets.uid then
		warn("Pet mismatch:", uid, _index, pets and pets.uid or "nil")
		return nil, 0
	end

	return pets, _index
end

function PetCmds.Get(uid) 
	debug.profilebegin("PetCmds.Get")

	local pet = Pets[uid]
	if pet then
		local save = Save.Get(pet)
		if save then
			local pets, _index = PetCmds.GetFrom(pet, save, uid)
			if pets then
				debug.profileend()
				return pets, pet, _index
			end
		end
		Pets[uid] = nil
	end

	for index, val2 in pairs(Save.GetSaves()) do
		local pets, _index = PetCmds.GetFrom(index, val2, uid)
		if pets then	
			Pets[uid] = index
			debug.profileend()
			return pets, index, _index
		end	
	end

	debug.profileend()
	return nil, nil, 0
end

Signal.Fired("Stats Removed"):Connect(function(player) 
	PetCmds.DeleteIndices(player)
	for index, _player in pairs(Pets) do
		if _player == player then
			Pets[index] = nil
		end	
	end
end)

function PetCmds.GetEquipped(plr, getData, includeIndex)
	local player
	if not plr then
		player = Players.LocalPlayer
	else
		assert(typeof(plr) == "Instance" and plr:IsA("Player") or false)
		player = plr
	end

	debug.profilebegin("PetCmds.GetEquipped")

	local Equipped = {}
	local save = Save.Get(player, true)
	if save then
		local pets = Shared.IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped

		if includeIndex then
			if getData then
				for index, data in pairs(pets) do
					if data then 
						Equipped[index] = true
					end
				end
			else
				for index, data in pairs(pets) do
					if data then 
						local pd = PetCmds.GetFrom(player, save, index)
						if pd then 
							Equipped[index] = pd
						end
					end
				end
			end
		elseif getData then
			for index, data in pairs(pets) do
				if data then  
					table.insert(Equipped, index)
				end
			end
		else
			for index, data in pairs(pets) do
				if data then 
					local pd = PetCmds.GetFrom(pets, save, index)
					if pd then 
						table.insert(Equipped, pd)
					end	
				end
			end
		end
	end
	debug.profileend()

	return Equipped
end 

function PetCmds.LocalEquipPet(player, uid, equip)  
	local save = Save.Get(player)
	if save then
		local changed = false
		local pets = Shared.IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped
		if equip then
			if not pets[uid] then
				pets[uid] = true
				changed = true
			end
		elseif pets[uid] then
			pets[uid] = nil
			changed = true
		end
		if changed then
			if player == Players.LocalPlayer then
				Signal.Fire("Pet Equips Changed")
				return
			end
			Signal.Fire("Other Pet Equips Changed", player)
		end
	end
end

Network.Fired("Pet Added"):Connect(function(player, pdata) 
	local save = Save.Get(player)
	if not save then
		return
	end
	assert(save)
	local PetIndices = PetCmds.GetIndices(player, save)
	table.insert(save.Pets, pdata)
	local petindice = #save.Pets
	PetIndices[pdata.uid] = petindice
	local islocalplayer = player == Players.LocalPlayer
	if islocalplayer then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", player, "Pets")
	end
	if islocalplayer then
		Signal.Fire("Stats Changed")
		return
	end
	Signal.Fire("Other Stats Changed", player)
end)


Network.Fired("Pet Removed"):Connect(function(player, uid) 
	local save = Save.Get(player)
	if not save then
		return 
	end
	assert(save)
	local playerPets = PetCmds.GetIndices(player, save)
	local pet = playerPets[uid]
	if not pet then
		return
	end
	assert(pet)
	local _pet = save.Pets[pet]
	if not _pet then
		return
	end
	assert(_pet)
	if uid ~= _pet.uid then 
		return
	end
	table.remove(save.Pets, pet)
	playerPets[uid] = nil
	for index = pet, #save.Pets do
		local __pet = save.Pets[index]
		if __pet then
			playerPets[__pet.uid] = index
		end
	end
	local IsLocalPlayer = player == Players.LocalPlayer
	if IsLocalPlayer then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", player, "Pets")
	end
	if IsLocalPlayer then
		Signal.Fire("Stats Changed")
	else
		Signal.Fire("Other Stats Changed", player)
	end
	PetCmds.LocalEquipPet(player, uid, false)
end)

Network.Fired("Pet Update"):Connect(function(player, pdata) 
	local save = Save.Get(player)
	if not save then
		return 
	end
	assert(save)
	local petindex = PetCmds.GetIndex(player, save, pdata.uid)
	if not petindex then
		return 
	end
	assert(petindex)
	local opdata = save.Pets[petindex]
	if not opdata then 
		return 
	end
	assert(opdata)
	if pdata.uid ~= opdata.uid then
		return
	end
	if Functions.DeepEqualsUnsafe(opdata, pdata) then
		return 
	end
	save.Pets[petindex] = pdata
	
	local islocalplayer = player == Players.LocalPlayer
	if islocalplayer then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", player, "Pets")
	end
	
	if islocalplayer then
		Signal.Fire("Stats Changed")
		return
	end
	
	Signal.Fire("Other Stats Changed", player)
end)

Network.Fired("Pet Equip Changed"):Connect(function(player, uid, equip)
	PetCmds.LocalEquipPet(player, uid, equip)
end)

function PetCmds.HasBestEquipped(player)
	assert(player == nil and true or typeof(player) == "Instance" and player:IsA("Player") or false)
	debug.profilebegin("PetCmds.HasBestEquipped")
	local save = Save.Get(player)
	if not save then
		debug.profileend()
		return false
	end
	assert(save)
	local playerEquipped = PetCmds.GetEquipped(player, true, true)
	local maxeqipslots = save.InfPetsEnabled and #save.Pets or Shared.GetMaxEquippedSlots(save)
	local n = LeftistHeap.new(Shared.PetOrderBest)
	for _, pet in ipairs(save.Pets) do
		if Directory.Pets[pet.id].isGift then
			continue 
		end
		n.insert(pet)
	end
	local hasbestequipped = true
	for index = 1, maxeqipslots do
		local v, pet = n.tryPop()
		if not v then 
			break 
		end
		if not playerEquipped[pet.uid] then
			hasbestequipped = false
			break
		end
	end
	debug.profileend()
	return hasbestequipped
end

function PetCmds.Match(pet, a) 
	assert(typeof(pet) == "table")
	if #a == 0 then
		return true
	end
	
	local dir = Directory.Pets[pet.id]
	if not dir then
		return false
	end
	local _match = {}
	if dir.rarity then
		table.insert(_match, dir.rarity)
	end
	if pet.sh then
		table.insert(_match, "Shiny")
	end
	if dir.name then
		table.insert(_match, dir.name)
	end
	if pet.nk then
		table.insert(_match, pet.nk)
	end
	
	return true
end

function PetCmds.Scaler(pet)  
	local scaler = pet.scaler
	if not scaler then
		scaler = Functions.Scaler()
		pet.scaler = scaler
	end
	assert(scaler)
	return scaler
end

function PetCmds.Spawn(p110, p111, p112, p113)
	-- upvalues: (copy) WorldCmds, (copy) Directory, (copy) Assets, (copy) Functions, (copy) GUIFX, (copy) Shared, (copy) Audio, (copy) rng
	debug.profilebegin("PetCmds.Spawn")
	assert(p110)
	assert(p111)
	local v114 = WorldCmds.Get()
	assert(v114)
	local v115 = Directory.Pets[p110.id]
	assert(v115)
	local v116 = p110.g == true
	local v117 = p110.r == true
	local v118 = p110.dm == true
	local v119 = p110.hc == true
	local v120 = p110.sh == true
	local Directory1 = (v116 and v115.modelGold or v115.model):Clone()
	if v115.replacements and p110.rep then
		for _, v122 in ipairs(p110.rep) do
			local v123 = v115.replacements[v122]
			if v123 then
				local v124 = v123.dst:Clone()
				local v125 = v123.src
				local v126
				if v125 then
					local v127 = Directory1:FindFirstChild(v125.Name)
					if v127 then
						v126 = v127.Parent or Directory1
						if v127:IsA("PVInstance") and v124:IsA("PVInstance") then
							v124:PivotTo(v127:GetPivot())
						end
						v127:Destroy()
					else
						v126 = Directory1
					end
				else
					v126 = Directory1
				end
				v124.Parent = v126
			end
		end
	end
	local v128 = { Directory1 }
	local v129 = {}
	for _, v130 in ipairs(Directory1:GetDescendants()) do
		if v130:IsA("BasePart") then
			table.insert(v128, v130)
			table.insert(v129, v130)
		end
	end
	local v131 = Directory1:FindFirstChildOfClass("SpecialMesh")
	assert(v131)
	local v132 = { v131 }
	for _, v133 in ipairs(v128) do
		local v134 = v133:FindFirstChildOfClass("SpecialMesh")
		if v134 and v134 ~= v131 then
			table.insert(v132, v134)
		end
	end
	local v135 = Directory1:WaitForChild("center")
	local v136 = Directory1:WaitForChild("bottom")
	local v137 = Directory1:FindFirstChild("mount", true)
	local v138 = Directory1:FindFirstChild("mount_character") or v137
	Directory1:SetAttribute("Owner", p111.Name)
	Directory1:SetAttribute("Dir", p110.id)
	Directory1:SetAttribute("ID", p110.uid)
	Directory1.Name = p110.uid
	local v139 = v131:GetAttribute("OriginalSize")
	if v139 then
		Directory1.Size = v139 * v131.Scale
	end
	Directory1.Anchored = true
	for _, v140 in ipairs(v128) do
		v140.Massless = true
		v140.CanCollide = false
		v140.CanQuery = true
		v140.CanTouch = true
		v140.CastShadow = false
		if v140.Material == Enum.Material.SmoothPlastic then
			v140.Material = Enum.Material.Plastic
			v140.MaterialVariant = ""
			if v115.balloon or p110.sh then
				v140.Material = Enum.Material.Metal
				v140.MaterialVariant = "MetalFineGold"
			end
			if v115.evolved then
				v140.Material = Enum.Material.SmoothPlastic
				v140.MaterialVariant = ""
			end
		end
		if v115.weld then
			v140.Anchored = true
		end
	end
	local v141 = p113 or Vector3.one
	local v142 = v131.Offset
	local v143 = v135.CFrame
	local v144 = CFrame.new(v142.X, v143.Y, v143.Z) * CFrame.fromOrientation(0, 1.5707963267948966, 0)
	v135.CFrame = v144
	local v145 = v136.CFrame
	local v146
	if v139 then
		v146 = CFrame.new(v144.X, -Directory1.Size.Y / 2 + v142.Y, v144.Z)
	else
		v146 = CFrame.new(v144.X, v145.Y, v144.Z)
	end
	v136.CFrame = v146 * CFrame.fromOrientation(0, 1.5707963267948966, 0)
	for _, v147 in ipairs(v132) do
		if v147.VertexColor == Vector3.one then
			v147.VertexColor = Vector3.new(1.125, 1.125, 1.125)
		end
	end
	if v116 then
		for _, v148 in ipairs(v132) do
			v148.VertexColor = Vector3.new(1.45, 1.45, 1.45)
		end
		for _, v149 in ipairs(Assets.Particles:WaitForChild("Golden Pet"):GetChildren()) do
			v149:Clone().Parent = Directory1
		end
	end
	local v150 = {}
	local v151 = {}
	if v117 then
		local v152 = Assets.Particles:WaitForChild("Rainbow Pet"):WaitForChild("Sparkles"):Clone()
		v152.Name = "__RAINBOWPARTICLES"
		v152.Parent = Directory1
		table.insert(v151, v152)
		for _, v153 in ipairs(v128) do
			local v154 = Assets.Other:WaitForChild("Rainbow Pet"):WaitForChild("Decal"):Clone()
			v154.Name = "__RAINBOWFX"
			v154.Parent = v153
			table.insert(v150, v154)
		end
		for _, v155 in ipairs(v132) do
			v155.VertexColor = Vector3.new(2, 2, 2)
		end
	end
	if v118 then
		for _, v156 in ipairs(v132) do
			if v119 then
				v156.VertexColor = Vector3.new(0.8, 20, 20)
			else
				v156.VertexColor = Vector3.new(20, 0.6, 20)
			end
		end
	end
	local v157 = v115.colorVariants and p110.cv and v115.colorVariants[p110.cv]
	if v157 then
		local v158 = v157.Color
		local v159 = Functions.Map3(Vector3.new(v158.R, v158.G, v158.B) * v157.Magnitude, Vector3.zero, Vector3.one, Vector3.new(0.1, 0.1, 0.1), Vector3.one)
		for _, v160 in ipairs(v132) do
			v160.VertexColor = v159
		end
		local Save1 = {
			{
				["a"] = Color3.new(1, 1, 1), 
				["b"] = v158
			}
		}
		local function v165(p162)
			-- upvalues: (ref) Functions, (copy) Save1
			local v163 = {}
			for _, v164 in ipairs(p162.Keypoints) do
				table.insert(v163, ColorSequenceKeypoint.new(v164.Time, (Functions.Recolor(v164.Value, Save1))))
			end
			return ColorSequence.new(v163)
		end
		for _, v166 in ipairs(Directory1:GetDescendants()) do
			if v166:IsA("ParticleEmitter") then
				v166.Color = v165(v166.Color)
			elseif v166:IsA("Trail") then
				v166.Color = v165(v166.Color)
			elseif v166:IsA("Light") then
				v166.Color = Functions.Recolor(v166.Color, Save1)
			end
		end
	end
	local v167 = nil
	if p110.vc then
		v167 = Vector3.new(table.unpack(p110.vc))
	elseif v115.vertexColor then
		v167 = v115.vertexColor
	end
	if v167 then
		local Save8 = Color3.new(v167.X, v167.Y, v167.Z)
		for _, v169 in ipairs(v132) do
			v169.VertexColor = v167
		end
		local function v174(p170)
			-- upvalues: (copy) Save8, (ref) Functions
			local v171 = {
				{
					["a"] = Color3.new(1, 1, 1), 
					["b"] = Save8
				}
			}
			local v172 = {}
			for _, v173 in ipairs(p170.Keypoints) do
				table.insert(v172, ColorSequenceKeypoint.new(v173.Time, (Functions.Recolor(v173.Value, v171))))
			end
			return ColorSequence.new(v172)
		end
		for _, v175 in ipairs(Directory1:GetDescendants()) do
			if v175:IsA("ParticleEmitter") then
				v175.Color = v174(v175.Color)
			elseif v175:IsA("Trail") then
				v175.Color = v174(v175.Color)
			end
		end
	end
	local v176 = {}
	if v119 then
		for _, v177 in ipairs((Assets.Particles["Hardcore Pets"]:GetChildren())) do
			v177:Clone().Parent = v135
		end
		if not (v117 or v118) then
			for _, _ in ipairs(v128) do
				local v178 = Assets.Other:WaitForChild("Hardcore Pet"):WaitForChild("Decal"):Clone()
				v178.Name = "__HARDCOREFX"
				v178.Parent = Directory1
				table.insert(v176, v178)
			end
		end
		v141 = v141 * 1.25
	end
	if p110.id == "294" then
		v141 = v141 * (0.2 + 1.3 * math.random())
	end
	if v120 then
		local v_u_179
		if v115.titanic then
			v_u_179 = Assets.Particles.Shiny:WaitForChild("TitanicShinyParticle"):Clone()
			Functions.Scaler()(v_u_179, 3.25)
		elseif v115.huge then
			v_u_179 = Assets.Particles.Shiny:WaitForChild("HugeShinyParticle"):Clone()
			Functions.Scaler()(v_u_179, 1.5)
		else
			v_u_179 = Assets.Particles.Shiny:WaitForChild("ShinyParticle"):Clone()
		end
		v_u_179.Parent = v135
		task.defer(function()
			-- upvalues: (ref) v_u_179
			v_u_179:Emit(1)
		end)
	end
	local v180 = string.find(v115.name, "Pixel") ~= nil and "Pixel" or nil
	local v181 = nil
	local v182
	if p112 then
		v182 = nil
	else
		v182 = Assets.Billboards.Pet:Clone()
		v182.Name = "__BILLBOARD"
		v182.Nickname.AutoLocalize = false
		v182.Nickname.Text = p110.nk or ""
		v182.StudsOffset = Vector3.new(0, (v135.Position - v136.Position).Y * 2, 0)
		if p110.snk then
			v181 = GUIFX.Rainbow(v182.Nickname, "TextColor3", 3)
		end
		if 2 <= Shared.PetRarityNumbers[v115.rarity] then
			local v183 = v182.Rarity
			v183.Text = v115.rarity
			Shared.ApplyRarityColor(v183, v115.rarity)
			v183.Visible = true
			v182.StudsOffset = v182.StudsOffset + Vector3.new(0, 1, 0)
		end
		v182.Parent = Directory1
	end
	local v184 = {}
	if v115.weld then
		for _, v185 in ipairs(v129) do
			local v186 = v185:FindFirstAncestorWhichIsA("Model")
			local v187
			if v186 then
				v187 = v186.PrimaryPart
			else
				v187 = nil
			end
			local v188 = v187 or v185:FindFirstAncestorWhichIsA("BasePart") or v185.AssemblyRootPart or Directory1
			assert(v188)
			local v189 = v188:GetPivot():ToObjectSpace(v185:GetPivot())
			local v190 = v185:GetAttribute("RotationRate")
			if v190 then
				v190 = v190 * math.pi / 180
			end
			v184[v185] = {
				["part"] = v185, 
				["root"] = v188, 
				["offset"] = v189, 
				["lastOffset"] = v189, 
				["scaling"] = not v188:GetAttribute("NoScale"), 
				["rotationRate"] = v190
			}
		end
	end
	task.defer(function()
		-- upvalues: (ref) Audio, (copy) Directory1, (ref) rng, (ref) Functions, (ref) Assets
		Audio.Play("rbxassetid://7000720081", Directory1, rng:NextNumber(0.95, 1.05), 0.125, 125)
		local v191, v192 = Functions.Emit(Directory1, nil, Assets.Particles:WaitForChild("Pet Spawn"))
		for _, v193 in ipairs(v191) do
			Functions.AddDebris(v193, v192)
		end
	end)
	local v194 = Vector3.one
	local v195 = Vector3.one * v141
	local v196
	if v194 == v195 then
		v195 = v194
		v196 = nil
	else
		v196 = Functions.Scaler(nil, function(p197)
			return not p197:GetAttribute("NoScale")
		end)
		assert(v196)
		v196(Directory1, v195)
	end
	debug.profileend()
	return {
		["id"] = p110.id, 
		["uid"] = p110.uid, 
		["golden"] = v116, 
		["rainbow"] = v117, 
		["darkMatter"] = v118, 
		["shiny"] = v120, 
		["hardcore"] = v119, 
		["world"] = v114, 
		["owner"] = p111, 
		["part"] = Directory1, 
		["mesh"] = v131, 
		["meshes"] = v132, 
		["childParts"] = v129, 
		["scriptedWelds"] = v184, 
		["center"] = v135, 
		["bottom"] = v136, 
		["mount"] = v137, 
		["mountCharacter"] = v138, 
		["rainbowParticles"] = v151, 
		["rainbowDecals"] = v150, 
		["hardcoreDecals"] = v176, 
		["specialType"] = v180, 
		["billboard"] = v182, 
		["signedAnimation"] = v181, 
		["scale"] = v195, 
		["overrideScale"] = v141, 
		["scaler"] = v196, 
		["moving"] = false, 
		["farming"] = false, 
		["movingTick"] = 0, 
		["spinTick"] = 0, 
		["jumping"] = false, 
		["riding"] = false
	}
end
function PetCmds.BasketballBounce(p198, p199, p200, p201)
	local v202 = p198 % p199
	return (p200 - v202) * math.exp(-v202) * math.abs((math.sin(math.pi * p201 * p198)))
end
function PetCmds.Effects(p_u_203, p204, p205, p206, p207)
	-- upvalues: (copy) Directory, (copy) v_u_2, (copy) rng, (copy) Audio, (copy) Variables, (copy) v_u_9, (copy) Functions, (copy) v_u_1, (copy) GUIFX
	debug.profilebegin("PetCmds.Effects")
	local v208 = Directory.Pets[p_u_203.id]
	assert(v208)
	local v_u_209 = p_u_203.part
	local v210 = Vector3.one
	local v211 = p_u_203.world == "Void"
	local v212 = p_u_203.walkSoundTick or p205
	p_u_203.walkSoundTick = v212
	local v213 = v211 and 0.65 or 0.3
	local v214 = 1
	if v211 then
		v214 = v214 * 0.4090909090909091
	end
	if v208.balloon then
		v214 = v214 * 0.5
	end
	if v208.jelly then
		v214 = v214 * 0.5
	end
	if p_u_203.moving and not v208.fly and not p_u_203.jumping and p_u_203.movingTick % v213 / v214 <= 0.1 and 0.2 < p205 - v212 then
		p_u_203.walkSoundTick = p205
		local v215 = v208.sounds.walk or WalkSounds
		if 0 < #v215 then
			local rng6 = v215[math.random(1, #v215)]
			local rng7 = rng:NextNumber(0.95, 1.2)
			local rng8 = 0.01
			if p_u_203.riding then
				rng7 = rng7 * 0.75
				rng8 = rng8 * 5
			end
			task.spawn(function()
				-- upvalues: (ref) Audio, (copy) rng6, (copy) v_u_209, (ref) rng7, (ref) rng8
				Audio.Play(rng6, v_u_209, rng7, rng8, 60)
			end)
		end
	end
	local v219 = p_u_203.randomSoundTick or p205
	p_u_203.randomSoundTick = v219
	if not p_u_203.moving and rng:NextNumber() <= 0.001 and 6 <= p205 - v219 and Variables.PetSoundsEnabled then
		p_u_203.randomSoundTick = p205
		local v220 = v208.sounds.random
		if 0 < #v220 then
			local v_u_221 = v220[math.random(1, #v220)]
			task.spawn(function()
				-- upvalues: (ref) Audio, (copy) v_u_221, (copy) v_u_209
				Audio.Play(v_u_221, v_u_209, 1, 0.5, 140)
			end)
		end
	end
	local v222 = p_u_203.specialType
	if v222 and v222 == "Pixel" and p_u_203.moving and not v208.fly and rng:NextInteger(1, 10) == 1 then
		(function()
			-- upvalues: (ref) rng, (copy) v_u_209, (copy) p_u_203, (ref) v_u_9, (ref) Functions
			debug.profilebegin("Pets.Tick.MakeCube")
			local v223 = Instance.new("Part")
			v223.Anchored = true
			v223.Massless = true
			v223.CanCollide = false
			v223.CastShadow = false
			v223.Size = Vector3.one * rng:NextNumber(0.4, 0.66)
			v223.Color = Color3.fromRGB(255, 255, 255)
			v223.CFrame = v_u_209.CFrame + Vector3.new(rng:NextNumber(-1, 1), p_u_203.bottom.CFrame.Y + rng:NextNumber(-1, 1), rng:NextNumber(-1, 1))
			v223.Name = "pixelFX"
			v223.Parent = debris
			local v224 = rng:NextNumber(0.33, 0.6)
			Functions.Tween(v223, {
				["Size"] = v223.Size * rng:NextNumber(0.25, 0.4), 
				["CFrame"] = v223.CFrame * CFrame.new(0, 0, rng:NextNumber(1, 2)) + Vector3.new(0, rng:NextNumber(0.25, 1.5), 0)
			}, { v224, "Linear" })
			Functions.AddDebris(v223, v224)
			debug.profileend()
		end)()
	end
	if p_u_203.rainbow then
		local _ = p_u_203.highlight
		local v225 = Color3.fromHSV(p205 / 1.5 % 1, 1, 1)
		local v226 = ColorSequence.new(v225)
		for _, v227 in ipairs(p_u_203.rainbowParticles) do
			v227.Color = v226
		end
		for _, v228 in ipairs(p_u_203.rainbowDecals) do
			v228.Color3 = v225
		end
	end
	if p_u_203.darkMatter then
		local v229 = math.sin(p205)
		if p_u_203.hardcore then
			local v230 = 0.8 + v229 * 0.2
			for _, v231 in ipairs(p_u_203.meshes) do
				v231.VertexColor = Vector3.new(v230, 13 + 7 * v229, 15 + 5 * v229)
			end
		else
			local v232 = not p_u_203.shiny and 0.6 or 0.75 + math.sin(p205) * 0.2
			for _, v233 in ipairs(p_u_203.meshes) do
				v233.VertexColor = Vector3.new(15 + 5 * v229, v232, 13 + 7 * v229)
			end
		end
	end
	if p_u_203.shiny then
		if p_u_203.golden then
			local v234 = math.sin(p205) * 0.25
			for _, v235 in ipairs(p_u_203.meshes) do
				v235.VertexColor = Vector3.new(2.2 + v234, 2.2 + v234, 2.2 + v234)
			end
		elseif not (p_u_203.golden or p_u_203.rainbow or p_u_203.darkMatter) then
			local v236 = math.sin(p205) * 0.2
			for _, v237 in ipairs(p_u_203.meshes) do
				v237.VertexColor = Vector3.new(1.8 + v236, 1.8 + v236, 1.8 + v236)
			end
		end
	end
	if p_u_203.hardcore then
		local v238 = math.sin(p205 * 5) * 0.2 + 0.8
		for _, v239 in ipairs(p_u_203.hardcoreDecals) do
			v239.Transparency = v238
		end
	end
	if v208.christmasLights then
		local v240 = math.floor(p205) % 2 == 0
		local v241 = v_u_209:FindFirstChild("LightsA")
		local v242 = v_u_209:FindFirstChild("LightsB")
		local v243, v244
		if p_u_203.golden then
			v243 = v240 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v244 = v240 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		elseif p_u_203.darkMatter then
			v243 = v240 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v244 = v240 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		else
			v243 = v240 and Color3.fromRGB(126, 255, 0) or Color3.fromRGB(255, 44, 26)
			v244 = v240 and Color3.fromRGB(255, 44, 26) or Color3.fromRGB(126, 255, 0)
		end
		v241.Color = v243
		v242.Color = v244
	end
	if p_u_203.id == "402" then
		local v245 = v_u_209:FindFirstChild("Back")
		if v245 and v245:IsA("Attachment") then
			local v246 = v245:FindFirstChild("Sparkles")
			if v246 and v246:IsA("ParticleEmitter") then
				v246.Enabled = p_u_203.moving
			end
		end
	end
	if v208.balloon then
		local v247 = v208.balloonScale or Vector3.one
		v210 = v210 * (v247 * Functions.Lerp(0.95, 1.05, (1 + math.sin(p205 * (v208.flySpeed or 1) * (v208.balloonSpeed or 1) * 4)) / 2) + Vector3.one - v247)
	end
	if v208.jelly then
		local v248 = 5.5 / 2 * math.pi * 2
		local v249, v250 =  0, 0.025
		if p_u_203.moving or p_u_203.farming then
			--v249 = 1
			--v250 = 0.15 --0.14285714285714285 
			v249 = 0.15 --0.14987624
			v250 = 1
		else
			v249 = 0
			v250 = 0.025
		end
		local v251 = 1 - math.pow(1 - v250, p206 * 60)
		local v252 = (p_u_203.jellyMoving or v249) * (1 - v251) + v249 * v251
		p_u_203.jellyMoving = v252
		local v253 = (p_u_203.jellyTick or 0) + p206 * (0.3 * (1 - v252) + v248 * v252)
		p_u_203.jellyTick = v253
		local v254 = 1 * (1 - v252) + 1.25 * v252
		local v255 = 2 * math.pi * v253
		local v256 = Functions.Map(math.sin(v255 + math.pi / 4), -1, 1, 0.9, 1.1) * v254
		v210 = v210 * Vector3.new(v256, Functions.Map(math.sin(v255), -1, 1, 0.8, 1.2) * v254, v256)
	end
	if p_u_203.id == "988" or p_u_203.id == "989" then
		local v257 = { "rbxassetid://13560436163", "rbxassetid://13560436029", "rbxassetid://13560435915" }
		if p_u_203.mesh.TextureId == "rbxassetid://13560728786" and math.random() < 0.01 then
			p_u_203.mesh.TextureId = v257[math.random(1, #v257)]
			task.delay(0.1, function()
				-- upvalues: (copy) p_u_203
				if p_u_203 and p_u_203.part.Parent and p_u_203.mesh then
					p_u_203.mesh.TextureId = "rbxassetid://13560728786"
				end
			end)
		end
	end
	local v258 = v210 * p_u_203.overrideScale
	if p_u_203.scale ~= v258 then
		p_u_203.scale = v258
		local v259 = p_u_203.scaler
		if not v259 then
			v259 = Functions.Scaler(nil, function(p260)
				local noscale = p260:GetAttribute("NoScale")
				return not noscale
			end)
			p_u_203.scaler = v259
		end
		assert(v259)
		v259(v_u_209, v258)
	end
	if p207 then
		for _, v261 in pairs(p_u_203.scriptedWelds) do
			local v262 = v261.part
			local v263 = v261.offset
			if v261.scaling then
				v263 = v263 - v263.Position + v263.Position * p_u_203.scale
			end
			local v264 = v261.rotationRate
			if v264 then
				local v265 = v264 * p205
				v263 = v263 * CFrame.fromOrientation(v265.X, v265.Y, v265.Z)
			end
			if p_u_203.id == "606" or p_u_203.id == "2148" then
				if v262.Name == "Basketball" then
					v263 = v263 + Vector3.new(0, PetCmds.BasketballBounce(p205, 3, p_u_203.id == "606" and 2 or 5, 2), 0) * p_u_203.scale
				end
			end
			if p_u_203.id == "630" or p_u_203.id == "631" then
				if v262.Name == "Beachball" then
					v263 = v263 + Vector3.new(0, PetCmds.BasketballBounce(p205, 3, (p_u_203.id == "630" or p_u_203.id == "631") and 2 or 5, 2), 0) * p_u_203.scale
				end
			end
			v262:PivotTo((v261.root:GetPivot():ToWorldSpace(v263)))
		end
	end
	if v208.flipbookAnimationSpeed then
		local v266
		if p_u_203.golden then
			v266 = v208.flipbookAnimationGold
		else
			v266 = v208.flipbookAnimation
		end
		assert(v266)
		local v267 = v266[1 + (math.floor(p205 / v208.flipbookAnimationSpeed) - 1) % #v266]
		local v268 = p_u_203.mesh
		if v268.TextureId ~= v267 then
			v268.TextureId = v267
		end
	end
	local v269 = p_u_203.billboard
	if v269 and p204 then
		if not p_u_203.nicknameUpdateTick or p_u_203.nicknameUpdateTick <= p205 then
			v269.Nickname.Text = p204.nk or ""
			p_u_203.nicknameUpdateTick = p205 + 2 + 2 * math.random()
		end
		if p204.snk and not p_u_203.signedAnimation then
			p_u_203.signedAnimation = GUIFX.Rainbow(v269.Nickname, "TextColor3", 3)
		elseif not p204.snk and p_u_203.signedAnimation then
			p_u_203.signedAnimation()
			p_u_203.signedAnimation = nil
			v269.Nickname.TextColor3 = Color3.new(1, 1, 1)
		end
	end
	debug.profileend()
end
return PetCmds
  -  Editar
  04:54:13.862    -  Editar
  04:54:13.862  ----- [2586] ServerStorage.__STORAGE.Unused Modules.TheseStupidThingsDontWorkInPSXfiles....Network -----  -  Editar
  04:54:13.863  -- Decompiled with the Synapse X Luau decompiler.

local v1 = game:GetService("RunService"):IsStudio();
local v2 = game.JobId;
if #v2 == 0 then
	v2 = "00000000-0000-0000-0000-000000000000";
end;
local u1 = { {}, {} };
local u2 = { {}, {}, {}, {} };
local u3 = { "BindableEvent", "BindableFunction", "BindableEvent", "BindableFunction" };
local function u4(p1, p2, p3)
	local v3 = u2[p1];
	local v4 = v3[p2];
	if not v4 and p3 then
		v4 = Instance.new(u3[p1]);
		v4.Parent = script;
		v3[p2] = v4;
	end;
	return v4;
end;
local function u5(p4, p5)
	assert(typeof(p4) == "number");
	assert(typeof(p5) == "string");
	local v5 = u1[p4];
	local v6 = v5[p5];
	if not v6 then
		v6 = (function(p6)
			local function v7(p7, p8, p9, p10)
				return bit32.lshift(p7, 24) + bit32.lshift(p8, 16) + bit32.lshift(p9, 8) + p10;
			end;
			local function v8(p11, p12, p13, p14)
				if p11 <= 19 then
					return bit32.bxor(p14, bit32.band(p12, bit32.bxor(p13, p14)));
				end;
				if p11 <= 39 then
					return bit32.bxor(p12, p13, p14);
				end;
				if not (p11 <= 59) then
					return bit32.bxor(p12, p13, p14);
				end;
				return bit32.bor(bit32.band(p12, bit32.bor(p13, p14)), bit32.band(p13, p14));
			end;
			local function v9(p15)
				if p15 <= 19 then
					return 1518500249;
				end;
				if p15 <= 39 then
					return 1859775393;
				end;
				if p15 <= 59 then
					return 2400959708;
				end;
				return 3395469782;
			end;
			local v10 = #p6 * 8;
			local v11 = v10 + 8;
			local v12 = 4;
			p6 = p6 .. string.char(128);
			while (v11 + 64) % 512 ~= 0 do
				v12 = v12 + 1;
				v11 = v11 + 8;			
			end;
			p6 = p6 .. string.rep("\000", v12);
			p6 = p6 .. string.char((function(p16)
				return bit32.extract(p16, 24, 8), bit32.extract(p16, 16, 8), bit32.extract(p16, 8, 8), bit32.extract(p16, 0, 8);
			end)(v10));
			local v13 = 1732584193;
			local v14 = 4023233417;
			local v15 = 2562383102;
			local v16 = 271733878;
			local v17 = 3285377520;
			local v18 = {};
			local v19 = 1;
			local v20 = #p6;
			if not (v20 <= v19) then
				while true do
					local v21 = v19;
					local v22 = 0;
					if not (v22 >= 15) then
						while true do
							v18[v22] = v7(string.byte(p6, v21, v21 + 3));
							v21 = v21 + 4;
							local v23 = v22 + 1;
							v22 = v23;
							if v23 > 15 then
								break;
							end;						
						end;
					end;
					local v24 = 16;
					if not (v24 >= 79) then
						while true do
							v18[v24] = bit32.lrotate(bit32.bxor(v18[v24 - 3], v18[v24 - 8], v18[v24 - 14], v18[v24 - 16]), 1);
							local v25 = v24 + 1;
							v24 = v25;
							if v25 > 79 then
								break;
							end;						
						end;
					end;
					local v26 = v13;
					local v27 = v14;
					local v28 = v15;
					local v29 = v16;
					local v30 = v17;
					local v31 = 0;
					if not (v31 >= 79) then
						while true do
							v30 = v29;
							v29 = v28;
							v28 = bit32.lrotate(v27, 30);
							v27 = v26;
							v26 = (bit32.lrotate(v26, 5) + v8(v31, v27, v28, v29) + v30 + v18[v31] + v9(v31)) % 4294967296;
							local v32 = v31 + 1;
							v31 = v32;
							if v32 > 79 then
								break;
							end;						
						end;
					end;
					v13 = (v13 + v26) % 4294967296;
					v14 = (v14 + v27) % 4294967296;
					v15 = (v15 + v28) % 4294967296;
					v16 = (v16 + v29) % 4294967296;
					v17 = (v17 + v30) % 4294967296;
					local v33 = v19 + 64;
					v19 = v33;
					if v20 < v33 then
						break;
					end;				
				end;
			end;
			return string.format("%08x%08x%08x%08x%08x", v13, v14, v15, v16, v17):reverse():sub(5, 36);
		end)("Network3/" .. "/" .. game.GameId .. "/" .. game.PlaceId .. "/" .. game.PlaceVersion .. "/" .. v2 .. "/" .. p4 .. "/" .. p5);
		v5[p5] = v6;
	end;
	return v6;
end;
local u6 = { {}, {} };
local l__ReplicatedStorage__7 = game:GetService("ReplicatedStorage");
local u8 = { "RemoteEvent", "RemoteFunction" };
local u9 = { function(p17, p18)
	local v34 = u4(1, p17, false);
	if v34 then
		p18.OnClientEvent:Connect(function(...)
			v34:Fire(...);
		end);
	end;
	local v35 = u4(3, p17, false);
	if not v35 then
		return;
	end;
	v35.Event:Connect(function(...)
		p18:FireServer(...);
	end);
end, function(p19, p20)
	local v36 = u4(2, p19, false);
	if v36 then
		function p20.OnClientInvoke(...)
			return v36:Invoke(...);
		end;
	end;
	local v37 = u4(4, p19, false);
	if not v37 then
		return;
	end;
	function v37.OnInvoke(...)
		return p20:InvokeServer(...);
	end;
end };
local function u10(p21, p22)
	local v38 = u6[p21];
	local v39 = v38[p22];
	if v39 then
		return v39;
	end;
	local v40 = l__ReplicatedStorage__7:FindFirstChild(p22);
	if not v40 then
		return nil;
	end;
	v40.Name = u8[p21];
	v38[p22] = v40;
	u9[p21](p22, v40);
	return v40;
end;
local v41 = {};
local function u11(p23)
	local v42 = nil;
	for v43, v44 in ipairs({ function()
			if pcall(settings) then
				return "pcall(settings)";
			end;
			return nil;
		end, function()
			local u12 = { game:GetService("ReplicatedFirst"), game:GetService("ReplicatedStorage"), game:GetService("Players"), game:GetService("Workspace") };
			local u13 = nil;
			local v46, v47 = pcall(function()
				local v48 = rawget(getfenv(6), "script");
				assert(typeof(v48) == "Instance");
				assert(v48:IsA("ModuleScript") or (v48:IsA("Script") or v48:IsA("LocalScript")));
				local v49 = false;
				for v50, v51 in ipairs(u12) do
					local v53 = nil; 
					if not v50 then
						v53 = v49;
						if v53 then
							return nil;
						else
							u13 = string.format("callerScript:badpath:'%s'", v48:GetFullName());
							return nil;
						end;
					end;
					if v51:IsAncestorOf(v48) then
						v49 = true;
						v53 = v49;
						if v53 then
							return nil;
						else
							u13 = string.format("callerScript:badpath:'%s'", v48:GetFullName());
							return nil;
						end;
					end;				
				end;
			end);
			if not v46 and not u13 then
				u13 = string.format("callerScript:err:'%s'", tostring(v47));
			end;
			return nil;
		end, function()
			local v54 = debug.info(2, "s");
			if v54 == nil then
				return "callerScriptName:nil";
			end;
			if v54 ~= "" and v54 ~= "[C]" then
				return nil;
			end;
			return string.format("callerScriptName:'%s'", v54);
		end, function()
			local v55 = 0;
			while true do
				local v56, v57 = pcall(getfenv, v55);
				if not v56 then
					break;
				end;
				if typeof(v57) == "table" and v57.getgenv ~= nil then
					return "getgenv";
				end;
				v55 = v55 + 1;			
			end;
			return nil;
		end }) do
		v42 = v44();
		if v42 then
			break;
		end;	
	end;
	if v42 == nil then
		return true;
	end;
	local v58 = string.format("Debug|%s|%s '%s' [%s]: %s", "Network", tostring(debug.info(2, "n")), tostring(v42), tostring(p23), tostring(debug.traceback()));
	return false;
end;
local function u14(p24)
	return u10(1, u5(1, p24));
end;
local function u15(p25)
	return u4(3, u5(1, p25), true);
end;
function v41.Fire(p26, ...)
	if not u11(p26) then
		return;
	end;
	local v59 = u14(p26);
	if v59 then
		task.spawn(function(...)
			v59:FireServer(...);
		end, ...);
		return;
	end;
	local u16 = u15(p26);
	task.spawn(function(...)
		u16:Fire(...);
	end, ...);
end;
local function u17(p27)
	return u4(1, u5(1, p27), true);
end;
function v41.Fired(p28)
	if not u11(p28) then
		return Instance.new("BindableEvent").Event;
	end;
	local v60 = u14(p28);
	if v60 then
		return v60.OnClientEvent;
	end;
	return u17(p28).Event;
end;
local function u18(p29)
	return u10(2, u5(2, p29));
end;
local function u19(p30)
	return u4(4, u5(2, p30), true);
end;
function v41.Invoke(p31, ...)
	if not u11(p31) then
		return;
	end;
	local v61 = u18(p31);
	if v61 then
		return v61:InvokeServer(...);
	end;
	return u19(p31):Invoke(...);
end;
local function u20(p32)
	return u4(2, u5(2, p32), true);
end;
function v41.Invoked(p33)
	local v62 = nil;
	if not u11(p33) then
		return Instance.new("BindableFunction");
	end;
	if not u4(2, u5(2, p33), false) then
		v62 = u18(p33);
		if not v62 then
			return u20(p33);
		end;
	else
		return u20(p33);
	end;
	local v63 = {};
	function v63.__newindex(p34, p35, p36)
		if p35 == "OnInvoke" then
			p35 = "OnClientInvoke";
		elseif p35 == "OnClientInvoke" then
			error(string.format("%s is not a valid member of BindableFunction \"BindableFunction\"", tostring(p35)));
		end;
		v62[p35] = p36;
	end;
	function v63.__index(p37, p38)
		if p38 == "OnInvoke" then
			p38 = "OnClientInvoke";
		elseif p38 == "OnClientInvoke" then
			error(string.format("%s is not a valid member of BindableFunction \"BindableFunction\"", tostring(p38)));
		end;
		return v62[p38];
	end;
	return setmetatable({}, v63);
end;
local function v64(p39)
	for v65, v66 in pairs(u6) do
		if not v65 then
			return;
		end;
		if p39:IsA(u8[v65]) then
			local l__Name__67 = p39.Name;
			if v66[l__Name__67] == nil then
				v66[l__Name__67] = p39;
				p39.Name = u8[v65];
				u9[v65](l__Name__67, p39);
				return;
			else
				return;
			end;
		end;
	end;
end;
l__ReplicatedStorage__7.ChildAdded:Connect(v64);
for v68, v69 in ipairs(l__ReplicatedStorage__7:GetChildren()) do
	v64(v69);
end;
table.freeze(v41);
task.spawn(function(p40)
	local v71 = table.clone(p40);
	setmetatable(v71, nil);
	local asdc = getmetatable(p40);
	if asdc then
		asdc = table.clone(asdc);
	end
	local function v72(p41, p42)
		if p41 == p42 then
			return true;
		end;
		if typeof(p41) ~= "table" or typeof(p42) ~= "table" then
			return false;
		end;
		for v73, v74 in pairs(p42) do
			if rawget(p41, v73) ~= v74 then
				break;
			end;
		end;
		return false;
	end;
	while v72(getmetatable(p40), asdc) and v72(p40, v71) do
		task.wait(math.random() * 15 + 1);	
	end;
end, v41);
local function u21(p43)

end;
task.spawn(function(p44)
	local v76 = p44();
	local v77 = table.clone(v76);
	setmetatable(v77, nil);
	--local v78 = getmetatable(v76) and table.clone(v78);
	local v78 = getmetatable(p44);
	if v78 then
		v78 = table.clone(v78);
	end
	local function v79(p45, p46)
		if p45 == p46 then
			return true;
		end;
		if typeof(p45) ~= "table" or typeof(p46) ~= "table" then
			return false;
		end;
		for v80, v81 in pairs(p46) do
			if rawget(p45, v80) ~= v81 then
				break;
			end;
		end;
		return false;
	end;
	while true do
		local v82 = p44();
		if not v79(getmetatable(v82), v78) then
			break;
		end;
		if not v79(v82, v77) then
			break;
		end;
		task.wait(math.random() * 15 + 1);	
	end;
end, function()
	return { false, false, v1, false, false, u21, v2, l__ReplicatedStorage__7, 1, 2, u1, 1, 2, 3, 4, u2, u3, u4, u17, u15, u20, u19, u9, u6, u8, u10, u14, u18, u11, v64 };
end);
return (function(p47)
	local v83 = {};
	function v83.__index(p48, p49)
		return p47[p49];
	end;
	function v83.__newindex(p50, p51, p52)

	end;
	v83.__metatable = {};
	return setmetatable({}, v83);
end)(v41);
  -  Editar
  04:54:13.863    -  Editar
  04:54:13.863  ----- [2587] ServerStorage.__STORAGE.Unused Modules.TheseStupidThingsDontWorkInPSXfiles....Network -----  -  Editar
  04:54:13.863  -- Decompiled with the Synapse X Luau decompiler.

return {
	Fire = function(p1)
		error("Unimplemented");
	end, 
	FireAll = function(p2)
		error("Unimplemented");
	end, 
	Fired = function(p3)
		error("Unimplemented");
	end, 
	Invoke = function(p4)
		error("Unimplemented");
	end, 
	Invoked = function(p5)
		error("Unimplemented");
	end
};
  -  Editar
  04:54:13.863    -  Editar
  04:54:13.863  ----- [2588] ServerStorage.__STORAGE.Unused Modules.TheseStupidThingsDontWorkInPSXfiles....Network -----  -  Editar
  04:54:13.863  -- Decompiled with the Synapse X Luau decompiler.

local v1 = game.JobId;
if #v1 == 0 then
	v1 = "00000000-0000-0000-0000-000000000000";
end;
local v2 = { "E", "F" };
local u1 = { {}, {} };
local u2 = require(script.SHA1);
local u3 = { {}, {} };
local u4 = { "RemoteEvent", "RemoteFunction" };
local l__ReplicatedStorage__5 = game:GetService("ReplicatedStorage");
local function u6(p1, p2)
	assert(typeof(p1) == "number");
	assert(typeof(p2) == "string");
	local v3 = u1[p1];
	local v4 = v3[p2];
	if not v4 then
		v4 = u2("Network3/" .. "/" .. game.GameId .. "/" .. game.PlaceId .. "/" .. game.PlaceVersion .. "/" .. v1 .. "/" .. p1 .. "/" .. p2):reverse():sub(5, 36);
		v3[p2] = v4;
	end;
	return v4;
end;
local v5 = {
	Fire = function(p3, p4, ...)
		local v6 = false;
		if typeof(p4) == "Instance" then
			v6 = p4:IsA("Player");
		end;
		assert(v6);
		if not p4:FindFirstChild("__LOADED") then
			return;
		end;
		local v7 = u6(1, p3);
		local v8 = u3[1];
		local v9 = v8[v7];
		if not v9 then
			v9 = Instance.new(u4[1]);
			v9.Name = v7;
			v9.Parent = l__ReplicatedStorage__5;
			v8[v7] = v9;
		end;
		task.spawn(function(...)
			v9:FireClient(p4, ...);
		end, ...);
	end
};
local l__Players__7 = game:GetService("Players");
function v5.FireAll(p5, ...)
	local v10 = l__Players__7:GetPlayers();
	local v11 = {};
	for v12, v13 in ipairs(v10) do
		if v13:FindFirstChild("__LOADED") then
			table.insert(v11, v13);
		end;	
	end;
	local v15 = u6(1, p5);
	local v16 = u3[1];
	local v17 = v16[v15];
	if not v17 then
		v17 = Instance.new(u4[1]);
		v17.Name = v15;
		v17.Parent = l__ReplicatedStorage__5;
		v16[v15] = v17;
	end;
	if #v11 <= #v10 then
		task.spawn(function(...)
			v17:FireAllClients(...);
		end, ...);
		return;
	end;
	for v18, v19 in ipairs(v11) do
		task.spawn(function(...)
			v17:FireClient(v19, ...);
		end, ...);	
	end;
end;
function v5.Fired(p6)
	local v21 = u6(1, p6);
	local v22 = u3[1];
	local v23 = v22[v21];
	if not v23 then
		v23 = Instance.new(u4[1]);
		v23.Name = v21;
		v23.Parent = l__ReplicatedStorage__5;
		v22[v21] = v23;
	end;
	return v23.OnServerEvent;
end;
function v5.Invoke(p7, p8, ...)
	local v24 = false;
	if typeof(p8) == "Instance" then
		v24 = p8:IsA("Player");
	end;
	assert(v24);
	if not p8:FindFirstChild("__LOADED") then
		return;
	end;
	local v25 = u6(2, p7);
	local v26 = u3[2];
	local v27 = v26[v25];
	if not v27 then
		v27 = Instance.new(u4[2]);
		v27.Name = v25;
		v27.Parent = l__ReplicatedStorage__5;
		v26[v25] = v27;
	end;
	return v27:InvokeClient(p8, ...);
end;
function v5.Invoked(p9)
	local v28 = u6(2, p9);
	local v29 = u3[2];
	local v30 = v29[v28];
	if not v30 then
		v30 = Instance.new(u4[2]);
		v30.Name = v28;
		v30.Parent = l__ReplicatedStorage__5;
		v29[v28] = v30;
	end;
	local v31 = {};
	function v31.__newindex(p10, p11, p12)
		if p11 == "OnInvoke" then
			p11 = "OnServerInvoke";
		elseif p11 == "OnServerInvoke" then
			error(string.format("%s is not a valid member of BindableFunction \"BindableFunction\"", tostring(p11)));
		end;
		v30[p11] = p12;
	end;
	function v31.__index(p13, p14)
		if p14 == "OnInvoke" then
			p14 = "OnServerInvoke";
		elseif p14 == "OnServerInvoke" then
			error(string.format("%s is not a valid member of BindableFunction \"BindableFunction\"", tostring(p14)));
		end;
		return v30[p14];
	end;
	return setmetatable({}, v31);
end;
return v5;
  -  Editar
  04:54:13.863    -  Editar
  04:54:13.863  ----- [2589] ServerStorage.__STORAGE.Unused Modules.TheseStupidThingsDontWorkInPSXfiles....Network.SHA1 -----  -  Editar
  04:54:13.863  -- Decompiled with the Synapse X Luau decompiler.

local u1 = string.char(128);
local function u2(p1)
	return bit32.extract(p1, 24, 8), bit32.extract(p1, 16, 8), bit32.extract(p1, 8, 8), bit32.extract(p1, 0, 8);
end;
local function u3(p2)
	local v1 = #p2 * 8;
	local v2 = v1 + 8;
	local v3 = 4;
	p2 = p2 .. u1;
	while (v2 + 64) % 512 ~= 0 do
		v3 = v3 + 1;
		v2 = v2 + 8;	
	end;
	p2 = p2 .. string.rep("\000", v3);
	p2 = p2 .. string.char(u2(v1));
	return p2;
end;
local function u4(p3, p4, p5, p6)
	if p3 <= 19 then
		return bit32.bxor(p6, (bit32.band(p4, (bit32.bxor(p5, p6)))));
	end;
	if p3 <= 39 then
		return bit32.bxor(p4, p5, p6);
	end;
	if not (p3 <= 59) then
		return bit32.bxor(p4, p5, p6);
	end;
	return bit32.bor(bit32.band(p4, (bit32.bor(p5, p6))), (bit32.band(p5, p6)));
end;
return function(p7)
	local v4 = nil;
	local v5 = nil;
	local v6 = nil;
	local v7 = nil;
	local v8 = nil;
	local v9 = u3(p7);
	v4 = 1732584193;
	v5 = 4023233417;
	v6 = 2562383102;
	v7 = 271733878;
	v8 = 3285377520;
	local v10 = {};
	for v11 = 1, #v9, 64 do
		local v12 = nil;
		local v13 = nil;
		local v14 = nil;
		local v15 = nil;
		local v16 = nil;
		local v17 = v11;
		for v18 = 0, 15 do
			local v19, v20, v21, v22 = string.byte(v9, v17, v17 + 3);
			v10[v18] = bit32.lshift(v19, 24) + bit32.lshift(v20, 16) + bit32.lshift(v21, 8) + v22;
			v17 = v17 + 4;
		end;
		for v23 = 16, 79 do
			v10[v23] = bit32.lrotate(bit32.bxor(v10[v23 - 3], v10[v23 - 8], v10[v23 - 14], v10[v23 - 16]), 1);
		end;
		v16 = v4;
		v15 = v5;
		v14 = v6;
		v13 = v7;
		v12 = v8;
		for v24 = 0, 79 do
			if v24 <= 19 then
			    v25 = 1518500249;
			elseif v24 <= 39 then
				v25 = 1859775393;
			elseif v24 <= 59 then
				v25 = 2400959708;
			else
				v25 = 3395469782;
			end;
			v12 = v13;
			v13 = v14;
			v14 = bit32.lrotate(v15, 30);
			v15 = v16;
			v16 = (bit32.lrotate(v16, 5) + u4(v24, v15, v14, v13) + v12 + v10[v24] + v25) % 4294967296;
		end;
		v4 = (v4 + v16) % 4294967296;
		v5 = (v5 + v15) % 4294967296;
		v6 = (v6 + v14) % 4294967296;
		v7 = (v7 + v13) % 4294967296;
		v8 = (v8 + v12) % 4294967296;
	end
	return string.format("%08x%08x%08x%08x%08x", v4, v5, v6, v7, v8);
end;
  -  Editar
  04:54:13.863    -  Editar
  04:54:13.863  ----- [2590] ServerStorage.__STORAGE.Reference.GAME INFO -----  -  Editar
  04:54:13.863  --[[
NAME: 
MODDED🔥 PET SIMULATOR X! 🐾
    
DESCRIPTION:
🎁 Credits to BIG Games for all the assets.

📅 Updates every other Saturday at 11am CDT!

💰 Earn coins!
🥚 Open eggs!
😺 Collect pets!
✨ Enchant and upgrade!
🗺️ Unlock worlds!
✔️ Trade pets!
Currently 1,000+ pets to collect! 🐾


🔔 Follow for game updates! 🔔 

🧡 Made by OneX
    
GAME ICON: https://cdn.discordapp.com/attachments/1058160689987997718/1131051153027768362/ICON.png
    
GAME BANNER: https://cdn.discordapp.com/attachments/1058160689987997718/1130255438605189203/Game.png
    
SERVER SIZE: 12
    
THIRD PARTY PURCHASE: enabled

--]]  -  Editar
  04:54:13.863    -  Editar
  04:54:13.863  ----- [2591] ServerStorage.__STORAGE.Reference.EXPLOITS -----  -  Editar
  04:54:13.863  -----   GET INVOKE DATA   -----
local Network = require(game:GetService("ReplicatedStorage").Library.Client.Network)
local Fire, Invoke = Network.Fire, Network.Invoke

local old 
old = hookfunction(debug.getupvalue(Fire, 1), function(...)
	return true
end)
local old2 
old2 = hookfunction(debug.getupvalue(Invoke, 1), function(...)
	return true
end)

local v1, v2 = Invoke("Comets: Get Data")

table.foreach(v2, warn)

-----   GET WORLD FOLDER  -----
local RunService = game:GetService("RunService")
local _L = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Client = _L:WaitForChild("Client")
local Players = game:GetService("Players")

function Load(world)
	require(_L.Variables).LoadingWorld = true

	if not getupvalues(require(Client.Network).Invoke)[2]("Request World"):InvokeServer(world) then
		return require(Client.GUIFX).Loading(world)
	end

	while not Players.LocalPlayer.PlayerGui:FindFirstChild("__MAP") do
		RunService.RenderStepped:Wait(); 
	end

	local PlayerGui = Players.LocalPlayer.PlayerGui
	local MAP = PlayerGui:FindFirstChild("__MAP")

	while not MAP do
		wait(0.1)
		PlayerGui:FindFirstChild("__MAP");
	end
	MAP = PlayerGui:FindFirstChild("__MAP")
	MAP.Name = world
	MAP.Parent = game.Workspace
end;

Load("Spawn")

-----     GET PET DATA    -----
local Save = require(game.ReplicatedStorage.Library.Client.Save)
local Player = game.Players["LocalOneX"]

local stats = Save.Get(Players)
print(stats.Pets[1].s)

  -  Editar
  04:54:13.864    -  Editar
  04:54:13.864  ----- [2592] ServerStorage.__STORAGE.Spawn.MAP.Interactive.Animations.Play Animations -----  -  Editar
  04:54:13.864  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local m_Library = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"));
while not m_Library.Loaded do
	game:GetService("RunService").Heartbeat:Wait();
end
for _, child1 in ipairs(script.Parent:GetChildren()) do
	if child1.ClassName ~= "Model" or not child1:FindFirstChild("HumanoidRootPart") then continue end
	local Attribute = child1:GetAttribute("AnimationID");
	for _, child2 in ipairs(child1:GetChildren()) do
		if not child2:IsA("BasePart") or child2.Name == "HumanoidRootPart" then continue end
		child2.Anchored = false;
	end
	m_Library.Functions.Animation(Attribute, child1, 1);
end
  -  Editar
  04:54:13.864    -  Editar
  04:54:13.864  ----- [2593] ServerStorage.__STORAGE.Platform PurchaseX -----  -  Editar
  04:54:13.864  -- Decompiled using Krnl
local v7 = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while not v7.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end
local v11 = {}
Locked = function(p1)
	local v16 = v7.Save.Get()
	if not v16 then
		return true
	end
	if v7.Shared.IsHardcore then
		local v19 = v16.Hardcore.AreasUnlocked
		if not v19 then
			v19 = v16.AreasUnlocked
		end
		if p1 == "Yeet Area 1" then
			return false
		end
		return not v7.Functions.SearchArray(v19, "Yeet Area " .. tonumber(p1:sub(-1)) - 1)
	end
end
Buy = function(p2)
	if not v11[p2] then
		return 
	end
	local v57 = v7.Directory.Areas[p2]
	local v46 = " "
	local v47 = v57.gate.currency
	if not v7.Message.New("Do you want to buy access to these eggs for " .. v7.Functions.Commas(v57.gate.cost) .. v46 .. v47 .. "?", true) then
		return 
	end
	local v52, v53 = v7.Network.Invoke("Buy Area", p2)
	if not v52 then
		v7.Message.New(v53 or "Error")
		return 
	end
	RemovePurchase_1(p2)
end
SetupPurchase = function(p3, p4)
	local v71 = false
	local v80, v81 = v7.Interact.Add(p4.PrimaryPart.Position + Vector3.new(0, 5, 0), {
		dist = 15, label = "Buy Eggs!"
	})
	v80:Connect(function()
		if not v71 then
			v71 = true
			Buy(p3)
			task.delay(0.5, function()
				v71 = false
			end)
		end
	end)
	v11[p3] = {
		Area = p3, Model = p4, Cancel = v81
	}
	UpdatePurchase(v11[p3])
end
UpdatePurchase = function(p5)
	local v102 = p5.Model
	local v105 = v102.PriceHUD:FindFirstChild("EggCost")
	if not v105 then
		v105 = v7.Assets.Billboards.EggCost:Clone()
		v105.Currency.Image = v7.Directory.Currency["Yeet Coins"].Image
		v105.Currency.Size = UDim2.new(0.15, 0, 0.8, 0)
		v105.Parent = p5.Model.PriceHUD
	end
	local v113 = Locked(p5.Area)
	v105.Currency.Visible = not v113
	if not v113 then
		v105.Amount.Text = v7.Functions.NumberShorten(v7.Directory.Areas[p5.Area].gate.cost)
		return 
	end
	v105.Amount.Text = "Locked"
end
function RemovePurchase_1(p6)
	local v142 = v11[p6]
	if not v142 then
		return 
	end
	v142.Model:Destroy()
	v142.Cancel()
	v11[p6] = nil
end
v7.Signal.Fired("World Changed"):Connect(function(p7)
	if p7 ~= "Yeet" then
		return 
	end
	local v153 = v7.Save.Get()
	if not v153 then
		return 
	end
	
	local v151
	if v7.Shared.IsHardcore then
		v151 = v153.Hardcore.AreasUnlocked
	else
		v151 = v153.AreasUnlocked
	end
	for v175, v167 in pairs(v7.WorldCmds.GetMap():WaitForChild("Interactive"):WaitForChild("Platforms")):getChildren() do
		if v7.Functions.SearchArray(v151, v167.Name) then
			v167:Destroy()
		else
			SetupPurchase(v167.Name, v167)
		end
	end
	return 
end)
v7.Signal.Fired("Stat Changed"):Connect(function(p8)
	if p8 == "AreasUnlocked" then
		local v188 = v7.Save.Get()
		if not v188 then
			return 
		end
		local v186 = nil
		if v7.Shared.IsHardcore then
			v186 = v188.Hardcore.AreasUnlocked
		else
			v186 = v188.AreasUnlocked
		end	
		for v196, v202 in pairs(v11) do
			local v197 = v7.Functions.SearchArray(v186, v196)
			if v197 then
				RemovePurchase_1(v196)
			else
				UpdatePurchase(v11[v196])
			end
		end
		return 
	end
end)
  -  Editar
  04:54:13.864    -  Editar
  04:54:13.864  ----- [2594] ServerStorage.__STORAGE.RocketsX -----  -  Editar
  04:54:13.864  -- Decompiled using Krnl
local v7 = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while not v7.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end
local v13 = v7.Assets.Billboards.Cannon.Size
local v10 = {}
local v12 = 0
local v11 = false
function Fire(p1, p2)
	if not p1 then
		v7.Print("Rocket does not exist")
		return 
	end
	local v18
	if p2 ~= v7.LocalPlayer then
		v18 = false
	else
		v18 = true
	end
	local v22 = v7.Player.Character(p2)
	local v25 = v7.Player.PrimaryPart(p2)
	local v28 = v7.Player.Humanoid(p2)
	if v22 then
		if v25 then
			if not v28 then
				v7.Print("Missing character - " .. p2.Name, true)
				return 
			end
			local v34 = v10[p1.Name]
			if v34.using then
				v7.Print("Rocket is already active", true)
				return 
			end
			v34.using = true
			local v173 = p1.Name
			if not v7.Directory.Worlds[v173] then
				v7.Print("World '" .. v173 .. "' doesn't exist", true)
				return 
			end
			p2:SetAttribute("UsingCannon", true)
			if v18 then
				v7.Signal.Fire("Entered Cannon")
				v7.Variables.UsingCannon = true
			else
				v7.Signal.Fire("Other Entered Cannon", p2)
			end
			v7.Audio.Play("rbxassetid://7480973873", p1.PrimaryPart, 1, 1, 200)
			v22:PivotTo((p1.PrimaryPart.CFrame) * CFrame.Angles(0, 3.1415926535898, 0) + Vector3.new(0, 10, 0))
			local v68 = Instance.new("WeldConstraint")
			v68.Part0 = p1.PrimaryPart
			v68.Part1 = v25
			v68.Parent = p1.PrimaryPart
			v7.Functions.Wait(1)
			if v18 then
				if not p1.PrimaryPart then
					return
				end
				local v84 = p1:FindFirstChild("Rocket Bottom")
				local v92 = v84:FindFirstChild("Smoke"):FindFirstChild("ParticleEmitter")
				v92.Enabled = true
				if v18 then
					local v96 = v7.Debris:FindFirstChild("__MAPDEBRIS")
					if v96 then
						v96:ClearAllChildren()
					end
					local v99 = v7.Lighting.ClockTime
					local v101 = v7.Lighting:FindFirstChildOfClass("Atmosphere")
					if v101 then
						v101:Destroy()
					end
					v7.Lighting.FogColor = Color3.new()
					local v106 = v7.Lighting:FindFirstChildOfClass("Sky")
					if v106 then
						v106.StarCount = 5000
						v106.CelestialBodiesShown = true
					end
					v7.Shake.Create(3, 0.75, 0.15, true)
					v92.Enabled = false
					for v118, v117 in pairs(v84:FindFirstChild("Flames"):GetChildren()) do
						v117.Enabled = true
					end
					local v114 = function(p3, p4)
						local v129 = p1:GetPivot()
						v129 = v129 + (Vector3.new(0, (v7.Functions.Easing(math.min(p4, 1), Enum.EasingStyle.Cubic, Enum.EasingDirection.In)) * 750, 0)) * p3
						p1:PivotTo(v129)
						v7.Lighting.ClockTime = v7.Functions.Lerp(v99, 0, (p4) / 2.5)
					end
					v7.Functions.Heartbeat(v114, 2.5):Wait()
					v7.Audio.Play(14155610836, p1, 1, 0.5, 450):Stop()
					v7.WorldCmds.Load(v173, nil, p1:GetAttribute("FinalPosition"))
					v7.Variables.UsingCannon = false
					p2:SetAttribute("UsingCannon", false)
					v7.Functions.Animation(11897877992, v28):Stop()
				else
					wait(5)
					v25.Anchored = false
				end
				v34.using = false
				return 
			end
		end
	end
end
function ClientAttemptFire(p5)
	local v207 = v7.WorldCmds.CanDoAction()
	if not v207 then
		return 
	end
	local v210 = v7.FFlags.Get(v7.FFlags.Keys.Cannons)
	if not v210 then
		local v212 = v7.FFlags.CanBypass(v7.LocalPlayer)
		if not v212 then
			v7.Message.New("Sorry this is disabled right now! Please try back later")
			return 
		end
	end
	local v216, v217 = v7.Network.Invoke("Request Cannon Launch", p5.Name)
	if v216 then
		Fire(p5, v7.LocalPlayer)
		return 
	end
	v7.Message.New(v217 or "You don't have access to this area!")
end
function Init(p4) 
	local u2 = v12;
	local t_Name4 = p4.Name;
	v10[t_Name4] = {
		physical = p4,
		using = false,
		event = nil,
		eventCancel = nil
	};
	coroutine.wrap(function() 
		while v12 == u2 and v10[t_Name4] do
			debug.profilebegin("Cannons.Init.pt1");
			local v17 = v10[t_Name4];
			if v17.using then
				v17.event = nil;
				if v17.eventCancel then
					v17.eventCancel();
					v17.eventCancel = nil;
				end
			elseif not v17.event then
				local v19, v20 = v7.Interact.Add(p4.PrimaryPart.CFrame.Position, {dist = 25});
				v17.event = v19;
				v17.eventCancel = v20;
				v19:Connect(function() 
					if not v11 then
						v11 = true;
						ClientAttemptFire(p4);
						v11 = false;
					end
				end);
			end
			debug.profileend();
			wait(0.25);
		end
	end)()
	coroutine.wrap(function()  
		local bool2 = false;
		local function Show()  
			local v18 = v7.Directory.Worlds[p4.Name];
			local Clone_ret3 = v7.Assets.Billboards.Cannon:Clone();
			Clone_ret3.Frame.World.Text = v18.display;
			Clone_ret3.Frame.Currency.Image = v7.Directory.Currency[v18.mainCurrency].Image;
			Clone_ret3.Name = "%HUD";
			Clone_ret3.Parent = p4;
			Clone_ret3.Size = UDim2.new(0, 0, 0, 0);
			Clone_ret3.StudsOffset = Vector3.new();
			v7.Functions.Tween(Clone_ret3, {
				Size = v13,
				StudsOffset = Vector3.new(0, 12, 0)
			}, {
				0.2,
				Enum.EasingStyle.Quad,
				Enum.EasingDirection.Out
			});
		end
		local function Hide() 
			local FindFirstChild_ret = p4:FindFirstChild("%HUD");
			if FindFirstChild_ret then
				v7.Functions.Tween(FindFirstChild_ret, {
					Size = UDim2.new(0, 0, 0, 0),
					StudsOffset = Vector3.new(0, 4, 0)
				}, {
					0.15,
					Enum.EasingStyle.Quad,
					Enum.EasingDirection.In
				}).Completed:Connect(function()  
					FindFirstChild_ret:Destroy();
				end);
			end
		end
		while v12 == u2 and v10[t_Name4] do
			local _ = v10[t_Name4];
			local DistanceFromCharacter_ret = v7.LocalPlayer:DistanceFromCharacter(p4.PrimaryPart.CFrame.Position);
			if not bool2 and DistanceFromCharacter_ret <= 35 then
				bool2 = true;
				Show();
			elseif bool2 and DistanceFromCharacter_ret > 35 then
				bool2 = false;
				Hide();
			end
			wait((math.clamp(DistanceFromCharacter_ret / 35, 0.1, 1)));
		end
	end)()
end
function GetRocketPhysical(p7)
	local v394 = game.Workspace:WaitForChild("__MAP"):FindFirstChild("Rockets")
	if not v394 then
		return nil
	end
	return v394:FindFirstChild(p7)
end
local function LoadWorld_1()
	v12 = v12 + 1
	v10 = {}
	local v404 = game.Workspace:WaitForChild("__MAP"):FindFirstChild("Rockets")
	if not v404 then
		return 
	end
	for v413, v412 in ipairs(v404:GetChildren()) do
		print("init")
		Init(v412)
	end
end
v7.Network.Fired("Cannon Fired"):Connect(function(p8, p9, p10)
	if v7.WorldCmds.Get() == p9 then
		if p8 ~= v7.LocalPlayer then
			local v424 = v7.WorldCmds.HasLoaded()
			if v424 then
				local v425 = GetRocketPhysical(p10)
				if v425 then
					Fire(v425, p8)
				end
			end
		end
	end
end)
v7.Signal.Fired("World Changed"):Connect(function()
	LoadWorld_1()
end)
  -  Editar
  04:54:13.864    -  Editar
  04:54:13.864  ----- [2595] ServerStorage.__STORAGE.Coming Soon -----  -  Editar
  04:54:13.864  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
--local Rocket = nil

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function AddInteractive(Rocket)
	local Interact, _ = _L.Interact.Add(Rocket.PrimaryPart, {dist = 12})
	if Interact then
		Interact:Connect(function()  
			_L.Message.New("Coming Soon!")
		end)
	end
end

function Setup()  
	--if Rocket then
	--	AddInteractive(Rocket)
	--	return
	--end
	
	local Map = _L.WorldCmds.GetMap()
	if Map:FindFirstChild("Rockets") then
		local Rocket = Map.Gates:FindFirstChild("Yeet")
		if Rocket then
			AddInteractive(Rocket)
		end
	end
end

_L.Signal.Fired("World Changed"):Connect(function(wrld) 
	if wrld == "Spawn" then
		Setup()
	end
end)  -  Editar
  04:54:13.864    -  Editar
  04:54:13.864  ----- [2596] ServerStorage.__STORAGE.PetOrderBest -----  -  Editar
  04:54:13.864  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local m_Directory = require(game:GetService("ReplicatedStorage"):WaitForChild("Library").Directory);
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Library = ReplicatedStorage:WaitForChild("Library");
local v15 = require(Library.Signal)
local _ = require(Library:WaitForChild("Modules").Pets);
local m_PetTypeIndex = require(script.Parent.PetTypeIndex);
local m_ComputePetStrength = require(script.Parent.ComputePetStrength);
local v35 = require(script.Parent.CanAuctionPetDir)
local v38 = require(script.Parent.ShowPetExists)
local v42 = require(script.Parent.Parent.Variables)
local v43
local isServer = game:GetService("RunService"):IsServer()
local inf = math.huge
if isServer then
	local v50 = require(require:GetService("ServerScriptService"):WaitForChild("Library").RAP)
	v43 = function(p1)
		local v53, v54 = v50.Get(p1)
		if v54 then
			v53 = nil
		end
		return v53
	end
else
	v43 = require(Library:WaitForChild("Client").RAPCmds).Get
end
local v56
if isServer then
	v56 = function(p2)
		return v15.Invoke("Get Pet Rarity", p2.id)
	end
else
	v56 = function(p3)
		return v15.Invoke("Get Pet Rarity", p3.id)
	end
end
return function(p1, p2, companion, p7, p8, p9, p10)  
	local t_id = p1.id;
	local t_id2 = p2.id;
	local v1 = m_Directory.Pets[t_id];
	local v2 = m_Directory.Pets[t_id2];
	if p10 then
		local v160 = p10(p1)
		local v77 = p10(p2)
		if v160 ~= v77 then
			return v77 - v160
		end
	end
	local v3 = v1.titanic == true;
	if v2.titanic == true ~= v3 then
		if v3 then
			return -1;
		end
		return 1;
	end
	local v4 = v1.huge == true;
	if v2.huge == true ~= v4 then
		if v4 then
			return -1;
		end
		return 1;
	end
	local v4 = v1.evolved == true;
	if v2.evolved == true ~= v4 then
		if v4 then
			return -1;
		end
		return 1;
	end
	local v5 = v1.companionEnchantLevel or 0;
	local v6 = v2.companionEnchantLevel or 0;
	if companion then
		if v5 ~= v6 then
			return v6 - v5;
		end
	end	
	if not v3 and not v4 and v5 == 0 then
		local v9 = m_ComputePetStrength(p1);
		local v10 = m_ComputePetStrength(p2);
		if v9 ~= v10 then
			return v10 - v9;
		end
	end
	local v7 = m_PetTypeIndex(p1);
	local v8 = m_PetTypeIndex(p2);
	if v7 ~= v8 then
		return v8 - v7;
	end
	if t_id ~= t_id2 then
		if t_id2 < t_id then
			return -1;
		end
		return 1;
	end
	return (p1.idt or 0) - (p2.idt or 0);
end;
  -  Editar
  04:54:13.864    -  Editar
  04:54:13.865  ----- [2597] ServerStorage.__STORAGE.Yeet GUIX -----  -  Editar
  04:54:13.865  local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))

while not _L.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end

local v12 = Random.new()
local v13 = _L.Shared
local v10 = v13.IsHardcore
local v15 = _L.GUI.Main.Right.PowerHolder
local v16 = _L.GUI.YeetMain.Gui

local v15Cache = {}  -- Cache for user thumbnails

function IsGameWorld()
	local v19 = _L.Save.Get()
	if not v19 then
		return false
	end

	if v10 then
		local v22 = true
		if v19.Hardcore.World ~= "Yeet" then
			if v19.World ~= "Yeet" then
				v22 = false
			end
			v22 = true
		end
		return v22
	end
end

function UpdatePowerGui(p1, p2)
	v15.BasePower.Text = "Base: " .. _L.Functions.NumberShorten(p1)
	v15.Power.Amount.Text = _L.Functions.NumberShorten(p1 + p2)
end

function UpdateBar(p3, p4, p5)
	local v48 = v16:FindFirstChild("DistanceBar")

	if p3 == _L.LocalPlayer.Name then
		local v52 = v48:FindFirstChild("You")
		local v54 = v52:FindFirstChild("Lap")

		task.spawn(function()
			if v52.Image == "rbxassetid://7543041571" then
				v52.Image = GetThumbnail(p3)
			end
		end)

		v54.Visible = p5 > 0
		v54.Text = string.format("\240\159\148\165 %d Lap", p5)
		v52.Position = UDim2.new(p4, 0, 1, 0)
		return
	end

	local v70 = p3
	local v71 = v48:FindFirstChild(v70)

	if not v71 then
		v71 = v48:FindFirstChild("Other"):Clone()
		v71.Parent = v48
		v71.Visible = true
		v71.Name = p3

		task.spawn(function()
			if v71.Image == "rbxassetid://7543041571" then
				v71.Image = GetThumbnail(p3)
			end
		end)
	end

	local v83 = v71:FindFirstChild("Lap")
	v83.Visible = p5 > 0
	v83.Text = string.format("\240\159\148\165 %d Lap", p5)
	v71.Position = UDim2.new(p4, 0, 1, 0)
end

function GetThumbnail(p6)
	local v104 = v15Cache[p6]

	if not v104 then
		local userId = _L.Players:GetUserIdFromNameAsync(p6)
		v104 = _L.Players:GetUserThumbnailAsync(userId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size48x48)
		v15Cache[p6] = v104
	end

	return v104
end

function UpdateDistanceTraveled(p7)
	local v132 = v16:FindFirstChild("Power")
	v132:FindFirstChild("Amount").Text = _L.Functions.NumberShorten(p7) .. "!"

	if not v132.Visible then
		v132.Visible = true
	end
end

local function HideDistanceTraveled()
	v16:FindFirstChild("Power").Visible = false
end

_L.Signal.Fired("Yeet a Pet: Hide Distance"):Connect(HideDistanceTraveled)
_L.Signal.Fired("Yeet a Pet: Update Distance"):Connect(UpdateDistanceTraveled)
_L.Signal.Fired("Yeet a Pet: Update Bar"):Connect(UpdateBar)
_L.Signal.Fired("World Changed"):Connect(function(p8)
	if p8 ~= "Yeet" then
		v13.Visible = false
		v16.Enabled = false
		return
	end

	v13.Visible = true
	v16.Enabled = true
	v16.Power.Visible = false
end)

_L.Network.Fired("Yeet a Pet: Notify Reward"):Connect(function(p9)
	local v175 = v16:FindFirstChild("Result")
	v175.Visible = true
	v175:FindFirstChild("Amount").Text = _L.Functions.NumberShorten(p9) .. "!"

	task.delay(3, function()
		v175.Visible = false
	end)

	_L.Audio.Play("rbxassetid://14151622000", script, 1, 0.5)
end)

_L.Network.Fired("Yeet a Pet: Notify Record"):Connect(function(p10)
	local v205 = v16:FindFirstChild("NewRecord")
	v205.Visible = true

	task.delay(3, function()
		v205.Visible = false
	end)

	_L.Signal.Fire("Fireworks Animation at Position", p10)
end)

_L.Network.Fired("Yeet: Power Updated"):Connect(function(p11, p12)
	UpdatePowerGui(p11, p12)
end)

_L.Network.Fired("World Switched"):Connect(function(p13, p14)
	if p13.Name == _L.LocalPlayer.Name then
		return
	end

	if p14 ~= "Yeet" then
		return
	end

	UpdateBar(p13.Name, 0, 0)
end)

_L.Network.Fired("Yeet a Pet: Lap Pet"):Connect(function(p15, p16)
	local v244 = _L.GUI.YeetMain.Lap:Clone()
	local v297 = p16 <= 2 and "1 LAP!" or p16 .. " LAPS!"
	v244.Amount.Text = v297
	v244.Position = UDim2.new(0.2 + math.random() * 0.55, 0, 0.2 + v297, 0)
	v244.Size = UDim2.new(0, 0, 0, 0)
	v244.Visible = true
	v244.Parent = _L.GUI.YeetMain.Gui

	_L.Functions.Tween(v244, {Rotation = 360 + math.random(-20, 20), Size = v244.Size}, {0.25, "Sine", "Out"})

	task.delay(1.2, function()
		_L.Functions.Tween(v244, {Size = UDim2.new(0, 0, 0, 0)}, {0.3, "Sine", "Out"}).Completed:Connect(function()
			v244:Destroy()
		end)
	end)

	_L.Audio.Play("rbxassetid://14152968657", script, 1 + (p16 - 1) * 0.02, 0.2)
end)

_L.Signal.Fired("Yeet: Critical"):Connect(function()
	local v332 = _L.GUI.YeetMain.CriticalYeet:Clone()
	v332.Position = UDim2.new(0.2 + math.random() * 0.55, 0, 0.2 + math.random() * 0.5, 0)
	v332.Size = UDim2.new(0, 0, 0, 0)
	v332.Visible = true
	v332.Rotation = v12:NextInteger(-20, 20)
	v332.Parent = _L.GUI.YeetMain.Gui

	_L.Functions.Tween(v332, {Size = v332.Size}, {0.25, "Sine", "Out"})

	task.delay(1.2, function()
		_L.Functions.Tween(v332, {Size = UDim2.new(0, 0, 0, 0)}, {0.3, "Sine", "Out"}).Completed:Connect(function()
			v332:Destroy()
		end)
	end)

	_L.Shake.Create(1.5, 0.5, 0.15, true)
end)

local function setup_1()
	local v410 = v16:FindFirstChild("DistanceBar"):FindFirstChild("You")
	local v413 = v410:FindFirstChild("Lap")
	v410.Position = UDim2.new(0, 0, 1, 0)

	task.spawn(function()
		if v410.Image == "rbxassetid://7543041571" then
			v410.Image = GetThumbnail(_L.LocalPlayer.Name)
		end
	end)

	local v430 = v16:FindFirstChild("Power")
	local v434 = v430.Size
	local v444 = _L.TweenService:Create(v430, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = v434
	})

	v430:FindFirstChild("Amount").Changed:Connect(function()
		if v444.PlaybackState == Enum.PlaybackState.Playing then
			return
		end

		v430.Size = UDim2.fromScale(v434.X.Scale * 1.3, v434.Y.Scale * 1.3)
		v444:Play()
	end)
end

setup = setup_1
setup_1 = setup
setup_1()

game.Players.PlayerRemoving:Connect(function(p17)
	local v472 = v16:FindFirstChild("DistanceBar"):FindFirstChild(p17.Name)
	if v472 then
		v472:Destroy()
	end
end)  -  Editar
  04:54:13.865    -  Editar
  04:54:13.865  ----- [2598] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Yeet Goal Sign -----  -  Editar
  04:54:13.865  local _L = require((game.ReplicatedStorage:WaitForChild("Framework")):WaitForChild("Library"))
while not _L.Loaded do 
	game:GetService("RunService").Heartbeat:Wait()
end

local Yeet = require(game.ReplicatedStorage.Library.Types.Yeet)
local YeetEventSign
local GameData

function Setup()
	local InteractiveMap = _L.WorldCmds.GetMap():FindFirstChild("Interactive")
	if InteractiveMap then
		YeetEventSign = InteractiveMap:FindFirstChild("Yeet Event Sign")
	end
end

local function UpdateOrbsSign()
	if YeetEventSign then
		if not GameData then
			return
		end

		local Panel = YeetEventSign:FindFirstChild("Main"):FindFirstChild("SurfaceGui").Panel
		local Goal = Panel.Goal

		Panel.Amount.Cost.Text = _L.Functions.Commas(GameData.OrbsCollected) .. "/" .. _L.Functions.Commas(10000)
		Panel.Progress.Bar.Size = UDim2.new((GameData.OrbsCollected) / 10000, 0, 1, 0)
	end
end

task.spawn(function()
	while task.wait(1) do
		if YeetEventSign and GameData then
			local GoalText = (YeetEventSign:FindFirstChild("Main")):FindFirstChild("SurfaceGui").Panel.Goal
			if GameData.OrbStormStarted then
				GoalText.Text = "Orb Storm Ending in " .. _L.Functions.FormatTime(math.max(0, GameData.OrbStormEnd - workspace:GetServerTimeNow()))
			else
				GoalText.Text = "5x Orb Spawn Rate!"
			end
		end
	end
end)

_L.Signal.Fired("World Changed"):Connect(function(world)
	if world == "Yeet" then
		Setup()
		UpdateOrbsSign()
		return
	end
	YeetEventSign = nil
end)

_L.Network.Fired("Yeet: Game Data"):Connect(function(data)
	GameData = data
	UpdateOrbsSign()
end)

_L.Signal.Fired("Yeet: Game Data"):Connect(function(data)
	GameData = data
	UpdateOrbsSign()
end)  -  Editar
  04:54:13.865    -  Editar
  04:54:13.865  ----- [2599] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Yeet GUI -----  -  Editar
  04:54:13.865  local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))

while not _L.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end

local v12 = Random.new()
local v13 = _L.Shared
local v10 = v13.IsHardcore
local v15 = _L.GUI.Main.Right.PowerHolder
local v16 = _L.GUI.YeetMain.Gui

local v15Cache = {}  -- Cache for user thumbnails

function IsGameWorld()
	local v19 = _L.Save.Get()
	if not v19 then
		return false
	end

	if v10 then
		local v22 = true
		if v19.Hardcore.World ~= "Yeet" then
			if v19.World ~= "Yeet" then
				v22 = false
			end
			v22 = true
		end
		return v22
	end
end

function UpdatePowerGui(p1, p2)
	v15.BasePower.Text = "Base: " .. _L.Functions.NumberShorten(p1)
	v15.Power.Amount.Text = _L.Functions.NumberShorten(p1 + p2)
end

function UpdateBar(p3, p4, p5)
	local v48 = v16:FindFirstChild("DistanceBar")

	if p3 == _L.LocalPlayer.Name then
		local v52 = v48:FindFirstChild("You")
		local v54 = v52:FindFirstChild("Lap")

		task.spawn(function()
			if v52.Image == "rbxassetid://7543041571" then
				v52.Image = GetThumbnail(p3)
			end
		end)

		v54.Visible = p5 > 0
		v54.Text = string.format("\240\159\148\165 %d Lap", p5)
		v52.Position = UDim2.new(p4, 0, 1, 0)
		return
	end

	local v70 = p3
	local v71 = v48:FindFirstChild(v70)

	if not v71 then
		v71 = v48:FindFirstChild("Other"):Clone()
		v71.Parent = v48
		v71.Visible = true
		v71.Name = p3

		task.spawn(function()
			if v71.Image == "rbxassetid://7543041571" then
				v71.Image = GetThumbnail(p3)
			end
		end)
	end

	local v83 = v71:FindFirstChild("Lap")
	v83.Visible = p5 > 0
	v83.Text = string.format("\240\159\148\165 %d Lap", p5)
	v71.Position = UDim2.new(p4, 0, 1, 0)
end

function GetThumbnail(p6)
	local v104 = v15Cache[p6]

	if not v104 then
		local userId = _L.Players:GetUserIdFromNameAsync(p6)
		v104 = _L.Players:GetUserThumbnailAsync(userId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size48x48)
		v15Cache[p6] = v104
	end

	return v104
end

function UpdateDistanceTraveled(p7)
	local v132 = v16:FindFirstChild("Power")
	v132:FindFirstChild("Amount").Text = _L.Functions.NumberShorten(p7) .. "!"

	if not v132.Visible then
		v132.Visible = true
	end
end

local function HideDistanceTraveled()
	v16:FindFirstChild("Power").Visible = false
end

_L.Signal.Fired("Yeet a Pet: Hide Distance"):Connect(HideDistanceTraveled)
_L.Signal.Fired("Yeet a Pet: Update Distance"):Connect(UpdateDistanceTraveled)
_L.Signal.Fired("Yeet a Pet: Update Bar"):Connect(UpdateBar)
_L.Signal.Fired("World Changed"):Connect(function(p8)
	if p8 ~= "Yeet" then
		v13.Visible = false
		v16.Enabled = false
		return
	end

	v13.Visible = true
	v16.Enabled = true
	v16.Power.Visible = false
end)

_L.Network.Fired("Yeet a Pet: Notify Reward"):Connect(function(p9)
	local v175 = v16:FindFirstChild("Result")
	v175.Visible = true
	v175:FindFirstChild("Amount").Text = _L.Functions.NumberShorten(p9) .. "!"

	task.delay(3, function()
		v175.Visible = false
	end)

	_L.Audio.Play("rbxassetid://14151622000", script, 1, 0.5)
end)

_L.Network.Fired("Yeet a Pet: Notify Record"):Connect(function(p10)
	local v205 = v16:FindFirstChild("NewRecord")
	v205.Visible = true

	task.delay(3, function()
		v205.Visible = false
	end)

	_L.Signal.Fire("Fireworks Animation at Position", p10)
end)

_L.Network.Fired("Yeet: Power Updated"):Connect(function(p11, p12)
	UpdatePowerGui(p11, p12)
end)

_L.Network.Fired("World Switched"):Connect(function(p13, p14)
	if p13.Name == _L.LocalPlayer.Name then
		return
	end

	if p14 ~= "Yeet" then
		return
	end

	UpdateBar(p13.Name, 0, 0)
end)

_L.Network.Fired("Yeet a Pet: Lap Pet"):Connect(function(p15, p16)
	local v244 = _L.GUI.YeetMain.Lap:Clone()
	local v297 = p16 <= 2 and "1 LAP!" or p16 .. " LAPS!"
	v244.Amount.Text = v297
	v244.Position = UDim2.new(0.2 + math.random() * 0.55, 0, 0.2 + v297, 0)
	v244.Size = UDim2.new(0, 0, 0, 0)
	v244.Visible = true
	v244.Parent = _L.GUI.YeetMain.Gui

	_L.Functions.Tween(v244, {Rotation = 360 + math.random(-20, 20), Size = v244.Size}, {0.25, "Sine", "Out"})

	task.delay(1.2, function()
		_L.Functions.Tween(v244, {Size = UDim2.new(0, 0, 0, 0)}, {0.3, "Sine", "Out"}).Completed:Connect(function()
			v244:Destroy()
		end)
	end)

	_L.Audio.Play("rbxassetid://14152968657", script, 1 + (p16 - 1) * 0.02, 0.2)
end)

_L.Signal.Fired("Yeet: Critical"):Connect(function()
	local v332 = _L.GUI.YeetMain.CriticalYeet:Clone()
	v332.Position = UDim2.new(0.2 + math.random() * 0.55, 0, 0.2 + math.random() * 0.5, 0)
	v332.Size = UDim2.new(0, 0, 0, 0)
	v332.Visible = true
	v332.Rotation = v12:NextInteger(-20, 20)
	v332.Parent = _L.GUI.YeetMain.Gui

	_L.Functions.Tween(v332, {Size = v332.Size}, {0.25, "Sine", "Out"})

	task.delay(1.2, function()
		_L.Functions.Tween(v332, {Size = UDim2.new(0, 0, 0, 0)}, {0.3, "Sine", "Out"}).Completed:Connect(function()
			v332:Destroy()
		end)
	end)

	_L.Shake.Create(1.5, 0.5, 0.15, true)
end)

local function setup_1()
	local v410 = v16:FindFirstChild("DistanceBar"):FindFirstChild("You")
	local v413 = v410:FindFirstChild("Lap")
	v410.Position = UDim2.new(0, 0, 1, 0)

	task.spawn(function()
		if v410.Image == "rbxassetid://7543041571" then
			v410.Image = GetThumbnail(_L.LocalPlayer.Name)
		end
	end)

	local v430 = v16:FindFirstChild("Power")
	local v434 = v430.Size
	local v444 = _L.TweenService:Create(v430, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = v434
	})

	v430:FindFirstChild("Amount").Changed:Connect(function()
		if v444.PlaybackState == Enum.PlaybackState.Playing then
			return
		end

		v430.Size = UDim2.fromScale(v434.X.Scale * 1.3, v434.Y.Scale * 1.3)
		v444:Play()
	end)
end

setup = setup_1
setup_1 = setup
setup_1()

game.Players.PlayerRemoving:Connect(function(p17)
	local v472 = v16:FindFirstChild("DistanceBar"):FindFirstChild(p17.Name)
	if v472 then
		v472:Destroy()
	end
end)  -  Editar
  04:54:13.865    -  Editar
  04:54:13.865  ----- [2600] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Yeet a Pet -----  -  Editar
  04:54:13.865  -- Decompiled using Krnl
local v7 = require((game.ReplicatedStorage:WaitForChild("Framework")):WaitForChild("Library"))
while not v7.Loaded do 
	game:GetService("RunService").Heartbeat:Wait()
end 
local v14 = require(game.ReplicatedStorage.Library.Types.Yeet)
local v16 = v7.Shared.IsHardcore
v15 = nil
function IsGameWorld()
	local v22 = v7.Save.Get()
	if not v22 then
		return false
	end
	if v16 then
		local v23 = true
		local world = v16 and v22.Hardcore.World or v22.World
		if world ~= "Yeet" then
			v23 = false
		end
		return v23
	end
end
function StartRound()
	local v30 = IsGameWorld()
	if not v30 then
		return 
	end
	local v37 = v7.WorldCmds.GetMap():FindFirstChild("Interactive"):FindFirstChild("Intermission Wall")
	if v37 then
		v37:Destroy()
	end
end
function StartIntermission()
	local v41 = IsGameWorld()
	if not v41 then
		return 
	end
	local v52 = v7.Assets.Models.Other.Yeet["Intermission Wall"]:Clone()
	v52.Parent = v7.WorldCmds.GetMap():FindFirstChild("Interactive")
	local v57 = v52:FindFirstChild("GateHUD"):FindFirstChild("Req"):FindFirstChild("Cost")
	task.spawn(function()
		while true do
			if v52 then
				break
			end
			v57.Text = "Starting in " .. math.floor(math.max(0, v15.IntermissionEndTime - workspace:GetServerTimeNow()))
			task.wait(1)
		end
	end)
end
function CalculateStrength()
	return 0
end
local function RequestGameData_1()
	v15 = v7.Network.Invoke("Yeet: Get Game Data")
	v7.Signal.Fire("Yeet: Game Data", v15)
end
local function v93()
	return 0
end
v7.Signal.Invoked("Yeet: Get Base Strength").OnInvoke = function()
	return 0
end
v7.Signal.Invoked("Yeet: Get Calculated Strength").OnInvoke = function()
	return CalculateStrength()
end
v7.Signal.Fired("World Changed"):Connect(function(p1)
	local v103 = v7.Lighting:FindFirstChildOfClass("Atmosphere")
	if p1 ~= "Yeet" then
		if v103.Density ~= 0.263 then
			v103.Density = 0.263
		end
		return 
	end
	if v103.Density ~= 0 then
		v103.Density = 0
	end
	if not v15 then
		RequestGameData_1()
	end
	if v15.RoundStarted then
		StartRound()
		return 
	end
	StartIntermission()
end)
v7.Network.Fired("Yeet: Game Data"):Connect(function(p2)
	v15 = p2
end)
v7.Network.Fired("Yeet: Round Started"):Connect(function()
	StartRound()
end)
v7.Network.Fired("Yeet: Intermission Started"):Connect(function()
	StartIntermission()
end)
v7.Network.Fired("Yeet: Orb Storm Started"):Connect(function()
	local v129 = IsGameWorld()
	if not v129 then
		return 
	end
	v7.Signal.Fire("Notification", "An Orb Storm has started! Collect now!", {
		color = Color3.fromRGB(255, 243, 62)
	})
	v7.Audio.Play("rbxassetid://14155267066", script, 1, 0.7)
end)
v7.Network.Fired("Yeet: Orb Storm Ended"):Connect(function()
	local v152 = IsGameWorld()
	if not v152 then
		return 
	end
	v7.Signal.Fire("Notification", "The Orb Storm has ended!", {
		color = Color3.fromRGB(255, 46, 46)
	})
end)
RequestGameData_1()
  -  Editar
  04:54:13.865    -  Editar
  04:54:13.865  ----- [2601] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Yeet a Pet Throwing -----  -  Editar
  04:54:13.865  local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

local v12 = Random.new()
inf = math.huge
v10 = false
local v13
local v14 = 0
local v19 = Vector3.new(-1, 0.1, 0)
local v20 = {
	[1] = "rbxassetid://14151864937",
	[2] = "rbxassetid://14151877437",
	[3] = "rbxassetid://14153443411",
	[4] = "rbxassetid://14155042993",
	[5] = "rbxassetid://14155043179"
}
local v21 = {
	[1] = "rbxassetid://14155659636",
	[2] = "rbxassetid://14155659935"
}
local v22 = {
	[1] = Color3.fromRGB(223, 223, 223),
	[2] = Color3.fromRGB(255, 0, 255),
	[3] = Color3.fromRGB(115, 0, 255),
	[4] = Color3.fromRGB(0, 132, 255),
	[5] = Color3.fromRGB(0, 221, 0),
	[6] = Color3.fromRGB(255, 255, 0),
	[7] = Color3.fromRGB(255, 85, 0),
	[8] = Color3.fromRGB(255, 0, 0)
}
local v27 = {
	{1000, 10000},
	{10000, 50000},
	{50000, 100000},
	{100000, 500000},
	{500000, 1000000},
	{1000000, 5000000},
	{5000000, inf} 
}
local v32 = nil
function track(p1)
	local v76 = string.sub(p1.Name, 1, -8)
	if p1.Name ~= _L.LocalPlayer.Name .. "_CLIENT" then
		if p1.Name == _L.LocalPlayer.Name .. "_SERVER" then
			return 
		end
		if string.sub(p1.Name, -7) ~= "_SERVER" then
			return 
		end
		local v79 = p1:GetAttribute("PetId")
		if v79 then
			if not p1:GetAttribute("PetIdt") then
				return 
			end
			local v85 = _L.Directory.Pets
			local v86 = v85[v79]
			v85 = {}
			v85.id = v79
			v85.uid = ""
			v85.idt = 0
			v85.s = 0
			v85.e = false
			v85.nk = v76
			local v90 = _L.PetCmds.Spawn(v85, game.Players[v76])
			local v91 = v90.part
			v91.Anchored = false
			v91.CanCollide = false
			v91.Position = p1.Position
			v91.CustomPhysicalProperties = PhysicalProperties.new(2, 1, 0, 100, 25)
			v91.Name = v76 .. "_CLIENT"
			v91.CollisionGroup = "Yeet"
			local v99 = Instance.new("Part")
			v99.Size = v91.Size
			v99.CanCollide = false
			v99.CanQuery = false
			v99.CanTouch = false
			v99.Transparency = 1
			v99.Name = "ParticleBox"
			v99.Position = v91.Position
			v99.Parent = v91
			local v284 = -1.5
			if v86.huge then
				v284 = -2.5
			elseif v86.titanic then
				v284 = -6
			end
			local v289 = v91:FindFirstChild("center").Position + Vector3.new(0, 0, -v284)
			local v292 = v91:FindFirstChild("center").Position + Vector3.new(-1, 0, -v284)
			local v295 = v91:FindFirstChild("center").Position + Vector3.new(1, 0, -v284)
			local v133 = _L.Assets.Other.Wind.Attachment:Clone()
			v133.Parent = v99
			v133.Position = v91:FindFirstChild("center").Position + Vector3.new(0, 0, v284)
			v133.Name = "FrontAttachment"
			if v86.huge then
				_L.Functions.Scaler(v133.Wind, 2.6666666666667)
				_L.Functions.Scaler(v133.smoke, 2.6666666666667)
			elseif v86.titanic then
				_L.Functions.Scaler(v133.Wind, 8)
				_L.Functions.Scaler(v133.smoke, 8)
			end
			local v146 = Instance.new("BodyPosition")
			v146.MaxForce = Vector3.new(0, inf, 0)
			v146.Parent = v133
			local v153 = Instance.new("BodyGyro")
			v153.MaxTorque = Vector3.new(inf, 0, 0)
			v153.Parent = v133
			v91.Parent = (workspace:FindFirstChild("__THINGS")):FindFirstChild("Yeet")
			local v162 = 0
			_L.RunService:BindToRenderStep(v76 .. "_effects", Enum.RenderPriority.Camera.Value + 1, function(p2)
				v162 = v162 + p2
				if v91 then
					if v91.Parent then
						if p1 then
							if not p1.Parent then
								return 
							end
							_L.PetCmds.Effects(v90, v85, v162, p2, true)
							v99.Position = v91.Position
							return 
						end
					end
				end
			end)
			local v184 =  p1.Position.X
			local v163 = 0
			local v185 = 0
			local v186
			v186 = _L.RunService.Heartbeat:Connect(function(p3)
				if p1.Parent ~= nil then
					if p1 == nil then
						if v91 then
							v91:Destroy()
						end
						_L.Signal.Fire("Yeet a Pet: Update Bar", v76, 0, 0)
						v186:Disconnect()
						_L.RunService:UnbindFromRenderStep(v76 .. "_effects")
						return 
					end
					v91.CFrame = p1.CFrame
					if p1.Position.X >= v184 then
						if math.abs(v184 - p1.Position.X) >= 1000 then
							v185 = v185 + 1
						else
							v163 = v163 + math.abs(v184 - p1.Position.X)
						end
						v184 = p1.Position.X
						local v232
						if v163 >= v14 then
							v232 = (v163) / v14 - math.floor((v163) / v14)
						else
							v232 = (v163) / v14
						end
						_L.Signal.Fire("Yeet a Pet: Update Bar", v76, v232, v185)
						local v215 = math.abs(v91.Velocity.X)
						local v216
						local v220 = nil
						local v222 = nil
						for v206, v221 in ipairs(v27) do
							if v206 == #v27 then
								v220 = v221[1]
								v222 = v221[2]
								v216 = v22[v206]
							end
						end
						if not v216 then
							if v133 then
								v133.Wind.Rate = 0
								v133.smoke.Rate = 0
								return 
							end
						end
						if v215 >= v220 then
							if v215 < v222 then
								if v216 then
									if v133 then
										v133.Wind.Rate = 100
										v133.smoke.Rate = 15
										v133.Wind.Color = ColorSequence.new(v216)
										v133.smoke.Color = ColorSequence.new(v216)
									end
								end
								return 
							end
						end
					end
				end
			end)
			return 
		end
	end
end
local function facePositiveX_1(p4)
	return CFrame.lookAt(p4.Position, p4.Position + p4.RightVector, p4.UpVector)
end
local function faceNegativeX_1(p5)
	return CFrame.lookAt(p5.Position, p5.Position + -p5.RightVector, p5.UpVector)
end
local function mapSpeedToValue_1(p6, p7, p8)
	return math.min(math.max(((p6 - p8) / p7 - p8) * 30 + 10, 10), 40)
end
v52 = false
function playHitSound()
	if v52 then
		return 
	end
	v52 = true
	_L.Audio.Play(v20[v12:NextInteger(1, #v20)], script, 1, 0.7)
	_L.Audio.Play(v21[v12:NextInteger(1, #v21)], script, 1, 0.7)
	task.wait(1)
	v52 = false
end
function createPetProjectile(p9, p10, p11, p12, p13, p14)
	local v377 = _L.LocalPlayer
	local v378 = v377.Character
	if not v378 then
		v378 = v377.CharacterAdded:Wait()
	end
	if not v378 then
		return false, "Something went wrong!"
	end
	assert(v378.PrimaryPart)
	local v386 = _L.Directory.Pets[p9.id]
	local v388 = _L.PetCmds.Spawn(p9, _L.LocalPlayer)
	v32 = v388.part
	v32.Anchored = false
	v32.CanCollide = true
	v32.Position = p10 + Vector3.new(-1, 0, 0)
	v32.CustomPhysicalProperties = PhysicalProperties.new(2, 1, 0, 100, 25)
	v32.Name = v377.Name .. "_CLIENT"
	v32.CollisionGroup = "Yeet"
	v32.Parent = (workspace:FindFirstChild("__THINGS")):FindFirstChild("Yeet")
	local v406 = Instance.new("Part")
	v406.Size = v32.Size
	v406.CanCollide = false
	v406.CanQuery = false
	v406.CanTouch = false
	v406.Transparency = 1
	v406.Name = "ParticleBox"
	v406.Parent = v32
	local v647 = -1.5
	if v386.huge then
		v647 = -2.5
	elseif v386.titanic then
		v647 = -6
	end
	local v652 = v32:FindFirstChild("center").Position + Vector3.new(0, 0, -v647)
	local v437 = Instance.new("Attachment")
	v437.Parent = v406
	v437.Position = v32:FindFirstChild("center").Position + Vector3.new(-1, 0, -v647)
	v437.Name = "TrailAttachment"
	local v440 = Instance.new("Attachment")
	v440.Parent = v406
	v440.Position = v32:FindFirstChild("center").Position + Vector3.new(1, 0, -v647)
	v440.Name = "TrailAttachment2"
	local v446 = _L.Assets.Other.Wind.Attachment:Clone()
	v446.Parent = v406
	v446.Position = v32:FindFirstChild("center").Position + Vector3.new(0, 0, v647)
	v446.Name = "FrontAttachment"
	local v447 = Instance.new("Trail")
	v447.Color = ColorSequence.new(Color3.new(1, 0, 0))
	v447.Attachment0 = v437
	v447.Attachment1 = v440
	v447.Parent = v406
	v447.Enabled = false
	v447.MaxLength = 0.01
	v447.Lifetime = 0.01
	if v386.huge then
		_L.Functions.Scaler(v446.Wind, 2.6666666666667)
		_L.Functions.Scaler(v446.smoke, 2.6666666666667)
	elseif v386.titanic then
		_L.Functions.Scaler(v446.Wind, 8)
		_L.Functions.Scaler(v446.smoke, 8)
	end
	local v467 = Instance.new("BodyPosition")
	v467.MaxForce = Vector3.new(0, inf, 0)
	v467.Parent = v446
	local v474 = Instance.new("BodyGyro")
	v474.MaxTorque = Vector3.new(inf, 0, 0)
	v474.Parent = v446
	local v481 = v32.CFrame
	v32.CFrame = CFrame.lookAt(v481.Position, v481.Position + v481.RightVector, v481.UpVector)
	v406.CFrame = v32.CFrame
	v32.Velocity = Vector3.new((v19.X) * p11, (v19.Y) * math.min(p11, 100000), 0)
	local v689 = _L.LocalPlayer
	workspace.CurrentCamera.CameraSubject = v32
	local v494 = 0
	local v498 = _L.Assets.Other.Hyperspace:Clone()
	v498.Parent = (workspace:FindFirstChild("__THINGS")):FindFirstChild("Yeet")
	local v694
	local idk
	idk = _L.RunService:BindToRenderStep("...", Enum.RenderPriority.Camera.Value + 1, function(p15)
		v494 = v494 + p15
		if v498 then
			if v498.Parent then
				if v32 and v32.Parent then
					if v32 == nil then
						_L.Signal.Fire("Yeet a Pet: Hide Distance")
						v498:Destroy()
					end
					local v541 = workspace.CurrentCamera
					v498.CFrame = CFrame.lookAt(v541.CFrame.Position + (v541.CFrame.LookVector) * math.min(math.max(((math.abs(v32.Velocity.X) - 1) / 99999) * 30 + 10, 10), 40), v541.CFrame.Position)
					_L.PetCmds.Effects(v388, p9, v494, p15, true)
					v406.Position = v32.Position
					return 
				end
			end
		end
	end)
	local v559 = false
	local v698
	
	local v613 = _L.RunService.Heartbeat:Connect(function(p16)
		--if not idk then
		if idk then
			idk:Disconnect()
			return 
		end
		if v32.Velocity.Z ~= 0 then
			v32.Velocity = Vector3.new(v32.Velocity.X, v32.Velocity.Y, 0)
		end
		if v446 then
			local v572 = v446:FindFirstChild("BodyGyro")
			if v572 then
				v446.BodyGyro.CFrame = CFrame.new(v446.Position, v446.Position - Vector3.new(1, 0, 0))
			end
		end
		local v583 = math.abs(v32.Velocity.X)
		local v584
		local v587 = nil
		local v589 = nil
		for v579, v588 in ipairs(v27) do
			if v579 == #v27 then
				v587 = v588[1]
				v589 = v588[2]
				v584 = v22[v579]
			end
		end
		if not v584 then
			if v446 then
				v446.Wind.Rate = 0
				v446.smoke.Rate = 0
			else
				if v584 then
					--break
					return
				end
				if v446 then
					--break
					return
				end 
				v446.Wind.Rate = 100
				v446.smoke.Rate = 15
				v446.Wind.Color = ColorSequence.new(v584)
				v446.smoke.Color = ColorSequence.new(v584)
			end
			if 10000 >= v583 then
				v447.Enabled = false
			end
			local v595 = RaycastParams.new()
			v595.CollisionGroup = "Yeet"
			v595.FilterType = Enum.RaycastFilterType.Exclude
			v595.FilterDescendantsInstances = {
				[1] = v32.Parent
			}
			if v386.titanic then
				v589 = -14
			else
				v589 = -5
			end
			if workspace:Raycast(v32.Position, Vector3.new(0, v589, 0), v595) then
				if not v559 then
					v559 = true
					playHitSound()
					--return 
					v559 = false
				end
				return 
			end
		end
		if v583 >= v587 then
			if v583 < v589 then
				return 
			end
		end
	end)
	if p14 then 
		_L.Signal.Fire("Yeet: Critical")
	end
	return true
end
function init(p17)
	if not p17 then
		if v13 then
			v13:Disconnect()
		end
		reset()
		return 
	end
	local v709 = workspace:FindFirstChild("__THINGS")
	if not v709 then
		return 
	end
	local v712 = v709:FindFirstChild("Yeet")
	if not v712 then
		return 
	end
	if v13 then
		v13:Disconnect()
	end
	v13 = v712.ChildAdded:Connect(function(p18)
		track(p18)
	end)
end
function Load(p19, p20)
	local v723 = _L.WorldCmds.GetMap()
	if not v723 then
		return 
	end
	local v727 = (v723:FindFirstChild("Interactive")):FindFirstChild("Yeet a Pet")
	if not v727 then
		boxPart = nil
		return 
	end
	boxPart = v727
end
local function handleClick_1(p21)
	if p21 then
		return 
	end
	if not v10 then
		if _L.Variables.ImportantWindowOpened then
			return 
		end
		v10 = true
		if not _L.Player.Humanoid(_L.LocalPlayer) then
			v10 = false
			return 
		end
		local v755 = function()
			local v732 = _L.Player.UpperTorso()
			if boxPart then
				if not v732 then
					return 
				end
				local v733 = RaycastParams.new() 
				v733.FilterDescendantsInstances = {
					[1] = {
						[1] = boxPart
					}
				} 
				v733.FilterType = Enum.RaycastFilterType.Whitelist
				local v743 = workspace:Raycast(v732.CFrame.p, (Vector3.new(0, -1, 0).Unit) * 25, v733)
				if v743 then
					if v743.Instance then
						return true
					end
				end
				return false
			end
		end
		if not v755() then
			v10 = false
			return 
		end
		--_L.Signal.Fire("Stop Riding Titanics")
		local v761, v762 = _L.Network.Invoke("Yeet a Pet: Throw")
		if not v761 then
			if v762 then
				_L.Signal.Fire("Notification", v762, {
					color = Color3.fromRGB(221, 85, 255)
				})
				v10 = false
			end
			return 
		end
		v10 = false
		return 
	end
end
function reset()
	v10 = false
	local v804 = _L.LocalPlayer
	local v805 = workspace.CurrentCamera
	v805.CameraSubject = v804.Character.Humanoid
	v805.CFrame = CFrame.new(v804.Character.HumanoidRootPart.Position)
	v804.CameraMode = Enum.CameraMode.Classic
	_L.Signal.Fire("Yeet a Pet: Hide Distance")
	_L.Signal.Fire("Yeet a Pet: Update Bar", v804.Name, 0, 0)
	local v800 = ((workspace:FindFirstChild("__THINGS")):FindFirstChild("Yeet")):FindFirstChild("Hyperspace")
	if v800 then
		v800:Destroy()
	end
	if v32 then
		v32:Destroy()
		v32 = nil
	end
end
_L.Signal.Fired("World Changed"):Connect(function(p22)
	Load(p22)
	if p22 == "Yeet" then
		init(true)
		return 
	end
	init(false)
end)
local v825 = false
game:GetService("UserInputService").TouchStarted:Connect(function(p23, p24)
	if p23.UserInputType ~= Enum.UserInputType.Touch then
		return 
	end
	v825 = true
end)
game:GetService("UserInputService").TouchEnded:Connect(function(p25, p26)
	if v825 then
		v825 = false
		handleClick_1(p26)
	end
end)
_L.UserInputService.InputBegan:Connect(function(p27, p28)
	if p27.UserInputType == Enum.UserInputType.MouseButton1 or p27.KeyCode == Enum.KeyCode.ButtonR2 then
		handleClick_1(p28)
	end
end)
_L.Network.Fired("Yeet a Pet: Finish Yeet"):Connect(reset)
v14 = _L.Network.Invoke("Yeet a Pet: Get Data")
_L.Network.Fired("Yeet a Pet: Send Data"):Connect(function(p29)
	v14 = p29
end)
_L.Network.Fired("Yeet a Pet: Lap Pet"):Connect(function(p30)
	local v873 = workspace:FindFirstChild("__THINGS"):FindFirstChild("Yeet"):FindFirstChild(_L.LocalPlayer.Name)
	if v873 then
		v873.CFrame = p30
	end
end)
_L.Network.Fired("Yeet a Pet: Update Client"):Connect(function(p31, p32, p33, p34)
	local v878
	if p31 >= v14 then
		v878 = (p31) / v14 - math.floor((p31) / v14)
	else
		v878 = (p31) / v14
	end
	_L.Signal.Fire("Yeet a Pet: Update Bar", _L.LocalPlayer.Name, v878, p32)
	_L.Signal.Fire("Yeet a Pet: Update Distance", p31)
	if v32 then
		v32.Velocity = p33
		v32.AssemblyAngularVelocity = p34
	end
end)
_L.Network.Fired("Yeet a Pet: Update Client Position"):Connect(function(p35)
	if v32 then
		v32.CFrame = p35
	end
end)
_L.Network.Fired("Yeet: Yeet Sound"):Connect(function(p36)
	local v907 = {
		[1] = "rbxassetid://14155659830", [2] = "rbxassetid://14152872463", [3] = "rbxassetid://14155659737"
	}
	_L.Audio.Play(v907[v12:NextInteger(1, #v907)], script, 0.9 + (math.random()) * 0.2, 0.2)
end)
_L.Network.Fired("Yeet a Pet: Client Throw"):Connect(createPetProjectile)
  -  Editar
  04:54:13.865    -  Editar
  04:54:13.865  ----- [2602] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Yeet Upgrades -----  -  Editar
  04:54:13.865  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local _ = {
	[0] = "rbxassetid://6869856569",
	[1] = "rbxassetid://6869856667",
	[2] = "rbxassetid://6869856744",
	[3] = "rbxassetid://6869856835",
	[4] = "rbxassetid://6869856917",
	[5] = "rbxassetid://6869856979"
};
local m_Library = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"));
while not m_Library.Loaded do
	game:GetService("RunService").Heartbeat:Wait();
end
local t_Upgrades = m_Library.GUI.YeetUpgrades;
local Holder = t_Upgrades.Container:FindFirstChild("Holder");
local _ = Random.new();
local bool1 = false;
function Buy(p1) -- Line: 28
	--[[
		Upvalues:
			[1] = m_Library
	--]]
	local v1, v2 = m_Library.Network.Invoke("Buy Upgrade", p1);
	if not v1 then
		m_Library.Message.New(v2 or "Something went wrong. Try again!");
		return;
	end
	m_Library.Functions.Wait(0.66);
end
function Update() -- Line: 38
	--[[
		Upvalues:
			[1] = m_Library
			[2] = Holder
			[3] = bool1
			[4] = t_Upgrades
	--]]
	local v3 = m_Library.Save.Get();
	if not v3 then return end
	local v4 = 0;
	local v5 = 0;
	for key1, val1 in pairs(m_Library.Directory.Upgrades) do
		if not val1.isYeetEvent then
			continue 
		end
		v4 = v4 + 5;
		local v6 = Holder:FindFirstChild(key1);
		if not v6 then
			v6 = m_Library.Assets.UI.Upgrades.YeetUpgrade:Clone();
			v6.Frame.Title.Text = val1.title;
			v6.Frame.Icon.Image = val1.icon;
			v6.Name = key1;
			local v9 = m_Library.Directory.Currency[val1.currency];
			v6.Frame.CostFrame.Currency.Image = v9.ImageOutline;
			v9.Gradient:Clone().Parent = v6.Frame.CostFrame.Cost;
			v6.Buy.Activated:Connect(function() -- Line: 67
				--[[
					Upvalues:
						[1] = bool1
						[2] = key1
				--]]
				if not bool1 then
					bool1 = true;
					Buy(key1);
					bool1 = false;
				end
			end);
			m_Library.GUIFX.ButtonFX(v6.Buy);
			v6.Parent = Holder;
		end
		local v7 = v3.Upgrades[key1] or 0;
		local v8 = val1.prices[v7 + 1];
		v6.Frame.CostFrame.Cost.Text = v8 and m_Library.Functions.NumberShorten(v8) or "Maxed";
		for _, child2 in ipairs(v6.Frame.Bars:GetChildren()) do
			if child2.ClassName ~= "ImageLabel" then continue end
			child2.Image = child2.LayoutOrder <= v7 and "rbxassetid://7055997958" or "rbxassetid://7055998070";
		end
		v5 = v5 + v7;
	end
	t_Upgrades.Completed.Text = math.round(v5 / v4 * 100) .. "% Complete";
	local UIListLayout = Holder:FindFirstChildOfClass("UIListLayout");
	local UIPadding = Holder:FindFirstChildOfClass("UIPadding");
	UIListLayout:ApplyLayout();
	Holder.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y + UIPadding.PaddingTop.Offset + UIPadding.PaddingBottom.Offset);
end
t_Upgrades.Close.Activated:Connect(function() -- Line: 110
	--[[
		Upvalues:
			[1] = bool1
			[2] = t_Upgrades
	--]]
	if not bool1 then
		bool1 = true;
		t_Upgrades.Gui.Enabled = false;
		bool1 = false;
	end
end);
m_Library.Signal.Fired("Open Yeet Upgrades"):Connect(function() -- Line: 119
	--[[
		Upvalues:
			[1] = t_Upgrades
	--]]
	t_Upgrades.Gui.Enabled = true;
end);
m_Library.GUIFX.ButtonFX(t_Upgrades.Close);
Update();
m_Library.Signal.Fired("Stat Changed"):Connect(function(p2) -- Line: 132
	if p2 == "Upgrades" then
		Update();
	end
end);
  -  Editar
  04:54:13.868    -  Editar
  04:54:13.868  ----- [2603] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Global Yeet Distance Leaderboard -----  -  Editar
  04:54:13.868  -- Decompiled using Krnl
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while not _L.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end
local v11
local v10 = nil
function Update()
	if v11 then
		if v10 then
			local v16 = v11:FindFirstChild("Main")
			if not v16 then
				return 
			end
			local v19 = v11.Main:FindFirstChildOfClass("SurfaceGui")
			for v27, v46 in ipairs(v10) do
				local v29 = v19.Frame:FindFirstChild("Spot" .. tostring(v27))
				if not v29 then
					local v31 = 3 >= v27
					v29 = _L.Assets.UI.Leaderboard.Spot:Clone()
					v29.LayoutOrder = v27
					v29.Rank.Text = "#" .. v27
					v29.Name = "Spot" .. v27
					if v31 then
						v32 = 50
					else
						v32 = 45
					end
					v29.Size = UDim2.new(1, 0, 0, v32)
					v29.Rank.TextColor3 = v31 and Color3.fromRGB(180, 170, 31) or Color3.fromRGB(102, 102, 102)
					v29.Parent = v19.Frame
					v29.Score.Text = _L.Functions.NumberShorten(v46.level, false)
					v29.Username.Text = "@" .. v46.username
					if v46.username == _L.LocalPlayer.Name then
						v29.Username.TextColor3 = Color3.fromRGB(28, 134, 173)
					else
						v29.Username.TextColor3 = Color3.fromRGB(121, 121, 121)
					end
				end
			end
			v19.Frame.CanvasSize = UDim2.new(0, 0, 0, v19.Frame:FindFirstChildOfClass("UIListLayout").AbsoluteContentSize.Y)
		end
	end
end
function Grab()
	local v89 = _L.Network.Invoke("Get Global Yeet Leaderboard")
	if v89 then
		v10 = v89
		Update()
	end
end
local function Check_1()
	local v96 = _L.WorldCmds.GetMap()
	local v98 = v96:FindFirstChild("Interactive")
	if v98 then
		v11 = v96.Interactive:FindFirstChild("Yeet Leaderboard")
		if v96.Interactive:FindFirstChild("Yeet Leaderboard") then
			Update()
			return 
		end
	end
end
_L.Signal.Fired("World Changed"):Connect(function()
	v11 = nil
	Check_1()
end)
coroutine.wrap(function()
	while true do
		if v11 then
			Grab()
		end
		wait(10)
	end
end)()
  -  Editar
  04:54:13.868    -  Editar
  04:54:13.868  ----- [2604] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Yeet Orbs -----  -  Editar
  04:54:13.869  -- Decompiled using Krnl
local v7 = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while not v7.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end
local v14 = require(game.ReplicatedStorage.Library.Types.Yeet)
local v18 = require(script.YeetOrbs)
local v19 = v7.Shared.IsHardcore
local v20 = Random.new()
local v21 = {"rbxassetid://14152825312","rbxassetid://14152854398","rbxassetid://14152854283"}
v22 = {"rbxassetid://14152825312","rbxassetid://14152854398","rbxassetid://14152854283"}
v23 = {}
v24 = {}
v25 = 0
local v26 = 12
function IsGameWorld()
	local v32 = v7.Save.Get()
	if not v32 then
		return false
	end
	if v19 then
		local v33 
		if not v19 then
			v33 = v32.World
		else
			v33 = v32.Hardcore.World
		end
		if v33 ~= "Yeet" then
			return false
		end
		return true
	end
end
function UpdatePickupDistance()
	local v42 = v7.Save.Get()
	if not v42 then
		return 
	end
	local v47 = v42.Upgrades["Yeet Orb Pickup Distance"] or 0
	if v47 >= 0 then
		v26 = 12 + (3.5) * v47
	end
end
function SpawnOrb(p1)
	local v52 = IsGameWorld()
	if not v52 then
		return 
	end
	local v59 = ((v7.WorldCmds.GetMap()):FindFirstChild("Interactive")):FindFirstChild("Orbs")
	if not v59 then
		return 
	end
	local v63 = v18[p1.OrbType].Model:Clone()
	v63.Name = p1.UUID
	v63:SetPrimaryPartCFrame(CFrame.new(p1.Position + Vector3.new(0, 3.5, 0)))
	local v74 = Instance.new("BodyPosition")
	v74.D = 50
	v74.P = 0
	v74.MaxForce = Vector3.zero
	v74.Parent = v63:FindFirstChild("Orb")
	v63.Parent = v59
	p1.Model = v63
	v23[p1.UUID] = p1
end
function CollectOrb(p2)
	local v88 = v7.Save.Get()
	if not v88 then
		return 
	end
	p2.Collected = true
	RemoveOrb_1(p2)
	local v93 = v7.Player.UpperTorso()
	local v114 = v88.Upgrades["Yeet Orb Power"] or 0
	local v113 = 0
	if v114 >= 0 then
		if not v14.Upgrades["Yeet Orb Power"][v114] then
			v113 = 1
		end
		v7.WorldFX.AddCurrency(v93.CFrame.p, v18[p2.OrbType].Amount, "Yeet Orbs", true)
		v7.WorldFX.AddCurrency(v93.CFrame.p, (125) * v113, "Yeet Strength", true)
		v25 = v25 + 1
		table.insert(v24, p2.UUID)
		return 
	end
end
function RemoveOrb_1(p3)
	v23[p3.UUID] = nil
	v7.Functions.AddDebris(p3.Model, 0)
end
v7.Network.Fired("Yeet: Spawn Orb"):Connect(function(p4)
	SpawnOrb(p4)
end)
v7.Network.Fired("Yeet: Reset Orbs"):Connect(function()
	v23 = {}
end)
v7.Signal.Fired("Stat Changed"):Connect(function(p5)
	if p5 == "Upgrades" then
		UpdatePickupDistance()
	end
end)
UpdatePickupDistance()
task.spawn(function()
	local v155 = 0
	v7.RunService.Heartbeat:Connect(function(p6)
		if #v24 >= 0 then
			v155 = v155 + p6
			if v155 > 0.25 then
				v155 = 0
				v24 = {}
				v7.Network.Fire("Yeet: Claim Orbs", v24)
			end
		end
	end)
end)
task.spawn(function()
	local v204 = 0
	v7.RunService.Heartbeat:Connect(function(p7)
		v204 = v204 + p7
		if 0.033333333333333 >= v204 then
			return 
		end
		v204 = 0
		(function()
			if v25 > 8 then
				v7.Audio.Play(v22, script, v20:NextNumber(0.95, 1.05), 0.45)
			else
				if v25 >= 0 then
					v7.Audio.Play(v21, script, v20:NextNumber(0.95, 1.05), 0.4)
				end
			end
			v25 = 0
		end)()
	end)
end)
task.spawn(function()
	local v216 = 0
	v7.RunService.Stepped:Connect(function(p9, p10)
		(function(p8)
			v216 = v216 + p8
			local v274 = v7.LocalPlayer
			local v223 = v7.Player.PrimaryPart()
			if not v223 then
				return 
			end
			local v224 = IsGameWorld()
			if not v224 then
				return 
			end
			for v273, v240 in ipairs((((v7.WorldCmds.GetMap()):FindFirstChild("Interactive")):FindFirstChild("Orbs")):GetChildren()) do
				local v241 = v23[v240.Name]
				local v278 = v241.Collected
				local v280 = v216 - v241.LastCheck
				local v281 = 0.33
				local v283 = v240:GetPivot().Position
				local v282 = v241.Pulling
				local v284 = v7.LocalPlayer:DistanceFromCharacter(v283 + Vector3.new(0, 2, 0))
				local v253 = 1
				local v257 = math.clamp((v284) / v26, 0, 1)
				local v290 = 0
				if v241.Pulling then
					v241.Pulling = false
					v241.Pulling = true
					local v258 = CFrame.lookAt(v283, v223.Position)
					v258 = (v258) * CFrame.Angles(0, 3.1415926535898, 0)
					v240:PivotTo(CFrame.new(v240:GetPivot().Position + (-v258.LookVector) * (v253 - v257) * 2))
					if v284 > v26 + 5 then
						v241.LastCheck = v216
					else
						if 4 > v284 then
							CollectOrb(v241)
						end
					end
				end
			end
		end)(p10)
	end)
end)

  -  Editar
  04:54:13.869    -  Editar
  04:54:13.869  ----- [2605] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Yeet Orbs.YeetOrbs -----  -  Editar
  04:54:13.869  local Assets = game.ReplicatedStorage.Assets
local Library = require(game.ReplicatedStorage.Library.Types.Yeet)

local Orbs = {}

Orbs.Basic = {
	Name = "Basic Orb",
	Amount = 1,
	StrengthMultiplier = 1.1,
	Model = Assets.Models.Other.Yeet.Orbs.Basic:Clone()
}

Orbs.Rare = {
	Name = "Rare Orb",
	Amount = 2,
	StrengthMultiplier = 1.2,
	Model = Assets.Models.Other.Yeet.Orbs.Rare:Clone()
}

Orbs.Epic = {
	Name = "Epic Orb",
	Amount = 3,
	StrengthMultiplier = 1.3,
	Model = Assets.Models.Other.Yeet.Orbs.Epic:Clone()
}

Orbs.Legendary = {
	Name = "Legendary Orb",
	Amount = 4,
	StrengthMultiplier = 1.4,
	Model = Assets.Models.Other.Yeet.Orbs.Legendary:Clone()
}

Orbs.Mythical = {
	Name = "Mythical Orb",
	Amount = 5,
	StrengthMultiplier = 1.5,
	Model = Assets.Models.Other.Yeet.Orbs.Mythical:Clone()
}

return Orbs  -  Editar
  04:54:13.869    -  Editar
  04:54:13.869  ----- [2606] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Delete Hardcore Sign -----  -  Editar
  04:54:13.869  -- Decompiled using Krnl

-- Import Library module from ReplicatedStorage
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))

-- Wait until Library is loaded
while not _L.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end

-- Import IsHardcore variable from Shared module in Library
local IsHardcore = _L.Shared.IsHardcore

-- Connect to the "World Changed" signal
_L.Signal.Fired("World Changed"):Connect(function(worldName)
	if worldName == "Yeet" then
		if IsHardcore then
			return 
		end

		-- Remove the HardcoreSign object from the Interactive map
		local InteractiveMap = _L.WorldCmds.GetMap():WaitForChild("Interactive")
		local HardcoreSign = InteractiveMap:FindFirstChild("HardcoreSign")
		if HardcoreSign then
			HardcoreSign:Destroy()
		end
	end
end)
  -  Editar
  04:54:13.869    -  Editar
  04:54:13.869  ----- [2607] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Platform Purchase -----  -  Editar
  04:54:13.870  -- Decompiled using Krnl

-- Import Library module from ReplicatedStorage
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))

-- Wait until Library is loaded
while not _L.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end

-- Table to hold purchase information
local purchases = {}

-- Function to check if an area is locked
function IsAreaLocked(areaName)
	local saveData = _L.Save.Get()
	if not saveData then
		return true
	end

	if _L.Shared.IsHardcore then
		local unlockedAreas = saveData.Hardcore.AreasUnlocked or saveData.AreasUnlocked
		if areaName == "Yeet Area 1" then
			return false
		end
		return not _L.Functions.SearchArray(unlockedAreas, "Yeet Area " .. tonumber(areaName:sub(-1)) - 1)
	end
end

-- Function to handle buying an area
function BuyArea(areaName)
	if not purchases[areaName] then
		return 
	end

	local areaData = _L.Directory.Areas[areaName]
	local currencySymbol = " "
	local currencyName = areaData.gate.currency

	-- Display confirmation message for buying access
	if not _L.Message.New("Do you want to buy access to these eggs for " .. _L.Functions.Commas(areaData.gate.cost) .. currencySymbol .. currencyName .. "?", true) then
		return 
	end

	local success, message = _L.Network.Invoke("Buy Area", areaName)
	if not success then
		_L.Message.New(message or "Error")
		return 
	end

	RemovePurchase(areaName)
end

-- Function to set up the purchase interaction
function SetupPurchase(areaName, areaModel)
	local purchaseLocked = false
	local interaction, cancelFunction = _L.Interact.Add(areaModel.PrimaryPart.Position + Vector3.new(0, 5, 0), {
		dist = 15, label = "Buy Eggs!"
	})

	interaction:Connect(function()
		if not purchaseLocked then
			purchaseLocked = true
			BuyArea(areaName)
			task.delay(0.5, function()
				purchaseLocked = false
			end)
		end
	end)

	purchases[areaName] = {
		Area = areaName, Model = areaModel, Cancel = cancelFunction
	}
	UpdatePurchase(purchases[areaName])
end

-- Function to update purchase information
function UpdatePurchase(purchaseData)
	local areaModel = purchaseData.Model
	local eggCostLabel = areaModel.PriceHUD:FindFirstChild("EggCost")

	if not eggCostLabel then
		eggCostLabel = _L.Assets.Billboards.EggCost:Clone()
		eggCostLabel.Currency.Image = _L.Directory.Currency["Yeet Coins"].Image
		eggCostLabel.Currency.Size = UDim2.new(0.15, 0, 0.8, 0)
		eggCostLabel.Parent = purchaseData.Model.PriceHUD
	end

	local isLocked = IsAreaLocked(purchaseData.Area)
	eggCostLabel.Currency.Visible = not isLocked

	if not isLocked then
		eggCostLabel.Amount.Text = _L.Functions.NumberShorten(_L.Directory.Areas[purchaseData.Area].gate.cost)
	else
		eggCostLabel.Amount.Text = "Locked"
	end
end

-- Function to remove a purchase
function RemovePurchase(areaName)
	local purchaseData = purchases[areaName]
	if not purchaseData then
		return 
	end

	purchaseData.Model:Destroy()
	purchaseData.Cancel()
	purchases[areaName] = nil
end

-- Connect to "World Changed" signal
_L.Signal.Fired("World Changed"):Connect(function(worldName)
	if worldName ~= "Yeet" then
		return 
	end

	local saveData = _L.Save.Get()
	if not saveData then
		return 
	end

	local unlockedAreas = _L.Shared.IsHardcore and saveData.Hardcore.AreasUnlocked or saveData.AreasUnlocked
	for _, platform in pairs(_L.WorldCmds.GetMap():WaitForChild("Interactive"):WaitForChild("Platforms"):GetChildren()) do
		if _L.Functions.SearchArray(unlockedAreas, platform.Name) then
			platform:Destroy()
		else
			SetupPurchase(platform.Name, platform)
		end
	end
end)

-- Connect to "Stat Changed" signal
_L.Signal.Fired("Stat Changed"):Connect(function(statName)
	if statName == "AreasUnlocked" then
		local saveData = _L.Save.Get()
		if not saveData then
			return 
		end

		local unlockedAreas = _L.Shared.IsHardcore and saveData.Hardcore.AreasUnlocked or saveData.AreasUnlocked
		for areaName, purchaseData in pairs(purchases) do
			local isUnlocked = _L.Functions.SearchArray(unlockedAreas, areaName)
			if isUnlocked then
				RemovePurchase(areaName)
			else
				UpdatePurchase(purchases[areaName])
			end
		end
	end
end)  -  Editar
  04:54:13.870    -  Editar
  04:54:13.870  ----- [2608] ServerStorage.__STORAGE.Yeet Stuff.Yeet.Rockets -----  -  Editar
  04:54:13.870  -- Decompiled using Krnl

-- Import Library module from ReplicatedStorage
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))

-- Wait until Library is loaded
while not _L.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end

-- Set cannon size
local cannonSize = _L.Assets.Billboards.Cannon.Size

-- Table to hold cannon information
local cannons = {}
local cannonCount = 0
local isFiring = false

-- Function to fire the cannon
local function FireRocket(rocket, player)
	if not rocket then
		_L.Print("Rocket does not exist")
		return 
	end

	local isLocalPlayer = player == _L.LocalPlayer

	-- Determine if the player is the local player
	local isLocalPlayer = (player == _L.LocalPlayer)

	local character = _L.Player.Character(player)
	local primaryPart = _L.Player.PrimaryPart(player)
	local humanoid = _L.Player.Humanoid(player)

	-- Check if the rocket is usable
	if character then
		if primaryPart then
			if not humanoid then
				_L.Print("Missing character - " .. player.Name, true)
				return 
			end

			local cannonInfo = cannons[rocket.Name]

			-- Check if the rocket is already in use
			if cannonInfo.using then
				_L.Print("Rocket is already active", true)
				return 
			end

			cannonInfo.using = true

			local worldName = rocket.Name
			if not _L.Directory.Worlds[worldName] then
				_L.Print("World '" .. worldName .. "' doesn't exist", true)
				return 
			end

			player:SetAttribute("UsingCannon", true)

			-- Fire the "Entered Cannon" signal
			if isLocalPlayer then
				_L.Signal.Fire("Entered Cannon")
				_L.Variables.UsingCannon = true
			else
				_L.Signal.Fire("Other Entered Cannon", player)
			end

			-- Play cannon launch sound
			_L.Audio.Play("rbxassetid://7480973873", rocket.PrimaryPart, 1, 1, 200)

			-- Adjust player position and orientation
			character:PivotTo((rocket.PrimaryPart.CFrame) * CFrame.Angles(0, math.pi, 0) + Vector3.new(0, 10, 0))

			local weldConstraint = Instance.new("WeldConstraint")
			weldConstraint.Part0 = rocket.PrimaryPart
			weldConstraint.Part1 = primaryPart
			weldConstraint.Parent = rocket.PrimaryPart

			_L.Functions.Wait(1)

			if isLocalPlayer then
				if not rocket.PrimaryPart then
					return
				end

				local rocketBottom = rocket:FindFirstChild("Rocket Bottom")
				local smokeEmitter = rocketBottom:FindFirstChild("Smoke"):FindFirstChild("ParticleEmitter")
				smokeEmitter.Enabled = true

				if isLocalPlayer then
					-- Clear debris and adjust lighting
					local mapDebris = _L.Debris:FindFirstChild("__MAPDEBRIS")
					if mapDebris then
						mapDebris:ClearAllChildren()
					end

					local initialClockTime = _L.Lighting.ClockTime
					local atmosphere = _L.Lighting:FindFirstChildOfClass("Atmosphere")
					if atmosphere then
						atmosphere:Destroy()
					end

					_L.Lighting.FogColor = Color3.new()

					local sky = _L.Lighting:FindFirstChildOfClass("Sky")
					if sky then
						sky.StarCount = 5000
						sky.CelestialBodiesShown = true
					end

					_L.Shake.Create(3, 0.75, 0.15, true)

					smokeEmitter.Enabled = false

					for _, flame in pairs(rocketBottom:FindFirstChild("Flames"):GetChildren()) do
						flame.Enabled = true
					end

					local function rocketAnimation(p3, p4)
						local pivot = rocket:GetPivot()
						pivot = pivot + (Vector3.new(0, (_L.Functions.Easing(math.min(p4, 1), Enum.EasingStyle.Cubic, Enum.EasingDirection.In)) * 750, 0)) * p3
						rocket:PivotTo(pivot)
						_L.Lighting.ClockTime = _L.Functions.Lerp(initialClockTime, 0, (p4) / 2.5)
					end

					_L.Functions.Heartbeat(rocketAnimation, 2.5):Wait()

					_L.Audio.Play(14155610836, rocket, 1, 0.5, 450):Stop()
					_L.WorldCmds.Load(worldName, nil, rocket:GetAttribute("FinalPosition"))
					_L.Variables.UsingCannon = false
					player:SetAttribute("UsingCannon", false)
					_L.Functions.Animation(11897877992, humanoid):Stop()
				else
					wait(5)
					primaryPart.Anchored = false
				end

				cannonInfo.using = false
				return 
			end
		end
	end
end

-- Function to handle client's attempt to fire the cannon
local function ClientAttemptFire(rocket)
	local canDoAction = _L.WorldCmds.CanDoAction()
	if not canDoAction then
		return 
	end

	local cannonFlag = _L.FFlags.Get(_L.FFlags.Keys.Cannons)
	if not cannonFlag then
		local canBypass = _L.FFlags.CanBypass(_L.LocalPlayer)
		if not canBypass then
			_L.Message.New("Sorry this is disabled right now! Please try back later")
			return 
		end
	end

	local success, message = _L.Network.Invoke("Request Cannon Launch", rocket.Name)
	if success then
		FireRocket(rocket, _L.LocalPlayer)
		return 
	end

	_L.Message.New(message or "You don't have access to this area!")
end

-- Function to initialize a cannon
local function InitializeCannon(cannon)
	local currentCount = cannonCount
	local cannonName = cannon.Name

	cannons[cannonName] = {
		physical = cannon,
		using = false,
		event = nil,
		eventCancel = nil
	}

	coroutine.wrap(function() 
		while cannonCount == currentCount and cannons[cannonName] do
			debug.profilebegin("Cannons.Init.pt1")

			local cannonInfo = cannons[cannonName]
			if cannonInfo.using then
				cannonInfo.event = nil
				if cannonInfo.eventCancel then
					cannonInfo.eventCancel()
					cannonInfo.eventCancel = nil
				end
			elseif not cannonInfo.event then
				local event, eventCancel = _L.Interact.Add(cannon.PrimaryPart.CFrame.Position, {dist = 25})
				cannonInfo.event = event
				cannonInfo.eventCancel = eventCancel
				event:Connect(function()
					if not isFiring then
						isFiring = true
						ClientAttemptFire(cannon)
						isFiring = false
					end
				end)
			end

			debug.profileend()
			wait(0.25)
		end
	end)()

	coroutine.wrap(function()
		local isNearby = false

		local function ShowHUD()
			local worldData = _L.Directory.Worlds[cannon.Name]
			local hudClone = _L.Assets.Billboards.Cannon:Clone()
			hudClone.Frame.World.Text = worldData.display
			hudClone.Frame.Currency.Image = _L.Directory.Currency[worldData.mainCurrency].Image
			hudClone.Name = "%HUD"
			hudClone.Parent = cannon
			hudClone.Size = UDim2.new(0, 0, 0, 0)
			hudClone.StudsOffset = Vector3.new()
			_L.Functions.Tween(hudClone, {
				Size = cannonSize,
				StudsOffset = Vector3.new(0, 12, 0)
			}, {
				0.2,
				Enum.EasingStyle.Quad,
				Enum.EasingDirection.Out
			})
		end

		local function HideHUD()
			local hud = cannon:FindFirstChild("%HUD")
			if hud then
				_L.Functions.Tween(hud, {
					Size = UDim2.new(0, 0, 0, 0),
					StudsOffset = Vector3.new(0, 4, 0)
				}, {
					0.15,
					Enum.EasingStyle.Quad,
					Enum.EasingDirection.In
				}).Completed:Connect(function()
					hud:Destroy()
				end)
			end
		end

		while cannonCount == currentCount and cannons[cannonName] do
			local cannonInfo = cannons[cannonName]
			local distanceFromCharacter = _L.LocalPlayer:DistanceFromCharacter(cannon.PrimaryPart.CFrame.Position)

			if not isNearby and distanceFromCharacter <= 35 then
				isNearby = true
				ShowHUD()
			elseif isNearby and distanceFromCharacter > 35 then
				isNearby = false
				HideHUD()
			end

			wait(math.clamp(distanceFromCharacter / 35, 0.1, 1))
		end
	end)()
end

-- Function to get the physical rocket
local function GetRocketPhysical(rocketName)
	local rocketsFolder = game.Workspace:WaitForChild("__MAP"):FindFirstChild("Rockets")
	if not rocketsFolder then
		return nil
	end
	return rocketsFolder:FindFirstChild(rocketName)
end

-- Function to load the world
local function LoadWorld()
	cannonCount = cannonCount + 1
	cannons = {}

	local rocketsFolder = game.Workspace:WaitForChild("__MAP"):FindFirstChild("Rockets")
	if not rocketsFolder then
		return 
	end

	for _, cannon in ipairs(rocketsFolder:GetChildren()) do
		InitializeCannon(cannon)
	end
end

-- Connect to "Cannon Fired" network event
_L.Network.Fired("Cannon Fired"):Connect(function(player, world, rocketName)
	if _L.WorldCmds.Get() == world then
		if player ~= _L.LocalPlayer then
			local hasLoaded = _L.WorldCmds.HasLoaded()
			if hasLoaded then
				local rocketPhysical = GetRocketPhysical(rocketName)
				if rocketPhysical then
					FireRocket(rocketPhysical, player)
				end
			end
		end
	end
end)

-- Connect to "World Changed" signal
_L.Signal.Fired("World Changed"):Connect(function()
	LoadWorld()
end)  -  Editar
  04:54:13.871    -  Editar
  04:54:13.871  ----- [2609] ServerStorage.__STORAGE.Yeet Stuff.Yeet.LocalScript -----  -  Editar
  04:54:13.871  -- Load the required Library
local Library = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))

-- Wait until the Library is loaded
while not Library.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end

-- Create a new Random generator
local RandomGenerator = Random.new()

-- Initialize variables
local isThrowing = false
local trackConnection

local gravity = Vector3.new(0, -9.8, 0) -- Gravity vector
local hyperspaceEffect = nil -- Hyperspace effect instance
local thrownPet = nil -- Thrown pet instance

-- Pet projectile data
local petData = {
	id = nil,
	uid = "",
	idt = 0,
	s = 0,
	e = false,
	nk = "",
}

-- List of asset IDs for sound effects
local hitSoundEffects = {
	"rbxassetid://14155659830",
	"rbxassetid://14152872463",
	"rbxassetid://14155659737",
}

-- Function to play a hit sound effect
local function playHitSound()
	if isThrowing then
		return
	end
	isThrowing = true
	Library.Audio.Play(hitSoundEffects[RandomGenerator:NextInteger(1, #hitSoundEffects)], script, 0.9 + (math.random()) * 0.2, 0.2)
	task.wait(1)
	isThrowing = false
end

-- Function to create a pet projectile
local function createPetProjectile(petId, startPos, throwSpeed, gravityScale, isCritical)
	local localPlayer = Library.LocalPlayer
	local character = localPlayer.Character

	if not character then
		character = localPlayer.CharacterAdded:Wait()
	end

	assert(character.PrimaryPart, "PrimaryPart not found!")

	local petInfo = Library.Directory.Pets[petId]
	local petSpawn = Library.PetCmds.Spawn(petData, localPlayer)
	local petPart = petSpawn.part

	-- Configure pet part
	petPart.Anchored = false
	petPart.CanCollide = true
	petPart.Position = startPos + Vector3.new(-1, 0, 0)
	petPart.CustomPhysicalProperties = PhysicalProperties.new(2, 1, 0, 100, 25)
	petPart.Name = localPlayer.Name .. "_CLIENT"
	petPart.CollisionGroup = "Yeet"
	petPart.Parent = (workspace:FindFirstChild("__THINGS")):FindFirstChild("Yeet")

	-- Other part configurations...

	-- Connect trail and effects...

	-- Set velocity based on throw speed and direction
	local throwDirection = Vector3.new(-1, 0, 0)
	petPart.Velocity = throwDirection * throwSpeed

	playHitSound()

	local v912 = Library.PetCmds
	if v912 then
		v912 = Library.PetCmds.Throw(petId, Library.LocalPlayer, v32, v32.Velocity)
		if not v912 then
			Library.Signal.Fire("Notification", "An error occurred while throwing the pet.", { color = Color3.fromRGB(221, 85, 85) })
			return false
		end
	end

	Library.Signal.Fire("Yeet a Pet: Threw")
	task.wait(1)
	v10 = false
end

-- Function to reset state
local function resetState()
	isThrowing = false
	local localPlayer = Library.LocalPlayer
	local camera = workspace.CurrentCamera
	camera.CameraSubject = localPlayer.Character.Humanoid
	camera.CFrame = CFrame.new(localPlayer.Character.HumanoidRootPart.Position)
	localPlayer.CameraMode = Enum.CameraMode.Classic
	Library.Signal.Fire("Yeet a Pet: Hide Distance")
	Library.Signal.Fire("Yeet a Pet: Update Bar", localPlayer.Name, 0, 0)
	if hyperspaceEffect then
		hyperspaceEffect:Destroy()
	end
	if thrownPet then
		thrownPet:Destroy()
		thrownPet = nil
	end
end

-- Function to handle pet throwing
local function handleThrowInput(input)
	if not input.UserInputType == Enum.UserInputType.MouseButton1 then
		if input.KeyCode == Enum.KeyCode.ButtonR2 then
			if not isThrowing then
				handleClick()
			end
		end
	end
end

-- Connect input events
Library.UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.Touch then
		isTouchingScreen = true
	end
end)

Library.UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
	if input.UserInputType == Enum.UserInputType.Touch then
		isTouchingScreen = false
		if isTapGesture then
			if not isThrowing then
				handleClick()
			end
		end
	end
end)

Library.UserInputService.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.Touch then
		local deltaPosition = input.DeltaPosition
		if isTouchingScreen and deltaPosition.Magnitude < 5 then
			isTapGesture = true
		else
			isTapGesture = false
		end
	end
end)

-- Listen for "Yeet a Pet: Finish Yeet" event to reset state
Library.Network.Fired("Yeet a Pet: Finish Yeet"):Connect(resetState)

-- Listen for "Yeet a Pet: Send Data" event to update pet data
Library.Network.Fired("Yeet a Pet: Send Data"):Connect(function(newData)
	petData = newData
end)

-- Listen for "Yeet a Pet: Update Client" event to update client state
Library.Network.Fired("Yeet a Pet: Update Client"):Connect(function(timestamp, barValue, velocity, angularVelocity)
	local progress = (timestamp >= petData.idt and (timestamp / petData.idt) % 1) or (timestamp / petData.idt)
	Library.Signal.Fire("Yeet a Pet: Update Bar", Library.LocalPlayer.Name, progress, barValue)
	Library.Signal.Fire("Yeet a Pet: Update Distance", timestamp)

	-- Update thrown pet state
	if thrownPet then
		thrownPet.Velocity = velocity
		thrownPet.AssemblyAngularVelocity = angularVelocity
	end
end)

-- Listen for "Yeet a Pet: Update Client Position" event to update pet position
Library.Network.Fired("Yeet a Pet: Update Client Position"):Connect(function(newPosition)
	if thrownPet then
		thrownPet.CFrame = newPosition
	end
end)

-- Listen for "Yeet: Yeet Sound" event to play a sound effect
Library.Network.Fired("Yeet: Yeet Sound"):Connect(function()
	-- Play the hit sound effect
	playHitSound()
end)

-- Listen for "Yeet a Pet: Play Hyperspace" event to play hyperspace effect
Library.Network.Fired("Yeet a Pet: Play Hyperspace"):Connect(function()
	if hyperspaceEffect then
		hyperspaceEffect:Destroy()
	end

	local localPlayer = Library.LocalPlayer
	local character = localPlayer.Character

	if not character then
		character = localPlayer.CharacterAdded:Wait()
	end

	local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
	local hyperspaceTemplate = Instance.new("Part")
	hyperspaceTemplate.Size = Vector3.new(1, 1, 1)
	hyperspaceTemplate.Anchored = true
	hyperspaceTemplate.CanCollide = false
	hyperspaceTemplate.Transparency = 1
	hyperspaceTemplate.Name = "HyperspaceEffect"
	hyperspaceTemplate.BrickColor = BrickColor.new("Bright blue")
	hyperspaceTemplate.Material = Enum.Material.SmoothPlastic
	hyperspaceTemplate.CFrame = humanoidRootPart.CFrame
	hyperspaceTemplate.Parent = character

	local fadeDuration = 0.4
	local fadeInDuration = fadeDuration * 0.2
	local fadeOutDuration = fadeDuration * 0.8

	local fadeIn = Instance.new("NumberValue")
	fadeIn.Name = "FadeIn"
	fadeIn.Value = fadeInDuration
	fadeIn.Parent = hyperspaceTemplate

	local fadeOut = Instance.new("NumberValue")
	fadeOut.Name = "FadeOut"
	fadeOut.Value = fadeOutDuration
	fadeOut.Parent = hyperspaceTemplate

	hyperspaceEffect = hyperspaceTemplate:Clone()
	hyperspaceEffect.Parent = character

	local fadeInTweenInfo = TweenInfo.new(fadeInDuration, Enum.EasingStyle.Linear)
	local fadeOutTweenInfo = TweenInfo.new(fadeOutDuration, Enum.EasingStyle.Linear)

	local fadeInTween = game.TweenService:Create(hyperspaceEffect, fadeInTweenInfo, { Transparency = 0 })
	local fadeOutTween = game.TweenService:Create(hyperspaceEffect, fadeOutTweenInfo, { Transparency = 1 })

	fadeInTween:Play()
	fadeInTween.Completed:Wait()

	fadeOutTween:Play()
	fadeOutTween.Completed:Wait()

	hyperspaceEffect:Destroy()
end)

-- Main loop
while wait() do
	if thrownPet then
		local localPlayer = Library.LocalPlayer
		local character = localPlayer.Character

		if character and character.PrimaryPart and thrownPet.PrimaryPart then
			local dist = (thrownPet.PrimaryPart.Position - character.PrimaryPart.Position).Magnitude
			local humanoid = character:FindFirstChild("Humanoid")
			if humanoid and dist >= 250 then
				humanoid.Health = 0
			end
		end
	end
end  -  Editar
  04:54:13.871    -  Editar
  04:54:13.871  ----- [2610] ServerStorage.__STORAGE.Admin CommandsBACKUP.Admin Cmds Client -----  -  Editar
  04:54:13.871  local colorTable = {
	Player = "#2cff79",
	Number = "#2ffcff",
	Boolean = "#b339ff",
	String = "#ffe02b",
	Any = "#ececec"
}

local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while not _L.Loaded do
	game:GetService("RunService").Heartbeat:Wait()
end

local adminCmdsGUI = _L.GUI.AdminCommands
local playerCommands = {}
local lockedCommands = {}
local prefix = nil
local searchText = ""
local debounce = false

function CreateCmdGui(name, commandData, locked) 	
	local cmd = script.Cmd:Clone()
	cmd.Name = name
	
	if locked then
		cmd.Header.BackgroundColor3 = Color3.new(0, 0, 0)
	end
	
	local function Title() 
		local text = locked and "🔒 " or "" 
		text = text .. prefix .. " <b>" .. commandData.cmds[1] .. "</b> "
		
		for i, v in ipairs(commandData.arguments) do
			local x, _, y = unpack(v)
			
            local clr = colorTable[x] or "#ececec"
			if i > 1 then
				text = text .. ", "
			end
			
            text = text .. '<font color="' .. clr .. '">' .. (tostring(y) or tostring(x)) .. "</font>"
		end
		
		cmd.Header.Title.Text = text
	end
	
	local cmds = {}
	local function Descs()
		
		if commandData.desc then
			if commandData.desc == "" then
				table.insert(cmds, "📄 <i>Description missing lmao.</i>")
			else
				table.insert(cmds, "📄 " .. commandData.desc)
			end
		end
		
		if #commandData.cmds > 1 then
			local text = "📌 "
			
			for i, v in ipairs(commandData.cmds) do
				if i == 1 then continue end
				
				if i >= 3 then
					text = text .. ", "
				end
				
				text = text .. "/" .. v
			end
			
			table.insert(cmds, text)
		end
		
		if not locked and #commandData.developers >= 1 then
			local text = "👥 "
			
			for i, v in ipairs(commandData.developers) do
				if i >= 2 then
					text = text .. ", "
				end
				text = text .. v
			end
			
			table.insert(cmds, text)
		end
		
		if commandData.permissions and locked then
			local text = "🔑 "
			
			for i, v in ipairs(commandData.permissions) do
				if i >= 2 then
					i = text .. ", "
				end
				
				text = text .. v
			end
			
			table.insert(cmds, text)
		end
		
		if commandData.fromGame then
			
			table.insert(cmds, '📜 <font color="#f7d7c4">Game Command</font>')
		end
		
		for i, v in ipairs(cmds) do
			local DescBlock = script.DescBlock:Clone()
			DescBlock.Title.Text = v
			DescBlock.LayoutOrder = i
			DescBlock.Parent = cmd.Descs
		end
	end
	
	local function Input() 
		local opened = false
		cmd.Header.ToggleOpen.Activated:Connect(function() 
			if not debounce then
				debounce = true
				
				opened = not opened
				cmd.Header.ToggleOpen.Image = opened and "http://www.roblox.com/asset/?id=6744295474" or "http://www.roblox.com/asset/?id=6744295081"
				if opened then
					cmd.Descs.Visible = true
					_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, script.DescBlock.Size.Y.Offset * #cmds + 35)}, {
						0.1,
						"Sine",
						"Out"
					})
				else
					_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, 35)}, {
						0.05,
						"Linear",
						"Out"
					}).Completed:Connect(function() 
						cmd.Descs.Visible = false
					end)
				end
				
				debounce = false
			end
		end)
	end
	
	Title()
	Descs()
	
	local opened = false
	cmd.Header.ToggleOpen.Activated:Connect(function() 
		if not debounce then
			debounce = true
			
			opened = not opened
			cmd.Header.ToggleOpen.Image = opened and "http://www.roblox.com/asset/?id=6744295474" or "http://www.roblox.com/asset/?id=6744295081"
			if opened then
				cmd.Descs.Visible = true
				_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, script.DescBlock.Size.Y.Offset * #cmds + 35)}, {
					0.1,
					"Sine",
					"Out"
				})
			else
				_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, 35)}, {
					0.05,
					"Linear",
					"Out"
				}).Completed:Connect(function() 
					cmd.Descs.Visible = false
				end)
			end
			
			debounce = false
		end
	end)
	
	cmd.Parent = adminCmdsGUI.Cmds
end

function Render() 
	for i, v in pairs(playerCommands) do
		CreateCmdGui(i, v)
	end
	
	for i, v in ipairs(lockedCommands) do
		CreateCmdGui("Locked-" .. i, v, true)
	end
end

function UpdateSearch() 
	local Input = adminCmdsGUI.Search:FindFirstChild("Input")
	
	if Input.Text and Input.Text ~= "" then
		searchText = string.lower(Input.Text)
	else
		searchText = ""
	end
	
	local function CheckIfInSearch(p6, p7) 
		for i, v in ipairs(p7.cmds) do
			if string.find(v, searchText, 1, true) == nil then continue end
			
			return true
		end
		
		if string.find(string.lower(p7.desc), searchText, 1, true) ~= nil then
			return true
		end
	end
	for i, v in ipairs(adminCmdsGUI.Cmds:GetChildren()) do
		local plyrCommand = playerCommands[v.Name]
		
		if v.ClassName ~= "Frame" or not plyrCommand then continue end
		
		if searchText ~= "" then			
			v.Visible = CheckIfInSearch(v, plyrCommand)
			continue
		end
		
		v.Visible = true
	end
end

function Scaling() 
	local cmds = adminCmdsGUI.Cmds
	local UIListLayout = cmds:FindFirstChildOfClass("UIListLayout")
	
	cmds.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y)
	UIListLayout:ApplyLayout()
end

function AddNotification(text) 
	local Notification = script.Notification:Clone()
	
	Notification.TextLabel.Text = text
	Notification.Parent = adminCmdsGUI.Notifications
	
	coroutine.wrap(function() 
		_L.Functions.Tween(Notification, {BackgroundColor3 = Color3.new(0, 0, 0)}, {
			0.25,
			"Sine",
			"In"
		})
		task.wait(3.5)
		_L.Functions.Tween(Notification.TextLabel, {TextTransparency = 1}, {
			1,
			"Sine",
			"In"
		})
		_L.Functions.Tween(Notification, {BackgroundTransparency = 1}, {
			1,
			"Sine",
			"In"
		}).Completed:Connect(function()
			Notification:Destroy()
		end)
	end)()
end

function Toggle() 
	local visible = not adminCmdsGUI.Frame.Visible
	
	if visible then
		local UIScale = adminCmdsGUI.Frame:FindFirstChildOfClass("UIScale")
		
		UIScale.Scale = 0.8
		_L.Functions.Tween(UIScale, {Scale = 1}, {
			0.15,
			"Expo",
			"Out"
		})
	end
	
	AddNotification(visible and "Opened Admin Commands HUD" or "Closed Admin Commands HUD")
	adminCmdsGUI.Frame.Visible = visible
end

playerCommands, lockedCommands, prefix = _L.Network.Invoke("Get BIG Admin Commands")

adminCmdsGUI.Search:FindFirstChild("Input"):GetPropertyChangedSignal("Text"):Connect(function() 
	UpdateSearch()
end)

adminCmdsGUI.Close.Activated:Connect(function() 
	if not debounce then
		debounce = true
		Toggle()
		debounce = false
	end
end)

_L.UserInputService.InputBegan:connect(function(input, gameProcessedEvent)
	if input.KeyCode == Enum.KeyCode.F4 then
		Toggle()
	end
end)

_L.Player.Player().Chatted:Connect(function(msg)
	if msg and msg == prefix .. " cmds" then
		Toggle()
	end
end)

_L.Network.Fired("Admin Cmds Notification"):Connect(function(text)
	AddNotification(text)
	if string.find(text, "Could not find player", 1, true) ~= nil then
		AddNotification("Tip: Start with @ if you are trying to get player by Display Name.")
	end
end)

Render()

coroutine.wrap(function()
	while true do
		if adminCmdsGUI.Frame.Visible then
			Scaling()
		end
		_L.RenderStepped()
	end
end)()  -  Editar
  04:54:13.871    -  Editar
  04:54:13.871  ----- [2611] ServerStorage.Admin Commands.Admin Cmds Client -----  -  Editar
  04:54:13.871  -- OneX rescripted this because yes

--------|     Setting     |--------
local Colors = {
	Player = "#2cff79",
	Number = "#2ffcff",
	Boolean = "#b339ff",
	String = "#ffe02b",
	Any = "#ececec"
}

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local adminCmdsGUI = _L.GUI.AdminCommands

--------|    Variables    |--------
local playerCommands, lockedCommands, prefix 
local searchText = ""
local debounce = false
local Input = adminCmdsGUI.Search:FindFirstChild("Input")

function CreateCmdGui(name, commandData, locked) 
	local cmds = {}	
	local cmd = script.Cmd:Clone()
	cmd.Name = name
	
	if commandData.fromGame then
		cmd.LayoutOrder = 9999
	end
	
	if locked then
		cmd.Header.BackgroundColor3 = Color3.new(0, 0, 0)
	end

	local function Title() 
		local text = locked and "🔒 " or "" 
		text = text .. prefix .. " <b>" .. commandData.cmds[1] .. "</b> "

		for i, v in ipairs(commandData.arguments) do
			local _type, _, title = unpack(v)
			local clr = Colors[_type] or "#ececec"
			if i > 1 then
				text = text .. ", "
			end

			text = text .. '<font color="' .. clr .. '">' .. (tostring(title) or tostring(_type)) .. "</font>"
		end

		cmd.Header.Title.Text = text
	end

	local function Descs()
		if commandData.desc then
			if commandData.desc == "" then
				table.insert(cmds, "📄 <i>Description missing lmao.</i>")
			else
				table.insert(cmds, "📄 " .. commandData.desc)
			end
		end

		if #commandData.cmds > 1 then
			local text = "📌 "
			for i, v in ipairs(commandData.cmds) do
				if i ~= 1 then 
					if i >= 3 then
						text = text .. ", "
					end
					text = text .. "/" .. v
				end	
			end
			table.insert(cmds, text)
		end

		if not locked and #commandData.developers >= 1 then
			local text = "👥 "
			for i, v in ipairs(commandData.developers) do
				if i >= 2 then
					text = text .. ", "
				end
				text = text .. v
			end
			table.insert(cmds, text)
		end

		if commandData.permissions and locked then
			local text = "🔑 "
			for i, v in ipairs(commandData.permissions) do
				if i >= 2 then
					text = text .. ", "
				end
				text = text .. v
			end
			table.insert(cmds, text)
		end

		if commandData.fromGame then
			table.insert(cmds, '📜 <font color="#f7d7c4">Game Command</font>')
		end

		for i, v in ipairs(cmds) do
			local DescBlock = script.DescBlock:Clone()
			DescBlock.Title.Text = v
			DescBlock.LayoutOrder = i
			DescBlock.Parent = cmd.Descs
		end
	end

	local function Input() 
		local opened = false
		cmd.Header.ToggleOpen.Activated:Connect(function() 
			if not debounce then
				debounce = true
				opened = not opened
				cmd.Header.ToggleOpen.Image = opened and "http://www.roblox.com/asset/?id=6744295474" or "http://www.roblox.com/asset/?id=6744295081"
				if opened then
					cmd.Descs.Visible = true
					_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, script.DescBlock.Size.Y.Offset * #cmds + 35)}, {0.1, "Sine", "Out"})
				else
					_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, 35)}, {0.05,"Linear", "Out"}).Completed:Connect(function() 
						cmd.Descs.Visible = false
					end)
				end
				debounce = false
			end
		end)
	end
	--
	Title()
	Descs()
	--
	local opened = false
	cmd.Header.ToggleOpen.Activated:Connect(function() 
		if not debounce then
			debounce = true
			opened = not opened
			cmd.Header.ToggleOpen.Image = opened and "http://www.roblox.com/asset/?id=6744295474" or "http://www.roblox.com/asset/?id=6744295081"
			if opened then
				cmd.Descs.Visible = true
				_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, script.DescBlock.Size.Y.Offset * #cmds + 35)}, {0.1, "Sine", "Out"})
			else
				_L.Functions.Tween(cmd, {Size = UDim2.new(1, 0, 0, 35)}, {0.05, "Linear", "Out"}).Completed:Connect(function() 
					cmd.Descs.Visible = false
				end)
			end
			debounce = false
		end
	end)

	cmd.Parent = adminCmdsGUI.Cmds
end

function RenderCategories()
	local category = script.Category:Clone()
	category.LayoutOrder = -2
	category.Header.Title.Text = "📜 Game Commands"
	category.Name = "CATEGORY"
	category.Parent = adminCmdsGUI.Cmds
	local category = script.Category:Clone()
	category.LayoutOrder = -1
	category.Header.Title.Text = "🌎 Universal Commands"
	category.Name = "CATEGORY"
	category.Parent = adminCmdsGUI.Cmds
end

function Render() 
	for i, v in pairs(playerCommands) do
		CreateCmdGui(i, v)
	end
	for i, v in ipairs(lockedCommands) do
		CreateCmdGui("Locked-" .. i, v, true)
	end
end

function UpdateSearch() 
	if Input.Text and Input.Text ~= "" then
		searchText = string.lower(Input.Text)
	else
		searchText = ""
	end
	
	local function IsSearched(_gui, data) 
		for i, v in ipairs(data.cmds) do
			if string.find(v, searchText, 1, true) ~= nil then
				return true 
			end
		end

		if string.find(string.lower(data.desc), searchText, 1, true) ~= nil then
			return true
		end
		
		return false
	end
	
	for i, v in ipairs(adminCmdsGUI.Cmds:GetChildren()) do
		local plyrCommand = playerCommands[v.Name]
		if v.ClassName == "Frame" and plyrCommand then
			if searchText ~= "" then			
				v.Visible = IsSearched(v, plyrCommand)
				continue
			end
			v.Visible = true
		end
	end
end

function Scaling() 
	local cmds = adminCmdsGUI.Cmds
	local UIListLayout = cmds:FindFirstChildOfClass("UIListLayout")

	cmds.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y)
	UIListLayout:ApplyLayout()
end

function AddNotification(text) 
	local Notification = script.Notification:Clone()

	Notification.TextLabel.Text = text
	Notification.Parent = adminCmdsGUI.Notifications

	coroutine.wrap(function() 
		_L.Functions.Tween(Notification, {BackgroundColor3 = Color3.new(0, 0, 0)}, {0.25, "Sine", "In"})
		task.wait(3.5)
		_L.Functions.Tween(Notification.TextLabel, {TextTransparency = 1}, {1, "Sine", "In"})
		_L.Functions.Tween(Notification, {BackgroundTransparency = 1}, {1, "Sine", "In"}).Completed:Connect(function()
			Notification:Destroy()
		end)
	end)()
end

function Toggle() 
	local visible = not adminCmdsGUI.Frame.Visible

	if visible then
		local UIScale = adminCmdsGUI.Frame:FindFirstChildOfClass("UIScale")

		UIScale.Scale = 0.8
		_L.Functions.Tween(UIScale, {Scale = 1}, {0.15, "Expo", "Out"})
	end

	AddNotification(visible and "Opened Admin Commands HUD" or "Closed Admin Commands HUD")
	adminCmdsGUI.Frame.Visible = visible
end

playerCommands, lockedCommands, prefix = _L.Network.Invoke("Get BIG Admin Commands")

adminCmdsGUI.Search:FindFirstChild("Input"):GetPropertyChangedSignal("Text"):Connect(function() 
	UpdateSearch()
end)

adminCmdsGUI.Close.Activated:Connect(function() 
	if not debounce then
		debounce = true
		Toggle()
		debounce = false
	end
end)

_L.UserInputService.InputBegan:connect(function(input, gameProcessedEvent)
	if input.KeyCode == Enum.KeyCode.F4 then
		Toggle()
	end
end)

_L.Player.Player().Chatted:Connect(function(msg)
	if msg and msg == prefix .. " cmds" then
		Toggle()
	end
end)

_L.Network.Fired("Admin Cmds Notification"):Connect(function(text)
	AddNotification(text)
	if string.find(text, "Could not find player", 1, true) ~= nil then
		AddNotification("Tip: Start with @ if you are trying to get player by Display Name.")
	end
end)

Render()
RenderCategories()

coroutine.wrap(function()
	while true do
		if adminCmdsGUI.Frame.Visible then
			Scaling()
		end
		_L.RenderStepped()
	end
end)()  -  Editar
  04:54:13.871    -  Editar
  04:54:13.871  ----- [2612] ServerStorage.Debug.Debug -----  -  Editar
  04:54:13.872  --------|     Setting     |--------

--- Time until an activity event expires from view
local activityExpireTime = 4 

--- Activity event label textColors
local activityTitleColors = {
	["INVOKE"] = Color3.fromRGB(236, 16, 255), -- Purple
	["INVOKED"] = Color3.fromRGB(236, 16, 255),
	["FIRE"] = Color3.fromRGB(251, 255, 0), -- Yellow
	["FIRED"] = Color3.fromRGB(251, 255, 0),
	["SIGNAL"] = Color3.fromRGB(70, 221, 255), -- Cyan
}

--- Activity event label parent frames
local activityparentFrames = {
	["INVOKE"] = "NetworkingSent",
	["INVOKED"] = "NetworkingReceived",
	["FIRE"] = "NetworkingSent",
	["FIRED"] = "NetworkingReceived",
	["SIGNAL"] = "Signals",
}

--- Filter most core signals from activity feed (internal framework stuff)
local filterCoreSignals = true

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local gui = _L.GUI.Debug
local starterGui = game:GetService("StarterGui")
local coreSignals = {
	"core network fire", "core network fired", "core network invoke", "core network invoked", 
	"core signal fired", "stats changed", "other stats changed"
}

--------|    Variables    |--------
local activity = {}
local lastEventId = 0
local debugOpen = false
local chatEnabled
local playerlistEnabled

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Update GUI
function Update()
	--- Disable chat and eladerboard if open
	if gui.Gui.Enabled and (not debugOpen) then
		debugOpen = true
		chatEnabled = starterGui:GetCore("ChatActive")
		playerlistEnabled = starterGui:GetCoreGuiEnabled("PlayerList")
		starterGui:SetCore("ChatActive", false)
		starterGui:SetCoreGuiEnabled("PlayerList", false)
	elseif (not gui.Gui.Enabled) and debugOpen then
		debugOpen = false
		starterGui:SetCore("ChatActive", chatEnabled)
		starterGui:SetCoreGuiEnabled("PlayerList", playerlistEnabled)
	end
	
	--- Only update if visible (reduce dropped frames)
	if not gui.Gui.Enabled then
		return
	end
	
	--- Get
	local log = _L.Debug.Get()
	
	--- Add
	for category, values in pairs(log) do
		--- Create category (and scale it)
		local node = gui.Nodes:FindFirstChild(category)
		if node == nil then
			node = script.node:Clone()
			node:FindFirstChild("%%title").Text = category
			node.Name = category
			node.Parent = gui.Nodes
		end
		
		--- Create value gui obj
		local function CreateValue(parent, name, value, ranking)
			local valueGui = parent:FindFirstChild(name)
			if valueGui == nil then
				valueGui = script.desc:Clone()
				valueGui.Text = name .. ":"
				valueGui.Name = name
				valueGui.Parent = parent
			end

			local descTextSize = _L.Services.TextService:GetTextSize(valueGui.Text, valueGui.TextSize, valueGui.Font, Vector2.new(1000, 1000))
			local valueTextSize = _L.Services.TextService:GetTextSize(tostring(value), valueGui.value.TextSize, valueGui.value.Font, Vector2.new(1000, 1000))
			
			descTextSize += Vector2.new(2, 2)

			local customType
			if type(value) == "string" then
				valueGui.value.Text = '"' .. valueGui.value.Text .. '"'
				valueGui.value.TextColor3 = Color3.fromRGB(255, 190, 23)
			elseif type(value) == "number" then
				valueGui.value.TextColor3 = Color3.fromRGB(11, 251, 255)
			elseif type(value) == "boolean" then
				valueGui.value.TextColor3 = value == true and Color3.fromRGB(81, 255, 42) or Color3.fromRGB(255, 41, 41)
			elseif typeof(value) == "Color3" or typeof(value) == "BrickColor" then
				--- create a color block for color3 and brickcolors
				customType = "color"
				local colorframe = valueGui.value:FindFirstChild("ColorBlock")
				if not colorframe then
					colorframe = Instance.new("Frame")
					colorframe.BorderSizePixel = 0
					colorframe.Size = UDim2.new(0, descTextSize.Y - 4, 0, descTextSize.Y - 4)
					colorframe.Position = UDim2.new(0, 2, 0.5, 0)
					colorframe.AnchorPoint = Vector2.new(0, 0.5)
					colorframe.Name = "ColorBlock"
					colorframe.Parent = valueGui.value
				end
				if typeof(value) == "Color3" then
					colorframe.BackgroundColor3 = value
				else
					colorframe.BackgroundColor3 = value.Color
				end
			end
			
			if not customType then
				valueGui.value.Position = UDim2.new(0, descTextSize.X, 0, 0)
				valueGui.value.Text = tostring(value)
				valueGui.Size = UDim2.new(0, (descTextSize.X + valueTextSize.X), 0, math.max(descTextSize.Y, valueTextSize.Y))
			elseif customType == "color" then --- custom formatting for color blocks since they dont take up space like regular text
				valueGui.value.Position = UDim2.new(0, descTextSize.X, 0, 0)
				valueGui.value.Text = ""
				valueGui.Size = UDim2.new(0, math.max(descTextSize.Y, valueTextSize.Y), 0, math.max(descTextSize.Y, valueTextSize.Y))
			end
			valueGui.LayoutOrder = (999999 - ranking)
		end
		
		--- Scan through
		local function ScanValues(index, frame)
			local ranking = 0
			for name, value in pairs(index) do
				ranking = ranking + 1
				if type(value) == "table" then
					local tableFrame = frame:FindFirstChild(tostring(value))
					if not tableFrame then
						tableFrame = script.node:Clone()
						tableFrame.Name = tostring(value)
						tableFrame:FindFirstChild("%%title").TextSize = 12
						tableFrame:FindFirstChild("%%title").Text = name
						tableFrame.BackgroundTransparency = 0.95
						tableFrame.Position = UDim2.new(0, 12, 0, 0)
						tableFrame.Parent = frame
					end
					ScanValues(value, tableFrame)
				else
					CreateValue(frame, name, value, ranking)
				end
			end
		end
		--
		ScanValues(values, node)
		
		--- Size titles
		for _, title in ipairs(node:GetDescendants()) do
			if title.Name == "%%title" and title.ClassName == "TextLabel" then
				local textSize = _L.Services.TextService:GetTextSize(title.Text, title.TextSize, title.Font, Vector2.new(1000, 1000))
				title.Size = UDim2.new(0, textSize.X, 0, textSize.Y)
			end
		end
		
		--- Size category
		local size = node:FindFirstChild("UIListLayout").AbsoluteContentSize
		node.Size = UDim2.new(0, size.X, 0, size.Y)
		
		--- Size table frames
		for _, frame in ipairs(node:GetDescendants()) do
			local layout = frame:FindFirstChild("UIListLayout")
			if frame.ClassName == "Frame" and layout then
				frame.Size = UDim2.new(0, layout.AbsoluteContentSize.X + 4, 0, layout.AbsoluteContentSize.Y + 4)
			end
		end
	end
	
	--- Remove
	local function ScanForRemove(parent, tbl)
		for _, node in ipairs(parent:GetChildren()) do
			if node.ClassName == "Frame" and string.find(node, "table: ") == nil then
				--- Bruh idk what this does anymore lol
				local category = log[node.Name]
				if category == nil then
					node:Destroy()
				else
					for _, value in ipairs(node:GetChildren()) do
						if value.ClassName == "TextLabel" and value.Name ~= "%%title" then
							if category[value.Name] == nil then
								value:Destroy()
							end
						end
					end
				end
			
			elseif node.ClassName == "Frame" then
				--- Searches ref for table hash
				local function ScanForTableHash(dict, hash)
					for _, t in pairs(dict) do
						if tostring(t) == hash then
							return t
						end
					end
				end
				
				--- Scan the for the table hash
				local tbl = ScanForTableHash(tbl or log, node.Name)
				
				--- Table hash doesn't exist anymore (no longer therew)
				if not tbl then
					node:Destroy()
				else
					for _, tblEntree in pairs(tbl) do
						ScanForRemove(node, tblEntree)
					end
				end
			end
		end
	end
	
	--- Size & Layout
	local layout = gui.Frame.Nodes:FindFirstChild("UIListLayout")
	layout:ApplyLayout()
	local size = layout.AbsoluteContentSize
	gui.Frame.Size = UDim2.new(0, size.X + 25, 0, size.Y + 25)
end


--- Update activity GUI
function UpdateActivity()
	--- Only update if visible (reduce dropped frames)
	if not gui.Gui.Enabled then
		return
	end
	
	--- Relative tick for event layoutorder based on timestamp
	local relativeTick = tick()
	
	--- Add
	for uid, data in pairs(activity) do
		local title = data.title
		local desc = data.desc
		local timestamp = data.timestamp
		local parent = gui.Activity:FindFirstChild(activityparentFrames[title]):FindFirstChild("Data")
		local dataGui = parent:FindFirstChild(uid)
		local timePassed = (relativeTick - timestamp)
		
		--- Check expire
		if timePassed < activityExpireTime then
			if not dataGui then
				--- Create
				dataGui = script.activity:Clone()
				dataGui.Name = uid
				dataGui.desc.Text = desc
				dataGui.title.Text = title
				
				--- Colors
				dataGui.title.TextColor3 = activityTitleColors[title]
				
				--- Sizing for text
				local descSize = _L.Services.TextService:GetTextSize(desc, dataGui.desc.TextSize, dataGui.desc.Font, Vector2.new(1000, 1000))
				local titleSize = _L.Services.TextService:GetTextSize(title, dataGui.title.TextSize, dataGui.title.Font, Vector2.new(1000, 1000))
				dataGui.desc.Size = UDim2.new(0, descSize.X, 0, descSize.Y)
				dataGui.title.Size = UDim2.new(0, titleSize.X, 0, titleSize.Y)
				dataGui.desc.Position = UDim2.new(0, titleSize.X + 4, 0, 0)
				dataGui.title.Position = UDim2.new(0, 2, 0, 0)
				dataGui.Size = UDim2.new(0, descSize.X + titleSize.X + 4, 0, math.max(descSize.Y, titleSize.Y))
				
				--
				dataGui.Parent = parent
			end
			
			dataGui.LayoutOrder = tonumber(uid)
			dataGui.Transparency = 0.5 + ((timePassed / activityExpireTime) * 0.5)
		end
	end
	
	--- Remove
	for _, frame in ipairs(gui.Activity:GetChildren()) do
		for _, dataGui in ipairs(frame:FindFirstChild("Data"):GetChildren()) do
			if dataGui.ClassName == "Frame" then
				local data = activity[dataGui.Name]
				
				--- Check for activity event expiration and remove if expired
				if data then
					local timePassed = (relativeTick - data.timestamp)
					if timePassed > activityExpireTime then
						dataGui:Destroy()
					end
				else
					dataGui:Destroy()
				end
			end
		end
	end
	
	--- Size & Layout
	for _, frame in ipairs(gui.Activity:GetChildren()) do
		local dataFrame = frame:FindFirstChild("Data")
		--
		local layout = dataFrame:FindFirstChild("UIListLayout")
		layout:ApplyLayout()
	end
end


--- Add activity event to activity queue for visualization
function AddActivity(title, desc)
	--- Ignore core stuff if enabled
	if filterCoreSignals and _L.Functions.SearchArray(coreSignals, desc) then
		return
	end
	
	--- Package and add
	lastEventId = lastEventId + 1
	local uid = tostring(lastEventId)
	local data = {uid = uid, title = title, desc = desc, timestamp = tick()}
	activity[uid] = data
	
	--- Remove event from memory after time (garbage collection)
	coroutine.wrap(function()
		wait(activityExpireTime)
		activity[uid] = nil
	end)()
end


--- Toggle visible
function Toggle()
	gui.Gui.Enabled = not gui.Gui.Enabled 
end


-----------------------------------------------------------------------------------------------------------------------


--- Signal was fired (for activity visualizer)
_L.Signal.Fired("CORE Signal Fired"):Connect(function(name)
	AddActivity("SIGNAL", name)
end)


--- Player invoked to server (for activity visualizer)
_L.Signal.Fired("CORE Network Invoke"):Connect(function(name)
	AddActivity("INVOKE", name)
end)


--- Player was invoked from server (for activity visualizer)
_L.Signal.Fired("CORE Network Invoked"):Connect(function(name)
	AddActivity("INVOKED", name)
end)


--- Player fired to server (for activity visualizer)
_L.Signal.Fired("CORE Network Fire"):Connect(function(name)
	AddActivity("FIRE", name)
end)


--- Player was sent something from server (for activity visualizer)
_L.Signal.Fired("CORE Network Fired"):Connect(function(name)
	AddActivity("FIRED", name)
end)


-----------------------------------------------------------------------------------------------------------------------


--- User input
_L.Services.UserInputService.InputBegan:connect(function(input, event)
	if input.KeyCode == Enum.KeyCode.F2 then
		Toggle()
	end
end)


--- Default items in the debug menu
coroutine.wrap(function()
	while wait() do
		if gui.Gui.Enabled then
			--- settings and variables
			local all = {Variables = _L.Variables, Settings = _L.Settings}
			for desc, values in pairs(all) do
				for name, value in pairs(values) do
					_L.Debug.Track(name, desc, value)
				end
			end
			
		end
	end
end)()


--- Main
while true do
	Update()
	UpdateActivity()
	_L.Services.RunService.RenderStepped:Wait()
end  -  Editar
  04:54:13.872    -  Editar
  04:54:13.872  ----- [2613] ServerStorage.Freecam.FreecamClient -----  -  Editar
  04:54:13.872  -- @localonex was here -- 
--------|     Library     |--------
local _L = require(game:GetService("ReplicatedStorage"):WaitForChild("Library")) _L.Load()
repeat task.wait() until _L.RunService:IsClient() or script.Parent.Parent ~= game:GetService("ServerStorage")

--------|    Reference    |--------
local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Settings = UserSettings()
local GameSettings = Settings.GameSettings

--------|    Variables    |--------
local pi    = math.pi
local abs   = math.abs
local clamp = math.clamp
local exp   = math.exp
local rad   = math.rad
local sign  = math.sign
local sqrt  = math.sqrt
local tan   = math.tan
local freecamGui = script.Parent

---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------
local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
	Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
	LocalPlayer = Players.LocalPlayer
end

local Camera = Workspace.CurrentCamera
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
	local newCamera = Workspace.CurrentCamera
	if newCamera then
		Camera = newCamera
	end
end)

local FFlagUserExitFreecamBreaksWithShiftlock
do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserExitFreecamBreaksWithShiftlock")
	end)
	FFlagUserExitFreecamBreaksWithShiftlock = success and result
end

------------------------------------------------------------------------

local TOGGLE_INPUT_PRIORITY = Enum.ContextActionPriority.Low.Value
local INPUT_PRIORITY = Enum.ContextActionPriority.High.Value

local NAV_GAIN = Vector3.new(1, 1, 1)*64
local PAN_GAIN = Vector2.new(0.75, 1)*8
local FOV_GAIN = 300

local PITCH_LIMIT = rad(90)

local VEL_STIFFNESS = 1.5
local PAN_STIFFNESS = 1.0
local FOV_STIFFNESS = 4.0

------------------------------------------------------------------------

local Spring = {} do
	Spring.__index = Spring

	function Spring.new(freq, pos)
		local self = setmetatable({}, Spring)
		self.f = freq
		self.p = pos
		self.v = pos*0
		return self
	end

	function Spring:Update(dt, goal)
		local f = self.f*2*pi
		local p0 = self.p
		local v0 = self.v

		local offset = goal - p0
		local decay = exp(-f*dt)

		local p1 = goal + (v0*dt - offset*(f*dt + 1))*decay
		local v1 = (f*dt*(offset*f - v0) + v0)*decay

		self.p = p1
		self.v = v1

		return p1
	end

	function Spring:Reset(pos)
		self.p = pos
		self.v = pos*0
	end
end

------------------------------------------------------------------------

local cameraPos = Vector3.new()
local cameraRot = Vector2.new()
local cameraFov = 0

local velSpring = Spring.new(VEL_STIFFNESS, Vector3.new())
local panSpring = Spring.new(PAN_STIFFNESS, Vector2.new())
local fovSpring = Spring.new(FOV_STIFFNESS, 0)

------------------------------------------------------------------------

local Input = {} do
	local thumbstickCurve do
		local K_CURVATURE = 2.0
		local K_DEADZONE = 0.15

		local function fCurve(x)
			return (exp(K_CURVATURE*x) - 1)/(exp(K_CURVATURE) - 1)
		end

		local function fDeadzone(x)
			return fCurve((x - K_DEADZONE)/(1 - K_DEADZONE))
		end

		function thumbstickCurve(x)
			return sign(x)*clamp(fDeadzone(abs(x)), 0, 1)
		end
	end

	local gamepad = {
		ButtonX = 0,
		ButtonY = 0,
		DPadDown = 0,
		DPadUp = 0,
		ButtonL2 = 0,
		ButtonR2 = 0,
		Thumbstick1 = Vector2.new(),
		Thumbstick2 = Vector2.new(),
	}

	local keyboard = {
		W = 0,
		A = 0,
		S = 0,
		D = 0,
		E = 0,
		Q = 0,
		U = 0,
		H = 0,
		J = 0,
		K = 0,
		I = 0,
		Y = 0,
		Up = 0,
		Down = 0,
		LeftShift = 0,
		RightShift = 0,
	}

	local mouse = {
		Delta = Vector2.new(),
		MouseWheel = 0,
	}

	local NAV_GAMEPAD_SPEED  = Vector3.new(1, 1, 1)
	local NAV_KEYBOARD_SPEED = Vector3.new(1, 1, 1)
	local PAN_MOUSE_SPEED    = Vector2.new(1, 1)*(pi/64)
	local PAN_GAMEPAD_SPEED  = Vector2.new(1, 1)*(pi/8)
	local FOV_WHEEL_SPEED    = 1.0
	local FOV_GAMEPAD_SPEED  = 0.25
	local NAV_ADJ_SPEED      = 0.75
	local NAV_SHIFT_MUL      = 0.25

	local navSpeed = 1

	function Input.Vel(dt)
		navSpeed = clamp(navSpeed + dt*(keyboard.Up - keyboard.Down)*NAV_ADJ_SPEED, 0.01, 4)

		local kGamepad = Vector3.new(
			thumbstickCurve(gamepad.Thumbstick1.X),
			thumbstickCurve(gamepad.ButtonR2) - thumbstickCurve(gamepad.ButtonL2),
			thumbstickCurve(-gamepad.Thumbstick1.Y)
		)*NAV_GAMEPAD_SPEED

		local kKeyboard = Vector3.new(
			keyboard.D - keyboard.A + keyboard.K - keyboard.H,
			keyboard.E - keyboard.Q + keyboard.I - keyboard.Y,
			keyboard.S - keyboard.W + keyboard.J - keyboard.U
		)*NAV_KEYBOARD_SPEED

		local shift = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift)

		return (kGamepad + kKeyboard)*(navSpeed*(shift and NAV_SHIFT_MUL or 1))
	end

	function Input.Pan(dt)
		local kGamepad = Vector2.new(
			thumbstickCurve(gamepad.Thumbstick2.Y),
			thumbstickCurve(-gamepad.Thumbstick2.X)
		)*PAN_GAMEPAD_SPEED
		local kMouse = mouse.Delta*PAN_MOUSE_SPEED
		mouse.Delta = Vector2.new()
		return kGamepad + kMouse
	end

	function Input.Fov(dt)
		local kGamepad = (gamepad.ButtonX - gamepad.ButtonY)*FOV_GAMEPAD_SPEED
		local kMouse = mouse.MouseWheel*FOV_WHEEL_SPEED
		mouse.MouseWheel = 0
		return kGamepad + kMouse
	end

	do
		local function Keypress(action, state, input)
			keyboard[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function GpButton(action, state, input)
			gamepad[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
			return Enum.ContextActionResult.Sink
		end

		local function MousePan(action, state, input)
			local delta = input.Delta
			mouse.Delta = Vector2.new(-delta.y, -delta.x)
			return Enum.ContextActionResult.Sink
		end

		local function Thumb(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position
			return Enum.ContextActionResult.Sink
		end

		local function Trigger(action, state, input)
			gamepad[input.KeyCode.Name] = input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function MouseWheel(action, state, input)
			mouse[input.UserInputType.Name] = -input.Position.z
			return Enum.ContextActionResult.Sink
		end

		local function Zero(t)
			for k, v in pairs(t) do
				t[k] = v*0
			end
		end

		function Input.StartCapture()
			ContextActionService:BindActionAtPriority("FreecamKeyboard", Keypress, false, INPUT_PRIORITY,
				Enum.KeyCode.W, Enum.KeyCode.U,
				Enum.KeyCode.A, Enum.KeyCode.H,
				Enum.KeyCode.S, Enum.KeyCode.J,
				Enum.KeyCode.D, Enum.KeyCode.K,
				Enum.KeyCode.E, Enum.KeyCode.I,
				Enum.KeyCode.Q, Enum.KeyCode.Y,
				Enum.KeyCode.Up, Enum.KeyCode.Down
			)
			ContextActionService:BindActionAtPriority("FreecamMousePan",          MousePan,   false, INPUT_PRIORITY, Enum.UserInputType.MouseMovement)
			ContextActionService:BindActionAtPriority("FreecamMouseWheel",        MouseWheel, false, INPUT_PRIORITY, Enum.UserInputType.MouseWheel)
			ContextActionService:BindActionAtPriority("FreecamGamepadButton",     GpButton,   false, INPUT_PRIORITY, Enum.KeyCode.ButtonX, Enum.KeyCode.ButtonY)
			ContextActionService:BindActionAtPriority("FreecamGamepadTrigger",    Trigger,    false, INPUT_PRIORITY, Enum.KeyCode.ButtonR2, Enum.KeyCode.ButtonL2)
			ContextActionService:BindActionAtPriority("FreecamGamepadThumbstick", Thumb,      false, INPUT_PRIORITY, Enum.KeyCode.Thumbstick1, Enum.KeyCode.Thumbstick2)
		end

		function Input.StopCapture()
			navSpeed = 1
			Zero(gamepad)
			Zero(keyboard)
			Zero(mouse)
			ContextActionService:UnbindAction("FreecamKeyboard")
			ContextActionService:UnbindAction("FreecamMousePan")
			ContextActionService:UnbindAction("FreecamMouseWheel")
			ContextActionService:UnbindAction("FreecamGamepadButton")
			ContextActionService:UnbindAction("FreecamGamepadTrigger")
			ContextActionService:UnbindAction("FreecamGamepadThumbstick")
		end
	end
end

local function GetFocusDistance(cameraFrame)
	local znear = 0.1
	local viewport = Camera.ViewportSize
	local projy = 2*tan(cameraFov/2)
	local projx = viewport.x/viewport.y*projy
	local fx = cameraFrame.rightVector
	local fy = cameraFrame.upVector
	local fz = cameraFrame.lookVector

	local minVect = Vector3.new()
	local minDist = 512

	for x = 0, 1, 0.5 do
		for y = 0, 1, 0.5 do
			local cx = (x - 0.5)*projx
			local cy = (y - 0.5)*projy
			local offset = fx*cx - fy*cy + fz
			local origin = cameraFrame.p + offset*znear
			local _, hit = Workspace:FindPartOnRay(Ray.new(origin, offset.unit*minDist))
			local dist = (hit - origin).magnitude
			if minDist > dist then
				minDist = dist
				minVect = offset.unit
			end
		end
	end

	return fz:Dot(minVect)*minDist
end

------------------------------------------------------------------------

local function StepFreecam(dt)
	local vel = velSpring:Update(dt, Input.Vel(dt))
	local pan = panSpring:Update(dt, Input.Pan(dt))
	local fov = fovSpring:Update(dt, Input.Fov(dt))

	local zoomFactor = sqrt(tan(rad(70/2))/tan(rad(cameraFov/2)))

	cameraFov = clamp(cameraFov + fov*FOV_GAIN*(dt/zoomFactor), 1, 120)
	cameraRot = cameraRot + pan*PAN_GAIN*(dt/zoomFactor)
	cameraRot = Vector2.new(clamp(cameraRot.x, -PITCH_LIMIT, PITCH_LIMIT), cameraRot.y%(2*pi))

	local cameraCFrame = CFrame.new(cameraPos)*CFrame.fromOrientation(cameraRot.x, cameraRot.y, 0)*CFrame.new(vel*NAV_GAIN*dt)
	cameraPos = cameraCFrame.p

	Camera.CFrame = cameraCFrame
	Camera.Focus = cameraCFrame*CFrame.new(0, 0, -GetFocusDistance(cameraCFrame))
	Camera.FieldOfView = cameraFov
end

local function CheckMouseLockAvailability()
	local devAllowsMouseLock = Players.LocalPlayer.DevEnableMouseLock
	local devMovementModeIsScriptable = Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
	local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
	local userHasClickToMoveEnabled =  GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
	local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable

	return MouseLockAvailable
end

------------------------------------------------------------------------

local PlayerState = {} do
	local mouseBehavior
	local mouseIconEnabled
	local cameraType
	local cameraFocus
	local cameraCFrame
	local cameraFieldOfView
	local screenGuis = {}
	local coreGuis = {
		Backpack = true,
		Chat = true,
		Health = true,
		PlayerList = true,
	}
	local setCores = {
		BadgesNotificationsActive = true,
		PointsNotificationsActive = true,
	}

	-- Save state and set up for freecam
	function PlayerState.Push()
		for name in pairs(coreGuis) do
			coreGuis[name] = StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType[name])
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], false)
		end
		for name in pairs(setCores) do
			setCores[name] = StarterGui:GetCore(name)
			StarterGui:SetCore(name, false)
		end
		local playergui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if playergui then
			for _, gui in pairs(playergui:GetChildren()) do
				if gui:IsA("ScreenGui") and gui.Enabled and gui.Name ~= "__FREECAM" then
					screenGuis[#screenGuis + 1] = gui
					gui.Enabled = false
				end
			end
		end

		cameraFieldOfView = Camera.FieldOfView
		Camera.FieldOfView = 70

		cameraType = Camera.CameraType
		Camera.CameraType = Enum.CameraType.Custom

		cameraCFrame = Camera.CFrame
		cameraFocus = Camera.Focus

		mouseIconEnabled = UserInputService.MouseIconEnabled
		--UserInputService.MouseIconEnabled = false

		if FFlagUserExitFreecamBreaksWithShiftlock and CheckMouseLockAvailability() then
			mouseBehavior = Enum.MouseBehavior.Default
		else
			mouseBehavior = UserInputService.MouseBehavior
		end
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end

	-- Restore state
	function PlayerState.Pop()
		for name, isEnabled in pairs(coreGuis) do
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType[name], isEnabled)
		end
		for name, isEnabled in pairs(setCores) do
			StarterGui:SetCore(name, isEnabled)
		end
		for _, gui in pairs(screenGuis) do
			if gui.Parent then
				gui.Enabled = true
			end
		end

		Camera.FieldOfView = cameraFieldOfView
		cameraFieldOfView = nil

		Camera.CameraType = cameraType
		cameraType = nil

		Camera.CFrame = cameraCFrame
		cameraCFrame = nil

		Camera.Focus = cameraFocus
		cameraFocus = nil

		--UserInputService.MouseIconEnabled = mouseIconEnabled
		mouseIconEnabled = nil

		UserInputService.MouseBehavior = mouseBehavior
		mouseBehavior = nil
	end
end

local function StartFreecam()
	local cameraCFrame = Camera.CFrame
	cameraRot = Vector2.new(cameraCFrame:toEulerAnglesYXZ())
	cameraPos = cameraCFrame.p
	cameraFov = Camera.FieldOfView

	velSpring:Reset(Vector3.new())
	panSpring:Reset(Vector2.new())
	fovSpring:Reset(0)

	PlayerState.Push()
	RunService:BindToRenderStep("Freecam", Enum.RenderPriority.Camera.Value, StepFreecam)
	Input.StartCapture()
end

local function StopFreecam()
	Input.StopCapture()
	RunService:UnbindFromRenderStep("Freecam")
	PlayerState.Pop()
end

------------------------------------------------------------------------

StartFreecam()

freecamGui.Close.Activated:Connect(function()
	StopFreecam()
	freecamGui:Destroy()
end)  -  Editar
  04:54:13.873    -  Editar
  04:54:13.873  ----- [2614] ServerStorage.Moderator Util.Main -----  -  Editar
  04:54:13.873  --------|     Setting     |--------
local logTypeImages = {
	Ban = "rbxassetid://2565271176",
	Unban = "rbxassetid://2570781919",
	Warn = "rbxassetid://2565271614",
}
local membershipSubString = {
	Premium = "Premium",
	None = "None",
}

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local GUI = {
	Gui = script.Parent,
	Frame = script.Parent:WaitForChild("Frame"),
	Content = script.Parent:WaitForChild("Frame"):WaitForChild("Content"),
	Search = script.Parent:WaitForChild("Frame"):WaitForChild("Search"),
	Player = script.Parent:WaitForChild("Frame"):WaitForChild("Content"):WaitForChild("Player"),
	Recent = script.Parent:WaitForChild("Frame"):WaitForChild("Content"):WaitForChild("Recent"),
	Keybind = script.Parent:WaitForChild("Keybind"),
}
local luaDate = require(script.LuaDate)

--------|    Variables    |--------
local clickDeb = false
local open = false
local navigationButtonEvents = {}
local actionButtonEvents = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


function LoadProfile(userId)
	local profile = _L.Network.Invoke("ModeratorUtil", "GetProfile", userId)
	if profile == nil then  return "Error"  end
	
	local baseOSTime = _L.Network.Invoke("ModeratorUtil", "GetOSTime")
	---
	for i = 1, #actionButtonEvents do
		actionButtonEvents[i]:disconnect()
	end
	actionButtonEvents = {}
	---
	coroutine.wrap(function()
		local username = _L.Functions.UserIdToUsername(userId)
		if username then
			GUI.Player.Title.Text = username
		else
			GUI.Player.Title.Text =  "(Unknown)"
		end
	end)()
	GUI.Player.Title.Text = GUI.Player.Title.Text .. "'s History"
	GUI.Player.Data.Age.Text = "Account Age - " .. _L.Functions.Commas(tonumber(profile.AccountAge)) .. " Days"
	GUI.Player.Data.Gamepasses.Text = "Gamepasses - " .. _L.Functions.Commas(tonumber(profile.Gamepasses))
	GUI.Player.Data.Membership.Text = "Membership - " .. membershipSubString[string.sub(profile.Membership, 21)] or "Unknown (None)"
	
	if profile.Spent ~= nil then
		GUI.Player.Data.Spent.Text = "Robux Spent - " .. _L.Functions.Commas(tonumber(profile.Spent))
		GUI.Player.Data.Spent.Visible = true
	else
		GUI.Player.Data.Spent.Visible = false
	end
	
	if profile.Paid ~= nil then
		if profile.Paid then
			GUI.Player.Data.Paid.Text = "Not a Paid Player"
			GUI.Player.Data.Paid.TextColor3 = Color3.fromRGB(255, 90, 90)
		else
			GUI.Player.Data.Paid.Text = "Paid Player"
			GUI.Player.Data.Paid.TextColor3 = Color3.fromRGB(105, 255, 88)
		end
		GUI.Player.Data.Paid.Visible = true
	else
		GUI.Player.Data.Paid.Visible = false
	end
	
	---
	if profile.IsBanned then
		GUI.Player.Data.Status.Text = "Status - Banned"
		GUI.Player.Data.Status.TextColor3 = Color3.fromRGB(236, 26, 26)
	elseif profile.IsWarned then
		GUI.Player.Data.Status.Text = "Status - Warned"
		GUI.Player.Data.Status.TextColor3 = Color3.fromRGB(228, 211, 20)
	else
		GUI.Player.Data.Status.Text = "Status - Clean"
		GUI.Player.Data.Status.TextColor3 = Color3.fromRGB(105, 255, 88)
	end
	---
	local timePassedSinceLastSeen = (baseOSTime - profile.LastUpdate)
	GUI.Player.Data.Seen.Text = "Last Seen - " .. _L.Functions.TimeString(timePassedSinceLastSeen)
	---
	GUI.Player.Portrait.Image = game.Players:GetUserThumbnailAsync(userId, Enum.ThumbnailType.AvatarThumbnail, Enum.ThumbnailSize.Size180x180)
	---
	local function LoadProfileHistory()
		GUI.Player.History:ClearAllChildren()
		---
		for _, log in ipairs(profile.History) do
			local logType = log.type
			local logReason = log.reason
			local logModeratorId = log.moderator
			local logDate = log.date
			local logTimePassed = (baseOSTime - logDate)
			--
			local logGui = script.ProfileLog:Clone()
			logGui.Reason.Text = string.upper(logType) .. " - " .. logReason
			logGui.Type.Image = logTypeImages[logType]
			logGui.TimePassed.Text = _L.Functions.TimeString(logTimePassed) .. " ago"
			--
			if logType == "Ban" then
				logGui.Reason.TextColor3 = Color3.fromRGB(236, 26, 26)
			elseif logType == "Warn" then
				logGui.Reason.TextColor3 = Color3.fromRGB(228, 211, 20)
			elseif logType == "Unban" then
				logGui.Reason.TextColor3 = Color3.fromRGB(105, 255, 88)
			end
			--
			coroutine.wrap(function()	
				local username = _L.Functions.UserIdToUsername(logModeratorId)
				if username then
					logGui.Moderator.Text = username
				else
					logGui.Moderator.Text = "(Unknown)"
				end
			end)()
			--
			logGui.LayoutOrder = logTimePassed
			logGui.Parent = GUI.Player.History
		end
		--- padding
		local padding = GUI.Player.History:FindFirstChild("%%Padding")
		if padding == nil then
			padding = Instance.new("UIPadding")
			padding.Name = "%%Padding"
			padding.PaddingRight = UDim.new(0, GUI.Player.History.ScrollBarThickness)
			padding.Parent = GUI.Player.History
		end
		--- layout
		local listLayout = GUI.Player.History:FindFirstChild("%%Layout")
		if listLayout == nil then
			listLayout = script.RecentLayout:Clone()
			listLayout.Name = "%%Layout"
			listLayout.Parent = GUI.Player.History
			coroutine.wrap(function()
				while (listLayout and listLayout.Parent) do
					listLayout:ApplyLayout()
					GUI.Player.History.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y+1)
					_L.Services.RunService.Stepped:wait()
				end
			end)()
		end
	end
	---
	local function GetReason()
		local reason
		local clickEvent
		--
		GUI.Player.Reason.Visible = true
		--
		clickEvent = GUI.Player.Reason.Submit.MouseButton1Click:Connect(function()
			reason = GUI.Player.Reason.Input.Text
			clickEvent:disconnect()
		end)
		--
		repeat  wait()  until GUI.Player.Reason.Visible == false or GUI.Player.Visible == false or GUI.Frame.Visible == false or reason ~= nil
		--
		GUI.Player.Reason.Visible = false
		return reason
	end
	---
	local function PerformAction(action)
		local reason = GetReason()
		if reason and reason ~= "" then
			local areYouSure = _L.Message.New("Are you sure?", true)
			if areYouSure then
				local success = _L.Network.Invoke("ModeratorUtil", action, userId, game.Players.LocalPlayer.UserId, reason)
				if success then
					_L.Message.New("Success!")
					LoadProfile(userId)
				else
					_L.Message.New("Failed!")
				end
			end
		elseif reason == nil or reason == "" then
			_L.Message.New("Reason cannot be blank")
		end
	end
	---
	actionButtonEvents[#actionButtonEvents + 1] = GUI.Player.Ban.MouseButton1Click:Connect(function()
		if clickDeb == false then
			clickDeb = true
			PerformAction("Ban")
			clickDeb = false
		end
	end)
	actionButtonEvents[#actionButtonEvents + 1] = GUI.Player.Clear.MouseButton1Click:Connect(function()
		if clickDeb == false then
			clickDeb = true
			PerformAction("Clear")
			clickDeb = false
		end
	end)
	actionButtonEvents[#actionButtonEvents + 1] = GUI.Player.Warn.MouseButton1Click:Connect(function()
		if clickDeb == false then
			clickDeb = true
			PerformAction("Warn")
			clickDeb = false
		end
	end)
	---
	LoadProfileHistory()
	---
	SwitchWindow("Player")
end


function LoadRecent(pageNum)
	local page = _L.Network.Invoke("ModeratorUtil", "GetList", pageNum)
	---
	GUI.Recent.Content:ClearAllChildren()
	for i = 1, #navigationButtonEvents do
		navigationButtonEvents[i]:disconnect()
	end
	navigationButtonEvents = {}
	---
	for i, log in ipairs(page) do
		local logType = log.t
		local logTimePassed = log.tp
		local logDate = log.d
		local logModId = log.m
		local logVictimId = log.v
		--
		local logGui = script.RecentLog:Clone()
		logGui.Type.Image = logTypeImages[logType]
		logGui.TimePassed.Text = _L.Functions.TimeString(logTimePassed) .. " ago"
		--
		local date = luaDate(logDate)
		logGui.Date.Text = date:fmt("%c GMT%z")
        --

        
		coroutine.wrap(function()
			local username = _L.Functions.UserIdToUsername(logVictimId)
			if logGui and logGui:FindFirstChild("Username") then
				if username then
					logGui.Username.Text = username
				else
					logGui.Username.Text =  "(Unknown)"
				end
			end
		end)()
		--
		coroutine.wrap(function()
			local username = _L.Functions.UserIdToUsername(logModId)
			if logGui and logGui:FindFirstChild("Username") then
				if username then
					logGui.Moderator.Text = logType .. " from: " .. username
				else
					logGui.Moderator.Text = logType .. " from: (Unknown)"
				end
			end
		end)()
		--
		logGui.Details.MouseButton1Click:Connect(function()
			if clickDeb == false then
				clickDeb = true
				LoadProfile(logVictimId)
				clickDeb = false
			end
		end)
		logGui.LayoutOrder = logTimePassed
		logGui.Parent = GUI.Recent.Content
	end
	--- padding
	local padding = GUI.Recent.Content:FindFirstChild("%%Padding")
	if padding == nil then
		padding = Instance.new("UIPadding")
		padding.Name = "%%Padding"
		padding.PaddingRight = UDim.new(0, GUI.Recent.Content.ScrollBarThickness)
		padding.Parent = GUI.Recent.Content
	end
	--- layout
	local listLayout = GUI.Recent.Content:FindFirstChild("%%Layout")
	if listLayout == nil then
		listLayout = script.RecentLayout:Clone()
		listLayout.Name = "%%Layout"
		listLayout.Parent = GUI.Recent.Content
		coroutine.wrap(function()
			while (listLayout and listLayout.Parent) do
				listLayout:ApplyLayout()
				GUI.Recent.Content.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y+1)
				_L.Services.RunService.Stepped:wait()
			end
		end)()
	end
	---
	GUI.Recent.Page.Text = "Page " .. pageNum
	navigationButtonEvents[#navigationButtonEvents + 1] = GUI.Recent.Forward.MouseButton1Click:Connect(function()
		if clickDeb == false then
			clickDeb = true
			LoadRecent(pageNum + 1)
			clickDeb = false
		end
	end)
	navigationButtonEvents[#navigationButtonEvents + 1] = GUI.Recent.ForwardFast.MouseButton1Click:Connect(function()
		if clickDeb == false then
			clickDeb = true
			LoadRecent(pageNum + 3)
			clickDeb = false
		end
	end)
	if pageNum > 1 then
		navigationButtonEvents[#navigationButtonEvents + 1] = GUI.Recent.Back.MouseButton1Click:Connect(function()
			if clickDeb == false then
				clickDeb = true
				LoadRecent(pageNum - 1)
				clickDeb = false
			end
		end)
		navigationButtonEvents[#navigationButtonEvents + 1] = GUI.Recent.BackFast.MouseButton1Click:Connect(function()
			if clickDeb == false then
				clickDeb = true
				LoadRecent(math.max(pageNum - 3, 1))
				clickDeb = false
			end
		end)
	end
	---
	SwitchWindow("Recent")
end


------------------------------------------------------------------------------


function SwitchWindow(window)
	for _, otherWIndow in ipairs(GUI.Content:GetChildren()) do
		if otherWIndow.ClassName == "Frame" then
			otherWIndow.Visible = false
		end
	end
	---
	GUI[window].Visible = true
end


function ToggleOpen()
	open = not open
	GUI.Frame.Visible = open
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


GUI.Search:WaitForChild("Go").MouseButton1Click:Connect(function()
	if not clickDeb then
		clickDeb = true
		local searchField = GUI.Search.Field.Text
		if searchField ~= "" then
			local userId
			local success = pcall(function()
				userId = game.Players:GetUserIdFromNameAsync(searchField)
			end)
			if success and userId then
				if LoadProfile(userId) == "Error" then
					_L.Message.New("Failed to fetch " .. searchField .. "'s history")
				end
			else
				_L.Message.New("Username does not exist")
			end
		else
			_L.Message.New("Enter username first")
		end
		clickDeb = false
	end
end)


GUI.Player:WaitForChild("Back").MouseButton1Click:Connect(function()
	--if not clickDeb then
	--	clickDeb = true
		SwitchWindow("Recent")
		--clickDeb = false
	--end
end)


game:GetService("UserInputService").InputBegan:connect(function(input, event)
	if input.KeyCode == Enum.KeyCode.F8 then
		ToggleOpen()
	end
end)


GUI.Keybind.MouseButton1Click:Connect(function()
	ToggleOpen()
end)


------------------------------------------------------------------------------

--- Console selection locks up. Not needed!
if _L.Variables.Console then
	script.Parent:Destroy()
	return
end

--- Load
LoadRecent(1)
