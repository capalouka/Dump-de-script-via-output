  04:54:13.789  ----- [2412] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.Queue -----  -  Editar
  04:54:13.789  --[=[
	Private queue class for loading system.

	@private
	@class Queue
]=]

local Queue = {}
Queue.ClassName = "Queue"
Queue.__index = Queue

--[=[
	Constructs a new queue
	@return Queue<T>
]=]
function Queue.new()
	return setmetatable({
		_first = 0;
		_last = -1;
	}, Queue)
end

--[=[
	Pushes an entry to the left of the queue
	@param value T
]=]
function Queue:PushLeft(value)
	self._first = self._first - 1
	self[self._first] = value
end

--[=[
	Pushes an entry to the right of the queue
	@param value T
]=]
function Queue:PushRight(value)
	self._last = self._last + 1
	self[self._last] = value
end

--[=[
	Pops an entry from the left of the queue
	@return T
]=]
function Queue:PopLeft()
	if self._first > self._last then
		error("Queue is empty")
	end

	local value = self[self._first]
	self[self._first] = nil
	self._first = self._first + 1

	return value
end

--[=[
	Pops an entry from the right of the queue
	@return T
]=]
function Queue:PopRight()
	if self._first > self._last then
		error("Queue is empty")
	end

	local value = self[self._last]
	self[self._last] = nil
	self._last = self._last - 1

	return value
end

--[=[
	Returns true if the queue is empty
	@return boolean
]=]
function Queue:IsEmpty()
	return self._first > self._last
end

return Queue
  -  Editar
  04:54:13.789    -  Editar
  04:54:13.789  ----- [2413] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.ScriptInfoUtils -----  -  Editar
  04:54:13.789  --[=[
	@private
	@class ScriptInfoUtils
]=]

local CollectionService = game:GetService("CollectionService")

local loader = script.Parent
local Utils = require(script.Parent.Utils)
local BounceTemplateUtils = require(script.Parent.BounceTemplateUtils)

local ScriptInfoUtils = {}

ScriptInfoUtils.DEPENDENCY_FOLDER_NAME = "node_modules";
ScriptInfoUtils.ModuleReplicationTypes = Utils.readonly({
	CLIENT = "client";
	SERVER = "server";
	SHARED = "shared";
	IGNORE = "ignore";
	PLUGIN = "plugin";
})

function ScriptInfoUtils.createScriptInfo(instance, name, replicationMode)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(name) == "string", "Bad name")
	assert(type(replicationMode) == "string", "Bad replicationMode")

	return Utils.readonly({
		name = name;
		replicationMode = replicationMode;
		instance = instance;
	})
end

function ScriptInfoUtils.createScriptInfoLookup()
	-- Server/client also contain shared entries
	return Utils.readonly({
		[ScriptInfoUtils.ModuleReplicationTypes.SERVER] = {}; -- [string name] = scriptInfo
		[ScriptInfoUtils.ModuleReplicationTypes.CLIENT] = {};
		[ScriptInfoUtils.ModuleReplicationTypes.SHARED] = {};
		[ScriptInfoUtils.ModuleReplicationTypes.PLUGIN] = {};
	})
end

function ScriptInfoUtils.getScriptInfoLookupForMode(scriptInfoLookup, replicationMode)
	assert(type(scriptInfoLookup) == "table", "Bad scriptInfoLookup")
	assert(type(replicationMode) == "string", "Bad replicationMode")

	return scriptInfoLookup[replicationMode]
end

function ScriptInfoUtils.populateScriptInfoLookup(instance, scriptInfoLookup, lastReplicationMode)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(scriptInfoLookup) == "table", "Bad scriptInfoLookup")
	assert(type(lastReplicationMode) == "string", "Bad lastReplicationMode")

	if instance:IsA("Folder") then
		local replicationMode = ScriptInfoUtils.getFolderReplicationMode(instance.Name, lastReplicationMode)
		if replicationMode ~= ScriptInfoUtils.ModuleReplicationTypes.IGNORE then
			for _, item in pairs(instance:GetChildren()) do
				if not BounceTemplateUtils.isBounceTemplate(item) then
					if item:IsA("Folder") then
						ScriptInfoUtils.populateScriptInfoLookup(item, scriptInfoLookup, replicationMode)
					elseif item:IsA("ModuleScript") then
						ScriptInfoUtils.addToInfoMap(scriptInfoLookup,
							ScriptInfoUtils.createScriptInfo(item, item.Name, replicationMode))
					end
				end
			end
		end
	elseif instance:IsA("ModuleScript") then
		if not BounceTemplateUtils.isBounceTemplate(instance) then
			if instance == loader then
				-- STRICT hack to support this module script as "loader" over "Nevermore" in replicated scenario
				ScriptInfoUtils.addToInfoMap(scriptInfoLookup,
					ScriptInfoUtils.createScriptInfo(instance, "loader", lastReplicationMode))
			else
				ScriptInfoUtils.addToInfoMap(scriptInfoLookup,
					ScriptInfoUtils.createScriptInfo(instance, instance.Name, lastReplicationMode))
			end
		end
	elseif instance:IsA("ObjectValue") then
		error("ObjectValue links are not supported at this time for retrieving inline module scripts")
	end
end

local AVAILABLE_IN_SHARED = {
	["HoldingBindersServer"] = true;
	["HoldingBindersClient"] = true;
	["IKService"] = true;
	["IKServiceClient"] = true;
}

function ScriptInfoUtils.isAvailableInShared(scriptInfo)
	if CollectionService:HasTag(scriptInfo.instance, "LinkToShared") then
		return true
	end

	-- Hack because we can't tag things in Rojo yet
	return AVAILABLE_IN_SHARED[scriptInfo.name]
end

function ScriptInfoUtils.addToInfoMap(scriptInfoLookup, scriptInfo)
	assert(type(scriptInfoLookup) == "table", "Bad scriptInfoLookup")
	assert(type(scriptInfo) == "table", "Bad scriptInfo")

	local replicationMode = assert(scriptInfo.replicationMode, "Bad replicationMode")
	local replicationMap = assert(scriptInfoLookup[replicationMode], "Bad replicationMode")

	ScriptInfoUtils.addToInfoMapForMode(replicationMap, scriptInfo)

	if replicationMode == ScriptInfoUtils.ModuleReplicationTypes.SHARED then
		ScriptInfoUtils.addToInfoMapForMode(
			scriptInfoLookup[ScriptInfoUtils.ModuleReplicationTypes.SERVER], scriptInfo)
		ScriptInfoUtils.addToInfoMapForMode(
			scriptInfoLookup[ScriptInfoUtils.ModuleReplicationTypes.CLIENT], scriptInfo)
	elseif ScriptInfoUtils.isAvailableInShared(scriptInfo) then
		ScriptInfoUtils.addToInfoMapForMode(
			scriptInfoLookup[ScriptInfoUtils.ModuleReplicationTypes.SHARED], scriptInfo)
	end
end

function ScriptInfoUtils.addToInfoMapForMode(replicationMap, scriptInfo)
	if replicationMap[scriptInfo.name] then
		warn(("Duplicate module %q in same package under same replication scope. Only using first one. \n- %q\n- %q")
			:format(scriptInfo.name,
				scriptInfo.instance:GetFullName(),
				replicationMap[scriptInfo.name].instance:GetFullName()))
		return
	end

	replicationMap[scriptInfo.name] = scriptInfo
end

function ScriptInfoUtils.getFolderReplicationMode(folderName, lastReplicationMode)
	assert(type(folderName) == "string", "Bad folderName")
	assert(type(lastReplicationMode) == "string", "Bad lastReplicationMode")

	--Plugin always replicates further
	if folderName == ScriptInfoUtils.DEPENDENCY_FOLDER_NAME then
		return ScriptInfoUtils.ModuleReplicationTypes.IGNORE
	elseif lastReplicationMode == ScriptInfoUtils.ModuleReplicationTypes.PLUGIN then
		return lastReplicationMode
	elseif folderName == "Shared" then
		return ScriptInfoUtils.ModuleReplicationTypes.SHARED
	elseif folderName == "Client" then
		return ScriptInfoUtils.ModuleReplicationTypes.CLIENT
	elseif folderName == "Server" then
		return ScriptInfoUtils.ModuleReplicationTypes.SERVER
	else
		return lastReplicationMode
	end
end

return ScriptInfoUtils  -  Editar
  04:54:13.789    -  Editar
  04:54:13.789  ----- [2414] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.StaticLegacyLoader -----  -  Editar
  04:54:13.789  --[=[
	@private
	@class StaticLegacyLoader
]=]

local loader = script.Parent
local ScriptInfoUtils = require(script.Parent.ScriptInfoUtils)
local LoaderUtils = require(script.Parent.LoaderUtils)
local BounceTemplateUtils = require(script.Parent.BounceTemplateUtils)

local StaticLegacyLoader = {}
StaticLegacyLoader.ClassName = "StaticLegacyLoader"
StaticLegacyLoader.__index = StaticLegacyLoader

function StaticLegacyLoader.new()
	local self = setmetatable({
		_packageLookups = {};
	}, StaticLegacyLoader)

	return self
end

function StaticLegacyLoader:__call(value)
	return self:Require(value)
end

function StaticLegacyLoader:Lock()
	error("Cannot start loader while not running")
end

function StaticLegacyLoader:Require(root, value)
	if type(value) == "number" then
		return require(value)
	elseif type(value) == "string" then
		-- use very slow module recovery mechanism
		local module = self:_findModule(root, value)
		if module then
			self:_ensureFakeLoader(module)
			return require(module)
		else
			error("Error: Library '" .. tostring(value) .. "' does not exist.", 2)
		end
	elseif typeof(value) == "Instance" and value:IsA("ModuleScript") then
		return require(value)
	else
		error(("Error: module must be a string or ModuleScript, got '%s' for '%s'")
			:format(typeof(value), tostring(value)))
	end
end

function StaticLegacyLoader:_findModule(root, name)
	assert(typeof(root) == "Instance", "Bad root")
	assert(type(name) == "string", "Bad name")

	-- Implement the node_modules recursive find algorithm
	local packageRoot = self:_findPackageRoot(root)
	while packageRoot do
		-- Build lookup
		local highLevelLookup = self:_getOrCreateLookup(packageRoot)
		if highLevelLookup[name] then
			return highLevelLookup[name]
		end

		-- Ok, search our package dependencies
		local dependencies = packageRoot:FindFirstChild(ScriptInfoUtils.DEPENDENCY_FOLDER_NAME)
		if dependencies then
			for _, instance in pairs(dependencies:GetChildren()) do
				if instance:IsA("Folder") and instance.Name:sub(1, 1) == "@" then
					for _, child in pairs(instance:GetChildren()) do
						local lookup = self:_getPackageFolderLookup(child)
						if lookup[name] then
							return lookup[name]
						end
					end
				else
					local lookup = self:_getPackageFolderLookup(instance)
					if lookup[name] then
						return lookup[name]
					end
				end
			end
		end

		-- We failed to find anything... search up a level...
		packageRoot = self:_findPackageRoot(packageRoot)
	end

	return nil
end

function StaticLegacyLoader:GetLoader(moduleScript)
	assert(typeof(moduleScript) == "Instance", "Bad moduleScript")

	return setmetatable({}, {
		__call = function(_self, value)
			return self:Require(moduleScript, value)
		end;
		__index = function(_self, key)
			return self:Require(moduleScript, key)
		end;
	})
end

function StaticLegacyLoader:_getPackageFolderLookup(instance)
	if instance:IsA("ObjectValue") then
		if instance.Value then
			return self:_getOrCreateLookup(instance.Value)
		else
			warn("[StaticLegacyLoader] - Bad link in packageFolder")
			return {}
		end
	elseif instance:IsA("Folder") then
		return self:_getOrCreateLookup(instance)
	elseif instance:IsA("ModuleScript") then
		return self:_getOrCreateLookup(instance)
	else
		warn(("Unknown instance %q (%s) in dependencyFolder - %q")
			:format(instance.Name, instance.ClassName, instance:GetFullName()))
		return {}
	end
end

function StaticLegacyLoader:_getOrCreateLookup(packageFolderOrModuleScript)
	assert(typeof(packageFolderOrModuleScript) == "Instance", "Bad packageFolderOrModuleScript")

	if self._packageLookups[packageFolderOrModuleScript] then
		return self._packageLookups[packageFolderOrModuleScript]
	end

	local lookup = {}

	self:_buildLookup(lookup, packageFolderOrModuleScript)

	self._packageLookups[packageFolderOrModuleScript] = lookup
	return lookup
end

function StaticLegacyLoader:_buildLookup(lookup, instance)
	if instance:IsA("Folder") then
		if instance.Name ~= ScriptInfoUtils.DEPENDENCY_FOLDER_NAME then
			for _, item in pairs(instance:GetChildren()) do
				self:_buildLookup(lookup, item)
			end
		end
	elseif instance:IsA("ModuleScript") then
		lookup[instance.Name] = instance
	end
end

function StaticLegacyLoader:_findPackageRoot(instance)
	assert(typeof(instance) == "Instance", "Bad instance")

	local current = instance.Parent

	while current and current ~= game do
		if LoaderUtils.isPackage(current) then
			return current
		else
			current = current.Parent
		end
	end

	return nil
end

function StaticLegacyLoader:_ensureFakeLoader(module)
	assert(typeof(module) == "Instance", "Bad module")

	local parent = module.Parent
	if not parent then
		warn("[StaticLegacyLoader] - No parent")
		return
	end

	-- NexusUnitTest
	-- luacheck: ignore
	-- selene: allow(undefined_variable)
	local shouldBeArchivable = Load and true or false

	-- Already have link
	local found = parent:FindFirstChild("loader")
	if found then
		if BounceTemplateUtils.isBounceTemplate(found) then
			found.Archivable = shouldBeArchivable
		end

		return
	end

	local link = BounceTemplateUtils.create(loader, "loader")
	link.Archivable = shouldBeArchivable
	link.Parent = parent
end

return StaticLegacyLoader  -  Editar
  04:54:13.789    -  Editar
  04:54:13.789  ----- [2415] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.Utils -----  -  Editar
  04:54:13.789  --[=[
	@private
	@class Utils
]=]

local Utils = {}

local function errorOnIndex(_, index)
	error(("Bad index %q"):format(tostring(index)), 2)
end

local READ_ONLY_METATABLE = {
	__index = errorOnIndex;
	__newindex = errorOnIndex;
}

function Utils.readonly(_table)
	return setmetatable(_table, READ_ONLY_METATABLE)
end

function Utils.copyTable(target)
	local new = {}
	for key, value in pairs(target) do
		new[key] = value
	end
	return new
end

function Utils.count(_table)
	local count = 0
	for _, _ in pairs(_table) do
		count = count + 1
	end
	return count
end

function Utils.getOrCreateValue(parent, instanceType, name, defaultValue)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(("[Utils.getOrCreateValue] - Value of type %q of name %q is of type %q in %s instead")
				:format(instanceType, name, foundChild.ClassName, foundChild:GetFullName()))
		end

		return foundChild
	else
		local newChild = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = defaultValue
		newChild.Parent = parent

		return newChild
	end
end

function Utils.getValue(parent, instanceType, name, default)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if foundChild:IsA(instanceType) then
			return foundChild.Value
		else
			warn(("[Utils.getValue] - Value of type %q of name %q is of type %q in %s instead")
				:format(instanceType, name, foundChild.ClassName, foundChild:GetFullName()))
			return nil
		end
	else
		return default
	end
end

function Utils.setValue(parent, instanceType, name, value)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(("[Utils.setValue] - Value of type %q of name %q is of type %q in %s instead")
				:format(instanceType, name, foundChild.ClassName, foundChild:GetFullName()))
		end

		foundChild.Value = value
	else
		local newChild = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = value
		newChild.Parent = parent
	end
end


function Utils.getOrCreateFolder(parent, folderName)
	local found = parent:FindFirstChild(folderName)
	if found then
		return found
	else
		local folder = Instance.new("Folder")
		folder.Name = folderName
		folder.Parent = parent
		return folder
	end
end


return Utils
  -  Editar
  04:54:13.789    -  Editar
  04:54:13.790  ----- [2416] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.maid.Shared.Maid -----  -  Editar
  04:54:13.790  --[=[
	Manages the cleaning of events and other things. Useful for
	encapsulating state and make deconstructors easy.

	See the [Five Powerful Code Patterns talk](https://developer.roblox.com/en-us/videos/5-powerful-code-patterns-behind-top-roblox-games)
	for a more in-depth look at Maids in top games.

	```lua
	local maid = Maid.new()

	maid:GiveTask(function()
		print("Cleaning up")
	end)

	maid:GiveTask(workspace.ChildAdded:Connect(print))

	-- Disconnects all events, and executes all functions
	maid:DoCleaning()
	```

	@class Maid
]=]
-- luacheck: pop

local Maid = {}
Maid.ClassName = "Maid"

--[=[
	Constructs a new Maid object

	```lua
	local maid = Maid.new()
	```

	@return Maid
]=]
function Maid.new()
	return setmetatable({
		_tasks = {}
	}, Maid)
end

--[=[
	Returns true if the class is a maid, and false otherwise.

	```lua
	print(Maid.isMaid(Maid.new())) --> true
	print(Maid.isMaid(nil)) --> false
	```

	@param value any
	@return boolean
]=]
function Maid.isMaid(value)
	return type(value) == "table" and value.ClassName == "Maid"
end

--[=[
	Returns Maid[key] if not part of Maid metatable

	```lua
	local maid = Maid.new()
	maid._current = Instance.new("Part")
	print(maid._current) --> Part

	maid._current = nil
	print(maid._current) --> nil
	```

	@param index any
	@return MaidTask
]=]
function Maid:__index(index)
	if Maid[index] then
		return Maid[index]
	else
		return self._tasks[index]
	end
end

--[=[
	Add a task to clean up. Tasks given to a maid will be cleaned when
	maid[index] is set to a different value.

	Task cleanup is such that if the task is an event, it is disconnected.
	If it is an object, it is destroyed.

	```
	Maid[key] = (function)         Adds a task to perform
	Maid[key] = (event connection) Manages an event connection
	Maid[key] = (Maid)             Maids can act as an event connection, allowing a Maid to have other maids to clean up.
	Maid[key] = (Object)           Maids can cleanup objects with a `Destroy` method
	Maid[key] = nil                Removes a named task.
	```

	@param index any
	@param newTask MaidTask
]=]
function Maid:__newindex(index, newTask)
	if Maid[index] ~= nil then
		error(("Cannot use '%s' as a Maid key"):format(tostring(index)), 2)
	end

	local tasks = self._tasks
	local oldTask = tasks[index]

	if oldTask == newTask then
		return
	end

	tasks[index] = newTask

	if oldTask then
		if type(oldTask) == "function" then
			oldTask()
		elseif typeof(oldTask) == "RBXScriptConnection" then
			oldTask:Disconnect()
		elseif oldTask.Destroy then
			oldTask:Destroy()
		end
	end
end

--[=[
	Gives a task to the maid for cleanup, but uses an incremented number as a key.

	@param task MaidTask -- An item to clean
	@return number -- taskId
]=]
function Maid:GiveTask(task)
	if not task then
		error("Task cannot be false or nil", 2)
	end

	local taskId = #self._tasks+1
	self[taskId] = task

	if type(task) == "table" and (not task.Destroy) then
		warn("[Maid.GiveTask] - Gave table task without .Destroy\n\n" .. debug.traceback())
	end

	return taskId
end

--[=[
	Gives a promise to the maid for clean.

	@param promise Promise<T>
	@return Promise<T>
]=]
function Maid:GivePromise(promise)
	if not promise:IsPending() then
		return promise
	end

	local newPromise = promise.resolved(promise)
	local id = self:GiveTask(newPromise)

	-- Ensure GC
	newPromise:Finally(function()
		self[id] = nil
	end)

	return newPromise
end

--[=[
	Cleans up all tasks and removes them as entries from the Maid.

	:::note
	Signals that are already connected are always disconnected first. After that
	any signals added during a cleaning phase will be disconnected at random times.
	:::

	:::tip
	DoCleaning() may be recursively invoked. This allows the you to ensure that
	tasks or other tasks. Each task will be executed once.

	However, adding tasks while cleaning is not generally a good idea, as if you add a
	function that adds itself, this will loop indefinitely.
	:::
]=]
function Maid:DoCleaning()
	local tasks = self._tasks

	-- Disconnect all events first as we know this is safe
	for index, job in pairs(tasks) do
		if typeof(job) == "RBXScriptConnection" then
			tasks[index] = nil
			job:Disconnect()
		end
	end

	-- Clear out tasks table completely, even if clean up tasks add more tasks to the maid
	local index, job = next(tasks)
	while job ~= nil do
		tasks[index] = nil
		if type(job) == "function" then
			job()
		elseif typeof(job) == "RBXScriptConnection" then
			job:Disconnect()
		elseif job.Destroy then
			job:Destroy()
		end
		index, job = next(tasks)
	end
end

--[=[
	Alias for [Maid.DoCleaning()](/api/Maid#DoCleaning)

	@function Destroy
	@within Maid
]=]
Maid.Destroy = Maid.DoCleaning

return Maid
  -  Editar
  04:54:13.790    -  Editar
  04:54:13.790  ----- [2417] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.maid.Shared.MaidTaskUtils -----  -  Editar
  04:54:13.790  --[=[
	Utility methods involving maids and tasks.
	@class MaidTaskUtils
]=]

--[=[
	An object that can have the method :Destroy() called on it
	@type Destructable Instance | { Destroy: function }
	@within MaidTaskUtils
]=]

--[=[
	An object that can be cleaned up
	@type MaidTask function | Destructable | RBXScriptConnection
	@within MaidTaskUtils
]=]
local MaidTaskUtils = {}

--[=[
	Returns whether a task is a valid job.

	@param job any
	@return boolean
]=]
function MaidTaskUtils.isValidTask(job)
	return type(job) == "function"
		or typeof(job) == "RBXScriptConnection"
		or type(job) == "table" and type(job.Destroy) == "function"
		or typeof(job) == "Instance"
end

--[=[
	Executes the task as requested.

	@param job MaidTask -- Task to execute
]=]
function MaidTaskUtils.doTask(job)
	if type(job) == "function" then
		job()
	elseif typeof(job) == "RBXScriptConnection" then
		job:Disconnect()
	elseif type(job) == "table" and type(job.Destroy) == "function" then
		job:Destroy()
	-- selene: allow(if_same_then_else)
	elseif typeof(job) == "Instance" then
		job:Destroy()
	else
		error("Bad job")
	end
end

--[=[
	Executes the task delayed after some time.

	```lua
	-- delays cleanup by 5 seconds
	maid:GiveTask(MaidTaskUtils.delayed(5, gui))
	```

	@param time number -- Time in seconds
	@param job MaidTask -- Job to delay execution
	@return () -> () -- function that will execute the job delayed
]=]
function MaidTaskUtils.delayed(time, job)
	assert(type(time) == "number", "Bad time")
	assert(MaidTaskUtils.isValidTask(job), "Bad job")

	return function()
		task.delay(time, function()
			MaidTaskUtils.doTask(job)
		end)
	end
end

return MaidTaskUtils  -  Editar
  04:54:13.790    -  Editar
  04:54:13.790  ----- [2418] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.Shared.Observable -----  -  Editar
  04:54:13.790  --[=[
	Observables are like an [signal](/api/Signal], except they do not execute code
	until the observable is subscribed to. This follows the standard
	Rx API surface for an observable.

	Observables use a [Subscription](/api/Subscription) to emit values.

	```lua
	-- Constucts an observable which will emit a, b, c via a subscription
	local observable = Observable.new(function(sub)
		print("Connected")
		sub:Fire("a")
		sub:Fire("b")
		sub:Fire("c")
		sub:Complete() -- ends stream
	end)

	local sub1 = observable:Subscribe() --> Connected
	local sub2 = observable:Subscribe() --> Connected
	local sub3 = observable:Subscribe() --> Connected

	sub1:Destroy()
	sub2:Destroy()
	sub3:Destroy()
	```

	Note that emitted values may be observed like this

	```lua
	observable:Subscribe(function(value)
		print("Got ", value)
	end)

	--> Got a
	--> Got b
	--> Got c
	```

	Note that also, observables return a [MaidTask](/api/MaidTask) which
	should be used to clean up the resulting subscription.

	```lua
	maid:GiveTask(observable:Subscribe(function(value)
		-- do work here!
	end))
	```

	Observables over signals are nice because observables may be chained and manipulated
	via the Pipe operation.

	:::tip
	You should always clean up the subscription using a [Maid](/api/Maid), otherwise
	you may memory leak.
	:::
	@class Observable
]=]

local require = require(script.Parent.loader).load(script)

local Subscription = require("Subscription")

local ENABLE_STACK_TRACING = false

local Observable = {}
Observable.ClassName = "Observable"
Observable.__index = Observable

--[=[
	Returns whether or not a value is an observable.
	@param item any
	@return boolean
]=]
function Observable.isObservable(item)
	return type(item) == "table" and item.ClassName == "Observable"
end

--[=[
	Constructs a new Observable

	```lua
	local function observeAllChildren(parent)
		return Observable.new(function(sub)
			local maid = Maid.new()

			for _, item in pairs(parent:GetChildren()) do
				sub:Fire(item)
			end
			maid:GiveTask(parent.ChildAdded:Connect(function(child)
				sub:Fire(child)
			end))

			return maid
		end)
	end

	-- Prints out all current children, and whenever a new
	-- child is added to workspace
	local maid = Maid.new()
	maid:GiveTask(observeAllChildren(workspace):Subscribe(print))
	```

	@param onSubscribe (subscription: Subscription<T>) -> MaidTask
	@return Observable<T>
]=]
function Observable.new(onSubscribe)
	assert(type(onSubscribe) == "function", "Bad onSubscribe")

	return setmetatable({
		_source = ENABLE_STACK_TRACING and debug.traceback() or "";
		_onSubscribe = onSubscribe;
	}, Observable)
end

--[=[
	Transforms the observable with the following transformers

	```lua
	Rx.of(1, 2, 3):Pipe({
		Rx.map(function(result)
			return result + 1
		end);
		Rx.map(function(value)
			return ("%0.2f"):format(value)
		end);
	}):Subscribe(print)

	--> 2.00
	--> 3.00
	--> 4.00
	```
	@param transformers { (observable: Observable<T>) -> Observable<T> }
	@return Observable<T>
]=]
function Observable:Pipe(transformers)
	assert(type(transformers) == "table", "Bad transformers")

	local current = self
	for _, transformer in pairs(transformers) do
		assert(type(transformer) == "function", "Bad transformer")
		current = transformer(current)
		assert(Observable.isObservable(current))
	end

	return current
end

--[=[
	Subscribes immediately, fireCallback may return a maid (or a task a maid can handle)
	to clean up

	@param fireCallback function?
	@param failCallback function?
	@param completeCallback function?
	@return MaidTask
]=]
function Observable:Subscribe(fireCallback, failCallback, completeCallback)
	local sub = Subscription.new(fireCallback, failCallback, completeCallback)
	local cleanup = self._onSubscribe(sub)

	if cleanup then
		sub:_giveCleanup(cleanup)
	end

	return sub
end

return Observable  -  Editar
  04:54:13.790    -  Editar
  04:54:13.790  ----- [2419] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.Shared.ObservableSubscriptionTable -----  -  Editar
  04:54:13.790  --[=[
	This allows the storage of subscriptions for keys, such that something
	can subscribe onto a key, and events can be invoked onto keys.
	@class ObservableSubscriptionTable
]=]

local require = require(script.Parent.loader).load(script)

local Observable = require("Observable")

local ObservableSubscriptionTable = {}
ObservableSubscriptionTable.ClassName = "ObservableSubscriptionTable"
ObservableSubscriptionTable.__index = ObservableSubscriptionTable

function ObservableSubscriptionTable.new()
	local self = setmetatable({}, ObservableSubscriptionTable)

	self._subMap = {} -- { TKey: Subscription<TEmit> }

	return self
end

--[=[
	Fires for the current key the given value
	@param key TKey
	@param ... TEmit
]=]
function ObservableSubscriptionTable:Fire(key, ...)
	assert(key ~= nil, "Bad key")

	local subs = self._subMap[key]
	if not subs then
		return
	end

	-- Make a copy so we don't have to worry about our last changing
	for _, sub in pairs(table.clone(subs)) do
		task.spawn(sub.Fire, sub, ...)
	end
end

function ObservableSubscriptionTable:Complete(key, ...)
	local subs = self._subMap[key]
	if not subs then
		return
	end

	local subsToComplete = table.clone(subs)
	self._subMap[key] = nil

	for _, sub in pairs(subsToComplete) do
		task.spawn(sub.Complete, sub, ...)
	end
end

--[=[
	Observes for the key
	@param key TKey
	@return Observable<TEmit>
]=]
function ObservableSubscriptionTable:Observe(key)
	assert(key ~= nil, "Bad key")

	return Observable.new(function(sub)
		if not self._subMap[key] then
			self._subMap[key] = { sub }
		else
			table.insert(self._subMap[key], sub)
		end

		return function()
			if not self._subMap[key] then
				return
			end

			local current = self._subMap[key]
			local index = table.find(current, sub)
			if not index then
				return
			end

			table.remove(current, index)
			if #current == 0 then
				self._subMap[key] = nil
			end

			-- Complete the subscription
			if sub:IsPending() then
				task.spawn(function()
					sub:Complete()
				end)
			end
		end
	end)
end

--[=[
	Completes all subscriptions and removes them from the list.
]=]
function ObservableSubscriptionTable:Destroy()
	while next(self._subMap) do
		local key, list = next(self._subMap)
		self._subMap[key] = nil

		for _, sub in pairs(list) do
			if sub:IsPending() then
				task.spawn(function()
					sub:Complete()
				end)
			end
		end
	end
end


return ObservableSubscriptionTable  -  Editar
  04:54:13.790    -  Editar
  04:54:13.791  ----- [2420] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.Shared.Rx -----  -  Editar
  04:54:13.791  --[=[
	Observable rx library for Roblox by Quenty. This provides a variety of
	composition classes to be used, and is the primary entry point for an
	observable.

	Most of these functions return either a function that takes in an
	observable (curried for piping) or an [Observable](/api/Observable)
	directly.

	@class Rx
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Observable = require("Observable")
local Promise = require("Promise")
local Symbol = require("Symbol")
local Table = require("Table")
local ThrottledFunction = require("ThrottledFunction")
local cancellableDelay = require("cancellableDelay")
local CancelToken = require("CancelToken")

local UNSET_VALUE = Symbol.named("unsetValue")

--[=[
	An empty observable that completes immediately
	@prop EMPTY Observable<()>
	@readonly
	@within Rx
]=]

--[=[
	An observable that never completes.
	@prop NEVER Observable<()>
	@readonly
	@within Rx
]=]
local Rx = {
	EMPTY = Observable.new(function(sub)
		sub:Complete()
	end);
	NEVER = Observable.new(function(_)

	end);
}

--[=[
	Pipes the tranformers through each other
	https://rxjs-dev.firebaseapp.com/api/index/function/pipe

	@param transformers { Observable<any> }
	@return (source: Observable<T>) -> Observable<U>
]=]
function Rx.pipe(transformers)
	assert(type(transformers) == "table", "Bad transformers")
	for index, transformer in pairs(transformers) do
		if type(transformer) ~= "function" then
			error(("[Rx.pipe] Bad pipe value of type %q at index %q, expected function")
				:format(type(transformer), tostring(index)))
		end
	end

	return function(source)
		assert(source, "Bad source")

		local current = source
		for key, transformer in pairs(transformers) do
			current = transformer(current)

			if not (type(current) == "table" and current.ClassName == "Observable") then
				error(("[Rx.pipe] - Failed to transform %q in pipe, made %q (%s)")
					:format(tostring(key), tostring(current), tostring(type(current) == "table" and current.ClassName or "")))
			end
		end

		return current
	end
end

--[=[
	http://reactivex.io/documentation/operators/just.html

	```lua
	Rx.of(1, 2, 3):Subscribe(print, function()
		print("Complete")
	end)) --> 1, 2, 3, "Complete"
	```

	@param ... any -- Arguments to emit
	@return Observable
]=]
function Rx.of(...)
	local args = table.pack(...)

	return Observable.new(function(sub)
		for i=1, args.n do
			sub:Fire(args[i])
		end

		sub:Complete()
	end)
end

--[=[
	Converts an item
	http://reactivex.io/documentation/operators/from.html

	@param item Promise | table
	@return Observable
]=]
function Rx.from(item)
	if Promise.isPromise(item) then
		return Rx.fromPromise(item)
	elseif type(item) == "table" then
		return Rx.of(unpack(item))
	else
		-- TODO: Iterator?
		error("[Rx.from] - cannot convert")
	end
end

--[=[
	Converts a promise to an observable.
	@param observable Observable<T>
	@param cancelToken CancelToken?
	@return Promise<T>
]=]
function Rx.toPromise(observable, cancelToken)
	local maid = Maid.new()

	local newCancelToken = CancelToken.new(function(cancel)
		maid:GiveTask(cancel)
		if cancelToken then
			if cancelToken:IsCancelled() then
				cancel()
			else
				maid:GiveTask(cancelToken.Cancelled:Connect(cancel))
			end
		end
	end)

	local promise = Promise.new(function(resolve, reject)
		if newCancelToken:IsCancelled() then
			reject()
			return
		end

		maid:GiveTask(newCancelToken.Cancelled:Connect(function()
			reject()
		end))

		maid:GiveTask(observable:Subscribe(resolve, reject, reject))
	end)

	promise:Finally(function()
		maid:DoCleaning()
	end)

	return promise
end

--[=[
	https://rxjs-dev.firebaseapp.com/api/operators/merge

	@param observables { Observable }
	@return Observable
]=]
function Rx.merge(observables)
	assert(type(observables) == "table", "Bad observables")

	for _, item in pairs(observables) do
		assert(Observable.isObservable(item), "Not an observable")
	end

	return Observable.new(function(sub)
		local maid = Maid.new()

		for _, observable in pairs(observables) do
			maid:GiveTask(observable:Subscribe(sub:GetFireFailComplete()))
		end

		return maid
	end)
end

--[=[
	Converts a Signal into an observable.
	https://rxjs-dev.firebaseapp.com/api/index/function/fromEvent

	@param event Signal<T>
	@return Observable<T>
]=]
function Rx.fromSignal(event)
	return Observable.new(function(sub)
		-- This stream never completes or fails!
		return event:Connect(function(...)
			sub:Fire(...)
		end)
	end)
end

--[=[
	Converts a Promise into an observable.
	https://rxjs-dev.firebaseapp.com/api/index/function/from

	@param promise Promise<T>
	@return Observable<T>
]=]
function Rx.fromPromise(promise)
	assert(Promise.isPromise(promise))

	return Observable.new(function(sub)
		if promise:IsFulfilled() then
			sub:Fire(promise:Wait())
			sub:Complete()
			return nil
		end

		local maid = Maid.new()

		local pending = true
		maid:GiveTask(function()
			pending = false
		end)

		promise:Then(
			function(...)
				if pending then
					sub:Fire(...)
					sub:Complete()
				end
			end,
			function(...)
				if pending then
					sub:Fail(...)
					sub:Complete()
				end
			end)

		return maid
	end)
end

--[=[
	Taps into the observable and executes the onFire/onError/onComplete
	commands.

	https://rxjs-dev.firebaseapp.com/api/operators/tap

	@param onFire function?
	@param onError function?
	@param onComplete function?
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.tap(onFire, onError, onComplete)
	assert(type(onFire) == "function" or onFire == nil, "Bad onFire")
	assert(type(onError) == "function" or onError == nil, "Bad onError")
	assert(type(onComplete) == "function" or onComplete == nil, "Bad onComplete")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(
				function(...)
					if onFire then
						onFire(...)
					end
					if sub:IsPending() then
						sub:Fire(...)
					end
				end,
				function(...)
					if onError then
						onError(...)
					end
					sub:Error(...)
				end,
				function(...)
					if onComplete then
						onComplete(...)
					end
					sub:Complete(...)
				end)
		end)
	end
end

--[=[
	Starts the observable with the given value from the callback

	http://reactivex.io/documentation/operators/start.html

	@param callback function
	@return (source: Observable) -> Observable
]=]
function Rx.start(callback)
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			sub:Fire(callback())

			return source:Subscribe(sub:GetFireFailComplete())
		end)
	end
end

--[=[
	Like start, but also from (list!)

	@param callback () -> { T }
	@return (source: Observable) -> Observable
]=]
function Rx.startFrom(callback)
	assert(type(callback) == "function", "Bad callback")
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			for _, value in pairs(callback()) do
				sub:Fire(value)
			end

			return source:Subscribe(sub:GetFireFailComplete())
		end)
	end
end

--[=[
	Starts with the given values
	https://rxjs-dev.firebaseapp.com/api/operators/startWith

	@param values { T }
	@return (source: Observable) -> Observable
]=]
function Rx.startWith(values)
	assert(type(values) == "table", "Bad values")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			for _, item in pairs(values) do
				sub:Fire(item)
			end

			return source:Subscribe(sub:GetFireFailComplete())
		end)
	end
end

--[=[
	Defaults the observable to a value if it isn't fired immediately

	```lua
	Rx.NEVER:Pipe({
		Rx.defaultsTo("Hello")
	}):Subscribe(print) --> Hello
	```

	@param value any
	@return (source: Observable) -> Observable
]=]
function Rx.defaultsTo(value)
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local fired = false

			maid:GiveTask(source:Subscribe(
				function(...)
					fired = true
					sub:Fire(...)
				end,
				sub:GetFailComplete()))

			if not fired then
				sub:Fire(value)
			end

			return maid
		end)
	end
end

--[=[
	Defaults the observable value to nil

	```lua
	Rx.NEVER:Pipe({
		Rx.defaultsToNil
	}):Subscribe(print) --> nil
	```

	Great for defaulting Roblox attributes and objects

	@function defaultsToNil
	@param source Observable
	@return Observable
	@within Rx
]=]
Rx.defaultsToNil = Rx.defaultsTo(nil)

--[=[
	Ends the observable with these values before cancellation
	https://www.learnrxjs.io/learn-rxjs/operators/combination/endwith

	@param values { T }
	@return (source: Observable) -> Observable
]=]
function Rx.endWith(values)
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(
				function(...)
					sub:Fire(...)
				end,
				function(...)
					for _, item in pairs(values) do
						sub:Fire(item)
					end
					sub:Fail(...)
				end),
				function()
					for _, item in pairs(values) do
						sub:Fire(item)
					end
					sub:Complete()
				end)

			return maid
		end)
	end
end

--[=[
	http://reactivex.io/documentation/operators/filter.html

	Filters out values

	```lua
	Rx.of(1, 2, 3, 4, 5):Pipe({
		Rx.where(function(value)
			return value % 2 == 0;
		end)
	}):Subscribe(print) --> 2, 4
	```
	@param predicate (value: T) -> boolean
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.where(predicate)
	assert(type(predicate) == "function", "Bad predicate callback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(
				function(...)
					if predicate(...) then
						sub:Fire(...)
					end
				end,
				sub:GetFailComplete()
			)
		end)
	end
end

--[=[
	Only takes distinct values from the observable stream.

	http://reactivex.io/documentation/operators/distinct.html

	```lua
	Rx.of(1, 1, 2, 3, 3, 1):Pipe({
		Rx.distinct();
	}):Subscribe(print) --> 1, 2, 3, 1
	```
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.distinct()
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local last = UNSET_VALUE

			return source:Subscribe(
				function(value)
					-- TODO: Support tuples
					if last == value then
						return
					end

					last = value
					sub:Fire(last)
				end,
				sub:GetFailComplete()
			)
		end)
	end
end

--[=[
	https://rxjs.dev/api/operators/mapTo
	@param ... any -- The value to map each source value to.
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.mapTo(...)
	local args = table.pack(...)
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(function()
				sub:Fire(table.unpack(args, 1, args.n))
			end, sub:GetFailComplete())
		end)
	end
end

--[=[
	http://reactivex.io/documentation/operators/map.html

	Maps one value to another

	```lua
	Rx.of(1, 2, 3, 4, 5):Pipe({
		Rx.map(function(x)
			return x + 1
		end)
	}):Subscribe(print) -> 2, 3, 4, 5, 6
	```

	@param project (T) -> U
	@return (source: Observable<T>) -> Observable<U>
]=]
function Rx.map(project)
	assert(type(project) == "function", "Bad project callback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			return source:Subscribe(function(...)
				sub:Fire(project(...))
			end, sub:GetFailComplete())
		end)
	end
end

--[=[
	Merges higher order observables together.

	Basically, if you have an observable that is emitting an observable,
	this subscribes to each emitted observable and combines them into a
	single observable.

	```lua
	Rx.of(Rx.of(1, 2, 3), Rx.of(4))
		:Pipe({
			Rx.mergeAll();
		})
		:Subscribe(print) -> 1, 2, 3, 4
	```

	@return (source: Observable<Observable<T>>) -> Observable<T>
]=]
function Rx.mergeAll()
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local pendingCount = 0
			local topComplete = false

			maid:GiveTask(source:Subscribe(
				function(observable)
					assert(Observable.isObservable(observable), "Not an observable")

					pendingCount = pendingCount + 1

					local innerMaid = Maid.new()

					innerMaid:GiveTask(observable:Subscribe(
						function(...)
							-- Merge each inner observable
							sub:Fire(...)
						end,
						function(...)
							-- Emit failure automatically
							sub:Fail(...)
						end,
						function()
							innerMaid:DoCleaning()
							pendingCount = pendingCount - 1
							if pendingCount == 0 and topComplete then
								sub:Complete()
								maid:DoCleaning()
							end
						end))

					local key = maid:GiveTask(innerMaid)

					-- Cleanup
					innerMaid:GiveTask(function()
						maid[key] = nil
					end)
				end,
				function(...)
					sub:Fail(...) -- Also reflect failures up to the top!
					maid:DoCleaning()
				end,
				function()
					topComplete = true
					if pendingCount == 0 then
						sub:Complete()
						maid:DoCleaning()
					end
				end))

			return maid
		end)
	end
end

--[=[
	Merges higher order observables together

	https://rxjs.dev/api/operators/switchAll

	Works like mergeAll, where you subscribe to an observable which is
	emitting observables. However, when another observable is emitted it
	disconnects from the other observable and subscribes to that one.

	@return (source: Observable<Observable<T>>) -> Observable<T>
]=]
function Rx.switchAll()
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local outerMaid = Maid.new()
			local topComplete = false
			local insideComplete = false
			local currentInside = nil

			outerMaid:GiveTask(function()
				-- Ensure inner subscription is disconnected first. This prevents
				-- the inner sub from firing while the outer is subscribed,
				-- throwing a warning.
				outerMaid._innerSub = nil
				outerMaid._outerSuber = nil
			end)

			outerMaid._outerSuber = source:Subscribe(
				function(observable)
					assert(Observable.isObservable(observable), "Bad observable")

					insideComplete = false
					currentInside = observable
					outerMaid._innerSub = nil

					outerMaid._innerSub = observable:Subscribe(
						function(...)
							sub:Fire(...)
						end, -- Merge each inner observable
						function(...)
							if currentInside == observable then
								sub:Fail(...)
							end
						end, -- Emit failure automatically
						function()
							if currentInside == observable then
								insideComplete = true
								if insideComplete and topComplete then
									sub:Complete()
									outerMaid:DoCleaning() -- Paranoid ensure cleanup.
								end
							end
						end)
				end,
				function(...)
					sub:Fail(...) -- Also reflect failures up to the top!
					outerMaid:DoCleaning()
				end,
				function()
					topComplete = true
					if insideComplete and topComplete then
						sub:Complete()
						outerMaid:DoCleaning() -- Paranoid ensure cleanup
					end
				end)

			return outerMaid
		end)
	end
end

--[=[
	Sort of equivalent of promise.then()

	This takes a stream of observables

	@param project (value: T) -> Observable<U>
	@param resultSelector ((initialValue: T, outputValue: U) -> U)?
	@return (source: Observable<T>) -> Observable<U>
]=]
function Rx.flatMap(project, resultSelector)
	assert(type(project) == "function", "Bad project")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local pendingCount = 0
			local topComplete = false

			maid:GiveTask(source:Subscribe(
				function(...)
					local outerValue = ...

					local observable = project(...)
					assert(Observable.isObservable(observable), "Bad observable from project")

					pendingCount = pendingCount + 1

					local innerMaid = Maid.new()

					innerMaid:GiveTask(observable:Subscribe(
						function(...)
							-- Merge each inner observable
							if resultSelector then
								sub:Fire(resultSelector(outerValue, ...))
							else
								sub:Fire(...)
							end
						end,
						function(...)
							sub:Fail(...)
						end, -- Emit failure automatically
						function()
							innerMaid:DoCleaning()
							pendingCount = pendingCount - 1
							if pendingCount == 0 and topComplete then
								sub:Complete()
								maid:DoCleaning()
							end
						end))

					local key = maid:GiveTask(innerMaid)

					-- Cleanup
					innerMaid:GiveTask(function()
						maid[key] = nil
					end)
				end,
				function(...)
					sub:Fail(...) -- Also reflect failures up to the top!
					maid:DoCleaning()
				end,
				function()
					topComplete = true
					if pendingCount == 0 then
						sub:Complete()
						maid:DoCleaning()
					end
				end))

			return maid
		end)
	end
end

function Rx.switchMap(project)
	return Rx.pipe({
		Rx.map(project);
		Rx.switchAll();
	})
end

function Rx.takeUntil(notifier)
	assert(Observable.isObservable(notifier))

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()
			local cancelled = false

			local function cancel()
				maid:DoCleaning()
				cancelled = true
			end

			-- Any value emitted will cancel (complete without any values allows all values to pass)
			maid:GiveTask(notifier:Subscribe(cancel, cancel, nil))

			-- Cancelled immediately? Oh boy.
			if cancelled then
				maid:DoCleaning()
				return nil
			end

			-- Subscribe!
			maid:GiveTask(source:Subscribe(sub:GetFireFailComplete()))

			return maid
		end)
	end
end

--[=[
	Returns an observable that takes in a tuple, and emits that tuple, then
	completes.

	```lua
	Rx.packed("a", "b")
		:Subscribe(function(first, second)
			print(first, second) --> a, b
		end)
	```

	@param ... any
	@return Observable
]=]
function Rx.packed(...)
	local args = table.pack(...)

	return Observable.new(function(sub)
		sub:Fire(unpack(args, 1, args.n))
		sub:Complete()
	end)
end

--[=[
	Unpacks the observables value if a table is received
	@param observable Observable<{T}>
	@return Observable<T>
]=]
function Rx.unpacked(observable)
	assert(Observable.isObservable(observable), "Bad observable")

	return Observable.new(function(sub)
		return observable:Subscribe(function(value)
			if type(value) == "table" then
				sub:Fire(unpack(value))
			else
				warn(("[Rx.unpacked] - Observable didn't return a table got type %q")
					:format(type(value)))
			end
		end, sub:GetFailComplete())
	end)
end

--[=[
	Acts as a finalizer callback once the subscription is unsubscribed.

	```lua
		Rx.of("a", "b"):Pipe({
			Rx.finalize(function()
				print("Subscription done!")
			end);
		})
	```

	http://reactivex.io/documentation/operators/do.html
	https://rxjs-dev.firebaseapp.com/api/operators/finalize
	https://github.com/ReactiveX/rxjs/blob/master/src/internal/operators/finalize.ts

	@param finalizerCallback () -> ()
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.finalize(finalizerCallback)
	assert(type(finalizerCallback) == "function", "Bad finalizerCallback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(sub:GetFireFailComplete()))
			maid:GiveTask(finalizerCallback)

			return maid
		end)
	end
end

--[=[
	Given an observable that emits observables, emit an
	observable that once the initial observable completes,
	the latest values of each emitted observable will be
	combined into an array that will be emitted.

	https://rxjs.dev/api/operators/combineLatestAll

	@return (source: Observable<Observable<T>>) -> Observable<{ T }>
]=]
function Rx.combineLatestAll()
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local observables = {}
			local maid = Maid.new()

			local alive = true
			maid:GiveTask(function()
				alive = false
			end)

			maid:GiveTask(source:Subscribe(
				function(value)
					assert(Observable.isObservable(value))

					table.insert(observables, value)
				end,
				function(...)
					sub:Fail(...)
				end),
				function()
					if not alive then
						return
					end

					maid:GiveTask(Rx.combineLatest(observables))
						:Subscribe(sub:GetFireFailComplete())
				end)

			return maid
		end)
	end
end

--[=[
	The same as combineLatestAll.

	This is for backwards compatability, and is deprecated.

	@function combineAll
	@deprecated 1.0.0 -- Use Rx.combineLatestAll
	@within Rx
	@return (source: Observable<Observable<T>>) -> Observable<{ T }>
]=]
Rx.combineAll = Rx.combineLatestAll

--[=[
	Catches an error, and allows another observable to be subscribed
	in terms of handling the error.

	:::warning
	This method is not yet tested
	:::

	@param callback (error: TError) -> Observable<TErrorResult>
	@return (source: Observable<T>) -> Observable<T | TErrorResult>
]=]
function Rx.catchError(callback)
	assert(type(callback) == "function", "Bad callback")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			-- Yikes, let's hope event ordering is good
			local alive = true
			maid:GiveTask(function()
				alive = false
			end)

			maid:GiveTask(source:Subscribe(
				function(...)
					sub:Fire(...)
				end,
				function(...)
					if not alive then
						-- if we failed because maid was cancelled, then we'll get called here?
						-- I think.
						return
					end

					-- at this point, we can only have one error, so we need to subscribe to the result
					-- and continue the observiable
					local observable = callback(...)
					assert(Observable.isObservable(observable), "Bad observable")

					maid:GiveTask(observable:Subscribe(sub:GetFireFailComplete()))
				end,
				function()
					sub:Complete()
				end));

			return maid
		end)
	end
end

--[=[
	One of the most useful functions this combines the latest values of
	observables at each chance!

	```lua
	Rx.combineLatest({
		child = Rx.fromSignal(Workspace.ChildAdded);
		lastChildRemoved = Rx.fromSignal(Workspace.ChildRemoved);
		value = 5;

	}):Subscribe(function(data)
		print(data.child) --> last child
		print(data.lastChildRemoved) --> other value
		print(data.value) --> 5
	end)

	```

	:::tip
	Note that the resulting observable will not emit until all input
	observables are emitted.
	:::

	@param observables { [TKey]: Observable<TEmitted> | TEmitted }
	@return Observable<{ [TKey]: TEmitted }>
]=]
function Rx.combineLatest(observables)
	assert(type(observables) == "table", "Bad observables")

	return Observable.new(function(sub)
		local pending = 0

		local latest = {}
		for key, value in pairs(observables) do
			if Observable.isObservable(value) then
				pending = pending + 1
				latest[key] = UNSET_VALUE
			else
				latest[key] = value
			end
		end

		if pending == 0 then
			sub:Fire(latest)
			sub:Complete()
			return
		end

		local maid = Maid.new()

		local function fireIfAllSet()
			for _, value in pairs(latest) do
				if value == UNSET_VALUE then
					return
				end
			end

			sub:Fire(Table.copy(latest))
		end

		for key, observer in pairs(observables) do
			if Observable.isObservable(observer) then
				maid:GiveTask(observer:Subscribe(
					function(value)
						latest[key] = value
						fireIfAllSet()
					end,
					function(...)
						pending = pending - 1
						sub:Fail(...)
					end,
					function()
						pending = pending - 1
						if pending == 0 then
							sub:Complete()
						end
					end))
			end
		end

		return maid
	end)
end

--[=[
	http://reactivex.io/documentation/operators/using.html

	Each time a subscription occurs, the resource is constructed
	and exists for the lifetime of the observation. The observableFactory
	uses the resource for subscription.

	:::note
	Note from Quenty: I haven't found this that useful.
	:::

	@param resourceFactory () -> MaidTask
	@param observableFactory (MaidTask) -> Observable<T>
	@return Observable<T>
]=]
function Rx.using(resourceFactory, observableFactory)
	return Observable.new(function(sub)
		local maid = Maid.new()

		local resource = resourceFactory()
		maid:GiveTask(resource)

		local observable = observableFactory(resource)
		assert(Observable.isObservable(observable), "Bad observable")

		maid:GiveTask(observable:Subscribe(sub:GetFireFailComplete()))

		return maid
	end)
end

--[=[
	Takes the first entry and terminates the observable. Equivalent to the following:

	```lua
	Rx.take(1)
	```

	https://reactivex.io/documentation/operators/first.html
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.first()
	return Rx.take(1)
end

--[=[
	Takes n entries and then completes the observation.

	https://rxjs.dev/api/operators/take
	@param number number
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.take(number)
	assert(type(number) == "number", "Bad number")
	assert(number > 0, "Bad number")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local taken = 0
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(...)
				if taken >= number then
					warn("[Rx.take] - Still getting values past subscription")
					return
				end

				taken = taken + 1
				sub:Fire(...)

				if taken >= number then
					sub:Complete()
				end
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Takes n entries and then completes the observation.

	https://rxjs.dev/api/operators/take
	@param toSkip number
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.skip(toSkip)
	assert(type(toSkip) == "number", "Bad toSkip")
	assert(toSkip > 0, "Bad toSkip")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local skipped = 0
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(...)
				if skipped <= toSkip then
					skipped = skipped + 1
					return
				end

				sub:Fire(...)
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Defers the subscription and creation of the observable until the
	actual subscription of the observable.

	https://rxjs-dev.firebaseapp.com/api/index/function/defer
	https://netbasal.com/getting-to-know-the-defer-observable-in-rxjs-a16f092d8c09

	@param observableFactory () -> Observable<T>
	@return Observable<T>
]=]
function Rx.defer(observableFactory)
	return Observable.new(function(sub)
		local observable
		local ok, err = pcall(function()
			observable = observableFactory()
		end)

		if not ok then
			sub:Fail(err)
			return
		end

		if not Observable.isObservable(observable) then
			sub:Fail("Not an observable")
			return
		end

		return observable:Subscribe(sub:GetFireFailComplete())
	end)
end

--[=[
	Shift the emissions from an Observable forward in time by a particular amount.

	@param seconds number
	@return (source: Observable<T>) -> Observable<T>
]=]
function Rx.delay(seconds)
	assert(type(seconds) == "number", "Bad seconds")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(...)
				local args = table.pack(...)

				maid[args] = cancellableDelay(seconds, function()
					maid[args] = nil
					sub:Fire(table.unpack(args, 1, args.n))
				end)
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Honestly, I have not used this one much.

	https://rxjs-dev.firebaseapp.com/api/operators/withLatestFrom
	https://medium.com/js-in-action/rxjs-nosy-combinelatest-vs-selfish-withlatestfrom-a957e1af42bf

	@param inputObservables {Observable<TInput>}
	@return (source: Observable<T>) -> Observable<{T, ...TInput}>
]=]
function Rx.withLatestFrom(inputObservables)
	assert(inputObservables, "Bad inputObservables")

	for _, observable in pairs(inputObservables) do
		assert(Observable.isObservable(observable), "Bad observable")
	end

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local latest = {}

			for key, observable in pairs(inputObservables) do
				latest[key] = UNSET_VALUE

				maid:GiveTask(observable:Subscribe(function(value)
					latest[key] = value
				end, nil, nil))
			end

			maid:GiveTask(source:Subscribe(function(value)
				for _, item in pairs(latest) do
					if item == UNSET_VALUE then
						return
					end
				end

				sub:Fire({value, unpack(latest)})
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	https://rxjs-dev.firebaseapp.com/api/operators/scan

	@param accumulator (current: TSeed, ...: TInput) -> TResult
	@param seed TSeed
	@return (source: Observable<TInput>) -> Observable<TResult>
]=]
function Rx.scan(accumulator, seed)
	assert(type(accumulator) == "function", "Bad accumulator")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local current = seed

			return source:Subscribe(function(...)
				current = accumulator(current, ...)
				sub:Fire(current)
			end, sub:GetFailComplete())
		end)
	end
end

--[=[
	Throttles emission of observables.

	https://rxjs-dev.firebaseapp.com/api/operators/debounceTime

	:::note
	Note that on complete, the last item is not included, for now, unlike the existing version in rxjs.
	:::

	@param duration number
	@param throttleConfig { leading = true; trailing = true; }
	@return (source: Observable) -> Observable
]=]
function Rx.throttleTime(duration, throttleConfig)
	assert(type(duration) == "number", "Bad duration")
	assert(type(throttleConfig) == "table" or throttleConfig == nil, "Bad throttleConfig")

	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local throttledFunction = ThrottledFunction.new(duration, function(...)
				sub:Fire(...)
			end, throttleConfig)

			maid:GiveTask(throttledFunction)
			maid:GiveTask(source:Subscribe(function(...)
				throttledFunction:Call(...)
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Throttles emission of observables on the defer stack to the last emission.
	@return (source: Observable) -> Observable
]=]
function Rx.throttleDefer()
	return function(source)
		assert(Observable.isObservable(source), "Bad observable")

		return Observable.new(function(sub)
			local maid = Maid.new()

			local lastResult

			maid:GiveTask(source:Subscribe(function(...)
				if not lastResult then
					lastResult = table.pack(...)

					-- Queue up our result
					task.defer(function()
						local current = lastResult
						lastResult = nil

						if sub:IsPending() then
							sub:Fire(table.unpack(current, 1, current.n))
						end
					end)
				else
					lastResult = table.pack(...)
				end
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

return Rx  -  Editar
  04:54:13.791    -  Editar
  04:54:13.791  ----- [2421] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.Shared.Rx.spec -----  -  Editar
  04:54:13.791  --[[
	@class Rx.spec.lua
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local Rx = require("Rx")

return function()
	describe("Rx.combineLatest({})", function()
		local observe = Rx.combineLatest({})
		local externalResult

		it("should execute immediately", function()
			local sub = observe:Subscribe(function(result)
				externalResult = result
			end)

			expect(externalResult).to.be.a("table")
			sub:Destroy()
		end)
	end)

	describe("Rx.combineLatest({ value = 5 })", function()
		local observe = Rx.combineLatest({ value = 5 })
		local externalResult

		it("should execute immediately", function()
			local sub = observe:Subscribe(function(result)
				externalResult = result
			end)

			expect(externalResult).to.be.a("table")
			expect(externalResult.value).to.equal(5)
			sub:Destroy()
		end)
	end)

	describe("Rx.combineLatest({ value = Rx.of(5) })", function()
		local observe = Rx.combineLatest({ value = Rx.of(5) })
		local externalResult

		it("should execute immediately", function()
			local sub = observe:Subscribe(function(result)
				externalResult = result
			end)

			expect(externalResult).to.be.a("table")
			expect(externalResult.value).to.equal(5)
			sub:Destroy()
		end)
	end)
end
  -  Editar
  04:54:13.792    -  Editar
  04:54:13.792  ----- [2422] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.Shared.Subscription -----  -  Editar
  04:54:13.792  --[=[
	Subscriptions are used in the callback for an [Observable](/api/Observable). Standard usage
	is as follows.

	```lua
	-- Constucts an observable which will emit a, b, c via a subscription
	Observable.new(function(sub)
		sub:Fire("a")
		sub:Fire("b")
		sub:Fire("c")
		sub:Complete() -- ends stream
	end)
	```
	@class Subscription
]=]

local require = require(script.Parent.loader).load(script)

local MaidTaskUtils = require("MaidTaskUtils")

local ENABLE_STACK_TRACING = false

local Subscription = {}
Subscription.ClassName = "Subscription"
Subscription.__index = Subscription

local stateTypes = {
	PENDING = "pending";
	FAILED = "failed";
	COMPLETE = "complete";
	CANCELLED = "cancelled";
}

--[=[
	Constructs a new Subscription

	@param fireCallback function?
	@param failCallback function?
	@param completeCallback function?
	@param onSubscribe () -> MaidTask
	@return Subscription
]=]
function Subscription.new(fireCallback, failCallback, completeCallback, onSubscribe)
	assert(type(fireCallback) == "function" or fireCallback == nil, "Bad fireCallback")
	assert(type(failCallback) == "function" or failCallback == nil, "Bad failCallback")
	assert(type(completeCallback) == "function" or completeCallback == nil, "Bad completeCallback")

	return setmetatable({
		_state = stateTypes.PENDING;
		_source = ENABLE_STACK_TRACING and debug.traceback() or "";
		_fireCallback = fireCallback;
		_failCallback = failCallback;
		_completeCallback = completeCallback;
		_onSubscribe = onSubscribe;
	}, Subscription)
end

--[=[
	Fires the subscription

	@param ... any
]=]
function Subscription:Fire(...)
	if self._state == stateTypes.PENDING then
		if self._fireCallback then
			self._fireCallback(...)
		end
	elseif self._state == stateTypes.CANCELLED then
		warn("[Subscription.Fire] - We are cancelled, but events are still being pushed")

		if ENABLE_STACK_TRACING then
			print(debug.traceback())
			print(self._source)
		end
	end
end

--[=[
	Fails the subscription, preventing anything else from emitting.
]=]
function Subscription:Fail()
	if self._state ~= stateTypes.PENDING then
		return
	end

	self._state = stateTypes.FAILED

	if self._failCallback then
		self._failCallback()
	end

	self:_doCleanup()
end


--[=[
	Returns a tuple of fire, fail and complete functions which
	can be chained into the the next subscription.

	```lua
	return function(source)
		return Observable.new(function(sub)
			sub:Fire("hi")

			return source:Subscribe(sub:GetFireFailComplete())
		end)
	end
	```

	@return function
	@return function
	@return function
]=]
function Subscription:GetFireFailComplete()
	return function(...)
		self:Fire(...)
	end, function(...)
		self:Fail(...)
	end, function(...)
		self:Complete(...)
	end
end

--[=[
	Returns a tuple of fail and complete functions which
	can be chained into the the next subscription.

	```lua
	return function(source)
		return Observable.new(function(sub)
			return source:Subscribe(function(result)
				sub:Fire(tostring(result))
			end, sub:GetFailComplete()) -- Reuse is easy here!
		end)
	end
	```

	@return function
	@return function
]=]
function Subscription:GetFailComplete()
	return function(...)
		self:Fail(...)
	end, function(...)
		self:Complete(...)
	end
end

--[=[
	Completes the subscription, preventing anything else from being
	emitted.
]=]
function Subscription:Complete()
	if self._state ~= stateTypes.PENDING then
		return
	end

	self._state = stateTypes.COMPLETE
	if self._completeCallback then
		self._completeCallback()
	end

	self:_doCleanup()
end

--[=[
	Returns whether the subscription is pending.
	@return boolean
]=]
function Subscription:IsPending()
	return self._state == stateTypes.PENDING
end

function Subscription:_giveCleanup(task)
	assert(task, "Bad task")
	assert(not self._cleanupTask, "Already have _cleanupTask")

	if self._state ~= stateTypes.PENDING then
		MaidTaskUtils.doTask(task)
		return
	end

	self._cleanupTask = task
end

function Subscription:_doCleanup()
	if self._cleanupTask then
		local task = self._cleanupTask
		self._cleanupTask = nil
		MaidTaskUtils.doTask(task)
	end
end

--[=[
	Cleans up the subscription

	:::tip
	This will be invoked by the Observable automatically, and should not
	be called within the usage of a subscription.
	:::
]=]
function Subscription:Destroy()
	if self._state == stateTypes.PENDING then
		self._state = stateTypes.CANCELLED
	end

	self:_doCleanup()
end

--[=[
	Alias for [Subscription.Destroy].
]=]
function Subscription:Disconnect()
	self:Destroy()
end

return Subscription  -  Editar
  04:54:13.792    -  Editar
  04:54:13.792  ----- [2423] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.cancellabledelay.Shared.cancellableDelay -----  -  Editar
  04:54:13.792  --[=[
	A version of task.delay that can be cancelled. Soon to be useless.
	@class cancellableDelay
]=]

--[=[
	@function cancellableDelay
	@param timeoutInSeconds number
	@param func function
	@param ... any -- Args to pass into the function
	@return function? -- Can be used to cancel
	@within cancellableDelay
]=]
local function cancellableDelay(timeoutInSeconds, func, ...)
	assert(type(timeoutInSeconds) == "number", "Bad timeoutInSeconds")
	assert(type(func) == "function", "Bad func")

	local args = table.pack(...)

	local running
	task.spawn(function()
		running = coroutine.running()
		task.wait(timeoutInSeconds)
		local localArgs = args
		running = nil
		args = nil
		func(table.unpack(localArgs, 1, localArgs.n))
	end)

	return function()
		if running then
			coroutine.close(running)
			running = nil
			args = nil
		end
	end
end

return cancellableDelay  -  Editar
  04:54:13.792    -  Editar
  04:54:13.792  ----- [2424] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.Shared.CancelToken -----  -  Editar
  04:54:13.792  --[=[
	Cancellation token
	@class CancelToken
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")
local Signal = require("Signal")

local CancelToken = {}
CancelToken.ClassName = "CancelToken"
CancelToken.__index = CancelToken

--[=[
	Constructs a new CancelToken

	@param executor (cancel: () -> ()) -> ()
	@return CancelToken
]=]
function CancelToken.new(executor)
	local self = setmetatable({}, CancelToken)

	assert(type(executor) == "function", "Bad executor")

	self.PromiseCancelled = Promise.new()

	self.Cancelled = Signal.new()

	self.PromiseCancelled:Then(function()
		self.Cancelled:Fire()
		self.Cancelled:Destroy()
	end)

	executor(function()
		self:_cancel()
	end)

	return self
end

local EMPTY_FUNCTION = function() end

--[=[
	Constructs a new CancelToken that cancels whenever the maid does.

	@param maid Maid
	@return CancelToken
]=]
function CancelToken.fromMaid(maid)
	local token = CancelToken.new(EMPTY_FUNCTION)

	local taskId = maid:GiveTask(function()
		token:_cancel()
	end)

	token.PromiseCancelled:Then(function()
		maid[taskId] = nil
	end)

	return token
end

--[=[
	Errors if cancelled
]=]
function CancelToken:ErrorIfCancelled()
	if not self.PromiseCancelled:IsPending() then
		error("[CancelToken.ErrorIfCancelled] - Cancelled")
	end
end

--[=[
	Returns true if cancelled
	@return boolean
]=]
function CancelToken:IsCancelled()
	return self.PromiseCancelled:IsFulfilled()
end

function CancelToken:_cancel()
	self.PromiseCancelled:Resolve()
end

return CancelToken  -  Editar
  04:54:13.792    -  Editar
  04:54:13.792  ----- [2425] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.Shared.Promise -----  -  Editar
  04:54:13.792  --[=[
	Promises, but without error handling as this screws with stack traces, using Roblox signals

	See: https://promisesaplus.com/

	@class Promise
]=]

local RunService = game:GetService("RunService")

-- Turns out debug.traceback() is slow
local ENABLE_TRACEBACK = false
local _emptyRejectedPromise = nil
local _emptyFulfilledPromise = nil

local Promise = {}
Promise.ClassName = "Promise"
Promise.__index = Promise

--[=[
	Determines whether a value is a promise or not.

	@param value any
	@return boolean
]=]
function Promise.isPromise(value)
	return type(value) == "table" and value.ClassName == "Promise"
end

--[=[
	Constructs a new promise.

	::warning
	Do not yield within this func callback, as it will yield on the
	main thread. This is a performance optimization.
	::

	@param func (resolve: (...) -> (), reject: (...) -> ()) -> ()?
	@return Promise<T>
]=]
function Promise.new(func)
	local self = setmetatable({
		_pendingExecuteList = {};
		_unconsumedException = true;
		_source = ENABLE_TRACEBACK and debug.traceback() or "";
	}, Promise)

	if type(func) == "function" then
		func(self:_getResolveReject())
	end

	return self
end

--[=[
	Initializes a new promise with the given function in a deferred wrapper.

	@param func (resolve: (...) -> (), reject: (...) -> ()) -> ()?
	@return Promise<T>
]=]
function Promise.spawn(func)
	local self = Promise.new()

	task.spawn(func, self:_getResolveReject())

	return self
end

--[=[
	Initializes a new promise with the given function in a deferred wrapper.

	@param func (resolve: (...) -> (), reject: (...) -> ()) -> ()?
	@return Promise<T>
]=]
function Promise.defer(func)
	local self = Promise.new()

	-- Just the function part of the resolve/reject protocol!
	task.defer(func, self:_getResolveReject())

	return self
end

--[=[
	Returns a resolved promise with the following values

	@param ... Values to resolve to
	@return Promise<T>
]=]
function Promise.resolved(...)
	local n = select("#", ...)
	if n == 0 then
		-- Reuse promise here to save on calls to Promise.resolved()
		return _emptyFulfilledPromise
	elseif n == 1 and Promise.isPromise(...) then
		local promise = (...)

		-- Resolving to promise that is already resolved. Just return the promise!
		if not promise._pendingExecuteList then
			return promise
		end
	end

	local promise = Promise.new()
	promise:Resolve(...)
	return promise
end

--[=[
	Returns a rejected promise with the following values

	@param ... Values to reject to
	@return Promise<T>
]=]
function Promise.rejected(...)
	local n = select("#", ...)
	if n == 0 then
		-- Reuse promise here to save on calls to Promise.rejected()
		return _emptyRejectedPromise
	end

	local promise = Promise.new()
	promise:_reject({...}, n)
	return promise
end

--[=[
	Returns whether or not the promise is pending

	@return bool -- True if pending, false otherwise
]=]
function Promise:IsPending()
	return self._pendingExecuteList ~= nil
end

--[=[
	Returns whether or not the promise is fulfilled

	@return bool -- True if fulfilled
]=]
function Promise:IsFulfilled()
	return self._fulfilled ~= nil
end

--[=[
	Returns whether or not the promise is rejected

	@return bool -- True if rejected
]=]
function Promise:IsRejected()
	return self._rejected ~= nil
end

--[=[
	Yields until the promise is complete, and errors if an error
	exists, otherwise returns the fulfilled results.

	@yields
	@return T
]=]
function Promise:Wait()
	if self._fulfilled then
		return unpack(self._fulfilled, 1, self._valuesLength)
	elseif self._rejected then
		return error(tostring(self._rejected[1]), 2)
	else
		local bindable = Instance.new("BindableEvent")

		self:Then(function()
			bindable:Fire()
		end, function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()

		if self._rejected then
			return error(tostring(self._rejected[1]), 2)
		else
			return unpack(self._fulfilled, 1, self._valuesLength)
		end
	end
end


--[=[
	Yields until the promise is complete, then returns a boolean indicating
	the result, followed by the values from the promise.

	@yields
	@return boolean, T
]=]
function Promise:Yield()
	if self._fulfilled then
		return true, unpack(self._fulfilled, 1, self._valuesLength)
	elseif self._rejected then
		return false, unpack(self._rejected, 1, self._valuesLength)
	else
		local bindable = Instance.new("BindableEvent")

		self:Then(function()
			bindable:Fire()
		end, function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()

		if self._fulfilled then
			return true, unpack(self._fulfilled, 1, self._valuesLength)
		elseif self._rejected then
			return false, unpack(self._rejected, 1, self._valuesLength)
		end
	end
end


--[=[
	Promise resolution procedure, resolves the given values

	@param ... T
]=]
function Promise:Resolve(...)
	if not self._pendingExecuteList then
		return
	end

	local len = select("#", ...)
	if len == 0 then
		self:_fulfill({}, 0)
	elseif self == (...) then
		self:Reject("TypeError: Resolved to self")
	elseif Promise.isPromise(...) then
		if len > 1 then
			local message = ("When resolving a promise, extra arguments are discarded! See:\n\n%s")
				:format(self._source)
			warn(message)
		end

		local promise2 = (...)
		if promise2._pendingExecuteList then -- pending
			promise2._unconsumedException = false
			promise2._pendingExecuteList[#promise2._pendingExecuteList + 1] = {
				function(...)
					self:Resolve(...)
				end,
				function(...)
					-- Still need to verify at this point that we're pending!
					if self._pendingExecuteList then
						self:_reject({...}, select("#", ...))
					end
				end,
				nil
			}
		elseif promise2._rejected then -- rejected
			promise2._unconsumedException = false
			self:_reject(promise2._rejected, promise2._valuesLength)
		elseif promise2._fulfilled then -- fulfilled
			self:_fulfill(promise2._fulfilled, promise2._valuesLength)
		else
			error("[Promise.Resolve] - Bad promise2 state")
		end
	elseif type(...) == "function" then
		if len > 1 then
			local message = ("When resolving a function, extra arguments are discarded! See:\n\n%s")
				:format(self._source)
			warn(message)
		end

		local func = {...}
		func(self:_getResolveReject())
	else
		-- TODO: Handle thenable promises!
		-- Problem: Lua has :andThen() and also :Then() as two methods in promise
		-- implementations.
		self:_fulfill({...}, len)
	end
end

--[=[
	Fulfills the promise with the value
	@param values { T } -- Params to fulfil with
	@param valuesLength number
	@private
]=]
function Promise:_fulfill(values, valuesLength)
	if not self._pendingExecuteList then
		return
	end

	self._fulfilled = values
	self._valuesLength = valuesLength

	local list = self._pendingExecuteList
	self._pendingExecuteList = nil
	for _, data in pairs(list) do
		self:_executeThen(unpack(data))
	end
end

--[=[
	Rejects the promise with the values given
	@param ... T -- Params to reject with
]=]
function Promise:Reject(...)
	self:_reject({...}, select("#", ...))
end

function Promise:_reject(values, valuesLength)
	if not self._pendingExecuteList then
		return
	end

	self._rejected = values
	self._valuesLength = valuesLength

	local list = self._pendingExecuteList
	self._pendingExecuteList = nil
	for _, data in pairs(list) do
		self:_executeThen(unpack(data))
	end

	-- Check for uncaught exceptions
	if self._unconsumedException and self._valuesLength > 0 then
		coroutine.resume(coroutine.create(function()
			-- Yield to end of frame, giving control back to Roblox.
			-- This is the equivalent of giving something back to a task manager.
			RunService.Heartbeat:Wait()

			if self._unconsumedException then
				if ENABLE_TRACEBACK then
					warn(("[Promise] - Uncaught exception in promise\n\n%q\n\n%s")
						:format(tostring(self._rejected[1]), self._source))
				else
					warn(("[Promise] - Uncaught exception in promise: %q")
						:format(tostring(self._rejected[1])))
				end
			end
		end))
	end
end

--[=[
	Handlers if/when promise is fulfilled/rejected. It takes up to two arguments, callback functions
	for the success and failure cases of the Promise. May return the same promise if certain behavior
	is met.

	:::info
	We do not comply with 2.2.4 (onFulfilled or onRejected must not be called until the execution context stack
	contains only platform code). This means promises may stack overflow, however, it also makes promises a lot cheaper
	:::

	If/when promise is rejected, all respective onRejected callbacks must execute in the order of their
	originating calls to then.

	If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their
	originating calls to then.

	@param onFulfilled function -- Called if/when fulfilled with parameters
	@param onRejected function -- Called if/when rejected with parameters
	@return Promise<T>
]=]
function Promise:Then(onFulfilled, onRejected)
	if type(onRejected) == "function" then
		self._unconsumedException = false
	end

	if self._pendingExecuteList then
		local promise = Promise.new()
		self._pendingExecuteList[#self._pendingExecuteList + 1] = { onFulfilled, onRejected, promise }
		return promise
	else
		return self:_executeThen(onFulfilled, onRejected, nil)
	end
end

--[=[
	Like then, but the value passed down the chain is the resolved value of the promise, not
	the value returned from onFulfilled or onRejected

	Will still yield for the result if a promise is returned, but will discard the result.

	@param onFulfilled function
	@param onRejected function
	@return Promise<T> -- Returns self
]=]
function Promise:Tap(onFulfilled, onRejected)
	-- Run immediately like then, but we return something safer!
	local result = self:Then(onFulfilled, onRejected)
	if result == self then
		return result
	end

	-- Most of the time we can just return the same
	-- promise. But sometimes we need to yield
	-- for the result to finish, and then resolve that result to a new result
	if result._fulfilled then
		return self
	elseif result._rejected then
		return self
	elseif result._pendingExecuteList then
		-- Definitely the most expensive case, might be able to make this better over time
		local function returnSelf()
			return self
		end

		return result:Then(returnSelf, returnSelf)
	else
		error("Bad result state")
	end
end

--[=[
	Executes upon pending stop

	@param func function
	@return Promise<T>
]=]
function Promise:Finally(func)
	return self:Then(func, func)
end

--[=[
	Catch errors from the promise

	@param onRejected function
	@return Promise<T>
]=]
function Promise:Catch(onRejected)
	return self:Then(nil, onRejected)
end

--[=[
	Rejects the current promise. Utility left for Maid task
]=]
function Promise:Destroy()
	self:_reject({}, 0)
end

--[=[
	Returns the results from the promise.

	:::warning
	This API surface will error if the promise is still pending.
	:::

	@return boolean -- true if resolved, false otherwise.
	@return any
]=]
function Promise:GetResults()
	if self._rejected then
		return false, unpack(self._rejected, 1, self._valuesLength)
	elseif self._fulfilled then
		return true, unpack(self._fulfilled, 1, self._valuesLength)
	else
		error("Still pending")
	end
end

function Promise:_getResolveReject()
	return function(...)
		self:Resolve(...)
	end, function(...)
		self:_reject({...}, select("#", ...))
	end
end

--[=[
	@private

	@param onFulfilled function?
	@param onRejected function?
	@param promise2 Promise<T>? -- May be nil. If it is, then we have the option to return self
	@return Promise
]=]
function Promise:_executeThen(onFulfilled, onRejected, promise2)
	if self._fulfilled then
		if type(onFulfilled) == "function" then
			-- If either onFulfilled or onRejected returns a value x, run
			-- the Promise Resolution Procedure [[Resolve]](promise2, x).
			if promise2 then
				promise2:Resolve(onFulfilled(unpack(self._fulfilled, 1, self._valuesLength)))
				return promise2
			else
				local results = table.pack(onFulfilled(unpack(self._fulfilled, 1, self._valuesLength)))
				if results.n == 0 then
					return _emptyFulfilledPromise
				elseif results.n == 1 and Promise.isPromise(results[1]) then
					return results[1]
				else
					local promise = Promise.new()
					-- Technically undefined behavior from A+, but we'll resolve to nil like ES6 promises
					promise:Resolve(table.unpack(results, 1, results.n))
					return promise
				end
			end
		else
			-- If onFulfilled is not a function, it must be ignored.
			-- If onFulfilled is not a function and promise1 is fulfilled,
			-- promise2 must be fulfilled with the same value as promise1.
			if promise2 then
				promise2:_fulfill(self._fulfilled, self._valuesLength)
				return promise2
			else
				return self
			end
		end
	elseif self._rejected then
		if type(onRejected) == "function" then
			-- If either onFulfilled or onRejected returns a value x, run
			-- the Promise Resolution Procedure [[Resolve]](promise2, x).
			if promise2 then
				promise2:Resolve(onRejected(unpack(self._rejected, 1, self._valuesLength)))
				return promise2
			else
				local results = table.pack(onRejected(unpack(self._rejected, 1, self._valuesLength)))
				if results.n == 0 then
					return _emptyFulfilledPromise
				elseif results.n == 1 and Promise.isPromise(results[1]) then
					return results[1]
				else
					local promise = Promise.new()
					-- Technically undefined behavior from A+, but we'll resolve to nil like ES6 promises
					promise:Resolve(table.unpack(results, 1, results.n))
					return promise
				end
			end
		else
			-- If onRejected is not a function, it must be ignored.
			-- If onRejected is not a function and promise1 is rejected, promise2 must be
			-- rejected with the same reason as promise1.
			if promise2 then
				promise2:_reject(self._rejected, self._valuesLength)

				return promise2
			else
				return self
			end
		end
	else
		error("Internal error: still pending")
	end
end

-- Initialize promise values
_emptyFulfilledPromise = Promise.new()
_emptyFulfilledPromise:_fulfill({}, 0)

_emptyRejectedPromise = Promise.new()
_emptyRejectedPromise:_reject({}, 0)

return Promise  -  Editar
  04:54:13.793    -  Editar
  04:54:13.793  ----- [2426] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.Shared.PromiseUtils -----  -  Editar
  04:54:13.793  --[=[
	Utility methods for promise
	@class PromiseUtils
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

local PromiseUtils = {}

--[=[
	Returns the value of the first promise resolved
	@param promises { Promise<T> }
	@return Promise<T> -- Promise that resolves with first result
]=]
function PromiseUtils.any(promises)
	local returnPromise = Promise.new()

	local function resolve(...)
		returnPromise:Resolve(...)
	end

	local function reject(...)
		returnPromise:Reject(...)
	end

	for _, promise in pairs(promises) do
		promise:Then(resolve, reject)
	end

	return returnPromise
end

--[=[
	Executes all promises. If any fails, the result will be rejected. However, it yields until
	every promise is complete.

	:::warning
	Passing in a spare array (i.e. {nil, promise}) will result in undefined behavior here.
	:::

	@param promises { Promise<T> }
	@return Promise<T>
]=]
function PromiseUtils.all(promises)
	if #promises == 0 then
		return Promise.resolved()
	elseif #promises == 1 then
		return promises[1]
	end

	local remainingCount = #promises
	local returnPromise = Promise.new()
	local results = {}
	local allFulfilled = true

	local function syncronize(index, isFullfilled)
		return function(value)
			allFulfilled = allFulfilled and isFullfilled
			results[index] = value
			remainingCount = remainingCount - 1
			if remainingCount == 0 then
				local method = allFulfilled and "Resolve" or "Reject"
				returnPromise[method](returnPromise, unpack(results, 1, #promises))
			end
		end
	end

	for index, promise in pairs(promises) do
		promise:Then(syncronize(index, true), syncronize(index, false))
	end

	return returnPromise
end

--[=[
	Inverts the result of a promise, turning a resolved promise
	into a rejected one, and a rejected one into a resolved one.

	@param promise Promise<T>
	@return Promise<T>
]=]
function PromiseUtils.invert(promise)
	if promise:IsPending() then
		return promise:Then(function(...)
			return Promise.rejected(...)
		end, function(...)
			return Promise.resolved(...)
		end)
	else
		local results = {promise:GetResults()}
		if results[1] then
			return Promise.rejected(unpack(results, 2))
		else
			return Promise.resolved(unpack(results, 2))
		end
	end
end

--[=[
	Creates a promise from a signal

	@param signal Signal<T>
	@return Promise<T>
]=]
function PromiseUtils.fromSignal(signal)
	local promise = Promise.new()
	local conn

	promise:Finally(function()
		conn:Disconnect()
		conn = nil
	end)

	conn = signal:Connect(function(...)
		promise:Resolve(...)
	end)

	return promise
end

--[=[
	Creates a new promise from the given promise that will
	reject after the given `timeoutTime`

	@param timeoutTime number
	@param fromPromise Promise<T>
	@return Promise<T>
]=]
function PromiseUtils.timeout(timeoutTime, fromPromise)
	assert(type(timeoutTime) == "number", "Bad timeoutTime")
	assert(fromPromise, "Bad fromPromise")

	if not fromPromise:IsPending() then
		return fromPromise
	end

	local promise = Promise.new()

	promise:Resolve(fromPromise)

	task.delay(timeoutTime, function()
		promise:Reject()
	end)

	return promise
end

return PromiseUtils  -  Editar
  04:54:13.793    -  Editar
  04:54:13.793  ----- [2427] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.Shared.Utility.PendingPromiseTracker -----  -  Editar
  04:54:13.793  --[=[
	Tracks pending promises
	@class PendingPromiseTracker
]=]

local PendingPromiseTracker = {}
PendingPromiseTracker.ClassName = "PendingPromiseTracker"
PendingPromiseTracker.__index = PendingPromiseTracker

function PendingPromiseTracker.new()
	local self = setmetatable({}, PendingPromiseTracker)

	self._pendingPromises = {}

	return self
end

function PendingPromiseTracker:Add(promise)
	if promise:IsPending() then
		self._pendingPromises[promise] = true
		promise:Finally(function()
			self._pendingPromises[promise] = nil
		end)
	end
end

function PendingPromiseTracker:GetAll()
	local promises = {}
	for promise, _ in pairs(self._pendingPromises) do
		table.insert(promises, promise)
	end
	return promises
end

return PendingPromiseTracker  -  Editar
  04:54:13.793    -  Editar
  04:54:13.793  ----- [2428] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.Shared.Utility.PromiseInstanceUtils -----  -  Editar
  04:54:13.793  --[=[
	@class PromiseInstanceUtils
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")
local Maid = require("Maid")

local PromiseInstanceUtils = {}

--[=[
	@param instance Instance
	@return Promise
]=]
function PromiseInstanceUtils.promiseRemoved(instance)
	assert(instance:IsDescendantOf(game))

	local maid = Maid.new()

	local promise = Promise.new()

	maid:GiveTask(instance.AncestryChanged:Connect(function(_, parent)
		if not parent then
			promise:Resolve()
		end
	end))

	promise:Finally(function()
		maid:DoCleaning()
	end)

	return promise
end

return PromiseInstanceUtils  -  Editar
  04:54:13.793    -  Editar
  04:54:13.793  ----- [2429] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.Shared.Utility.promiseChild -----  -  Editar
  04:54:13.793  --[=[
	Warps the WaitForChild API with a promise
	@class promiseChild
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

--[=[
	Wraps the :WaitForChild API with a promise

	@function promiseChild
	@param parent Instance
	@param name string
	@param timeOut number?
	@return Promise<Instance>
	@within promiseChild
]=]
return function(parent, name, timeOut)
	local result = parent:FindFirstChild(name)
	if result then
		return Promise.resolved(result)
	end

	return Promise.spawn(function(resolve, reject)
		local child = parent:WaitForChild(name, timeOut)

		if child then
			resolve(child)
		else
			reject("Timed out")
		end
	end)
end  -  Editar
  04:54:13.793    -  Editar
  04:54:13.793  ----- [2430] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.Shared.Utility.promisePropertyValue -----  -  Editar
  04:54:13.793  --[=[
	Promises a property value
	@class promisePropertyValue
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

-- NOTE: To use properly please make sure to reject the promise for proper GC if the object requiring
-- this value is GCed.
return function(instance, propertyName)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(propertyName) == "string", "Bad propertyName")

	local result = instance[propertyName]
	if result then
		return Promise.resolved(result)
	end

	local promise = Promise.new()

	local conn
	promise:Finally(function()
		if conn then
			conn:Disconnect()
		end
	end)

	conn = instance:GetPropertyChangedSignal(propertyName):Connect(function()
		if instance[propertyName] then
			promise:Resolve(instance[propertyName])
		end
	end)

	return promise
end  -  Editar
  04:54:13.794    -  Editar
  04:54:13.794  ----- [2431] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.Shared.Utility.promiseWait -----  -  Editar
  04:54:13.795  --[=[
	Wraps the wait()/delay() API in a promise

	@class promiseWait
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")

return function(time)
	return Promise.new(function(resolve, _)
		task.delay(time, function()
			resolve()
		end)
	end)
end  -  Editar
  04:54:13.795    -  Editar
  04:54:13.795  ----- [2432] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.promise.node_modules.@quenty.deferred.Shared.deferred -----  -  Editar
  04:54:13.795  --[=[
	An expensive way to spawn a function. However, unlike spawn(), it executes on the same frame, and
	unlike coroutines, does not obscure errors

	@deprecated 2.0.1
	@class deferred
]=]

return task.defer  -  Editar
  04:54:13.795    -  Editar
  04:54:13.795  ----- [2433] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.signal.Shared.Signal -----  -  Editar
  04:54:13.795  --[=[
	Lua-side duplication of the API of events on Roblox objects.
	Signals are needed for to ensure that for local events objects are passed by
	reference rather than by value where possible, as the BindableEvent objects
	always pass signal arguments by value, meaning tables will be deep copied.
	Roblox's deep copy method parses to a non-lua table compatable format.

	This class is designed to work both in deferred mode and in regular mode.
	It follows whatever mode is set.

	```lua
	local signal = Signal.new()

	local arg = {}

	signal:Connect(function(value)
		assert(arg == value, "Tables are preserved when firing a Signal")
	end)

	signal:Fire(arg)
	```

	:::info
	Why this over a direct [BindableEvent]? Well, in this case, the signal
	prevents Roblox from trying to serialize and desialize each table reference
	fired through the BindableEvent.
	:::

	@class Signal
]=]

local HttpService = game:GetService("HttpService")

local ENABLE_TRACEBACK = false

local Signal = {}
Signal.__index = Signal
Signal.ClassName = "Signal"

--[=[
	Returns whether a class is a signal
	@param value any
	@return boolean
]=]
function Signal.isSignal(value)
	return type(value) == "table"
		and getmetatable(value) == Signal
end

--[=[
	Constructs a new signal.
	@return Signal<T>
]=]
function Signal.new()
	local self = setmetatable({}, Signal)

	self._bindableEvent = Instance.new("BindableEvent")
	self._argMap = {}
	self._source = ENABLE_TRACEBACK and debug.traceback() or ""

	-- Events in Roblox execute in reverse order as they are stored in a linked list and
	-- new connections are added at the head. This event will be at the tail of the list to
	-- clean up memory.
	self._bindableEvent.Event:Connect(function(key)
		self._argMap[key] = nil

		-- We've been destroyed here and there's nothing left in flight.
		-- Let's remove the argmap too.
		-- This code may be slower than leaving this table allocated.
		if (not self._bindableEvent) and (not next(self._argMap)) then
			self._argMap = nil
		end
	end)

	return self
end

--[=[
	Fire the event with the given arguments. All handlers will be invoked. Handlers follow
	@param ... T -- Variable arguments to pass to handler
]=]
function Signal:Fire(...)
	if not self._bindableEvent then
		warn(("Signal is already destroyed. %s"):format(self._source))
		return
	end

	local args = table.pack(...)

	-- TODO: Replace with a less memory/computationally expensive key generation scheme
	local key = HttpService:GenerateGUID(false)
	self._argMap[key] = args

	-- Queues each handler onto the queue.
	self._bindableEvent:Fire(key)
end

--[=[
	Connect a new handler to the event. Returns a connection object that can be disconnected.
	@param handler (... T) -> () -- Function handler called when `:Fire(...)` is called
	@return RBXScriptConnection
]=]
function Signal:Connect(handler)
	if not (type(handler) == "function") then
		error(("connect(%s)"):format(typeof(handler)), 2)
	end

	return self._bindableEvent.Event:Connect(function(key)
		-- note we could queue multiple events here, but we'll do this just as Roblox events expect
		-- to behave.

		local args = self._argMap[key]
		if args then
			handler(table.unpack(args, 1, args.n))
		else
			error("Missing arg data, probably due to reentrance.")
		end
	end)
end

--[=[
	Wait for fire to be called, and return the arguments it was given.
	@yields
	@return T
]=]
function Signal:Wait()
	local key = self._bindableEvent.Event:Wait()
	local args = self._argMap[key]
	if args then
		return table.unpack(args, 1, args.n)
	else
		error("Missing arg data, probably due to reentrance.")
		return nil
	end
end

--[=[
	Disconnects all connected events to the signal. Voids the signal as unusable.
	Sets the metatable to nil.
]=]
function Signal:Destroy()
	if self._bindableEvent then
		-- This should disconnect all events, but in-flight events should still be
		-- executed.

		self._bindableEvent:Destroy()
		self._bindableEvent = nil
	end

	-- Do not remove the argmap. It will be cleaned up by the cleanup connection.

	setmetatable(self, nil)
end

return Signal  -  Editar
  04:54:13.795    -  Editar
  04:54:13.795  ----- [2434] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.canceltoken.node_modules.@quenty.signal.Shared.SignalUtils -----  -  Editar
  04:54:13.795  --[=[
	Utilities involving signals
	@class SignalUtils
]=]

local SignalUtils = {}

--[=[
	Executes on the next event connection.
	@param event RBXScriptSignal
	@param _function function
	@return RBXScriptConnection
]=]
function SignalUtils.onNext(event, _function)
	assert(typeof(event) == "RBXScriptSignal", "Bad event")
	assert(type(_function) == "function", "Bad _function")

	local conn
	conn = event:Connect(function(...)
		if conn.Connected then
			return -- Multiple events got queued
		end

		conn:Disconnect()
		_function(...)
	end)

	return conn
end

return SignalUtils  -  Editar
  04:54:13.795    -  Editar
  04:54:13.795  ----- [2435] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.symbol.Shared.Symbol -----  -  Editar
  04:54:13.795  --[=[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
	@class Symbol
]=]

local Symbol = {}

--[=[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.

	@param name string
	@return Symbol
]=]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol  -  Editar
  04:54:13.795    -  Editar
  04:54:13.795  ----- [2436] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.table.Shared.Set -----  -  Editar
  04:54:13.795  --[=[
	Utility functions involving sets, which are tables with the key as an index, and the value as a
	truthy value.
	@class Set
]=]

local Set = {}

--[=[
	Unions the set with the other set, making a copy.
	@param set table
	@param otherSet table
	@return table
]=]
function Set.union(set, otherSet)
	local newSet = {}
	for key, _ in pairs(set) do
		newSet[key] = true
	end
	for key, _ in pairs(otherSet) do
		newSet[key] = true
	end
	return newSet
end

--[=[
	Unions the set with the other set, updating the `set`
	@param set table
	@param otherSet table
	@return table
]=]
function Set.unionUpdate(set, otherSet)
	for key, _ in pairs(otherSet) do
		set[key] = true
	end
end

--[=[
	Finds the set intersection betwen the two sets
	@param set table
	@param otherSet table
	@return table
]=]
function Set.intersection(set, otherSet)
	local newSet = {}
	for key, _ in pairs(set) do
		if otherSet[key] ~= nil then
			newSet[key] = true
		end
	end
	return newSet
end

--[=[
	Makes a copy of the set, making the values as true.
	@param set table
	@return table
]=]
function Set.copy(set)
	local newSet = {}
	for key, _ in pairs(set) do
		newSet[key] = true
	end
	return newSet
end

--[=[
	Converts a set from table values.
	@param tab table
	@return table
]=]
function Set.fromTableValue(tab)
	local set = {}

	for _, value in pairs(tab) do
		set[value] = true
	end

	return set
end

--[=[
	Converts a set from a list
	@function fromList
	@param tab table
	@return table
	@within Set
]=]
Set.fromList = Set.fromTableValue

--[=[
	Converts a set to a list
	@param set table
	@return table
]=]
function Set.toList(set)
	local list = {}

	for value, _ in pairs(set) do
		table.insert(list, value)
	end

	return list
end

--[=[
	Converts a set to a list
	@param set table
	@param otherSet table
	@return table
]=]
function Set.differenceUpdate(set, otherSet)
	for value, _ in pairs(otherSet) do
		set[value] = nil
	end
end

--[=[
	Computes the set difference between the two sets
	@param set table
	@param otherSet table
	@return table
]=]
function Set.difference(set, otherSet)
	local newSet = {}
	for key, _ in pairs(set) do
		newSet[key] = true
	end
	for key, _ in pairs(otherSet) do
		newSet[key] = nil
	end
	return newSet
end


return Set  -  Editar
  04:54:13.796    -  Editar
  04:54:13.796  ----- [2437] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.table.Shared.Table -----  -  Editar
  04:54:13.796  --[=[
	Provide a variety of utility table operations
	@class Table
]=]

local Table = {}

--[=[
	Concats `target` with `source`.

	@param target table -- Table to append to
	@param source table -- Table read from
	@return table -- parameter table
]=]
function Table.append(target, source)
	for _, value in pairs(source) do
		target[#target+1] = value
	end

	return target
end

--[=[
	Shallow merges two tables without modifying either.

	@param orig table -- Original table
	@param new table -- Result
	@return table
]=]
function Table.merge(orig, new)
	local result = {}
	for key, val in pairs(orig) do
		result[key] = val
	end
	for key, val in pairs(new) do
		result[key] = val
	end
	return result
end

--[=[
	Reverses the list and returns the reversed copy

	@param orig table -- Original table
	@return table
]=]
function Table.reverse(orig)
	local new = {}
	for i=#orig, 1, -1 do
		table.insert(new, orig[i])
	end
	return new
end

--[=[
	Returns a list of all of the values that a table has.

	@param source table -- Table source to extract values from
	@return table -- A list with all the values the table has
]=]
function Table.values(source)
	local new = {}
	for _, val in pairs(source) do
		table.insert(new, val)
	end
	return new
end

--[=[
	Returns a list of all of the keys that a table has. (In order of pairs)

	@param source table -- Table source to extract keys from
	@return table -- A list with all the keys the table has
]=]
function Table.keys(source)
	local new = {}
	for key, _ in pairs(source) do
		table.insert(new, key)
	end
	return new
end

--[=[
	Shallow merges two lists without modifying either.

	@param orig table -- Original table
	@param new table -- Result
	@return table
]=]
function Table.mergeLists(orig, new)
	local _table = {}
	for _, val in pairs(orig) do
		table.insert(_table, val)
	end
	for _, val in pairs(new) do
		table.insert(_table, val)
	end
	return _table
end

--[=[
	Swaps keys with values, overwriting additional values if duplicated.

	@param orig table -- Original table
	@return table
]=]
function Table.swapKeyValue(orig)
	local tab = {}
	for key, val in pairs(orig) do
		tab[val] = key
	end
	return tab
end

--[=[
	Converts a table to a list.

	@param _table table -- Table to convert to a list
	@return table
]=]
function Table.toList(_table)
	local list = {}
	for _, item in pairs(_table) do
		table.insert(list, item)
	end
	return list
end

--[=[
	Counts the number of items in `_table`.
	Useful since `__len` on table in Lua 5.2 returns just the array length.

	@param _table table -- Table to count
	@return number -- count
]=]
function Table.count(_table)
	local count = 0
	for _, _ in pairs(_table) do
		count = count + 1
	end
	return count
end

--[=[
	Shallow copies a table from target into a new table

	@function Table.copy
	@param target table -- Table to copy
	@return table -- Result
	@within Table
]=]
Table.copy = table.clone

--[=[
	Deep copies a table including metatables

	@param target table -- Table to deep copy
	@param _context table? -- Cntext to deepCopy the value in
	@return table -- Result
]=]
function Table.deepCopy(target, _context)
	_context = _context or  {}
	if _context[target] then
		return _context[target]
	end

	if type(target) == "table" then
		local new = {}
		_context[target] = new
		for index, value in pairs(target) do
			new[Table.deepCopy(index, _context)] = Table.deepCopy(value, _context)
		end
		return setmetatable(new, Table.deepCopy(getmetatable(target), _context))
	else
		return target
	end
end

--[=[
	Overwrites a table's value
	@param target table -- Target table
	@param source table -- Table to read from
	@return table -- target
]=]
function Table.deepOverwrite(target, source)
	for index, value in pairs(source) do
		if type(target[index]) == "table" and type(value) == "table" then
			target[index] = Table.deepOverwrite(target[index], value)
		else
			target[index] = value
		end
	end
	return target
end

--[=[
	Gets an index by value, returning `nil` if no index is found.
	@param haystack table -- To search in
	@param needle Value to search for
	@return The index of the value, if found
	@return nil -- if not found
]=]
function Table.getIndex(haystack, needle)
	assert(needle ~= nil, "Needle cannot be nil")

	for index, item in pairs(haystack) do
		if needle == item then
			return index
		end
	end
	return nil
end

--[=[
	Recursively prints the table. Does not handle recursive tables.

	@param _table table -- Table to stringify
	@param indent number? -- Indent level
	@param output string? -- Output string, used recursively
	@return string -- The table in string form
]=]
function Table.stringify(_table, indent, output)
	output = output or tostring(_table)
	indent = indent or 0
	for key, value in pairs(_table) do
		local formattedText = "\n" .. string.rep("  ", indent) .. tostring(key) .. ": "
		if type(value) == "table" then
			output = output .. formattedText
			output = Table.stringify(value, indent + 1, output)
		else
			output = output .. formattedText .. tostring(value)
		end
	end
	return output
end

--[=[
	Returns whether `value` is within `table`

	@param _table table -- To search in for value
	@param value any -- Value to search for
	@return boolean -- `true` if within, `false` otherwise
]=]
function Table.contains(_table, value)
	for _, item in pairs(_table) do
		if item == value then
			return true
		end
	end

	return false
end

--[=[
	Overwrites an existing table with the source values.

	@param target table -- Table to overwite
	@param source table -- Source table to read from
	@return table -- target
]=]
function Table.overwrite(target, source)
	for index, item in pairs(source) do
		target[index] = item
	end

	return target
end

--[=[
	Takes `count` entries from the table. If the table does not have
	that many entries, will return up to the number the table has to
	provide.

	@param source table -- Source table to retrieve values from
	@param count number -- Number of entries to take
	@return table -- List with the entries retrieved
]=]
function Table.take(source, count)
	local newTable = {}
	for i=1, math.min(#source, count) do
		newTable[i] = source[i]
	end
	return newTable
end

local function errorOnIndex(_, index)
	error(("Bad index %q"):format(tostring(index)), 2)
end

local READ_ONLY_METATABLE = {
	__index = errorOnIndex;
	__newindex = errorOnIndex;
}

--[=[
	Sets a metatable on a table such that it errors when
	indexing a nil value

	@param target table -- Table to error on indexing
	@return table -- The same table, with the metatable set to readonly
]=]
function Table.readonly(target)
	return setmetatable(target, READ_ONLY_METATABLE)
end

--[=[
	Recursively sets the table as ReadOnly

	@param target table -- Table to error on indexing
	@return table -- The same table
]=]
function Table.deepReadonly(target)
	for _, item in pairs(target) do
		if type(item) == "table" then
			Table.deepReadonly(item)
		end
	end

	return Table.readonly(target)
end

return Table
  -  Editar
  04:54:13.796    -  Editar
  04:54:13.796  ----- [2438] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.throttle.Shared.ThrottledFunction -----  -  Editar
  04:54:13.796  --[=[
	Throttles execution of a functon. Does both leading, and following
	@class ThrottledFunction
]=]

local ThrottledFunction = {}
ThrottledFunction.ClassName = "ThrottledFunction"
ThrottledFunction.__index = ThrottledFunction

function ThrottledFunction.new(timeoutInSeconds, func, config)
	local self = setmetatable({}, ThrottledFunction)

	self._nextCallTimeStamp = 0
	self._timeout = timeoutInSeconds or error("No timeoutInSeconds")
	self._func = func or error("No func")

	self._trailingValue = nil

	self._callLeading = true
	self._callTrailing = true

	self:_configureOrError(config)

	return self
end

function ThrottledFunction:Call(...)
	if self._trailingValue then
		-- Update the next value to be dispatched
		self._trailingValue = table.pack(...)
	elseif self._nextCallTimeStamp <= tick() then
		if self._callLeading or self._callLeadingFirstTime then
			self._callLeadingFirstTime = false
			-- Dispatch immediately
			self._nextCallTimeStamp = tick() + self._timeout
			self._func(...)
		elseif self._callTrailing then
			-- Schedule for trailing at exactly timeout
			self._trailingValue = table.pack(...)
			task.delay(self._timeout, function()
				if self.Destroy then
					self:_dispatch()
				end
			end)
		else
			error("[ThrottledFunction.Cleanup] - Trailing and leading are both disabled")
		end
	elseif self._callLeading or self._callTrailing or self._callLeadingFirstTime then
		self._callLeadingFirstTime = false
		-- As long as either leading or trailing are set to true, we are good
		local remainingTime = self._nextCallTimeStamp - tick()
		self._trailingValue = table.pack(...)

		task.delay(remainingTime, function()
			if self.Destroy then
				self:_dispatch()
			end
		end)
	end
end

function ThrottledFunction:_dispatch()
	self._nextCallTimeStamp = tick() + self._timeout

	local trailingValue = self._trailingValue
	if trailingValue then
		-- Clear before call so we are in valid state!
		self._trailingValue = nil
		self._func(unpack(trailingValue, 1, trailingValue.n))
	end
end

function ThrottledFunction:_configureOrError(throttleConfig)
	if throttleConfig == nil then
		return
	end

	assert(type(throttleConfig) == "table", "Bad throttleConfig")

	for key, value in pairs(throttleConfig) do
		assert(type(value) == "boolean", "Bad throttleConfig entry")

		if key == "leading" then
			self._callLeading = value
		elseif key == "trailing" then
			self._callTrailing = value
		elseif key == "leadingFirstTimeOnly" then
			self._callLeadingFirstTime = value
		else
			error(("Bad key %q in config"):format(tostring(key)))
		end
	end

	assert(self._callLeading or self._callTrailing, "Cannot configure both leading and trailing disabled")
end

function ThrottledFunction:Destroy()
	self._trailingValue = nil
	self._func = nil
	setmetatable(self, nil)
end

return ThrottledFunction  -  Editar
  04:54:13.796    -  Editar
  04:54:13.796  ----- [2439] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.rx.node_modules.@quenty.throttle.Shared.throttle -----  -  Editar
  04:54:13.796  --[=[
	Debounce a existing function by timeout

	@class throttle
]=]

local require = require(script.Parent.loader).load(script)

local ThrottledFunction = require("ThrottledFunction")

--[=[
	Provides a debounce function call on an operation.

	@function throttle
	@within throttle
	@param timeoutInSeconds number
	@param func function
	@param throttleConfig? { leading = true; trailing = true; }
	@return function
]=]
local function throttle(timeoutInSeconds, func, throttleConfig)
	assert(type(timeoutInSeconds) == "number", "timeoutInSeconds is not a number")
	assert(type(func) == "function", "func is not a function")

	local throttled = ThrottledFunction.new(timeoutInSeconds, func, throttleConfig)

	return function(...)
		throttled:Call(...)
	end
end

return throttle  -  Editar
  04:54:13.796    -  Editar
  04:54:13.796  ----- [2440] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.baseobject.Shared.BaseObject -----  -  Editar
  04:54:13.796  --[=[
	A BaseObject basically just adds the :Destroy() interface, and a _maid, along with an optional object it references.
	@class BaseObject
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")

local BaseObject = {}
BaseObject.ClassName = "BaseObject"
BaseObject.__index = BaseObject

--[=[
	Constructs a new BaseObject

	@param obj? Instance
	@return BaseObject
]=]
function BaseObject.new(obj)
	local self = setmetatable({}, BaseObject)

	self._maid = Maid.new()
	self._obj = obj

	return self
end

--[=[
	Cleans up the BaseObject and sets the metatable to nil
]=]
function BaseObject:Destroy()
	self._maid:DoCleaning()
	setmetatable(self, nil)
end

return BaseObject  -  Editar
  04:54:13.796    -  Editar
  04:54:13.796  ----- [2441] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.basicpane.Client.BasicPane -----  -  Editar
  04:54:13.796  --[=[
	Base UI object with visibility and a maid. BasicPane provides three points of utility.

	1. BasicPane contain visibility API. It's very standard practice to use the VisibleChanged event and
	pass visibility up or down the entire stack.

	```lua
	-- Standard visibility chaining
	self._maid:GiveTask(self.VisibleChanged:Connect(function(isVisible, doNotAnimate)
		self._otherComponent:SetVisible(isVisible, doNotAnimate)
	end))
	```

	2. BasicPane contains a maid which cleans up upon :Destroy(). This just saves some time typing.

	3. Finally, BasicPanes, by convention (although not requirement), contain a .Gui object which can generally
	be safely reparented to another object.

	@class BasicPane
]=]

local require = require(script.Parent.loader).load(script)

local Signal = require("Signal")
local Maid = require("Maid")

local BasicPane = {}
BasicPane.__index = BasicPane
BasicPane.ClassName = "BasicPane"

--[=[
	Returns whether the value is a basic pane
	@param value any
	@return boolean
]=]
function BasicPane.isBasicPane(value)
	return type(value) == "table"
		and Maid.isMaid(value._maid)
		and Signal.isSignal(value.VisibleChanged)
		and type(value.SetVisible) == "function"
		and type(value.IsVisible) == "function"
		and type(value.Show) == "function"
		and type(value.Hide) == "function"
		and type(value.Toggle) == "function"
		and type(value.Destroy) == "function"
end

--[=[
	Gui object which can be reparented or whatever

	@prop Gui Instance?
	@within BasicPane
]=]
--[=[
	Fires whenever visibility changes. FIres with isVisible, doNotAnimate, and a maid which
	has the lifetime of the visibility.

	:::info
	Do not use the Maid if you want the code to work in Deferred signal mode.
	:::

	@prop VisibleChanged Signal<boolean, boolean, Maid>
	@within BasicPane
]=]

--[=[
	Constructs a new BasicPane with the .Gui property set.

	@param gui GuiBase? -- Optional Gui object
	@return BasicPane
]=]
function BasicPane.new(gui)
	local self = setmetatable({}, BasicPane)

	self._maid = Maid.new()
	self.Maid = self._maid

	self._visible = false

	self.VisibleChanged = Signal.new() -- :Fire(isVisible, doNotAnimate, maid)
	self._maid:GiveTask(self.VisibleChanged)

	if gui then
		self._gui = gui
		self.Gui = gui
		self._maid:GiveTask(gui)
	end

	return self
end

--[=[
	Sets the BasicPane to be visible

	@param isVisible boolean -- Whether or not the pane should be visible
	@param doNotAnimate boolean? -- True if this visiblity should not animate
]=]
function BasicPane:SetVisible(isVisible, doNotAnimate)
	assert(type(isVisible) == "boolean", "Bad isVisible")

	if self._visible ~= isVisible then
		self._visible = isVisible

		local maid = Maid.new()
		self._maid._paneVisibleMaid = maid
		self.VisibleChanged:Fire(self._visible, doNotAnimate, maid)
	end
end

--[=[
	Shows the pane
	@param doNotAnimate boolean? -- True if this visiblity should not animate
]=]
function BasicPane:Show(doNotAnimate)
	self:SetVisible(true, doNotAnimate)
end

--[=[
	Hides the pane
	@param doNotAnimate boolean? -- True if this visiblity should not animate
]=]
function BasicPane:Hide(doNotAnimate)
	self:SetVisible(false, doNotAnimate)
end

--[=[
	Toggles the pane
	@param doNotAnimate boolean? -- True if this visiblity should not animate
]=]
function BasicPane:Toggle(doNotAnimate)
	self:SetVisible(not self._visible, doNotAnimate)
end

--[=[
	Returns if the pane is visible
	@return boolean
]=]
function BasicPane:IsVisible()
	return self._visible
end

--[=[
	Cleans up the BasicPane, invoking Maid:DoCleaning() on the BasicPane and
	setting the metatable to nil.
]=]
function BasicPane:Destroy()
	self._maid:DoCleaning()
	self._maid = nil
	setmetatable(self, nil)
end

return BasicPane  -  Editar
  04:54:13.796    -  Editar
  04:54:13.797  ----- [2442] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.basicpane.Client.BasicPaneUtils -----  -  Editar
  04:54:13.797  --[=[
	@class BasicPaneUtils
]=]

local require = require(script.Parent.loader).load(script)

local Observable = require("Observable")
local Maid = require("Maid")
local Rx = require("Rx")
local BasicPane = require("BasicPane")

local BasicPaneUtils = {}

--[=[
	Observes visibility
	@param basicPane BasicPane
	@return Observable<boolean>
]=]
function BasicPaneUtils.observeVisible(basicPane)
	assert(BasicPane.isBasicPane(basicPane), "Bad BasicPane")

	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(basicPane.VisibleChanged:Connect(function(isVisible)
			sub:Fire(isVisible)
		end))
		sub:Fire(basicPane:IsVisible())

		return maid
	end)
end

--[=[
	Observes percent visibility
	@param basicPane BasicPane
	@return Observable<number>
]=]
function BasicPaneUtils.observePercentVisible(basicPane)
	assert(BasicPane.isBasicPane(basicPane), "Bad BasicPane")

	return BasicPaneUtils.observeVisible(basicPane):Pipe({
		Rx.map(function(visible)
			return visible and 1 or 0
		end);
		Rx.startWith({0}); -- Ensure fade in every time.
	})
end

--[=[
	Convert percentVisible observable to transparency

	@function toTransparency
	@param source Observable<number>
	@return Observable<number>
	@within BasicPaneUtils
]=]
BasicPaneUtils.toTransparency = Rx.map(function(value)
	return 1 - value
end)

--[=[
	Observes showing a basic pane
	@param basicPane BasicPane
	@return Observable<boolean>
]=]
function BasicPaneUtils.observeShow(basicPane)
	return BasicPaneUtils.observeVisible(basicPane):Pipe({
		Rx.where(function(isVisible)
			return isVisible
		end)
	})
end

return BasicPaneUtils  -  Editar
  04:54:13.797    -  Editar
  04:54:13.797  ----- [2443] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Blend.Blend -----  -  Editar
  04:54:13.797  --[=[
	Declarative UI system inspired by Fusion
	@class Blend
]=]

local require = require(script.Parent.loader).load(script)

local AccelTween = require("AccelTween")
local BlendDefaultProps = require("BlendDefaultProps")
local Brio = require("Brio")
local Maid = require("Maid")
local MaidTaskUtils = require("MaidTaskUtils")
local Observable = require("Observable")
local Promise = require("Promise")
local Rx = require("Rx")
local BrioUtils = require("BrioUtils")
local RxInstanceUtils = require("RxInstanceUtils")
local RxValueBaseUtils = require("RxValueBaseUtils")
local Signal = require("Signal")
local Spring = require("Spring")
local SpringUtils = require("SpringUtils")
local StepUtils = require("StepUtils")
local ValueBaseUtils = require("ValueBaseUtils")
local ValueObject = require("ValueObject")
local ValueObjectUtils = require("ValueObjectUtils")

local Blend = {}

--[=[
	Creates a new function which will return an observable that, given the props
	in question, will construct a new instance and assign all props. This is the
	equivalent of a pipe-able Rx command.

	```lua
	Blend.New "ScreenGui" {
		Parent = game.Players.LocalPlayer.PlayerGui;
		[Blend.Children] = {
			Blend.New "Frame" {
				Size = UDim2.new(1, 0, 1, 0);
				BackgroundTransparency = 0.5;
			};
		};
	};

	@param className string
	@return (props: { [string]: any; }) -> Observable<Instance>
	```
]=]
function Blend.New(className)
	assert(type(className) == "string", "Bad className")

	local defaults = BlendDefaultProps[className]

	return function(props)
		return Observable.new(function(sub)
			local maid = Maid.new()

			local instance = Instance.new(className)
			maid:GiveTask(instance)

			if defaults then
				for key, value in pairs(defaults) do
					instance[key] = value
				end
			end

			maid:GiveTask(Blend.mount(instance, props))

			sub:Fire(instance)

			return maid
		end)
	end
end

--[=[
	Creates a new Blend State which is actually just a ValueObject underneath.

	@param defaultValue T
	@return ValueObject<T>
]=]
function Blend.State(defaultValue)
	return ValueObject.new(defaultValue)
end

function Blend.Dynamic(...)
	return Blend.Computed(...)
		:Pipe({
			-- This switch map is relatively expensive, so we don't do this for defaul computed
			-- and instead force the user to switch to another promise
			Rx.switchMap(function(promise, ...)
				if Promise.isPromise(promise) then
					return Rx.fromPromise(promise)
				elseif Observable.isObservable(promise) then
					return promise
				else
					return Rx.of(promise, ...)
				end
			end)
		})
end

--[=[
	Takes a list of variables and uses them to compute an observable that
	will combine into any value. These variables can be any value, and if they
	can be converted into an Observable, they will be, which will be used to compute
	the value.

	```lua
	local verbState = Blend.State("hi")
	local nameState = Blend.State("alice")

	local computed = Blend.Computed(verbState, nameState, function(verb, name)
		return verb .. " " .. name
	end)

	maid:GiveTask(computed:Subscribe(function(sentence)
		print(sentence)
	end)) --> "hi alice"

	nameState.Value = "bob" --> "hi bob"
	verbState.Value = "bye" --> "bye bob"
	nameState.Value = "alice" --> "bye alice"
	```

	@param ... A series of convertable states, followed by a function at the end.
	@return Observable<T>
]=]
function Blend.Computed(...)
	local values = {...}
	local n = select("#", ...)
	local compute = values[n]

	assert(type(compute) == "function", "Bad compute")

	local args = {}
	for i=1, n - 1 do
		local observable = Blend.toPropertyObservable(values[i])
		if observable then
			args[i] = observable
		else
			args[i] = Rx.of(values[i])
		end
	end

	if #args == 0 then
		-- static value?
		return Observable.new(function(sub)
			sub:Fire(compute())
		end)
	elseif #args == 1 then
		return Rx.map(compute)(args[1])
	else
		return Rx.combineLatest(args)
			:Pipe({
				Rx.map(function(result)
					return compute(unpack(result, 1, n - 1))
				end);
			})
	end
end

--[=[
	Short hand to register a propertyEvent changing

	```lua
	Blend.mount(workspace, {
		[Blend.OnChange "Name"] = function(name)
			print(name)
		end;
	}) --> Immediately will print "Workspace"

	workspace.Name = "Hello" --> Prints "Hello"
	```

	@param propertyName string
	@return (instance: Instance) -> Observable
]=]
function Blend.OnChange(propertyName)
	assert(type(propertyName) == "string", "Bad propertyName")

	return function(instance)
		return RxInstanceUtils.observeProperty(instance, propertyName)
	end
end

--[=[
	Short hand to register an event from the instance

	```lua
		Blend.mount(workspace, {
			[Blend.OnEvent "ChildAdded"] = function(child)
				print("Child added", child)
			end;
		})

		local folder = Instance.new("Folder")
		folder.Name = "Hi"
		folder.Parent = workspace --> prints "Child added Hi"
	```

	@param eventName string
	@return (instance: Instance) -> Observable
]=]
function Blend.OnEvent(eventName)
	assert(type(eventName) == "string", "Bad eventName")

	return function(instance)
		return Rx.fromSignal(instance[eventName])
	end
end

--[=[
	Uses the constructor to attach a class or resource to the actual object
	for the lifetime of the subscription of that object.
	@param constructor T
	@return (parent: Instance) -> Observable<T>
]=]
function Blend.Attached(constructor)
	return function(parent)
		return Observable.new(function(sub)
			local maid = Maid.new()

			local resource = constructor(parent)

			if MaidTaskUtils.isValidTask(resource) then
				maid:GiveTask(resource)
			end

			sub:Fire(resource)

			return maid
		end)
	end;
end

--[=[
	Similiar to Fusion's ComputedPairs, where the changes are cached, and the lifetime limited.
	@param source Observable<T> | any
	@param compute (key: any, value: any, innerMaid: Maid) -> Instance | Observable<Instance>
	@return Observable<Brio<Instance>>
]=]
function Blend.ComputedPairs(source, compute)
	local sourceObservable = Blend.toPropertyObservable(source) or Rx.of(source)

	return Observable.new(function(sub)
		local cache = {}
		local topMaid = Maid.new()

		local maidForKeys = Maid.new()
		topMaid:GiveTask(maidForKeys)

		topMaid:GiveTask(sourceObservable:Subscribe(function(newValue)
			-- It's gotta be a table
			assert(type(newValue) == "table", "Bad value emitted from source")

			local excluded = {}
			for key, _ in pairs(cache) do
				excluded[key] = true
			end

			for key, value in pairs(newValue) do
				excluded[key] = nil

				if cache[key] ~= value then
					local innerMaid = Maid.new()
					local result = compute(key, value, innerMaid)

					local brio = Brio.new(result)
					innerMaid:GiveTask(brio)

					sub:Fire(brio)

					maidForKeys[key] = innerMaid
					cache[key] = value
				end
			end

			for key, _ in pairs(excluded) do
				maidForKeys[key] = nil
				cache[key] = nil
			end
		end), sub:GetFailComplete())

		return topMaid
	end)
end

--[=[
	Like Blend.Spring, but for AccelTween

	@param source any -- Source observable (or convertable)
	@param acceleration any -- Source acceleration (or convertable)
	@return Observable
]=]
function Blend.AccelTween(source, acceleration)
	local sourceObservable = Blend.toPropertyObservable(source) or Rx.of(source)
	local accelerationObservable = Blend.toNumberObservable(acceleration)

	local function createAccelTween(maid, initialValue)
		local accelTween = AccelTween.new(initialValue)

		if accelerationObservable then
			maid:GiveTask(accelerationObservable:Subscribe(function(value)
				assert(type(value) == "number", "Bad value")
				accelTween.a = value
			end))
		end

		return accelTween
	end

	-- TODO: Centralize and cache
	return Observable.new(function(sub)
		local accelTween
		local maid = Maid.new()

		local startAnimate, stopAnimate = StepUtils.bindToRenderStep(function()
			sub:Fire(accelTween.p)
			return accelTween.rtime > 0
		end)

		maid:GiveTask(stopAnimate)
		maid:GiveTask(sourceObservable:Subscribe(function(value)
			accelTween = accelTween or createAccelTween(maid, value)
			accelTween.t = value
			startAnimate()
		end))

		return maid
	end)
end

--[=[
	Converts this arbitrary value into an observable that will initialize a spring
	and interpolate it between values upon subscription.

	```lua
	local percentVisible = Blend.State(0)
	local visibleSpring = Blend.Spring(percentVisible, 30)
	local transparency = Blend.Computed(visibleSpring, function(percent)
		return 1 - percent
	end);

	Blend.mount(frame, {
		BackgroundTransparency = visibleSpring;
	})
	```

	@param source any
	@param speed any
	@param damper any
	@return Observable?
]=]
function Blend.Spring(source, speed, damper)
	local sourceObservable = Blend.toPropertyObservable(source) or Rx.of(source)
	local speedObservable = Blend.toNumberObservable(speed)
	local damperObservable = Blend.toNumberObservable(damper)

	local function createSpring(maid, initialValue)
		local spring = Spring.new(initialValue)

		if speedObservable then
			maid:GiveTask(speedObservable:Subscribe(function(value)
				assert(type(value) == "number", "Bad value")
				spring.Speed = value
			end))
		end

		if damperObservable then
			maid:GiveTask(damperObservable:Subscribe(function(value)
				assert(type(value) == "number", "Bad value")

				spring.Damper = value
			end))
		end

		return spring
	end

	-- TODO: Centralize and cache
	return Observable.new(function(sub)
		local spring
		local maid = Maid.new()

		local startAnimate, stopAnimate = StepUtils.bindToRenderStep(function()
			local animating, position = SpringUtils.animating(spring)
			sub:Fire(SpringUtils.fromLinearIfNeeded(position))
			return animating
		end)

		maid:GiveTask(stopAnimate)
		maid:GiveTask(sourceObservable:Subscribe(function(value)
			if value then
				local linearValue = SpringUtils.toLinearIfNeeded(value)
				spring = spring or createSpring(maid, linearValue)
				spring.t = SpringUtils.toLinearIfNeeded(value)
				startAnimate()
			else
				warn("Got nil value from emitted source")
			end
		end))

		return maid
	end)
end

--[=[
	Converts this arbitrary value into an observable suitable for use in properties.

	@param value any
	@return Observable?
]=]
function Blend.toPropertyObservable(value)
	if Observable.isObservable(value) then
		return value
	elseif typeof(value) == "Instance" then
		-- IntValue, ObjectValue, et cetera
		if ValueBaseUtils.isValueBase(value) then
			return RxValueBaseUtils.observeValue(value)
		end
	elseif type(value) == "table" then
		if ValueObject.isValueObject(value) then
			return ValueObjectUtils.observeValue(value)
		elseif Promise.isPromise(value) then
			return Rx.fromPromise(value)
		end
	end

	return nil
end

--[=[
	Converts this arbitrary value into an observable that emits numbers.

	@param value number | any
	@return Observable<number>?
]=]
function Blend.toNumberObservable(value)
	if type(value) == "number" then
		return Rx.of(value)
	else
		return Blend.toPropertyObservable(value)
	end
end

--[=[
	Converts this arbitrary value into an observable that can be used to emit events.

	@param value any
	@return Observable?
]=]
function Blend.toEventObservable(value)
	if Observable.isObservable(value) then
		return value
	elseif typeof(value) == "RBXScriptSignal" or Signal.isSignal(value) then
		return Rx.fromSignal(value)
	else
		return nil
	end
end

--[=[
	Converts this arbitrary value into an event handler, which can be subscribed to

	@param value any
	@return function?
]=]
function Blend.toEventHandler(value)
	if type(value) == "function" then
		return value
	elseif typeof(value) == "Instance" then
		-- IntValue, ObjectValue, et cetera
		if ValueBaseUtils.isValueBase(value) then
			return function(result)
				value.Value = result
			end
		end
	elseif type(value) == "table" then
		if Signal.isSignal(value) then
			return function(...)
				value:Fire(...)
			end
		elseif value.ClassName == "ValueObject" then
			return function(result)
				value.Value = result
			end
		end
	end

	return nil
end

--[=[
	Mounts children to the parent and returns an object which will cleanup and delete
	all children when removed.

	Note that this effectively recursively mounts children and their values, which is
	the heart of the reactive tree.

	```lua
	Blend.New "ScreenGui" {
		Parent = game.Players.LocalPlayer.PlayerGui;
		[Blend.Children] = {
			Blend.New "Frame" {
				Size = UDim2.new(1, 0, 1, 0);
				BackgroundTransparency = 0.5;
			};
		};
	};
	```

	Rules:

	* `{ Instance }` -Tables of instances are all parented to the parent
	* Brio<Instance> will last for the lifetime of the brio
	* Brio<Observable<Instance>> will last for the lifetime of the brio
		* Brio<Signal<Instance>> will also act as above
		* Brio<Promise<Instance>> will also act as above
		* Brio<{ Instance } will also act as above
	* Observable<Instance> will parent to the parent
		* Signal<Instance> will act as Observable<Instance>
		* ValueObject<Instance> will act as an Observable<Instance>
		* Promise<Instance> will act as an Observable<Instance>
	*  will parent all instances to the parent
	* Observables may emit non-observables (in form of Computed/Dynamic)
		* Observable<Brio<Instance>> will last for the lifetime of the brio, and parent the instance.
		* Observable<Observable<Instance>> occurs when computed returns a value.
	* ValueObject<Instance> will switch to the current value

	Cleanup:
	* Instances will be cleaned up on unsubscribe

	@param parent Instance
	@param value any
	@return MaidTask
]=]
function Blend.Children(parent, value)
	assert(typeof(parent) == "Instance", "Bad parent")

	local observe = Blend._observeChildren(value)
	if observe then
		return observe:Pipe({
			Rx.tap(function(child)
				child.Parent = parent;
			end);
		})
	else
		return Rx.EMPTY
	end
end

--[=[
	An event emitter that emits the instance that was actually created. This is
	useful for a variety of things.

	Using this to track an instance

	```lua
	local currentCamera = Blend.State()

	return Blend.New "ViewportFrame" {
		CurrentCamera = currentCamera;
		[Blend.Children] = {
			self._current;
			Blend.New "Camera" {
				[Blend.Instance] = currentCamera;
			};
		};
	};
	```

	You can also use this to execute code against an instance.

	```lua
	return Blend.New "Frame" {
		[Blend.Instance] = function(frame)
			print("We got a new frame!")
		end;
	};
	```

	Note that if you subscribe twice to the resulting observable, the internal function
	will execute twice.

	@param parent Instance
	@return Observable<Instance>
]=]
function Blend.Instance(parent)
	return Observable.new(function(sub)
		sub:Fire(parent)
	end)
end

--[=[
	Ensures the computed version of a value is limited by lifetime instead
	of multiple. Used in conjunction with [Blend.Children] and [Blend.Computed].

	:::warning
	In general, cosntructing new instances like this is a bad idea, so it's recommended against it.
	:::

	```lua
	Blend.New "ScreenGui" {
		Parent = game.Players.LocalPlayer.PlayerGui;
		[Blend.Children] = {
			Blend.Single(Blend.Computed(percentVisible, function()
				-- you generally would not want to do this anyway because this reconstructs a new frame
				-- every frame.

				Blend.New "Frame" {
					Size = UDim2.new(1, 0, 1, 0);
					BackgroundTransparency = 0.5;
				};
			end)
		};
	};
	```

	@function Single
	@param Observable<Instance | Brio<Instance>>
	@return Observable<Brio<Instance>>
	@within Blend
]=]
function Blend.Single(observable)
	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(observable:Subscribe(function(result)
			if Brio.isBrio(result) then
				local copy = BrioUtils.clone(result)
				maid._current = copy
				sub:Fire(copy)
				return copy
			end

			local current = Brio.new(result)
			maid._current = current
			sub:Fire(current)

			return current
		end))

		return maid
	end)
end

--[=[
	Observes children and ensures that the value is cleaned up
	afterwards.
	@param value any
	@return Observable<Instance>
]=]
function Blend._observeChildren(value)
	if typeof(value) == "Instance" then
		-- Should be uncommon
		return Observable.new(function(sub)
			sub:Fire(value)
			-- don't complete, as this would clean everything up
			return value
		end)
	end

	if ValueObject.isValueObject(value) then
		return Observable.new(function(sub)
			local maid = Maid.new()

			-- Switch instead of emitting every value.
			local function update()
				local result = value.Value
				if typeof(result) == "Instance" then
					maid._current = result
					sub:Fire(result)
					return
				end

				local observe = Blend._observeChildren(result)
				if observe then
					maid._current = nil

					local doCleanup = false
					local cleanup
					cleanup = observe:Subscribe(function(inst)
						sub:Fire(inst)
					end, function(...)
						sub:Fail(...)
					end, function()
						-- incase of immediate execution
						doCleanup = true

						-- Do not pass complete through to the end
						if maid._current == cleanup then
							maid._current = nil
						end
					end)

					-- TODO: Complete when valueobject cleans up

					if doCleanup then
						if cleanup then
							MaidTaskUtils.doCleanup(cleanup)
						end
					else
						maid._current = cleanup
					end

					return
				end

				maid._current = nil
			end
			maid:GiveTask(value.Changed:Connect(update))
			update()

			return maid
		end)
	end

	if Brio.isBrio(value) then
		return Observable.new(function(sub)
			if value:IsDead() then
				return nil
			end

			local result = value:GetValue()
			if typeof(result) == "Instance" then
				local maid = value:ToMaid()
				maid:GiveTask(result)
				sub:Fire(result)

				return maid
			end

			local observe = Blend._observeChildren(result)
			if observe then
				local maid = value:ToMaid()

				-- Subscription is for lifetime of brio, so we do
				-- not need to specifically add these results to the maid, and
				-- risk memory leak of the maid with a lot of items in it.
				maid:GiveTask(observe:Subscribe(function(inst)
					sub:Fire(inst)
				end, function(...)
					sub:Fail(...)
				end, function()
					-- completion should not result more than maid cleaning up
					maid:DoCleaning()
				end))

				return maid
			end

			warn(("Unknown type in brio %q"):format(typeof(result)))
			return nil
		end)
	end

	-- Handle like observable
	if Promise.isPromise(value) then
		value = Rx.fromPromise(value)
	end

	-- Handle like observable
	if Signal.isSignal(value) or typeof(value) == "RBXScriptSignal" then
		value = Rx.fromSignal(value)
	end

	if Observable.isObservable(value) then
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(value:Subscribe(function(result)
				if typeof(result) == "Instance" then
					-- lifetime of subscription
					maid:GiveTask(result)
					sub:Fire(result)
					return
				end

				local observe = Blend._observeChildren(result)

				if observe then
					local innerMaid = Maid.new()

					-- Note: I think this still memory leaks
					innerMaid:GiveTask(observe:Subscribe(function(inst)
						sub:Fire(inst)
					end, function(...)
						innerMaid:DoCleaning()
						sub:Fail(...)
					end, function()
						innerMaid:DoCleaning()
					end))

					innerMaid:GiveTask(function()
						maid[innerMaid] = nil
					end)
					maid[innerMaid] = innerMaid
				else
					warn(("Failed to convert %q into children"):format(tostring(result)))
				end
			end, function(...)
				sub:Fire(...)
			end, function()
				-- Drop completion, other inner components may have completed.
			end))

			return maid
		end)
	end

	if type(value) == "table" and not getmetatable(value) then
		local observables = {}
		for key, item in pairs(value) do
			local observe = Blend._observeChildren(item)
			if observe then
				table.insert(observables, observe)
			else
				warn(("Failed to convert [%s] %q into children"):format(tostring(key), tostring(item)))
			end
		end

		if next(observables) then
			return Rx.merge(observables)
		else
			return nil
		end
	end

	return nil
end

--[=[
	Mounts the instance to the props. This handles mounting children, and events.

	The contract is that the props table is turned into observables. Note the following.

	* Keys of strings are turned into properties
		* If this can be turned into an observable, it will be used to subscribe to this event
		* Otherwise, we assign directly
	* Keys of functions are invoked on the instance in question
		* `(instance, value) -> Observable
		* If this returns an observable (or can be turned into one), we subscribe the event immediately
	* If the key is [Blend.Children] then we invoke mountChildren on it

	@param instance Instance
	@param props table
	@return Maid
]=]
function Blend.mount(instance, props)
	local maid = Maid.new()

	local parent = nil
	local dependentObservables = {}

	for key, value in pairs(props) do
		if type(key) == "string" then
			if key == "Parent" then
				parent = value
			else
				local observable = Blend.toPropertyObservable(value)
				if observable then
					maid:GiveTask(observable:Subscribe(function(result)
						task.spawn(function()
							instance[key] = result
						end)
					end))
				else
					task.spawn(function()
						instance[key] = value
					end)
				end
			end
		elseif type(key) == "function" then
			local observable = Blend.toEventObservable(key(instance, value))

			if Observable.isObservable(observable) then
				table.insert(dependentObservables, {observable, value})
			else
				warn(("Unable to apply event listener %q"):format(tostring(key)))
			end
		else
			warn(("Unable to apply property %q"):format(tostring(key)))
		end
	end

	-- Subscribe dependentObservables (which includes adding children)
	for _, event in pairs(dependentObservables) do
		maid:GiveTask(event[1]:Subscribe(Blend.toEventHandler(event[2])))
	end

	if parent then
		local observable = Blend.toPropertyObservable(parent)
		if observable then
			maid:GiveTask(observable:Subscribe(function(result)
				instance.Parent = result
			end))
		else
			instance.Parent = parent
		end
	end

	return maid
end


return Blend  -  Editar
  04:54:13.797    -  Editar
  04:54:13.797  ----- [2444] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Blend.BlendDefaultProps -----  -  Editar
  04:54:13.798  --[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

--[[

MIT License

Copyright (c) 2021 Elttob

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

]]

return {
	ScreenGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = "Sibling"
	},

	BillboardGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = "Sibling"
	},

	SurfaceGui = {
		ResetOnSpawn = false,
		ZIndexBehavior = "Sibling",

		SizingMode = "PixelsPerStud",
		PixelsPerStud = 50
	},

	Frame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ScrollingFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ScrollBarImageColor3 = Color3.new(0, 0, 0)
	},

	TextLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		Font = "SourceSans",
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false,

		Font = "SourceSans",
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	TextBox = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		ClearTextOnFocus = false,

		Font = "SourceSans",
		Text = "",
		TextColor3 = Color3.new(0, 0, 0),
		TextSize = 14
	},

	ImageLabel = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	ImageButton = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0,

		AutoButtonColor = false
	},

	ViewportFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	VideoFrame = {
		BackgroundColor3 = Color3.new(1, 1, 1),
		BorderColor3 = Color3.new(0, 0, 0),
		BorderSizePixel = 0
	},

	UIListLayout = {
		SortOrder = Enum.SortOrder.LayoutOrder;
	},
}  -  Editar
  04:54:13.798    -  Editar
  04:54:13.798  ----- [2445] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Blend.SpringObject -----  -  Editar
  04:54:13.798  --[=[
	@class SpringObject
]=]

local require = require(script.Parent.loader).load(script)

local RunService= game:GetService("RunService")

local Spring = require("Spring")
local Maid = require("Maid")
local Signal = require("Signal")
local StepUtils = require("StepUtils")
local Observable = require("Observable")
local SpringUtils = require("SpringUtils")
local Blend = require("Blend")
local Rx = require("Rx")

local SpringObject = {}
SpringObject.ClassName = "SpringObject"
SpringObject.__index = SpringObject

--[=[
	Constructs a new SpringObject.
	@param target T
	@param speed number | Observable<number> | ValueObject<number> | NumberValue | any
	@param damper number | Observable<number> | NumberValue | any
	@return Spring<T>
]=]
function SpringObject.new(target, speed, damper)
	local self = setmetatable({
		_maid = Maid.new();
		Changed = Signal.new();
	}, SpringObject)

--[=[
	Event fires when the spring value changes
	@prop Changed Signal<()> -- Fires whenever the spring initially changes state
	@within ValueObject
]=]
	self._maid:GiveTask(self.Changed)

	if target then
		self.Target = target
	else
		self:_getSpringForType(0)
	end

	if speed then
		self.Speed = speed
	end

	if damper then
		self.Damper = damper
	end

	return self
end

--[=[
	Returns whether an object is a SpringObject.
	@param value any
	@return boolean
]=]
function SpringObject.isSpringObject(value)
	return type(value) == "table" and getmetatable(value) == SpringObject
end

--[=[
	Observes the spring animating
	@return Observable<T>
]=]
function SpringObject:ObserveRenderStepped()
	return self:ObserveOnSignal(RunService.RenderStepped)
end

function SpringObject:ObserveVelocityOnRenderStepped()
	return self:ObserveVelocityOnSignal(RunService.RenderStepped)
end

function SpringObject:ObserveVelocityOnSignal(signal)
	return Observable.new(function(sub)
		local maid = Maid.new()

		local startAnimate, stopAnimate = StepUtils.bindToSignal(signal, function()
			local animating = SpringUtils.animating(self._currentSpring)
			if animating then
				sub:Fire(SpringUtils.fromLinearIfNeeded(self._currentSpring.Velocity))
			else
				sub:Fire(SpringUtils.fromLinearIfNeeded(0*self._currentSpring.Velocity))
			end
			return animating
		end)

		maid:GiveTask(stopAnimate)
		maid:GiveTask(self.Changed:Connect(startAnimate))
		startAnimate()

		return maid
	end)
end

--[=[
	Observes the spring animating
	@param signal RBXScriptSignal
	@return Observable<T>
]=]
function SpringObject:ObserveOnSignal(signal)
	return Observable.new(function(sub)
		local maid = Maid.new()

		local startAnimate, stopAnimate = StepUtils.bindToSignal(signal, function()
			local animating, position = SpringUtils.animating(self._currentSpring)
			sub:Fire(SpringUtils.fromLinearIfNeeded(position))
			return animating
		end)

		maid:GiveTask(stopAnimate)
		maid:GiveTask(self.Changed:Connect(startAnimate))
		startAnimate()

		return maid
	end)
end

--[=[
	Returns true when we're animating
	@return boolean -- True if animating
]=]
function SpringObject:IsAnimating()
	return (SpringUtils.animating(self._currentSpring))
end

--[=[
	Impulses the spring, increasing velocity by the amount given. This is useful to make something shake,
	like a Mac password box failing.

	@param velocity T -- The velocity to impulse with
	@return ()
]=]
function SpringObject:Impulse(velocity)
	self._currentSpring:Impulse(SpringUtils.toLinearIfNeeded(velocity))
	self.Changed:Fire()
end

--[=[
	Instantly skips the spring forwards by that amount time
	@param delta number -- Time to skip forwards
	@return ()
]=]
function SpringObject:TimeSkip(delta)
	assert(type(delta) == "number", "Bad delta")

	self._currentSpring:TimeSkip(delta)
	self.Changed:Fire()
end

function SpringObject:__index(index)
	if index == "Value" or index == "Position" or index == "p" then
		return SpringUtils.fromLinearIfNeeded(self._currentSpring.Value)
	elseif index == "Velocity" or index == "v" then
		return SpringUtils.fromLinearIfNeeded(self._currentSpring.Velocity)
	elseif index == "Target" or index == "t" then
		return SpringUtils.fromLinearIfNeeded(self._currentSpring.Target)
	elseif index == "Damper" or index == "d" then
		return self._currentSpring.Damper
	elseif index == "Speed" or index == "s" then
		return self._currentSpring.Speed
	elseif index == "Clock" then
		return self._currentSpring.Clock
	elseif SpringObject[index] then
		return SpringObject[index]
	else
		error(("%q is not a member of SpringObject"):format(tostring(index)))
	end
end

function SpringObject:__newindex(index, value)
	if index == "Value" or index == "Position" or index == "p" then
		local observable = Blend.toPropertyObservable(value) or Rx.of(value)

		self._maid._valueSub = observable:Subscribe(function(unconverted)
			local converted = SpringUtils.toLinearIfNeeded(unconverted)
			self:_getSpringForType(converted).Value = converted
			self.Changed:Fire()
		end)
	elseif index == "Velocity" or index == "v" then
		local observable = Blend.toPropertyObservable(value) or Rx.of(value)

		self._maid._velocitySub = observable:Subscribe(function(unconverted)
			local converted = SpringUtils.toLinearIfNeeded(unconverted)

			self:_getSpringForType(0*converted).Velocity = converted
			self.Changed:Fire()
		end)
	elseif index == "Target" or index == "t" then
		local observable = Blend.toPropertyObservable(value) or Rx.of(value)

		self._maid._targetSub = observable:Subscribe(function(unconverted)
			local converted = SpringUtils.toLinearIfNeeded(unconverted)
			self:_getSpringForType(converted).Target = converted

			self.Changed:Fire()
		end)
	elseif index == "Damper" or index == "d" then
		local observable = assert(Blend.toNumberObservable(value), "Invalid damper")

		self._maid._damperSub = observable:Subscribe(function(unconverted)
			assert(type(unconverted) == "number", "Bad damper")

			self._currentSpring.Damper = unconverted
			self.Changed:Fire()
		end)
	elseif index == "Speed" or index == "s" then
		local observable = assert(Blend.toNumberObservable(value), "Invalid speed")

		self._maid._speedSub = observable:Subscribe(function(unconverted)
			assert(type(unconverted) == "number", "Bad damper")

			self._currentSpring.Speed = unconverted
			self.Changed:Fire()
		end)
	elseif index == "Clock" then
		assert(type(value) == "function", "Bad clock value")
		self._currentSpring.Clock = value
		self.Changed:Fire()
	else
		error(("%q is not a member of SpringObject"):format(tostring(index)))
	end
end

function SpringObject:_getSpringForType(converted)
	if rawget(self, "_currentSpring") == nil then
		-- only happens on init
		rawset(self, "_currentSpring", Spring.new(converted))
		return self._currentSpring
	else
		local currentType = typeof(SpringUtils.fromLinearIfNeeded(self._currentSpring.Value))
		if currentType == typeof(converted) then
			return self._currentSpring
		else
			local oldDamper = self._currentSpring.d
			local oldSpeed = self._currentSpring.s

			self._currentSpring = Spring.new(converted)
			self._currentSpring.Speed = oldSpeed
			self._currentSpring.Damper = oldDamper
			return self._currentSpring
		end
	end
end

--[=[
	Cleans up the BaseObject and sets the metatable to nil
]=]
function SpringObject:Destroy()
	self._maid:DoCleaning()
	setmetatable(self, nil)
end

return SpringObject  -  Editar
  04:54:13.798    -  Editar
  04:54:13.798  ----- [2446] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Test.BlendChildren.story -----  -  Editar
  04:54:13.798  --[[
	@class Blend.story
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local Maid = require("Maid")
local ValueObject = require("ValueObject")
local Rx = require("Rx")

return function(target)
	local maid = Maid.new()

	local percentVisible = Blend.State(0)
	local state = Blend.State("a")
	maid:GiveTask(state)

	local uiCornerValueObject = ValueObject.new()
	uiCornerValueObject.Value = Blend.New "UICorner" {
		CornerRadius = UDim.new(0, 5);
	};
	maid:GiveTask(uiCornerValueObject)

	-- Reassign to a new value
	task.delay(1, function()
		if uiCornerValueObject.Destroy then
			uiCornerValueObject.Value = Blend.New "UICorner" {
				CornerRadius = UDim.new(0, 25);
			};
		end
	end)

	maid:GiveTask((Blend.New "TextLabel" {
		Parent = target;
		Size = Blend.Computed(percentVisible, function(visible)
			return UDim2.new(0, visible*100, 0, 50);
		end);
		BackgroundTransparency = Blend.Computed(percentVisible, function(visible)
			return 1 - visible
		end);
		Position = UDim2.new(0.5, 0, 0.5, 0);
		AnchorPoint = Vector2.new(0.5, 0.5);
		Text = state;
		TextScaled = true;

		[Blend.Children] = {
			uiCornerValueObject;

			Rx.NEVER;
			Rx.EMPTY;

			{
				Blend.Single(Blend.Computed(percentVisible, function(visible)
					if visible <= 0.5 then
						return nil
					else
						return Blend.New "Frame" {
							Size = UDim2.new(0, 100, 0, 100);
							BackgroundTransparency = 0.5;
						}
					end
				end));

			};

			{
				Blend.Single(Blend.Computed(percentVisible, function(visible)
					local results = {}

					-- constructs a ton of children everytime this changes
					for x=0, visible*100, 10 do
						table.insert(results, Blend.New "Frame" {
							Size = UDim2.new(0, 8, 0, 8);
							Position = UDim2.new(0, x, 0.9, 0);
							AnchorPoint = Vector2.new(0.5, 0.5);
							BorderSizePixel = 0;
							BackgroundColor3 = Color3.new(x/100, 0.5, 0.5);

							[Blend.Children] = {
								Blend.New "UICorner" {
									CornerRadius = UDim.new(0.5, 5);
								};
							};
						})
					end

					return results
				end));
			};
		};
	}):Subscribe())

	local PERIOD = 5
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		state.Value = tostring(os.clock())
		percentVisible.Value = (math.sin(os.clock()*math.pi*2/PERIOD) + 1)/2
	end))

	return function()
		maid:DoCleaning()
	end
end  -  Editar
  04:54:13.799    -  Editar
  04:54:13.799  ----- [2447] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Test.BlendComputePairs.story -----  -  Editar
  04:54:13.799  --[[
	@class Blend.story
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local Blend = require("Blend")
local Maid = require("Maid")

return function(target)
	local maid = Maid.new()

	local state = Blend.State({"a", "b", "c"})
	maid:GiveTask(state)

	maid:GiveTask((Blend.New "TextLabel" {
		Parent = target;

		[Blend.Children] = {
			Blend.New "TextButton" {
				Text = "Add";
				AutoButtonColor = true;
				Size = UDim2.new(0, 100, 0, 20);
				[Blend.OnEvent "Activated"] = function()
					local newState = {}
					for _, item in pairs(state.Value) do
						table.insert(newState, item)
					end
					table.insert(newState, string.char(string.byte("a") + #newState))
					state.Value = newState
				end;
			};
			Blend.ComputedPairs(state, function(_index, value)
				print("Compute", value)
				return Blend.New "TextLabel" {
					Text = tostring(value);
					Size = UDim2.new(0, 20, 0, 20);
				}
			end);

			Blend.New "UIListLayout" {
				Padding = UDim.new(0, 5);
			};
		};
	}):Subscribe())

	return function()
		maid:DoCleaning()
	end
end  -  Editar
  04:54:13.799    -  Editar
  04:54:13.799  ----- [2448] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Test.BlendPromise.story -----  -  Editar
  04:54:13.799  --[[
	@class BlendTextbox.story
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local Maid = require("Maid")
local PlayerThumbnailUtils = require("PlayerThumbnailUtils")

return function(target)
	local maid = Maid.new()

	local userIdState = Instance.new("IntValue")
	userIdState.Value = 4397833
	maid:GiveTask(userIdState)

	local isVisible = Instance.new("BoolValue")
	isVisible.Value = false
	maid:GiveTask(isVisible)

	local userImage = Blend.Dynamic(userIdState, function(userId)
		return PlayerThumbnailUtils.promiseUserThumbnail(userId)
	end)
	local userName = Blend.Dynamic(userIdState, function(userId)
		return PlayerThumbnailUtils.promiseUserName(userId)
	end)
	local percentVisible = Blend.Spring(Blend.Computed(isVisible, function(visible)
		return visible and 1 or 0
	end), 35)
	local transparency = Blend.Computed(percentVisible, function(percent)
		return 1 - percent
	end)

	maid:GiveTask((Blend.New "Frame" {
		Parent = target;
		Name = "ProfileImage";
		LayoutOrder = 15;
		BackgroundTransparency = 1;
		Size = UDim2.new(0, 100, 0, 130);
		Position = UDim2.fromScale(0.5, 0.5);
		AnchorPoint = Vector2.new(0.5, 0.5);
		[Blend.Children] = {
			Blend.New "UIScale" {
				Scale = Blend.Computed(percentVisible, function(percent)
					return 0.8 + 0.2*percent
				end);
			};

			Blend.New "TextLabel" {
				Size = UDim2.new(1, 0, 0, 30);
				Position = UDim2.new(0.5, 0, 1, 0);
				AnchorPoint = Vector2.new(0.5, 1);
				BackgroundTransparency = 1;
				TextTransparency = transparency;
				TextColor3 = Color3.new(1, 1, 1);
				TextSize = 20;
				Font = Enum.Font.Gotham;
				Text = userName;
			};

			Blend.New "Frame" {
				Position = UDim2.new(0.5, 0, 0, 0);
				AnchorPoint = Vector2.new(0.5, 0);
				Size = UDim2.new(1, 0, 1, 0);
				BackgroundColor3 = Color3.new(0.2, 0.25, 0.2);
				BackgroundTransparency = transparency;
				[Blend.Children] = {
					Blend.New "UIAspectRatioConstraint" {
						AspectRatio = 1;
					};
					Blend.New "UICorner" {
						CornerRadius = UDim.new(1, 0);
					};
					Blend.New "UIPadding" {
						PaddingLeft = UDim.new(0, 2);
						PaddingRight = UDim.new(0, 2);
						PaddingTop = UDim.new(0, 2);
						PaddingBottom = UDim.new(0, 2);
					};

					Blend.New "ImageLabel" {
						Size = UDim2.new(1, 0, 1, 0);
						Image = userImage;
						BackgroundTransparency = transparency;
						ImageTransparency = transparency;
						BackgroundColor3 = Color3.new(0.1, 0.1, 0.1);

						[Blend.Children] = {
							Blend.New "UICorner" {
								CornerRadius = UDim.new(1, 0);
							};
						};
					};
				};
			};
		};
	}):Subscribe())

	local PERIOD = 2
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		isVisible.Value = os.clock()/PERIOD % 1 < 0.5
	end))

	local alive = true
	maid:GiveTask(function()
		alive = false
	end)
	maid:GiveTask(isVisible.Changed:Connect(function()
		if not isVisible.Value then
			task.delay(PERIOD/2, function()
				if alive then
					userIdState.Value = Random.new():NextInteger(1, 1e9)
				end
			end)
		end
	end))

	return function()
		maid:DoCleaning()
	end
end  -  Editar
  04:54:13.799    -  Editar
  04:54:13.799  ----- [2449] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Test.BlendSingle.story -----  -  Editar
  04:54:13.799  --[[
	@class BlendSingle.story
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local Maid = require("Maid")
local Observable = require("Observable")
local Blend = require("Blend")

return function(target)
	local maid = Maid.new()

	local state = Blend.State("a")

	local result = Blend.Single(Blend.Dynamic(state, function(text)
		return Blend.New "TextLabel" {
			Parent = target;
			Text = text;
			Size = UDim2.new(1, 0, 1, 0);
			BackgroundTransparency = 0.5;
			[function()
				return Observable.new(function()
					local internal = Maid.new()

					print("Made for", text)
					internal:GiveTask(function()
						print("Cleaning up", text)
					end)

					return internal
				end)
			end] = true;
		}
	end))


	maid:GiveTask(result:Subscribe())

	state.Value = "b"

	return function()
		maid:DoCleaning()
	end
end  -  Editar
  04:54:13.799    -  Editar
  04:54:13.799  ----- [2450] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Test.BlendSpring.story -----  -  Editar
  04:54:13.799  --[[
	@class Blend.story
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local RunService = game:GetService("RunService")

local Blend = require("Blend")
local Maid = require("Maid")

return function(target)
	local maid = Maid.new()

	local isVisible = Instance.new("BoolValue")
	isVisible.Value = false

	local percentVisible = Blend.Spring(Blend.Computed(isVisible, function(visible)
		return visible and 1 or 0
	end), 35)

	local transparency = Blend.Computed(percentVisible, function(percent)
		return 1 - percent
	end)

	maid:GiveTask((Blend.New "Frame" {
		Size = UDim2.new(0.5, 0, 0.5, 0);
		BackgroundColor3 = Color3.new(0.9, 0.9, 0.9);
		AnchorPoint = Vector2.new(0.5, 0.5);
		Position = UDim2.new(0.5, 0, 0.5, 0);
		BackgroundTransparency = transparency;
		Parent = target;

		[Blend.Children] = {
			Blend.New "UIScale" {
				Scale = Blend.Computed(percentVisible, function(percent)
					return 0.8 + 0.2*percent
				end);
			};
			Blend.New "UICorner" {
				CornerRadius = UDim.new(0.05, 0);
			};
		};
	}):Subscribe())

	local PERIOD = 5
	maid:GiveTask(RunService.RenderStepped:Connect(function()
		isVisible.Value = os.clock()/PERIOD % 1 < 0.5
	end))

	return function()
		maid:DoCleaning()
	end
end  -  Editar
  04:54:13.799    -  Editar
  04:54:13.799  ----- [2451] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.Shared.Test.BlendTextbox.story -----  -  Editar
  04:54:13.799  --[[
	@class BlendTextbox.story
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local Blend = require("Blend")
local Maid = require("Maid")

return function(target)
	local maid = Maid.new()

	local state = Blend.State("hi")

	maid:GiveTask((Blend.New "Frame" {
		Size = UDim2.new(1, 0, 1, 0);
		BackgroundTransparency = 1;
		Parent = target;

		[Blend.Children] = {
			Blend.New "TextBox" {
				Size = UDim2.new(0, 200, 0, 50);
				Text = state;
				[Blend.OnChange "Text"] = state;
				[Blend.OnEvent "Focused"] = function()
					print("Focused")
				end;

				[function(inst) return inst.Focused end] = function()
					print("Focused (via func)")
				end;

				-- this also works
				[function(inst) return inst:GetPropertyChangedSignal("Text") end] = function()
					print("Property changed from :GetPropertyChangedSignal()")
				end;
			};

			Blend.New "TextBox" {
				Size = UDim2.new(0, 200, 0, 50);
				[Blend.OnChange "Text"] = state; -- read state
				Text = state; -- write state
			};

			Blend.New "UIListLayout" {
				Padding = UDim.new(0, 10);
			};
		};
	}):Subscribe())

	return function()
		maid:DoCleaning()
	end
end  -  Editar
  04:54:13.799    -  Editar
  04:54:13.800  ----- [2452] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.acceltween.Shared.AccelTween -----  -  Editar
  04:54:13.800  --[=[
	Provides a means to, with both a continuous position and velocity,
	accelerate from its current position to a target position in minimum time
	given a maximum acceleration. See [Spring] for another version of this.

	Author: TreyReynolds/AxisAngles
	@class AccelTween
]=]

local AccelTween = {}

--[=[
	Constructs a new AccelTween.

	```lua
	local accelTween = AccelTween.new(30)
	accelTween.t = 1

	conn = RunService.RenderStepped:Connect(function()
		print(accelTween.p)
	end)
	task.delay(accelTween.rtime, function()
		conn:Disconnect()
	end)
	```

	@param maxaccel number? -- The maximum acceleration applied to reach its target. Defaults to 1
	@return AccelTween
]=]
function AccelTween.new(maxaccel)
	local self = setmetatable({
		_accel = maxaccel or 1;
		_t0 = 0;
		_y0 = 0;
		_a0 = 0;
		_t1 = 0;
		_y1 = 0;
		_a1 = 0;
	}, AccelTween)

	return self
end

--[=[
	Gets and sets the current position of the AccelTween
	@prop p number
	@within AccelTween
]=]

--[=[
	Gets and sets the current velocity of the AccelTween
	@prop v number
	@within AccelTween
]=]

--[=[
	Gets and sets the maximum acceleration.
	@prop a number
	@within AccelTween
]=]

--[=[
	Gets and sets the target position.
	@prop t number
	@within AccelTween
]=]

--[=[
	Returns the remaining time before the AccelTween attains the target.
	@readonly
	@prop rtime number
	@within AccelTween
]=]

--[=[
	Sets the current and target position, and sets the velocity to 0.
	@prop pt number
	@within AccelTween
]=]

function AccelTween:__index(index)
	if AccelTween[index] then
		return AccelTween[index]
	elseif index == "p" then
		local pos, _ = self:_getstate(tick())
		return pos
	elseif index == "v" then
		local _, vel = self:_getstate(tick())
		return vel
	elseif index == "a" then
		return self._accel
	elseif index == "t" then
		return self._y1
	elseif index == "rtime" then
		local time = tick()
		return time < self._t1 and self._t1 - time or 0
	else
		error(("Bad index %q"):format(tostring(index)))
	end
end

function AccelTween:__newindex(index, value)
	if index == "p" then
		self:_setstate(value, nil, nil, nil)
	elseif index == "v" then
		self:_setstate(nil, value, nil, nil)
	elseif index == "a" then
		self:_setstate(nil, nil, value, nil)
	elseif index == "t" then
		self:_setstate(nil, nil, nil, value)
	elseif index == "pt" then
		self:_setstate(value, 0, nil, value)
	else
		error(("Bad index %q"):format(tostring(index)))
	end
end

function AccelTween:_getstate(time)
	if time < (self._t0 + self._t1)/2 then
		local t = time - self._t0
		return self._y0 + t*t/2*self._a0, t*self._a0
	elseif time < self._t1 then
		local t = time - self._t1
		return self._y1 + t*t/2*self._a1, t*self._a1
	else
		return self._y1, 0
	end
end

function AccelTween:_setstate(newpos, newvel, newaccel, newtarg)
	local time = tick()
	local pos, vel = self:_getstate(time)
	pos = newpos or pos
	vel = newvel or vel
	self._accel = newaccel or self._accel
	local targ = newtarg or self._y1

	if self._accel*self._accel < 1e-8 then
		self._t0, self._y0, self._a0 = 0, pos, 0
		self._t1, self._y1, self._a1 = math.huge, targ, 0
	else
		local conda = targ < pos
		local condb = vel < 0
		local condc = pos - vel*vel/(2*self._accel) < targ
		local condd = pos + vel*vel/(2*self._accel) < targ
		if conda and condb and condc or not conda and (condb or not condb and condd) then
			self._a0 = self._accel
			self._t1 = time + ((2*vel*vel + 4*self._accel*(targ - pos))^0.5 - vel)/self._accel
		else
			self._a0 = -self._accel
			self._t1 = time + ((2*vel*vel - 4*self._accel*(targ - pos))^0.5 + vel)/self._accel
		end
		self._t0 = time - vel/self._a0
		self._y0 = pos - vel*vel/(2*self._a0)
		self._y1 = targ
		self._a1 = -self._a0
	end
end

return AccelTween  -  Editar
  04:54:13.800    -  Editar
  04:54:13.800  ----- [2453] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.brio.Shared.Brio -----  -  Editar
  04:54:13.800  --[=[
	Brios wrap a value (or tuple of values) and are used to convey the lifetime of that
	object. The brio is better than a maid, by providing the following constraints:

	- Can be in 2 states, dead or alive.
	- While alive, can retrieve values.
	- While dead, retrieving values is forbidden.
	- Died will fire once upon death.

	Brios encapsulate the "lifetime" of a valid resource. Unlike a maid, they
	- Can only die once, ensuring duplicate calls never occur.
	- Have less memory leaks. Memory leaks in maids can occur when use of the maid occurs
	  after the cleanup of the maid has occured, in certain race conditions.
	- Cannot be reentered, i.e. cannot retrieve values after death.

	:::info
	Calling `brio:Destroy()` or `brio:Kill()` after death does nothing. Brios cannot
	be resurrected.
	:::

	Brios are useful for downstream events where you want to emit a resource. Typically
	brios should be killed when their source is killed. Brios are intended to be merged
	with downstream brios so create a chain of reliable resources.

	```lua
	local brio = Brio.new("a", "b")
	print(brio:GetValue()) --> a b
	print(brio:IsDead()) --> false

	brio:GetDiedSignal():Connect(function()
		print("Hello from signal!")
	end)
	brio:ToMaid():GiveTask(function()
		print("Hello from maid cleanup!")
	end)
	brio:Kill()
	--> Hello from signal!
	--> Hello from maid cleanup!

	print(brio:IsDead()) --> true
	print(brio:GetValue()) --> ERROR: Brio is dead
	```

	## Design philosophy

	Brios are designed to solve this issue where we emit an object with a lifetime associated with it from an
	Observable stream. This resource is only valid for some amount of time (for example, while the object is
	in the Roblox data model).

	In order to know how long we can keep this object/use it, we wrap the object with a Brio, which denotes
	 the lifetime of the object.

	Modeling this with pure observables is very tricky because the subscriber will have to also monitor/emit
	a similar object with less clear conventions. For example  an observable that emits the object, and then nil on death.

	@class Brio
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")

local Brio = {}
Brio.ClassName = "Brio"
Brio.__index = Brio

--[=[
	Returns whether a value is a Brio.

	```lua
	print(Brio.isBrio("yolo")) --> false
	```
	@param value any
	@return boolean
]=]
function Brio.isBrio(value)
	return type(value) == "table" and value.ClassName == "Brio"
end

--[=[
	Constructs a new Brio.

	```lua
	local brio = Brio.new("a", "b")
	print(brio:GetValue()) --> a b
	```

	@param ... any -- Brio values
	@return Brio
]=]
function Brio.new(...) -- Wrap
	return setmetatable({
		_values = table.pack(...);
	}, Brio)
end

--[=[
	Constructs a new brio that will cleanup afer the set amount of time

	@since 3.6.0
	@param time number
	@param ... any -- Brio values
	@return Brio
]=]
function Brio.delayed(time, ...)
	local brio = Brio.new(...)
	task.delay(time, function()
		brio:Kill()
	end)
	return brio
end

--[=[
	Gets a signal that will fire when the Brio dies. If the brio is already dead
	calling this method will error.

	:::info
	Calling this while the brio is already dead will throw a error.
	:::

	```lua
	local brio = Brio.new("a", "b")
	brio:GetDiedSignal():Connect(function()
		print("Brio died")
	end)

	brio:Kill() --> Brio died
	brio:Kill() -- no output
	```

	@return Signal
]=]
function Brio:GetDiedSignal()
	if self:IsDead() then
		error("Brio is dead")
	end

	if self._diedEvent then
		return self._diedEvent.Event
	end

	self._diedEvent = Instance.new("BindableEvent")
	return self._diedEvent.Event
end

--[=[
	Returns true is the brio is dead.

	```lua
	local brio = Brio.new("a", "b")
	print(brio:IsDead()) --> false

	brio:Kill()

	print(brio:IsDead()) --> true
	```

	@return boolean
]=]
function Brio:IsDead()
	return self._values == nil
end

--[=[
	Throws an error if the Brio is dead.

	```lua
	brio.DEAD:ErrorIfDead() --> ERROR: [Brio.ErrorIfDead] - Brio is dead
	```
]=]
function Brio:ErrorIfDead()
	if not self._values then
		error("[Brio.ErrorIfDead] - Brio is dead")
	end
end

--[=[
	Constructs a new Maid which will clean up when the brio dies.
	Will error if the Brio is dead.

	:::info
	Calling this while the brio is already dead will throw a error.
	:::

	```lua
	local brio = Brio.new("a")
	local maid = brio:ToMaid()
	maid:GiveTask(function()
		print("Cleaning up!")
	end)
	brio:Kill() --> Cleaning up!
	```

	@return Maid
]=]
function Brio:ToMaid()
	assert(self._values ~= nil, "Brio is dead")

	local maid = Maid.new()

	maid:GiveTask(self:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return maid
end

--[=[
	If the brio is not dead, will return the values unpacked from the brio.

	:::info
	Calling this while the brio is already dead will throw a error. Values should
	not be used past the lifetime of the brio, and can be considered invalid.
	:::

	```lua
	local brio = Brio.new("a", 1, 2)
	print(brio:GetValue()) --> "a" 1 2
	brio:Kill()

	print(brio:GetValue()) --> ERROR: Brio is dead
	```

	@return any
]=]
function Brio:GetValue()
	assert(self._values, "Brio is dead")

	return unpack(self._values, 1, self._values.n)
end

--[=[
	Returns the packed values from table.pack() format

	@since 3.6.0
	@return { n: number, ... T }
]=]
function Brio:GetPackedValues()
	assert(self._values, "Brio is dead")

	return self._values
end

--[=[
	Kills the Brio.

	:::info
	You can call this multiple times and it will not error if the brio is dead.
	:::

	```lua
	local brio = Brio.new("hi")
	print(brio:GetValue()) --> "hi"
	brio:Kill()

	print(brio:GetValue()) --> ERROR: Brio is dead
	```
]=]
function Brio:Destroy()
	if not self._values then
		return
	end

	self._values = nil

	if self._diedEvent then
		self._diedEvent:Fire()
		self._diedEvent:Destroy()
		self._diedEvent = nil
	end
end

--[=[
	Alias for Destroy.
	@method Kill
	@within Brio
]=]
Brio.Kill = Brio.Destroy

--[=[
	An already dead brio which may be used for identity purposes.

	```lua
	print(Brio.DEAD:IsDead()) --> true
	```

	@prop DEAD Brio
	@within Brio
]=]
Brio.DEAD = Brio.new()
Brio.DEAD:Kill()

return Brio  -  Editar
  04:54:13.800    -  Editar
  04:54:13.800  ----- [2454] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.brio.Shared.BrioUtils -----  -  Editar
  04:54:13.801  --[=[
	Utility functions affecting Brios.
	@class BrioUtils
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Brio = require("Brio")

local BrioUtils = {}

--[=[
	Clones a brio, such that it may be killed without affecting the original
	brio.

	@param brio Brio<T>
	@return Brio<T>
]=]
function BrioUtils.clone(brio)
	assert(brio, "Bad brio")

	if brio:IsDead() then
		return Brio.DEAD
	end

	local newBrio = Brio.new(brio:GetValue())

	newBrio:ToMaid():GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	return newBrio
end

--[=[
	Returns a list of alive Brios only

	@param brios {Brio<T>}
	@return {Brio<T>}
]=]
function BrioUtils.aliveOnly(brios)
	local alive = {}
	for _, brio in pairs(brios) do
		if not brio:IsDead() then
			table.insert(alive, brio)
		end
	end
	return alive
end

--[=[
	Returns the first alive Brio in a list

	@param brios {Brio<T>}
	@return Brio<T>
]=]
function BrioUtils.firstAlive(brios)
	for _, brio in pairs(brios) do
		if not brio:IsDead() then
			return brio
		end
	end
	return nil
end

--[=[
	Given a list of brios of brios, flattens that list into a brio with
	just one T value.

	@param brioTable { any: Brio<Brio<T> | T>}
	@return Brio<{T}>
]=]
function BrioUtils.flatten(brioTable)
	local newValue = {}
	local brios = {}

	for key, brio in pairs(brioTable) do
		if Brio.isBrio(brio) then
			if brio:IsDead() then
				return Brio.DEAD
			else
				table.insert(brios, brio)
				newValue[key] = brio:GetValue()
			end
		else
			newValue[key] = brio
		end
	end

	return BrioUtils.first(brios, newValue)
end

--[=[
	Returns a brio that dies whenever the first Brio in the list
	dies. The value of the Brio is the `...` value.

	@param brios {Brio<T>}
	@param ... U
	@return Brio<U>
]=]
function BrioUtils.first(brios, ...)
	for _, brio in pairs(brios) do
		if Brio.isBrio(brio) then
			if brio:IsDead() then
				return Brio.DEAD
			end
		end
	end

	local maid = Maid.new()
	local topBrio = Brio.new(...)

	for _, brio in pairs(brios) do
		if Brio.isBrio(brio) then
			maid:GiveTask(brio:GetDiedSignal():Connect(function()
				topBrio:Kill()
			end))
		end
	end

	maid:GiveTask(topBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return topBrio
end

--[=[
	Clones a brio, such that it may be killed without affecting the original
	brio.

	@since 3.6.0
	@param brio Brio<T>
	@param ... U
	@return Brio<U>
]=]
function BrioUtils.withOtherValues(brio, ...)
	assert(brio, "Bad brio")

	if brio:IsDead() then
		return Brio.DEAD
	end

	local newBrio = Brio.new(...)

	newBrio:ToMaid():GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	return newBrio
end

--[=[
	Makes a brio that is limited by the lifetime of its parent (but could be shorter)
	and has the new values given.

	@param brio Brio<U>
	@param ... T
	@return Brio<T>
]=]
function BrioUtils.extend(brio, ...)
	if brio:IsDead() then
		return Brio.DEAD
	end

	local values = brio._values
	local current = {}
	for i=1, values.n do
		current[i] = values[i]
	end
	local otherValues = table.pack(...)
	for i=1, otherValues.n do
		current[values.n+i] = otherValues[i]
	end

	local maid = Maid.new()
	local newBrio = Brio.new(unpack(current, 1, values.n + otherValues.n))

	maid:GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	maid:GiveTask(newBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return newBrio
end

--[=[
	Makes a brio that is limited by the lifetime of its parent (but could be shorter)
	and has the new values given at the beginning of the result

	@since 3.6.0
	@param brio Brio<U>
	@param ... T
	@return Brio<T>
]=]
function BrioUtils.prepend(brio, ...)
	if brio:IsDead() then
		return Brio.DEAD
	end

	local values = brio._values
	local current = {}
	local otherValues = table.pack(...)
	for i=1, otherValues.n do
		current[i] = otherValues[i]
	end
	for i=1, values.n do
		current[otherValues.n+i] = values[i]
	end

	local maid = Maid.new()
	local newBrio = Brio.new(unpack(current, 1, values.n + otherValues.n))

	maid:GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	maid:GiveTask(newBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return newBrio
end

--[=[
	Merges the existing brio value with the other brio

	@param brio Brio<{T}>
	@param otherBrio Brio<{U}>
	@return Brio<{T | U}>
]=]
function BrioUtils.merge(brio, otherBrio)
	assert(Brio.isBrio(brio), "Not a brio")
	assert(Brio.isBrio(otherBrio), "Not a brio")

	if brio:IsDead() or otherBrio:IsDead() then
		return Brio.DEAD
	end

	local values = brio._values
	local current = {}
	for i=1, values.n do
		current[i] = values[i]
	end

	local otherValues = otherBrio._values
	for i=1, otherValues.n do
		current[values.n+i] = otherValues[i]
	end

	local maid = Maid.new()
	local newBrio = Brio.new(unpack(current, 1, values.n + otherValues.n))

	maid:GiveTask(brio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))
	maid:GiveTask(otherBrio:GetDiedSignal():Connect(function()
		newBrio:Kill()
	end))

	maid:GiveTask(newBrio:GetDiedSignal():Connect(function()
		maid:DoCleaning()
	end))

	return newBrio
end

return BrioUtils  -  Editar
  04:54:13.801    -  Editar
  04:54:13.801  ----- [2455] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.brio.Shared.BrioUtils.spec -----  -  Editar
  04:54:13.801  --[[
	Unit tests for BrioUtils.lua
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local BrioUtils = require("BrioUtils")
local Brio = require("Brio")

return function()
	describe("BrioUtils.flatten({})", function()
		local brio = BrioUtils.flatten({})

		describe("should return a brio that", function()
			it("is a brio", function()
				expect(brio).to.be.a("table")
				expect(Brio.isBrio(brio)).to.equal(true)
			end)

			it("is alive", function()
				expect(not brio:IsDead()).to.equal(true)
			end)

			it("contains a table", function()
				expect(brio:GetValue()).to.be.a("table")
			end)

			it("contains a table with nothing in it", function()
				expect(next(brio:GetValue())).to.equal(nil)
			end)
		end)
	end)

	describe("BrioUtils.flatten with out a brio in it", function()
		local brio = BrioUtils.flatten({
			value = 5;
		})

		describe("should return a brio that", function()
			it("is a brio", function()
				expect(brio).to.be.a("table")
				expect(Brio.isBrio(brio)).to.equal(true)
			end)

			it("is alive", function()
				expect(not brio:IsDead()).to.equal(true)
			end)

			it("contains a table", function()
				expect(brio:GetValue()).to.be.a("table")
			end)

			it("contains a table with value", function()
				expect(brio:GetValue().value).to.equal(5)
			end)
		end)
	end)

	describe("BrioUtils.flatten a dead brio in it", function()
		local brio = BrioUtils.flatten({
			value = Brio.DEAD;
		})

		describe("should return a brio that", function()
			it("is a brio", function()
				expect(brio).to.be.a("table")
				expect(Brio.isBrio(brio)).to.equal(true)
			end)

			it("is dead", function()
				expect(brio:IsDead()).to.equal(true)
			end)
		end)
	end)
end
  -  Editar
  04:54:13.802    -  Editar
  04:54:13.803  ----- [2456] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.brio.Shared.RxBrioUtils -----  -  Editar
  04:54:13.803  --[=[
	Utility functions involving brios and rx. Brios encapsulate the lifetime of resources,
	which could be expired by the time a subscription occurs. These functions allow us to
	manipulate the state of these at a higher order.

	@class RxBrioUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local BrioUtils = require("BrioUtils")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")

local RxBrioUtils = {}

--[=[
	Takes a result and converts it to a brio if it is not one.

	@return (source: Observable<Brio<T> | T>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.toBrio()
	return Rx.map(function(result)
		if Brio.isBrio(result) then
			return result
		end

		return Brio.new(result)
	end)
end

--[=[
	Completes the observable on death

	@param brio Brio
	@param observable Observable<T>
	@return Observable<T>
]=]
function RxBrioUtils.completeOnDeath(brio, observable)
	assert(Brio.isBrio(brio))
	assert(Observable.isObservable(observable))

	return Observable.new(function(sub)
		if brio:IsDead() then
			sub:Complete()
			return
		end

		local maid = brio:ToMaid()

		maid:GiveTask(function()
			sub:Complete()
		end)
		maid:GiveTask(observable:Subscribe(sub:GetFireFailComplete()))

		return maid
	end)
end

--[=[
	Whenever all returned brios are dead, emits this value wrapped
	in a brio.

	@param valueToEmitWhileAllDead T
	@return (source: Observable<Brio<U>>) -> Observable<Brio<U | T>>
]=]
function RxBrioUtils.emitWhileAllDead(valueToEmitWhileAllDead)
	return function(source)
		return Observable.new(function(sub)
			local topMaid = Maid.new()

			local subscribed = true
			topMaid:GiveTask(function()
				subscribed = false
			end)
			local aliveBrios = {}
			local fired = false

			local function updateBrios()
				if not subscribed then -- No work if we don't need to.
					return
				end

				aliveBrios = BrioUtils.aliveOnly(aliveBrios)
				if next(aliveBrios) then
					topMaid._lastBrio = nil
				else
					local newBrio = Brio.new(valueToEmitWhileAllDead)
					topMaid._lastBrio = newBrio
					sub:Fire(newBrio)
				end

				fired = true
			end

			local function handleNewBrio(brio)
				-- Could happen due to throttle or delay...
				if brio:IsDead() then
					return
				end

				local maid = Maid.new()
				topMaid[maid] = maid -- Use maid as key so it's unique (reemitted brio)

				maid:GiveTask(function() -- GC properly
					topMaid[maid] = nil
					updateBrios()
				end)
				maid:GiveTask(brio:GetDiedSignal():Connect(function()
					topMaid[maid] = nil
				end))

				table.insert(aliveBrios, brio)
				updateBrios()
			end

			topMaid:GiveTask(source:Subscribe(
				function(brio)
					if not Brio.isBrio(brio) then
						warn(("[RxBrioUtils.emitWhileAllDead] - Not a brio, %q"):format(tostring(brio)))
						topMaid._lastBrio = nil
						sub:Fail("Not a brio")
						return
					end

					handleNewBrio(brio)
				end,
				function(...)
					sub:Fail(...)
				end,
				function(...)
					sub:Complete(...)
				end))

			-- Make sure we emit an empty list if we discover nothing
			if not fired then
				updateBrios()
			end

			return topMaid
		end)
	end
end

--[=[
	This can't be cheap. Consider deeply if you want this or not.

	@param selectFromBrio ((value: T) -> U)?
	@return (source: Observable<Brio<T>>) -> Observable<Brio{U}>
]=]
function RxBrioUtils.reduceToAliveList(selectFromBrio)
	assert(type(selectFromBrio) == "function" or selectFromBrio == nil, "Bad selectFromBrio")

	return function(source)
		return Observable.new(function(sub)
			local topMaid = Maid.new()

			local subscribed = true
			topMaid:GiveTask(function()
				subscribed = false
			end)
			local aliveBrios = {}
			local fired = false

			local function updateBrios()
				if not subscribed then -- No work if we don't need to.
					return
				end

				aliveBrios = BrioUtils.aliveOnly(aliveBrios)
				local values = {}
				if selectFromBrio then
					for _, brio in pairs(aliveBrios) do
						-- Hope for no side effects
						local value = selectFromBrio(brio:GetValue())
						assert(value ~= nil, "Bad value")

						table.insert(values, value)
					end
				else
					for _, brio in pairs(aliveBrios) do
						local value = brio:GetValue()
						assert(value ~= nil, "Bad value")

						table.insert(values, value)
					end
				end

				local newBrio = BrioUtils.first(aliveBrios, values)
				topMaid._lastBrio = newBrio

				fired = true
				sub:Fire(newBrio)
			end

			local function handleNewBrio(brio)
				-- Could happen due to throttle or delay...
				if brio:IsDead() then
					return
				end

				local maid = Maid.new()
				topMaid[maid] = maid -- Use maid as key so it's unique (reemitted brio)

				maid:GiveTask(function() -- GC properly
					topMaid[maid] = nil
					updateBrios()
				end)
				maid:GiveTask(brio:GetDiedSignal():Connect(function()
					topMaid[maid] = nil
				end))

				table.insert(aliveBrios, brio)
				updateBrios()
			end

			topMaid:GiveTask(source:Subscribe(
				function(brio)
					if not Brio.isBrio(brio) then
						warn(("[RxBrioUtils.mergeToAliveList] - Not a brio, %q"):format(tostring(brio)))
						topMaid._lastBrio = nil
						sub:Fail("Not a brio")
						return
					end

					handleNewBrio(brio)
				end,
				function(...)
					sub:Fail(...)
				end,
				function(...)
					sub:Complete(...)
				end))

			-- Make sure we emit an empty list if we discover nothing
			if not fired then
				updateBrios()
			end

			return topMaid
		end)
	end
end

--[=[
	Whenever the last brio dies, reemit it as a dead brio

	@return (source Observable<Brio<T>>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.reemitLastBrioOnDeath()
	return function(source)
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(
				function(brio)
					maid._conn = nil

					if not Brio.isBrio(brio) then
						warn(("[RxBrioUtils.reemitLastBrioOnDeath] - Not a brio, %q"):format(tostring(brio)))
						sub:Fail("Not a brio")
						return
					end

					if brio:IsDead() then
						sub:Fire(brio)
						return
					end

					-- Setup conn!
					maid._conn = brio:GetDiedSignal():Connect(function()
						sub:Fire(brio)
					end)

					sub:Fire(brio)
				end,
				function(...)
					sub:Fail(...)
				end,
				function(...)
					sub:Complete(...)
				end))

			return maid
		end)
	end
end

--[=[
	Unpacks the brio, and then repacks it. Ignored items
	still invalidate the previous brio

	@since 3.6.0
	@param predicate (T) -> boolean
	@return (source: Observable<Brio<T>>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.where(predicate)
	assert(type(predicate) == "function", "Bad predicate")
	return function(source)
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(brio)
				assert(Brio.isBrio(brio), "Not a brio")
				if brio:IsDead() then
					return
				end

				if predicate(brio:GetValue()) then
					sub:Fire(brio)
				end
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Same as [RxBrioUtils.where]. Here to keep backwards compatability.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@function filter
	@param predicate (T) -> boolean
	@return (source: Observable<Brio<T>>) -> Observable<Brio<T>>
	@within RxBrioUtils
]=]
RxBrioUtils.filter = RxBrioUtils.where

--[=[
	Flattens all the brios in one brio and combines them. Note that this method leads to
	gaps in the lifetime of the brio.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param observables { [any]: Observable<Brio<T>> | Observable<T> | T }
	@return Observable<Brio<{ [any]: T }>>
]=]
function RxBrioUtils.combineLatest(observables)
	assert(type(observables) == "table", "Bad observables")

	warn("[RxBrioUtils.combineLatest] - Deprecated since 3.6.0. Use RxBrioUtils.flatCombineLatest")

	return Rx.combineLatest(observables)
		:Pipe({
			Rx.map(BrioUtils.flatten);
			RxBrioUtils.onlyLastBrioSurvives();
		})
end

--[=[
	Flat map equivalent for brios. The resulting observables will
	be disconnected at the end of the brio.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param project (value: TBrio) -> TProject
	@param resultSelector ((initial TBrio, value: TProject) -> TResult)?
	@return (source: Observable<Brio<TBrio>> -> Observable<TResult>)
]=]
function RxBrioUtils.flatMap(project, resultSelector)
	assert(type(project) == "function", "Bad project")

	warn("[RxBrioUtils.flatMap] - Deprecated since 3.6.0. Use RxBrioUtils.flatMapBrio")

	return Rx.flatMap(RxBrioUtils.mapBrio(project), resultSelector)
end

--[=[
	Flat map equivalent for brios. The resulting observables will
	be disconnected at the end of the brio.

	Like [RxBrioUtils.flatMap], but emitted values are wrapped in brios.
	The lifetime of this brio is limited by the lifetime of the
	input brios, which are unwrapped and repackaged.

	@since 3.6.0
	@param project (value: TBrio) -> TProject | Brio<TProject>
	@return (source: Observable<Brio<TBrio>> -> Observable<Brio<TResult>>)
]=]
function RxBrioUtils.flatMapBrio(project)
	return Rx.flatMap(RxBrioUtils.mapBrioBrio(project))
end

--[=[
	Switch map but for brios. The resulting observable will be
	disconnected on the end of the brio's life.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param project (value: TBrio) -> TProject
	@return (source: Observable<Brio<TBrio>>) -> Observable<TResult>
]=]
function RxBrioUtils.switchMap(project)
	assert(type(project) == "function", "Bad project")

	warn("[RxBrioUtils.switchMap] - Deprecated since 3.6.0. Use RxBrioUtils.switchMapBrio")

	return Rx.switchMap(RxBrioUtils.mapBrio(project))
end

--[=[
	Switch map but for brios. The resulting observable will be
	disconnected on the end of the brio's life.

	Like [RxBrioUtils.switchMap] but emitted values are wrapped in brios.
	The lifetime of this brio is limited by the lifetime of the
	input brios, which are unwrapped and repackaged.

	@since 3.6.0
	@param project (value: TBrio) -> TProject | Brio<TProject>
	@return (source: Observable<Brio<TBrio>>) -> Observable<Brio<TResult>>
]=]
function RxBrioUtils.switchMapBrio(project)
	assert(type(project) == "function", "Bad project")

	return Rx.switchMap(RxBrioUtils.mapBrioBrio(project))
end

--[=[
	Works line combineLatest, but allow the transformation of a brio into an observable
	that emits the value, and then nil, on death.

	The issue here is this:

	1. Resources are found with combineLatest()
	2. One resource dies
	3. All resources are invalidated
	4. We still wanted to be able to use most of the resources

	With this method we are able to do this, as we'll re-emit a table with all resoruces
	except the invalidated one.

	@since 3.6.0
	@param observables { [any]: Observable<Brio<T>> | Observable<T> | T }
	@return Observable<{ [any]: T? }>
]=]
function RxBrioUtils.flatCombineLatest(observables)
	assert(type(observables) == "table", "Bad observables")

	local newObservables = {}
	for key, observable in pairs(observables) do
		if Observable.isObservable(observable) then
			newObservables[key] = RxBrioUtils.flattenToValueAndNil(observable)
		else
			newObservables[key] = observable
		end
	end

	return Rx.combineLatest(newObservables)
end

--[=[
	Takes in a brio and returns an observable that emits the brio, and then completes
	on death.

	@deprecated 3.6.0 -- This method does not wrap the resulting value in a Brio, which can sometimes lead to leaks.
	@param project (value: TBrio) -> TProject
	@return (brio<TBrio>) -> TProject
]=]
function RxBrioUtils.mapBrio(project)
	assert(type(project) == "function", "Bad project")

	warn("[RxBrioUtils.mapBrio] - Deprecated since 3.6.0. Use RxBrioUtils.mapBrioBrio")

	return function(brio)
		assert(Brio.isBrio(brio), "Not a brio")

		if brio:IsDead() then
			return Rx.EMPTY
		end

		local observable = project(brio:GetValue())
		assert(Observable.isObservable(observable), "Not an observable")

		return RxBrioUtils.completeOnDeath(brio, observable)
	end
end

--[=[
	Prepends the value onto the emitted brio
	@since 3.6.0
	@param ... T
	@return (source: Observable<Brio<U>>) -> Observable<Brio<U | T>>
]=]
function RxBrioUtils.prepend(...)
	local args = table.pack(...)

	return Rx.map(function(brio)
		assert(Brio.isBrio(brio), "Bad brio")

		return BrioUtils.prepend(brio, table.unpack(args, 1, args.n))
	end)
end

--[=[
	Extends the value onto the emitted brio
	@since 3.6.0
	@param ... T
	@return (source: Observable<Brio<U>>) -> Observable<Brio<U | T>>
]=]
function RxBrioUtils.extend(...)
	local args = table.pack(...)

	return Rx.map(function(brio)
		assert(Brio.isBrio(brio), "Bad brio")

		return BrioUtils.extend(brio, table.unpack(args, 1, args.n))
	end)
end

--[=[
	Maps the input brios to the output observables
	@since 3.6.0
	@param project project (Brio<T> | T) -> Brio<U> | U
	@return (source: Observable<Brio<T> | T>) -> Observable<Brio<U>>
]=]
function RxBrioUtils.map(project)
	return Rx.map(function(...)
		local n = select("#", ...)
		local brios = {}
		local args

		if n == 1 then
			if Brio.isBrio(...) then
				table.insert(brios, (...))
				args = (...):GetPackedValues()
			else
				args = {[1] = ...}
			end
		else
			args = {}
			for index, item in pairs({...}) do
				if Brio.isBrio(item) then
					table.insert(brios, item)
					args[index] = item:GetValue() -- we lose data here, but I think this is fine
				else
					args[index] = item
				end
			end
			args.n = n
		end

		local results = table.pack(project(table.unpack(args, 1, args.n)))
		local transformedResults = {}
		for i=1, results.n do
			local item = results[i]
			if Brio.isBrio(item) then
				table.insert(brios, item) -- add all subsequent brios into this table...
				transformedResults[i] = item:GetValue()
			else
				transformedResults[i] = item
			end
		end

		return BrioUtils.first(brios, table.unpack(transformedResults, 1, transformedResults.n))
	end)
end

function RxBrioUtils._mapResult(brio)
	return function(...)
		local n = select("#", ...)
		if n == 0 then
			return BrioUtils.withOtherValues(brio)
		elseif n == 1 then
			if Brio.isBrio(...) then
				return BrioUtils.first({brio, (...)}, (...):GetValue())
			else
				return BrioUtils.withOtherValues(brio, ...)
			end
		else
			local brios = { brio }
			local args = {}

			for index, item in pairs({...}) do
				if Brio.isBrio(item) then
					table.insert(brios, item)
					args[index] = item:GetValue() -- we lose data here, but I think this is fine
				else
					args[index] = item
				end
			end

			return BrioUtils.first(brios, unpack(args, 1, n))
		end
	end
end

--[=[
	Takes in a brio and returns an observable that emits the brio, and then completes
	on death.

	@since 3.6.0
	@param project (value: TBrio) -> TProject | Brio<TProject>
	@return (Brio<TBrio>) -> Brio<TProject>
]=]
function RxBrioUtils.mapBrioBrio(project)
	assert(type(project) == "function", "Bad project")

	return function(brio)
		assert(Brio.isBrio(brio), "Not a brio")

		if brio:IsDead() then
			return Rx.EMPTY
		end

		local observable = project(brio:GetValue())
		assert(Observable.isObservable(observable), "Not an observable")

		return RxBrioUtils.completeOnDeath(brio, observable):Pipe({
			Rx.map(RxBrioUtils._mapResult(brio))
		})
	end
end

--[=[
	Transforms the brio into an observable that emits the initial value of the brio, and then another value on death
	@param brio Brio<T> | T
	@param emitOnDeathValue U
	@return Observable<T | U>
]=]
function RxBrioUtils.toEmitOnDeathObservable(brio, emitOnDeathValue)
	if not Brio.isBrio(brio) then
		return Rx.of(brio)
	else
		return Observable.new(function(sub)
			if brio:IsDead() then
				sub:Fire(emitOnDeathValue)
				sub:Complete()
			else
				sub:Fire(brio:GetValue())
				return brio:GetDiedSignal():Connect(function()
					sub:Fire(emitOnDeathValue)
					sub:Complete()
				end)
			end
		end)
	end
end

--[=[
	Returns a mapping function that emits the given value.

	@param emitOnDeathValue U
	@return (brio: Brio<T> | T) -> Observable<T | U>
]=]
function RxBrioUtils.mapBrioToEmitOnDeathObservable(emitOnDeathValue)
	return function(brio)
		return RxBrioUtils.toEmitOnDeathObservable(brio, emitOnDeathValue)
	end
end

--[=[
	Takes in an observable of brios and returns an observable of the inner values that will also output
	nil if there is no other value for the brio.

	@param emitOnDeathValue U
	@return (source: Observable<Brio<T> | T>) -> Observable<T | U>
]=]
function RxBrioUtils.emitOnDeath(emitOnDeathValue)
	return Rx.switchMap(RxBrioUtils.mapBrioToEmitOnDeathObservable(emitOnDeathValue));
end

--[=[
	Flattens the observable to nil and the value

	@function flattenToValueAndNil
	@param source Observable<Brio<T> | T>
	@return T | nil
	@within RxBrioUtils
]=]
RxBrioUtils.flattenToValueAndNil = RxBrioUtils.emitOnDeath(nil)

--[=[
	Ensures only the last brio survives.

	@return (source Observable<Brio<T>>) -> Observable<Brio<T>>
]=]
function RxBrioUtils.onlyLastBrioSurvives()
	return function(source)
		return Observable.new(function(sub)
			local maid = Maid.new()

			maid:GiveTask(source:Subscribe(function(brio)
				if not Brio.isBrio(brio) then
					warn(("[RxBrioUtils.onlyLastBrioSurvives] - Not a brio, %q"):format(tostring(brio)))
					maid._lastBrio = nil
					sub:Fail("Not a brio")
					return
				end

				local wrapperBrio = BrioUtils.clone(brio)
				maid._lastBrio = wrapperBrio

				sub:Fire(wrapperBrio)
			end, sub:GetFailComplete()))

			return maid
		end)
	end
end

--[=[
	Switches the result to a brio, and ensures only the last brio lives.

	@since 3.6.0
	@function switchToBrio
	@return (source: Observable<T>) -> Observable<Brio<T>>
	@within RxBrioUtils
]=]
RxBrioUtils.switchToBrio = Rx.pipe({
	RxBrioUtils.toBrio();
	RxBrioUtils.onlyLastBrioSurvives();
})

return RxBrioUtils  -  Editar
  04:54:13.803    -  Editar
  04:54:13.803  ----- [2457] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.brio.Shared.RxBrioUtils.spec -----  -  Editar
  04:54:13.803  --[[
	Unit tests for RxBrioUtils.lua
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local RxBrioUtils = require("RxBrioUtils")
local Brio = require("Brio")
local Observable = require("Observable")

return function()
	describe("RxBrioUtils.combineLatest({})", function()
		it("should execute immediately", function()
			local observe = RxBrioUtils.combineLatest({})
			local brio
			local sub = observe:Subscribe(function(result)
				brio = result
			end)
			expect(brio).to.be.ok()
			expect(Brio.isBrio(brio)).to.equal(true)
			expect(brio:IsDead()).to.equal(true)

			sub:Destroy()
		end)
	end)

	describe("RxBrioUtils.combineLatest({ value = Observable(Brio(5)) })", function()
		it("should execute immediately", function()
			local observe = RxBrioUtils.combineLatest({
				value = Observable.new(function(sub)
					sub:Fire(Brio.new(5));
				end);
				otherValue = 25;
			})
			local brio

			local sub = observe:Subscribe(function(result)
				brio = result
			end)
			expect(brio).to.be.ok()
			expect(Brio.isBrio(brio)).to.equal(true)
			expect(not brio:IsDead()).to.equal(true)
			expect(brio:GetValue()).to.be.a("table")
			expect(brio:GetValue().value).to.equal(5)

			sub:Destroy()
		end)
	end)

	describe("RxBrioUtils.flatCombineLatest", function()
		local doFire
		local brio = Brio.new(5)
		local observe = RxBrioUtils.flatCombineLatest({
			value = Observable.new(function(sub)
				sub:Fire(brio);
				doFire = function(...)
					sub:Fire(...)
				end
			end);
			otherValue = 25;
		})

		local lastResult = nil
		local fireCount = 0

		it("should execute immediately", function()
			local sub = observe:Subscribe(function(result)
				lastResult = result
				fireCount = fireCount + 1
			end)
			expect(fireCount).to.equal(1)
			expect(lastResult).to.be.a("table")
			expect(Brio.isBrio(lastResult)).to.equal(false)
			expect(lastResult.value).to.equal(5)
			expect(lastResult.otherValue).to.equal(25)

			sub:Destroy()
		end)

		it("should reset when the brio is killed", function()
			expect(fireCount).to.equal(1)

			brio:Kill()

			expect(fireCount).to.equal(2)
			expect(lastResult).to.be.a("table")
			expect(Brio.isBrio(lastResult)).to.equal(false)
			expect(lastResult.value).to.equal(nil)
			expect(lastResult.otherValue).to.equal(25)
		end)

		it("should allow a new value", function()
			expect(fireCount).to.equal(2)

			doFire(Brio.new(70))

			expect(fireCount).to.equal(3)
			expect(lastResult).to.be.a("table")
			expect(Brio.isBrio(lastResult)).to.equal(false)
			expect(lastResult.value).to.equal(70)
			expect(lastResult.otherValue).to.equal(25)
		end)

		it("should only fire once if we replace the value", function()
			expect(fireCount).to.equal(3)

			doFire(Brio.new(75))

			expect(fireCount).to.equal(4)
			expect(lastResult).to.be.a("table")
			expect(Brio.isBrio(lastResult)).to.equal(false)
			expect(lastResult.value).to.equal(75)
			expect(lastResult.otherValue).to.equal(25)
		end)
	end)
end
  -  Editar
  04:54:13.803    -  Editar
  04:54:13.804  ----- [2458] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.contentproviderutils.Client.ContentProviderUtils -----  -  Editar
  04:54:13.804  --[=[
	Utility functions to ensure that content is preloaded (wrapping calls in promises)
	@class ContentProviderUtils
]=]

local require = require(script.Parent.loader).load(script)

local ContentProvider = game:GetService("ContentProvider")

local Promise = require("Promise")

local ContentProviderUtils = {}

--[=[
	Preloads assets
	:::note
	If strings are passed in, it only preloads textures, and will preload meshes, but only to http client.
	:::

	@param contentIdList { Instance | string }
	@return Promise
]=]
function ContentProviderUtils.promisePreload(contentIdList)
	assert(type(contentIdList) == "table", "Bad contentIdList")

	return Promise.spawn(function(resolve, reject)
		local ok, err = pcall(function()
			ContentProvider:PreloadAsync(contentIdList)
		end)

		if not ok then
			return reject(err)
		end

		resolve()
	end)
end

return ContentProviderUtils  -  Editar
  04:54:13.804    -  Editar
  04:54:13.804  ----- [2459] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.instanceutils.Shared.RxInstanceUtils -----  -  Editar
  04:54:13.804  --[=[
	Utility functions to observe the state of Roblox. This is a very powerful way to query
	Roblox's state.

	:::tip
	Use RxInstanceUtils to program streaming enabled games, and make it easy to debug. This API surface
	lets you use Roblox as a source-of-truth which is very valuable.
	:::

	@class RxInstanceUtils
]=]

local require = require(script.Parent.loader).load(script)

local Brio = require("Brio")
local Maid = require("Maid")
local Observable = require("Observable")
local Rx = require("Rx")
local Symbol = require("Symbol")

local UNSET_VALUE = Symbol.named("unsetValue")

local RxInstanceUtils = {}

--[=[
	Observes an instance's property

	@param instance Instance
	@param propertyName string
	@return Observable<T>
]=]
function RxInstanceUtils.observeProperty(instance, propertyName)
	assert(typeof(instance) == "Instance", "'instance' should be of type Instance")
	assert(type(propertyName) == "string", "'propertyName' should be of type string")

	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GiveTask(instance:GetPropertyChangedSignal(propertyName):Connect(function()
			sub:Fire(instance[propertyName], instance)
		end))
		sub:Fire(instance[propertyName], instance)

		return maid
	end)
end

--[=[
	Observes an instance's ancestry

	@param instance Instance
	@return Observable<Instance>
]=]
function RxInstanceUtils.observeAncestry(instance)
	local startWithParent = Rx.start(function()
		return instance, instance.Parent
	end)

	return startWithParent(Rx.fromSignal(instance.AncestryChanged))
end

--[=[
	Observes an instance's ancestry

	@param instance Instance
	@param className string
	@return Observable<Instance>
]=]
function RxInstanceUtils.observeFirstAncestorBrio(instance, className)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(className) == "string", "Bad className")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local lastFound = nil
		local function handleAncestryChanged()
			local found = instance:FindFirstAncestorWhichIsA(className)

			if found then
				if found ~= lastFound then
					lastFound = found
					local brio = Brio.new(found)
					maid._current = brio
					sub:Fire(brio)
				end
			elseif lastFound then
				maid._current = nil
				lastFound = nil
			end
		end

		maid:GiveTask(instance.AncestryChanged:Connect(handleAncestryChanged))
		handleAncestryChanged()

		return maid
	end)
end

--[=[
	Returns a brio of the property value

	@param instance Instance
	@param propertyName string
	@param predicate ((value: T) -> boolean)? -- Optional filter
	@return Observable<Brio<T>>
]=]
function RxInstanceUtils.observePropertyBrio(instance, propertyName, predicate)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(propertyName) == "string", "Bad propertyName")
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()
		local lastValue = UNSET_VALUE

		local function handlePropertyChanged()
			local propertyValue = instance[propertyName]

			-- Deferred events can cause multiple values to be queued at once
			-- but we operate at this post-deferred layer, so lets only output
			-- reflected values.
			if lastValue ~= propertyValue then
				lastValue = propertyValue

				if not predicate or predicate(propertyValue) then
					local brio = Brio.new(instance[propertyName])

					maid._lastBrio = brio

					-- The above line can cause us to be overwritten so make sure before firing.
					if maid._lastBrio == brio then
						sub:Fire(brio)
					end
				else
					maid._lastBrio = nil
				end
			end
		end

		maid:GiveTask(instance:GetPropertyChangedSignal(propertyName):Connect(handlePropertyChanged))
		handlePropertyChanged()

		return maid
	end)
end

--[=[
	Observes the last child with a specific name.

	@param parent Instance
	@param className string
	@param name string
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeLastNamedChildBrio(parent, className, name)
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")
	assert(type(name) == "string", "Bad name")

	return Observable.new(function(sub)
		local topMaid = Maid.new()

		local function handleChild(child)
			if not child:IsA(className) then
				return
			end

			local maid = Maid.new()

			local function handleNameChanged()
				if child.Name == name then
					local brio = Brio.new(child)
					maid._brio = brio
					topMaid._lastBrio = brio

					sub:Fire(brio)
				else
					maid._brio = nil
				end
			end

			maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(handleNameChanged))
			handleNameChanged()

			topMaid[child] = maid
		end

		topMaid:GiveTask(parent.ChildAdded:Connect(handleChild))
		topMaid:GiveTask(parent.ChildRemoved:Connect(function(child)
			topMaid[child] = nil
		end))

		for _, child in pairs(parent:GetChildren()) do
			handleChild(child)
		end

		return topMaid
	end)
end

--[=[
	Observes the children with a specific name.

	@param parent Instance
	@param className string
	@param name string
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeChildrenOfNameBrio(parent, className, name)
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")
	assert(type(name) == "string", "Bad name")

	return Observable.new(function(sub)
		local topMaid = Maid.new()

		local function handleChild(child)
			if not child:IsA(className) then
				return
			end

			local maid = Maid.new()

			local function handleNameChanged()
				if child.Name == name then
					local brio = Brio.new(child)
					maid._brio = brio

					sub:Fire(brio)
				else
					maid._brio = nil
				end
			end

			maid:GiveTask(child:GetPropertyChangedSignal("Name"):Connect(handleNameChanged))
			handleNameChanged()

			topMaid[child] = maid
		end

		topMaid:GiveTask(parent.ChildAdded:Connect(handleChild))
		topMaid:GiveTask(parent.ChildRemoved:Connect(function(child)
			topMaid[child] = nil
		end))

		for _, child in pairs(parent:GetChildren()) do
			handleChild(child)
		end

		return topMaid
	end)
end

--[=[
	Observes all children of a specific class

	@param parent Instance
	@param className string
	@return Observable<Instance>
]=]
function RxInstanceUtils.observeChildrenOfClassBrio(parent, className)
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(className) == "string", "Bad className")

	return RxInstanceUtils.observeChildrenBrio(parent, function(child)
		return child:IsA(className)
	end)
end

--[=[
	Observes all children

	@param parent Instance
	@param predicate ((value: Instance) -> boolean)? -- Optional filter
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeChildrenBrio(parent, predicate)
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function handleChild(child)
			if not predicate or predicate(child) then
				local value = Brio.new(child)
				maid[child] = value
				sub:Fire(value)
			end
		end

		maid:GiveTask(parent.ChildAdded:Connect(handleChild))
		maid:GiveTask(parent.ChildRemoved:Connect(function(child)
			maid[child] = nil
		end))

		for _, child in pairs(parent:GetChildren()) do
			handleChild(child)
		end

		return maid
	end)
end

--[=[
	Observes all descendants that match a predicate

	@param parent Instance
	@param predicate ((value: Instance) -> boolean)? -- Optional filter
	@return Observable<Brio<Instance>>
]=]
function RxInstanceUtils.observeDescendants(parent, predicate)
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(predicate) == "function" or predicate == nil, "Bad predicate")

	return Observable.new(function(sub)
		local maid = Maid.new()
		local added = {}

		local function handleDescendant(child)
			if not predicate or predicate(child) then
				added[child] = true
				sub:Fire(child, true)
			end
		end

		maid:GiveTask(parent.DescendantAdded:Connect(handleDescendant))
		maid:GiveTask(parent.DescendantRemoving:Connect(function(child)
			if added[child] then
				added[child] = nil
				sub:Fire(child, false)
			end
		end))

		for _, descendant in pairs(parent:GetDescendants()) do
			handleDescendant(descendant)
		end

		return maid
	end)
end

return RxInstanceUtils  -  Editar
  04:54:13.804    -  Editar
  04:54:13.804  ----- [2460] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.instanceutils.Shared.RxInstanceUtils.spec -----  -  Editar
  04:54:13.804  --[[
	@class RxInstanceUtils.spec.lua
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local RxInstanceUtils = require("RxInstanceUtils")

return function()
	describe("RxInstanceUtils.observeChildrenBrio", function()
		local part = Instance.new("Part")
		local observe = RxInstanceUtils.observeChildrenBrio(part)
		local externalResult = nil

		it("should not emit anything", function()
			observe:Subscribe(function(result)
				externalResult = result
			end)

			expect(externalResult).to.equal(nil)
		end)
	end)
end
  -  Editar
  04:54:13.804    -  Editar
  04:54:13.805  ----- [2461] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.playerthumbnailutils.Shared.PlayerThumbnailUtils -----  -  Editar
  04:54:13.805  --[=[
	Reimplementation of Player:GetUserThumbnailAsync but as a promise with
	retry logic.

	@class PlayerThumbnailUtils
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")

local Promise = require("Promise")

local MAX_TRIES = 5

local PlayerThumbnailUtils = {}

--[=[
	Promises a user thumbnail with retry enabled.

	```lua
	PlayerThumbnailUtils.promiseUserThumbnail(4397833):Then(function(image)
		imageLabel.Image = image
	end)
	```
	@param userId number
	@param thumbnailType ThumbnailType?
	@param thumbnailSize ThumbnailSize?
	@return Promise<string>
]=]
function PlayerThumbnailUtils.promiseUserThumbnail(userId, thumbnailType, thumbnailSize)
	assert(type(userId) == "number", "Bad userId")
	thumbnailType = thumbnailType or Enum.ThumbnailType.HeadShot
	thumbnailSize = thumbnailSize or Enum.ThumbnailSize.Size100x100

	local promise
	promise = Promise.spawn(function(resolve, reject)
		local tries = 0
		repeat
			tries = tries + 1
			local content, isReady
			local ok, err = pcall(function()
				content, isReady = Players:GetUserThumbnailAsync(userId, thumbnailType, thumbnailSize)
			end)

			-- Don't retry if we immediately error (timeout exceptions!)
			if not ok then
				return reject(err)
			end

			if isReady then
				return resolve(content)
			else
				task.wait(0.05)
			end
		until tries >= MAX_TRIES or (not promise:IsPending())
		reject()
	end)

	return promise
end

--[=[
	Promises a player userName with retries enabled.
	@param userId number
	@return Promise<string>
]=]
function PlayerThumbnailUtils.promiseUserName(userId)
	assert(type(userId) == "number", "Bad userId")

	local promise
	promise = Promise.spawn(function(resolve, reject)
		local tries = 0
		repeat
			tries = tries + 1
			local name
			local ok, err = pcall(function()
				name = Players:GetNameFromUserIdAsync(userId)
			end)

			-- Don't retry if we immediately error (timeout exceptions!)
			if not ok then
				return reject(err)
			end

			if type(name) == "string" then
				return resolve(name)
			else
				task.wait(0.05)
			end
		until tries >= MAX_TRIES or (not promise:IsPending())
		reject()
	end)

	return promise
end

return PlayerThumbnailUtils  -  Editar
  04:54:13.805    -  Editar
  04:54:13.805  ----- [2462] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.spring.Shared.LinearValue -----  -  Editar
  04:54:13.805  --[=[
	Represents a value that can operate in linear space

	@class LinearValue
]=]
local LinearValue = {}
LinearValue.ClassName = "LinearValue"
LinearValue.__index = LinearValue

--[=[
	Constructs a new LinearValue object.

	@param constructor (number ...) -> T
	@param values ({ number })
	@return LinearValue<T>
]=]
function LinearValue.new(constructor, values)
	return setmetatable({
		_constructor = constructor;
		_values = values;
	}, LinearValue)
end

--[=[
	Returns whether or not a value is a LinearValue object.

	@param value any -- A value to check
	@return boolean -- True if a linear value, false otherwise
]=]
function LinearValue.isLinear(value)
	return type(value) == "table" and getmetatable(value) == LinearValue
end

--[=[
	Converts the value back to the base value

	@return T
]=]
function LinearValue:ToBaseValue()
	return self._constructor(unpack(self._values))
end

local function operation(func)
	return function(a, b)
		if LinearValue.isLinear(a) and LinearValue.isLinear(b) then
			assert(a._constructor == b._constructor, "a is not the same type of linearValue as b")

			local values = {}
			for i=1, #a._values do
				values[i] = func(a._values[i], b._values[i])
			end
			return LinearValue.new(a._constructor, values)
		elseif LinearValue.isLinear(a) then
			if type(b) == "number" then
				local values = {}
				for i=1, #a._values do
					values[i] = func(a._values[i], b)
				end
				return LinearValue.new(a._constructor, values)
			else
				error("Bad type (b)")
			end
		elseif LinearValue.isLinear(b) then
			if type(a) == "number" then
				local values = {}
				for i=1, #b._values do
					values[i] = func(a, b._values[i])
				end
				return LinearValue.new(b._constructor, values)
			else
				error("Bad type (a)")
			end
		else
			error("Neither value is a linearValue")
		end
	end
end

--[=[
	Returns the magnitude of the linear value.

	@return number -- The magnitude of the linear value.
]=]
function LinearValue:GetMagnitude()
	local dot = 0
	for i=1, #self._values do
		local value = self._values[i]
		dot = dot + value*value
	end
	return math.sqrt(dot)
end

--[=[
	Returns the magnitude of the linear value.

	@prop magnitude number
	@readonly
	@within LinearValue
]=]
function LinearValue:__index(key)
	if LinearValue[key] then
		return LinearValue[key]
	elseif key == "magnitude" then
		return self:GetMagnitude()
	else
		return nil
	end
end

LinearValue.__add = operation(function(a, b)
	return a + b
end)

LinearValue.__sub = operation(function(a, b)
	return a - b
end)

LinearValue.__mul = operation(function(a, b)
	return a * b
end)

LinearValue.__div = operation(function(a, b)
	return a / b
end)

function LinearValue:__eq(a, b)
	if LinearValue.isLinear(a) and LinearValue.isLinear(b) then
		if #a._values ~= #b._values then
			return false
		end

		for i=1, #a._values do
			if a._values[i] ~= b._values[i] then
				return false
			end
		end

		return true
	else
		return false
	end
end


return LinearValue  -  Editar
  04:54:13.805    -  Editar
  04:54:13.805  ----- [2463] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.spring.Shared.Spring -----  -  Editar
  04:54:13.805  --[=[
	A physical model of a spring, useful in many applications.

	A spring is an object that will compute based upon Hooke's law. Properties only evaluate
	upon index making this model good for lazy applications.

	```lua
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")

	local spring = Spring.new(Vector3.new(0, 0, 0))

	RunService.RenderStepped:Connect(function()
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then
			spring.Target = Vector3.new(0, 0, 1)
		else
			spring.Target = Vector3.new(0, 0, 0)
		end

		print(spring.Position) -- A smoothed out version of the input keycode W
	end)
	```

	A good visualization can be found here, provided by Defaultio:
	https://www.desmos.com/calculator/hn2i9shxbz

	@class Spring
]=]
local Spring = {}

--[=[
	Constructs a new Spring at the position and target specified, of type T.

	```lua
	-- Linear spring
	local linearSpring = Spring.new(0)

	-- Vector2 spring
	local vector2Spring = Spring.new(Vector2.new(0, 0))

	-- Vector3 spring
	local vector3Spring = Spring.new(Vector3.new(0, 0, 0))
	```

	@param initial T -- The initial parameter is a number or Vector3 (anything with * number and addition/subtraction).
	@param clock? () -> number -- The clock function is optional, and is used to update the spring
	@return Spring<T>
]=]
function Spring.new(initial, clock)
	local target = initial or 0
	clock = clock or os.clock
	return setmetatable({
		_clock = clock;
		_time0 = clock();
		_position0 = target;
		_velocity0 = 0*target;
		_target = target;
		_damper = 1;
		_speed = 1;
	}, Spring)
end

--[=[
	Impulses the spring, increasing velocity by the amount given. This is useful to make something shake,
	like a Mac password box failing.

	@param velocity T -- The velocity to impulse with
	@return ()
]=]
function Spring:Impulse(velocity)
	self.Velocity = self.Velocity + velocity
end

--[=[
	Instantly skips the spring forwards by that amount time
	@param delta number -- Time to skip forwards
	@return ()
]=]
function Spring:TimeSkip(delta)
	local now = self._clock()
	local position, velocity = self:_positionVelocity(now+delta)
	self._position0 = position
	self._velocity0 = velocity
	self._time0 = now
end

--[=[
	The current position at the given clock time. Assigning the position will change the spring to have that position.

	```lua
	local spring = Spring.new(0)
	print(spring.Position) --> 0
	```

	@prop Position T
	@within Spring
]=]
--[=[
	Alias for [Spring.Position](/api/Spring#Position)

	@prop p T
	@within Spring
]=]
--[=[
	The current velocity. Assigning the velocity will change the spring to have that velocity.

	```lua
	local spring = Spring.new(0)
	print(spring.Velocity) --> 0
	```

	@prop Velocity T
	@within Spring
]=]
--[=[
	Alias for [Spring.Velocity](/api/Spring#Velocity)

	@prop v T
	@within Spring
]=]
--[=[
	The current target. Assigning the target will change the spring to have that target.

	```lua
	local spring = Spring.new(0)
	print(spring.Target) --> 0
	```

	@prop Target T
	@within Spring
]=]
--[=[
	Alias for [Spring.Target](/api/Spring#Target)
	@prop t T
	@within Spring
]=]
--[=[
	The current damper, defaults to 1. At 1 the spring is critically damped. At less than 1, it
	will be underdamped, and thus, bounce, and at over 1, it will be critically damped.

	@prop Damper number
	@within Spring
]=]
--[=[
	Alias for [Spring.Damper](/api/Spring#Damper)

	@prop d number
	@within Spring
]=]
--[=[
	The speed, defaults to 1, but should be between [0, infinity)

	@prop Speed number
	@within Spring
]=]
--[=[
	Alias for [Spring.Speed](/api/Spring#Speed)

	@prop s number
	@within Spring
]=]
--[=[
	The current clock object to syncronize the spring against.

	@prop Clock () -> number
	@within Spring
]=]
function Spring:__index(index)
	if Spring[index] then
		return Spring[index]
	elseif index == "Value" or index == "Position" or index == "p" then
		local position, _ = self:_positionVelocity(self._clock())
		return position
	elseif index == "Velocity" or index == "v" then
		local _, velocity = self:_positionVelocity(self._clock())
		return velocity
	elseif index == "Target" or index == "t" then
		return self._target
	elseif index == "Damper" or index == "d" then
		return self._damper
	elseif index == "Speed" or index == "s" then
		return self._speed
	elseif index == "Clock" then
		return self._clock
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:__newindex(index, value)
	local now = self._clock()

	if index == "Value" or index == "Position" or index == "p" then
		local _, velocity = self:_positionVelocity(now)
		self._position0 = value
		self._velocity0 = velocity
		self._time0 = now
	elseif index == "Velocity" or index == "v" then
		local position, _ = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = value
		self._time0 = now
	elseif index == "Target" or index == "t" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._target = value
		self._time0 = now
	elseif index == "Damper" or index == "d" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._damper = value
		self._time0 = now
	elseif index == "Speed" or index == "s" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._speed = value < 0 and 0 or value
		self._time0 = now
	elseif index == "Clock" then
		local position, velocity = self:_positionVelocity(now)
		self._position0 = position
		self._velocity0 = velocity
		self._clock = value
		self._time0 = value()
	else
		error(("%q is not a valid member of Spring"):format(tostring(index)), 2)
	end
end

function Spring:_positionVelocity(now)
	local p0 = self._position0
	local v0 = self._velocity0
	local p1 = self._target
	local d = self._damper
	local s = self._speed

	local t = s*(now - self._time0)
	local d2 = d*d

	local h, si, co
	if d2 < 1 then
		h = math.sqrt(1 - d2)
		local ep = math.exp(-d*t)/h
		co, si = ep*math.cos(h*t), ep*math.sin(h*t)
	elseif d2 == 1 then
		h = 1
		local ep = math.exp(-d*t)/h
		co, si = ep, ep*t
	else
		h = math.sqrt(d2 - 1)
		local u = math.exp((-d + h)*t)/(2*h)
		local v = math.exp((-d - h)*t)/(2*h)
		co, si = u + v, u - v
	end

	local a0 = h*co + d*si
	local a1 = 1 - (h*co + d*si)
	local a2 = si/s

	local b0 = -s*si
	local b1 = s*si
	local b2 = h*co - d*si

	return
		a0*p0 + a1*p1 + a2*v0,
		b0*p0 + b1*p1 + b2*v0
end

return Spring
  -  Editar
  04:54:13.805    -  Editar
  04:54:13.805  ----- [2464] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.spring.Shared.SpringUtils -----  -  Editar
  04:54:13.805  --[=[
	Utility functions that are related to the Spring object
	@class SpringUtils
]=]

local EPSILON = 1e-6

local require = require(script.Parent.loader).load(script)
local LinearValue = require("LinearValue")

local SpringUtils = {}

--[=[
	Utility function that returns whether or not a spring is animating based upon
	velocity and closeness to target, and as the second value, the value that should be
	used.

	@param spring Spring<T>
	@param epsilon number? -- Optional epsilon
	@return boolean, T
]=]
function SpringUtils.animating(spring, epsilon)
	epsilon = epsilon or EPSILON

	local position = spring.Position
	local target = spring.Target

	local animating
	if type(target) == "number" then
		animating = math.abs(spring.Position - spring.Target) > epsilon
			or math.abs(spring.Velocity) > epsilon
	else
		local rbxtype = typeof(target)
		if rbxtype == "Vector3" or rbxtype == "Vector2" or LinearValue.isLinear(target) then
			animating = (spring.Position - spring.Target).magnitude > epsilon
				or spring.Velocity.magnitude > epsilon
		else
			error("Unknown type")
		end
	end

	if animating then
		return true, position
	else
		-- We need to return the target so we use the actual target value (i.e. pretend like the spring is asleep)
		return false, target
	end
end

--[=[
	Add to spring position to adjust for velocity of target. May have to set clock to time().

	@param velocity T
	@param dampen number
	@param speed number
	@return T
]=]
function SpringUtils.getVelocityAdjustment(velocity, dampen, speed)
	assert(velocity, "Bad velocity")
	assert(dampen, "Bad dampen")
	assert(speed, "Bad speed")

	return velocity*(2*dampen/speed)
end

--[=[
	Converts an arbitrary value to a LinearValue if Roblox has not defined this value
	for multiplication and addition.

	@param value T
	@return LinearValue<T> | T
]=]
function SpringUtils.toLinearIfNeeded(value)
	if typeof(value) == "Color3" then
		return LinearValue.new(Color3.new, {value.r, value.g, value.b})
	elseif typeof(value) == "UDim2" then
		return LinearValue.new(UDim2.new, {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset})
	elseif typeof(value) == "UDim" then
		return LinearValue.new(UDim.new, {value.scale, value.offset})
	else
		return value
	end
end

--[=[
	Extracts the base value out of a packed linear value if needed.

	@param value LinearValue<T> | any
	@return T | any
]=]
function SpringUtils.fromLinearIfNeeded(value)
	if LinearValue.isLinear(value) then
		return value:ToBaseValue()
	else
		return value
	end
end

return SpringUtils  -  Editar
  04:54:13.806    -  Editar
  04:54:13.806  ----- [2465] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.steputils.Shared.StepUtils -----  -  Editar
  04:54:13.806  --[=[
	Utility functions primarily used to bind animations into update loops of the Roblox engine.
	@class StepUtils
]=]

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local StepUtils = {}

--[=[
	Binds the given update function to render stepped.

	```lua
	local spring = Spring.new(0)
	local maid = Maid.new()

	local startAnimation, maid._stopAnimation = StepUtils.bindToRenderStep(function()
		local animating, position = SpringUtils.animating(spring)

		print(position)

		return animating
	end)

	spring.t = 1
	startAnimation()
	```

	:::tip
	Be sure to call the disconnect function when cleaning up, otherwise you may memory leak.
	:::

	@param update () -> boolean -- should return true while it needs to update
	@return (...) -> () -- Connect function
	@return () -> () -- Disconnect function
]=]
function StepUtils.bindToRenderStep(update)
	return StepUtils.bindToSignal(RunService.RenderStepped, update)
end

--[=[
	Binds an update event to a signal until the update function stops returning a truthy
	value.

	@param signal Signal | RBXScriptSignal
	@param update () -> boolean -- should return true while it needs to update
	@return (...) -> () -- Connect function
	@return () -> () -- Disconnect function
]=]
function StepUtils.bindToSignal(signal, update)
	if typeof(signal) ~= "RBXScriptSignal" then
		error("signal must be of type RBXScriptSignal")
	end
	if type(update) ~= "function" then
		error(("update must be of type function, got %q"):format(type(update)))
	end

	local conn = nil
	local function disconnect()
		if conn then
			conn:Disconnect()
			conn = nil
		end
	end

	local function connect(...)
		-- Ignore if we have an existing connection
		if conn and conn.Connected then
			return
		end

		-- Check to see if we even need to bind an update
		if not update(...) then
			return
		end

		-- Avoid reentrance, if update() triggers another connection, we'll already be connected.
		if conn and conn.Connected then
			return
		end

		-- Usually contains just the self arg!
		local args = {...}

		-- Bind to render stepped
		conn = signal:Connect(function()
			if not update(unpack(args)) then
				disconnect()
			end
		end)
	end

	return connect, disconnect
end

--[=[
	Calls the function once at the given priority level, unless the cancel callback is
	invoked.

	@param priority number
	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtRenderPriority(priority, func)
	assert(type(priority) == "number", "Bad priority")
	assert(type(func) == "function", "Bad func")

	local key = ("StepUtils.onceAtPriority_%s"):format(HttpService:GenerateGUID(false))

	local function cleanup()
		RunService:UnbindFromRenderStep(key)
	end

	RunService:BindToRenderStep(key, priority, function()
		cleanup()
		func()
	end)

	return cleanup
end

--[=[
	Invokes the function once at stepped, unless the cancel callback is called.

	```lua
	-- Sometimes you need to defer the execution of code to make physics happy
	maid:GiveTask(StepUtils.onceAtStepped(function()
		part.CFrame = CFrame.new(0, 0, )
	end))
	```
	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtStepped(func)
	return StepUtils.onceAtEvent(RunService.Stepped, func)
end

--[=[
	Invokes the function once at renderstepped, unless the cancel callback is called.

	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtRenderStepped(func)
	return StepUtils.onceAtEvent(RunService.RenderStepped, func)
end

--[=[
	Invokes the function once at the given event, unless the cancel callback is called.

	@param event Signal | RBXScriptSignal
	@param func function -- Function to call
	@return function -- Call this function to cancel call
]=]
function StepUtils.onceAtEvent(event, func)
	assert(type(func) == "function", "Bad func")

	local conn
	local function cleanup()
		if conn then
			conn:Disconnect()
			conn = nil
		end
	end

	conn = event:Connect(function(...)
		cleanup()
		func(...)
	end)

	return cleanup
end

return StepUtils  -  Editar
  04:54:13.806    -  Editar
  04:54:13.806  ----- [2466] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.steputils.Shared.onRenderStepFrame -----  -  Editar
  04:54:13.806  --[=[
	Executes code at a specific point in render step priority queue
	@class onRenderStepFrame
]=]

local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

--[=[
	Executes code at a specific point in render step priority queue.
	@function onRenderStepFrame
	@param priority number
	@return MaidTask
	@within onRenderStepFrame
]=]

return function(priority, callback)
	assert(type(priority) == "number", "Bad priority")
	assert(type(callback) == "function", "Bad callback")

	local key = HttpService:GenerateGUID(false) .. "_onRenderStepFrame"
	local unbound = false

	RunService:BindToRenderStep(key, priority, function()
		if not unbound then -- Probably not needed
			RunService:UnbindFromRenderStep(key)
			callback()
		end
	end)

	return function()
		if not unbound then
			RunService:UnbindFromRenderStep(key)
			unbound = true
		end
	end
end  -  Editar
  04:54:13.806    -  Editar
  04:54:13.806  ----- [2467] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.steputils.Shared.onSteppedFrame -----  -  Editar
  04:54:13.806  --[=[
	Executes code at a specific point in Roblox's engine
	@class onSteppedFrame
]=]

local RunService = game:GetService("RunService")

--[=[
	Executes code at a specific point in Roblox's engine.
	@function onSteppedFrame
	@param func function
	@return RBXScriptConnection
	@within onSteppedFrame
]=]
return function(func)
	assert(type(func) == "function", "Bad func")

	local conn
	conn = RunService.Stepped:Connect(function()
		conn:Disconnect()
		func()
	end)

	return conn
end  -  Editar
  04:54:13.806    -  Editar
  04:54:13.806  ----- [2468] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.string.Shared.String -----  -  Editar
  04:54:13.806  --[=[
	This module provides utility functions for strings
	@class String
]=]

local String = {}

--[=[
	Trims the string of the given pattern

	@param str string
	@param pattern string? -- Defaults to whitespace
	@return string
]=]
function String.trim(str: string, pattern: string?): string
	if not pattern then
		return str:match("^%s*(.-)%s*$")
	else
		-- When we find the first non space character defined by ^%s
		-- we yank out anything in between that and the end of the string
		-- Everything else is replaced with %1 which is essentially nothing
		return str:match("^"..pattern.."*(.-)"..pattern.."*$")
	end
end

--[=[
	Converts the string to UpperCamelCase
	@param str string
	@return string
]=]
function String.toCamelCase(str: string): string
	str = str:lower()
	str = str:gsub("[ _](%a)", string.upper)
	str = str:gsub("^%a", string.upper)
	str = str:gsub("%p", "")

	return str
end


--[=[
	Uppercases the first letter of the string
	@param str string
	@return string
]=]
function String.uppercaseFirstLetter(str: string): string
	return str:gsub("^%a", string.upper)
end

--[=[
	Converts to the string to lowerCamelCase
	@param str string
	@return string
]=]
function String.toLowerCamelCase(str: string): string
	str = str:lower()
	str = str:gsub("[ _](%a)", string.upper)
	str = str:gsub("^%a", string.lower)
	str = str:gsub("%p", "")

	return str
end

--[=[
	Converts the string to _privateCamelCase
	@param str string
	@return string
]=]
function String.toPrivateCase(str: string): string
	return "_" .. str:sub(1, 1):lower() .. str:sub(2, #str)
end

--[=[
	Like trim, but only applied to the beginning of the setring
	@param str string
	@param pattern string? -- Defaults to whitespace
	@return string
]=]
function String.trimFront(str: string, pattern: string?): string
	pattern = pattern or "%s";
	return (str:gsub("^"..pattern.."*(.-)"..pattern.."*", "%1"))
end

--[=[
	Counts the number of times a char appears in a string.

	:::note
	Note that this is not UTF8 safe
	:::

	@param str string
	@param char string
	@return number
]=]
function String.checkNumOfCharacterInString(str: string, char: string): number
	local count = 0
	for _ in string.gmatch(str, char) do
		count = count + 1
	end
	return count
end

--[=[
	Checks if a string is empty or nil
	@param str string
	@return boolean
]=]
function String.isEmptyOrWhitespaceOrNil(str: string): boolean
	return type(str) ~= "string" or str == "" or String.isWhitespace(str)
end

--[=[
	Returns whether or not text is only whitespace
	@param str string
	@return boolean
]=]
function String.isWhitespace(str: string): boolean
	return string.match(str, "[%s]+") == str
end

--[=[
	Converts text to have a ... after it if it's too long.
	@param str string
	@param characterLimit number
	@return string
]=]
function String.elipseLimit(str: string, characterLimit: number): string
	if #str > characterLimit then
		str = str:sub(1, characterLimit-3).."..."
	end
	return str
end

--[=[
	Removes a prefix from a string if it exists
	@param str string
	@param prefix string
	@return string
]=]
function String.removePrefix(str: string, prefix: string): string
	if str:sub(1, #prefix) == prefix then
		return str:sub(#prefix + 1)
	else
		return str
	end
end

--[=[
	Removes a postfix from a string if it exists
	@param str string
	@param postfix string
	@return string
]=]
function String.removePostfix(str: string, postfix: string): string
	if str:sub(-#postfix) == postfix then
		return str:sub(1, -#(postfix) - 1)
	else
		return str
	end
end

--[=[
	Returns if a string ends with a postfix
	@param str string
	@param postfix string
	@return boolean
]=]
function String.endsWith(str: string, postfix: string): boolean
	return str:sub(-#postfix) == postfix
end

--[=[
	Returns if a string starts with a postfix
	@param str string
	@param prefix string
	@return boolean
]=]
function String.startsWith(str: string, prefix: string): boolean
	return str:sub(1, #prefix) == prefix
end

--[=[
	Adds commas to a number. Not culture aware.
	@param number string | number
	@return string
]=]
function String.addCommas(number: string | number): string
	if type(number) == "number" then
		number = tostring(number)
	end

	local index = -1

	while index ~= 0 do
		number, index = string.gsub(number, "^(-?%d+)(%d%d%d)", '%1,%2')
	end

	return number
end

return String  -  Editar
  04:54:13.807    -  Editar
  04:54:13.807  ----- [2469] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.valuebaseutils.Shared.RxValueBaseUtils -----  -  Editar
  04:54:13.807  --[=[
	@class RxValueBaseUtils
]=]

local require = require(script.Parent.loader).load(script)

local RxInstanceUtils = require("RxInstanceUtils")
local RxBrioUtils = require("RxBrioUtils")

local RxValueBaseUtils = {}

--[=[
	:::warning
	This caches the last value seen, and may memory leak.
	:::

	@param parent Instance
	@param className string
	@param name string
	@return Observable<any>
	:::
]=]
-- TODO: Handle default value/nothing there, instead of memory leaking!
function RxValueBaseUtils.observe(parent, className, name)
	warn("[RxValueBaseUtils.observe] - Deprecated since 4.0.0. Use RxValueBaseUtils.observeBrio")

	return RxInstanceUtils.observeLastNamedChildBrio(parent, className, name)
		:Pipe({
			RxBrioUtils.switchMap(function(valueObject)
				return RxValueBaseUtils.observeValue(valueObject)
			end)
		})
end

--[=[
	Observes a value base underneath a parent (last named child).

	@param parent Instance
	@param className string
	@param name string
	@return Observable<Brio<any>>
]=]
function RxValueBaseUtils.observeBrio(parent, className, name)
	return RxInstanceUtils.observeLastNamedChildBrio(parent, className, name)
		:Pipe({
			RxBrioUtils.switchMapBrio(function(valueObject)
				return RxValueBaseUtils.observeValue(valueObject)
			end)
		})
end


--[=[
	Observables a given value object's value
	@param valueObject Instance
	@return Observable<T>
]=]
function RxValueBaseUtils.observeValue(valueObject)
	return RxInstanceUtils.observeProperty(valueObject, "Value")
end

return RxValueBaseUtils  -  Editar
  04:54:13.807    -  Editar
  04:54:13.807  ----- [2470] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.valuebaseutils.Shared.ValueBaseUtils -----  -  Editar
  04:54:13.807  --[=[
	Provides utilities for working with valuesbase objects, like IntValue or ObjectValue in Roblox.
	@class ValueBaseUtils
]=]

local ValueBaseUtils = {}

function ValueBaseUtils.isValueBase(instance)
	return typeof(instance) == "Instance" and instance.ClassName:sub(-#"Value") == "Value"
end

function ValueBaseUtils.getOrCreateValue(parent, instanceType, name, defaultValue)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(("[ValueBaseUtils.getOrCreateValue] - Value of type %q of name %q is of type %q in %s instead")
				:format(instanceType, name, foundChild.ClassName, foundChild:GetFullName()))
		end

		return foundChild
	else
		local newChild = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = defaultValue
		newChild.Parent = parent

		return newChild
	end
end

function ValueBaseUtils.setValue(parent, instanceType, name, value)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if not foundChild:IsA(instanceType) then
			warn(("[ValueBaseUtils.setValue] - Value of type %q of name %q is of type %q in %s instead")
				:format(instanceType, name, foundChild.ClassName, foundChild:GetFullName()))
		end

		foundChild.Value = value
	else
		local newChild = Instance.new(instanceType)
		newChild.Name = name
		newChild.Value = value
		newChild.Parent = parent
	end
end

function ValueBaseUtils.getValue(parent, instanceType, name, default)
	assert(typeof(parent) == "Instance", "Bad argument 'parent'")
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	local foundChild = parent:FindFirstChild(name)
	if foundChild then
		if foundChild:IsA(instanceType) then
			return foundChild.Value
		else
			warn(("[ValueBaseUtils.getValue] - Value of type %q of name %q is of type %q in %s instead")
				:format(instanceType, name, foundChild.ClassName, foundChild:GetFullName()))
			return nil
		end
	else
		return default
	end
end

function ValueBaseUtils.createGetSet(instanceType, name)
	assert(type(instanceType) == "string", "Bad argument 'instanceType'")
	assert(type(name) == "string", "Bad argument 'name'")

	return function(parent, defaultValue)
		assert(typeof(parent) == "Instance", "Bad argument 'parent'")

		return ValueBaseUtils.getValue(parent, instanceType, name, defaultValue)
	end, function(parent, value)
		assert(typeof(parent) == "Instance", "Bad argument 'parent'")

		return ValueBaseUtils.setValue(parent, instanceType, name, value)
	end, function(parent, defaultValue)
		return ValueBaseUtils.getOrCreateValue(parent, instanceType, name, defaultValue)
	end
end

return ValueBaseUtils  -  Editar
  04:54:13.807    -  Editar
  04:54:13.807  ----- [2471] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.valueobject.Shared.ValueObject -----  -  Editar
  04:54:13.807  --[=[
	To work like value objects in Roblox and track a single item,
	with `.Changed` events
	@class ValueObject
]=]

local require = require(script.Parent.loader).load(script)

local Signal = require("Signal")
local Maid = require("Maid")
local Observable = require("Observable")

local ValueObject = {}
ValueObject.ClassName = "ValueObject"

--[=[
	Constructs a new value object
	@param baseValue T
	@return ValueObject
]=]
function ValueObject.new(baseValue)
	local self = {}

	rawset(self, "_value", baseValue)

	self._maid = Maid.new()

--[=[
	Event fires when the value's object value change
	@prop Changed Signal<T> -- fires with oldValue, newValue
	@within ValueObject
]=]
	self.Changed = Signal.new() -- :Fire(newValue, oldValue, maid)
	self._maid:GiveTask(self.Changed)

	return setmetatable(self, ValueObject)
end

--[=[
	Constructs a new value object
	@param observable Observable<T>
	@return ValueObject<T>
]=]
function ValueObject.fromObservable(observable)
	local result = ValueObject.new()

	result._maid:GiveTask(observable:Subscribe(function(value)
		result.Value = value
	end))

	return result
end

--[=[
	Returns whether the object is a ValueObject class
	@param value any
	@return boolean
]=]
function ValueObject.isValueObject(value)
	return type(value) == "table" and getmetatable(value) == ValueObject
end

--[=[
	Observes the current value of the ValueObject
	@return Observable<T>
]=]
function ValueObject:Observe()
	return Observable.new(function(sub)
		if not self.Destroy then
			warn("[ValueObject.observeValue] - Connecting to dead ValueObject")
			-- No firing, we're dead
			sub:Complete()
			return
		end

		local maid = Maid.new()

		maid:GiveTask(self.Changed:Connect(function()
			sub:Fire(self.Value)
		end))

		sub:Fire(self.Value)

		return maid
	end)

end

--[=[
	The value of the ValueObject
	@prop Value T
	@within ValueObject
]=]
function ValueObject:__index(index)
	if index == "Value" then
		return self._value
	elseif ValueObject[index] then
		return ValueObject[index]
	elseif index == "_value" then
		return nil -- Edge case
	else
		error(("%q is not a member of ValueObject"):format(tostring(index)))
	end
end

function ValueObject:__newindex(index, value)
	if index == "Value" then
		local previous = rawget(self, "_value")
		if previous ~= value then
			rawset(self, "_value", value)

			local maid = Maid.new()

			self.Changed:Fire(value, previous, maid)

			self._maid._valueMaid = maid
		end
	else
		error(("%q is not a member of ValueObject"):format(tostring(index)))
	end
end

--[=[
	Forces the value to be nil on cleanup, cleans up the Maid

	Does not fire the event since 3.5.0
]=]
function ValueObject:Destroy()
	rawset(self, "_value", nil)
	self._maid:DoCleaning()
	setmetatable(self, nil)
end

return ValueObject
  -  Editar
  04:54:13.807    -  Editar
  04:54:13.807  ----- [2472] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.blend.node_modules.@quenty.valueobject.Shared.ValueObjectUtils -----  -  Editar
  04:54:13.807  --[=[
	Utils that work with Roblox Value objects (and also ValueObject)
	@class ValueObjectUtils
]=]

local require = require(script.Parent.loader).load(script)

local Maid = require("Maid")
local Brio = require("Brio")
local Observable = require("Observable")
local ValueObject = require("ValueObject")

local ValueObjectUtils = {}

--[=[
	Syncs the value from `from` to `to`.
	@param from ValueObject<T>
	@param to ValueObject<T>
	@return MaidTask
]=]
function ValueObjectUtils.syncValue(from, to)
	local maid = Maid.new()
	to.Value = from.Value

	maid:GiveTask(from.Changed:Connect(function()
		to.Value = from.Value
	end))

	return maid
end

--[=[
	Observes the current value of the ValueObject
	@param valueObject ValueObject<T>
	@return Observable<T>
]=]
function ValueObjectUtils.observeValue(valueObject)
	assert(ValueObject.isValueObject(valueObject), "Bad valueObject")

	return Observable.new(function(sub)
		if not valueObject.Destroy then
			warn("[ValueObjectUtils.observeValue] - Connecting to dead ValueObject")
			-- No firing, we're dead
			sub:Complete()
			return
		end

		local maid = Maid.new()

		maid:GiveTask(valueObject.Changed:Connect(function()
			sub:Fire(valueObject.Value)
		end))

		sub:Fire(valueObject.Value)

		return maid
	end)
end

--[=[
	Observes the current value of the ValueObject
	@param valueObject ValueObject<T>
	@return Observable<Brio<T>>
]=]
function ValueObjectUtils.observeValueBrio(valueObject)
	assert(valueObject, "Bad valueObject")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function refire()
			local brio = Brio.new(valueObject.Value)
			maid._lastBrio = brio
			sub:Fire(brio)
		end

		maid:GiveTask(valueObject.Changed:Connect(refire))

		refire()

		return maid
	end)
end


return ValueObjectUtils  -  Editar
  04:54:13.808    -  Editar
  04:54:13.808  ----- [2473] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.clienttranslator.Client.JSONTranslator -----  -  Editar
  04:54:13.808  --[=[
	Utility function that loads a translator from a folder or a table.
	@class JSONTranslator
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local JsonToLocalizationTable = require("JsonToLocalizationTable")
local PseudoLocalize = require("PseudoLocalize")
local LocalizationServiceUtils = require("LocalizationServiceUtils")
local Promise = require("Promise")
local Observable = require("Observable")
local Maid = require("Maid")
local Blend = require("Blend")
local Rx = require("Rx")

local JSONTranslator = {}
JSONTranslator.ClassName = "JSONTranslator"
JSONTranslator.__index = JSONTranslator

--[=[
	Constructs a new JSONTranslator from the given args.

	```lua
	local translator = JSONTranslator.new("en", {
		actions = {
			respawn = "Respawn {playerName}";
		};
	})

	print(translator:FormatByKey("actions.respawn"), { playerName = "Quenty"}) --> Respawn Quenty
	```

	```lua
	local translator = JSONTranslator.new(script)
	-- assume there is an `en.json` underneath the script with valid JSON.
	```

	@param ... any
	@return JSONTranslator
]=]
function JSONTranslator.new(...)
	local self = setmetatable({}, JSONTranslator)

	-- Cache localizaiton table, because it can take 10-20ms to load.
	self._localizationTable = JsonToLocalizationTable.toLocalizationTable(...)
	self._englishTranslator = self._localizationTable:GetTranslator("en")
	self._fallbacks = {}

	if RunService:IsRunning() then
		self._promiseTranslator = LocalizationServiceUtils.promiseTranslator(Players.LocalPlayer)
	else
		self._promiseTranslator = Promise.resolved(self._englishTranslator)
	end

	if RunService:IsStudio() then
		PseudoLocalize.addToLocalizationTable(self._localizationTable, nil, "en")
	end

	return self
end

function JSONTranslator:GetLocalizationTable()
	return self._localizationTable
end

--[=[
	Returns a promise that will resolve once the translator is loaded from the cloud.
	@return Promise
]=]
function JSONTranslator:PromiseLoaded()
	return self._promiseTranslator
end

--[=[
	Makes the translator fall back to another translator if an entry cannot be found.

	Mostly just used for testing.

	@param translator JSONTranslator | Translator
]=]
function JSONTranslator:FallbackTo(translator)
	assert(translator, "Bad translator")
	assert(translator.FormatByKey, "Bad translator")

	table.insert(self._fallbacks, translator)
end

--[=[
	Formats the resulting entry by args.
	@param key string
	@param args table?
	@return Promise<string>
]=]
function JSONTranslator:PromiseFormatByKey(key, args)
	assert(self ~= JSONTranslator, "Construct a new version of this class to use it")
	assert(type(key) == "string", "Key must be a string")

	return self._promiseTranslator:Then(function()
		return self:FormatByKey(key, args)
	end)
end

--[=[
	Observes the translated value
	@param key string
	@param argData table? -- May have observables (or convertable to observables) in it.
	@return Observable<string>
]=]
function JSONTranslator:ObserveFormatByKey(key, argData)
	assert(self ~= JSONTranslator, "Construct a new version of this class to use it")
	assert(type(key) == "string", "Key must be a string")

	local argObservable
	if argData then
		local args = {}
		for argKey, value in pairs(argData) do
			args[argKey] = Blend.toPropertyObservable(value) or Rx.of(value)
		end

		argObservable = Rx.combineLatest(args)
	else
		argObservable = nil
	end

	return Observable.new(function(sub)
		local maid = Maid.new()

		maid:GivePromise(self._promiseTranslator:Then(function()
			if argObservable then
				maid:GiveTask(argObservable:Subscribe(function(args)
					sub:Fire(self:FormatByKey(key, args))
				end))
			else
				sub:Fire(self:FormatByKey(key, nil))
			end
		end))

		return maid
	end)
end

--[=[
	Formats or errors if the cloud translations are not loaded.
	@param key string
	@param args table?
	@return string
]=]
function JSONTranslator:FormatByKey(key, args)
	assert(self ~= JSONTranslator, "Construct a new version of this class to use it")
	assert(type(key) == "string", "Key must be a string")

	if not RunService:IsRunning() then
		return self:_formatByKeyTestMode(key, args)
	end

	local clientTranslator = self:_getClientTranslatorOrError()

	local result
	local ok, err = pcall(function()
		result = clientTranslator:FormatByKey(key, args)
	end)

	if ok and not err then
		return result
	end

	if err then
		warn(err)
	else
		warn("Failed to localize '" .. key .. "'")
	end

	-- Fallback to English
	if clientTranslator.LocaleId ~= self._englishTranslator.LocaleId then
		-- Ignore results as we know this may error
		ok, err = pcall(function()
			result = self._englishTranslator:FormatByKey(key, args)
		end)

		if ok and not err then
			return result
		end
	end

	return key
end

function JSONTranslator:_getClientTranslatorOrError()
	assert(self._promiseTranslator, "ClientTranslator is not initialized")

	if self._promiseTranslator:IsFulfilled() then
		return assert(self._promiseTranslator:Wait(), "Failed to get translator")
	else
		error("Translator is not yet acquired yet")
		return nil
	end
end

function JSONTranslator:_formatByKeyTestMode(key, args)
	-- Can't read LocalizationService.ForcePlayModeRobloxLocaleId :(
	local translator = self._localizationTable:GetTranslator("en")
	local result
	local ok, err = pcall(function()
		result = translator:FormatByKey(key, args)
	end)

	if ok and not err then
		return result
	end

	for _, fallback in pairs(self._fallbacks) do
		local value = fallback:FormatByKey(key, args)
		if value then
			return value
		end
	end

	if err then
		warn(err)
	else
		warn("Failed to localize '" .. key .. "'")
	end

	return key
end

--[=[
	Cleans up the translator and deletes the localization table if it exists.
]=]
function JSONTranslator:Destroy()
	self._localizationTable:Destroy()
	self._localizationTable = nil
	self._englishTranslator = nil
	self._promiseTranslator = nil

	setmetatable(self, nil)
end

return JSONTranslator  -  Editar
  04:54:13.808    -  Editar
  04:54:13.808  ----- [2474] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.clienttranslator.Client.LocalizationServiceUtils -----  -  Editar
  04:54:13.808  --[=[
	@class LocalizationServiceUtils
]=]

local require = require(script.Parent.loader).load(script)

local LocalizationService = game:GetService("LocalizationService")
local RunService = game:GetService("RunService")

local Promise = require("Promise")
local ERROR_PUBLISH_REQUIRED = "Publishing the game is required to use GetTranslatorForPlayerAsync API."

local LocalizationServiceUtils = {}

function LocalizationServiceUtils.promiseTranslator(player)
	local asyncTranslatorPromise = Promise.spawn(function(resolve, reject)
		local translator = nil
		local ok, err = pcall(function()
			translator = LocalizationService:GetTranslatorForPlayerAsync(player)
		end)

		if not ok then
			reject(err or "Failed to GetTranslatorForPlayerAsync")
			return
		end

		if translator then
			assert(typeof(translator) == "Instance", "Bad translator")
			resolve(translator)
			return
		end

		reject("Translator was not returned")
		return
	end)

	-- Give longer in non-studio mode
	local timeout = 20
	if RunService:IsStudio() then
		timeout = 0.5
	end

	task.delay(timeout, function()
		if not asyncTranslatorPromise:IsPending() then
			return
		end
		asyncTranslatorPromise:Reject(
			("GetTranslatorForPlayerAsync is still pending after %f, using local table")
			:format(timeout))
	end)

	return asyncTranslatorPromise:Catch(function(err)
		if err ~= ERROR_PUBLISH_REQUIRED then
			warn(("[LocalizationServiceUtils.promiseTranslator] - %s"):format(tostring(err)))
		end

		-- Fallback to just local stuff
		local translator = LocalizationService:GetTranslatorForPlayer(player)
		return translator
	end)
end


return LocalizationServiceUtils  -  Editar
  04:54:13.808    -  Editar
  04:54:13.808  ----- [2475] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.clienttranslator.Shared.JsonToLocalizationTable -----  -  Editar
  04:54:13.808  --[=[
	Utility to build a localization table from json, intended to be used with rojo. Can also handle Rojo json
	objects turned into tables!

	@class JsonToLocalizationTable
]=]

local LocalizationService = game:GetService("LocalizationService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local JsonToLocalizationTable = {}

local LOCALIZATION_TABLE_NAME = "GeneratedJSONTable"

--[[
	Recursively iterates through the object to construct strings and add it to the localization table
	@param localeId string -- The localizationid to add
	@param baseKey string -- the key to add
	@param object any -- The value to iterate over
]]
local function recurseAdd(localizationTable, localeId, baseKey, object)
	if baseKey ~= "" then
		baseKey = baseKey .. "."
	end

	for index, value in pairs(object) do
		local key = baseKey .. index
		if type(value) == "table" then
			recurseAdd(localizationTable, localeId, key, value)
		elseif type(value) == "string" then
			local source = ""
			local context = ""

			if localeId == "en" then
				source = value
			end

			localizationTable:SetEntryValue(key, source, context, localeId, value)
		else
			error("Bad type for value in '" .. key .. "'.")
		end
	end
end

--[=[
	Extracts the locale from the name
	@param name string -- The name to parse
	@return string -- The locale
]=]
function JsonToLocalizationTable.localeFromName(name)
	if name:sub(-5) == ".json" then
		return name:sub(1, #name-5)
	else
		return name
	end
end

function JsonToLocalizationTable.getOrCreateLocalizationTable()
	local localizationTable = LocalizationService:FindFirstChild(LOCALIZATION_TABLE_NAME)

	if not localizationTable then
		localizationTable = Instance.new("LocalizationTable")
		localizationTable.Name = LOCALIZATION_TABLE_NAME

		if RunService:IsRunning() then
			localizationTable.Parent = LocalizationService
		end
	end

	return localizationTable
end

--[=[
	Loads a folder into a localization table
	@param folder Folder -- A Roblox folder with StringValues containing JSON, named with the localization in mind
]=]
function JsonToLocalizationTable.loadFolder(folder)
	local localizationTable = JsonToLocalizationTable.getOrCreateLocalizationTable()

	for _, item in pairs(folder:GetDescendants()) do
		if item:IsA("StringValue") then
			local localeId = JsonToLocalizationTable.localeFromName(item.Name)
			JsonToLocalizationTable.addJsonToTable(localizationTable, localeId, item.Value)
		elseif item:IsA("ModuleScript") then
			local localeId = JsonToLocalizationTable.localeFromName(item.Name)
			recurseAdd(localizationTable, localeId, "", require(item))
		end
	end
	return localizationTable
end

--[=[
	Extracts the locale from the folder, or a locale and table.
	@param first Instance | string
	@param second table?
	@return LocalizationTable
]=]
function JsonToLocalizationTable.toLocalizationTable(first, second)
	if typeof(first) == "Instance" then
		local result = JsonToLocalizationTable.loadFolder(first)
		-- result.Name = ("JSONTable_%s"):format(first.Name)
		return result
	elseif type(first) == "string" and type(second) == "table" then
		local result = JsonToLocalizationTable.loadTable(first, second)
		return result
	else
		error("Bad args")
	end
end

--[=[
	Extracts the locale from the name
	@param localeId string -- the defaultlocaleId
	@param dataTable table -- Data table to load from
	@return LocalizationTable
]=]
function JsonToLocalizationTable.loadTable(localeId, dataTable)
	local localizationTable = JsonToLocalizationTable.getOrCreateLocalizationTable()

	recurseAdd(localizationTable, localeId, "", dataTable)

	return localizationTable
end

--[=[
	Adds json to a localization table
	@param localizationTable LocalizationTable -- The localization table to add to
	@param localeId string -- The localeId to use
	@param json string -- The json to add with
]=]
function JsonToLocalizationTable.addJsonToTable(localizationTable, localeId, json)
	local decodedTable = HttpService:JSONDecode(json)
	recurseAdd(localizationTable, localeId, "", decodedTable)
end

return JsonToLocalizationTable

  -  Editar
  04:54:13.810    -  Editar
  04:54:13.811  ----- [2476] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.clienttranslator.node_modules.@quenty.pseudolocalize.Shared.PseudoLocalize -----  -  Editar
  04:54:13.811  --[=[
    Pseudo localizes text. Useful for verifying translation without having
    actual translations available

    @class PseudoLocalize
]=]

local PseudoLocalize = {}

--[=[
    Translates a line into pseudo text while maintaining params
    @param line string -- The line to translate
    @return string -- The translated line
]=]
function PseudoLocalize.pseudoLocalize(line)
	local charMap = PseudoLocalize.PSEUDO_CHARACTER_MAP
	local out = ""
	local isParam = false

	for start, stop in utf8.graphemes(line) do
		local char = line:sub(start, stop)
		if char == "{" or char == "[" then
			isParam = true
			out = out .. char
		elseif char == "}" or char == "]" then
			isParam = false
			out = out .. char
		elseif not isParam and charMap[char] then
			out = out .. charMap[char]
		else
			out = out .. char
		end
	end

	return out
end

--[=[
    Parses a localization table and adds a pseudo localized locale to the table.

    @param localizationTable LocalizationTable -- LocalizationTable to add to.
    @param preferredLocaleId string? -- Preferred locale to use. Defaults to "qlp-pls"
    @param preferredFromLocale string? -- Preferred from locale. Defaults to "en-us"
    @return string -- The translated line
]=]
function PseudoLocalize.addToLocalizationTable(localizationTable, preferredLocaleId, preferredFromLocale)
	local localeId = preferredLocaleId or "qlp-pls"
	local fromLocale = preferredFromLocale or "en"

	local entries = localizationTable:GetEntries()
	for _, entry in pairs(entries) do
		if not entry.Values[localeId] then
			local line = entry.Values[fromLocale]
			if line then
				entry.Values[localeId] = PseudoLocalize.pseudoLocalize(line)
			else
				warn(("[PseudoLocalize.addToLocalizationTable] - No entry in key %q for locale %q")
					:format(entry.Key, fromLocale))
			end
		end
	end

	localizationTable:SetEntries(entries)
end

--[=[
    Mapping of English characters to pseudo localized characters.

    @prop PSEUDO_CHARACTER_MAP { [string]: string }
    @within PseudoLocalize
]=]
PseudoLocalize.PSEUDO_CHARACTER_MAP = {
    ["a"] = "";
    ["b"] = "";
    ["c"] = "";
    ["d"] = "";
    ["e"] = "";
    ["f"] = "";
    ["g"] = "";
    ["h"] = "";
    ["i"] = "";
    ["j"] = "J";
    ["k"] = "";
    ["l"] = "";
    ["m"] = "";
    ["n"] = "";
    ["o"] = "";
    ["p"] = "";
    ["q"] = "9";
    ["r"] = "";
    ["s"] = "";
    ["t"] = "";
    ["u"] = "";
    ["v"] = "";
    ["w"] = "";
    ["x"] = "";
    ["y"] = "";
    ["z"] = "";
    ["A"] = "";
    ["B"] = "";
    ["C"] = "";
    ["D"] = "";
    ["E"] = "";
    ["F"] = "F";
    ["G"] = "G";
    ["H"] = "H";
    ["I"] = "";
    ["J"] = "J";
    ["K"] = "K";
    ["L"] = "";
    ["M"] = "M";
    ["N"] = "N";
    ["O"] = "";
    ["P"] = "";
    ["Q"] = "Q";
    ["R"] = "R";
    ["S"] = "";
    ["T"] = "T";
    ["U"] = "";
    ["V"] = "V";
    ["W"] = "W";
    ["X"] = "X";
    ["Y"] = "";
    ["Z"] = "Z";
}

return PseudoLocalize
  -  Editar
  04:54:13.812    -  Editar
  04:54:13.812  ----- [2477] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.datastore.Server.DataStore -----  -  Editar
  04:54:13.812  --[=[
	Wraps the datastore object to provide async cached loading and saving. See [DataStoreStage] for more API.

	Has the following features
	* Automatic save
	* Jitter
	* De-duplication (only updates data it needs)

	```lua
	local playerMoneyValue = Instance.new("IntValue")
	playerMoneyValue.Value = 0

	local dataStore = DataStore.new(DataStoreService:GetDataStore("test"), test-store")
	dataStore:Load("money", 0):Then(function(money)
		playerMoneyValue.Value = money
		dataStore:StoreOnValueChange("money", playerMoneyValue)
	end):Catch(function()
		-- TODO: Notify player
	end)

	```

	@server
	@class DataStore
]=]

local require = require(script.Parent.loader).load(script)

local DataStoreDeleteToken = require("DataStoreDeleteToken")
local DataStorePromises = require("DataStorePromises")
local DataStoreStage = require("DataStoreStage")
local Maid = require("Maid")
local Promise = require("Promise")
local Signal = require("Signal")

local DEBUG_WRITING = false

local AUTO_SAVE_TIME = 60*5
local CHECK_DIVISION = 15
local JITTER = 20 -- Randomly assign jitter so if a ton of players join at once we don't hit the datastore at once

local DataStore = setmetatable({}, DataStoreStage)
DataStore.ClassName = "DataStore"
DataStore.__index = DataStore

--[=[
	Constructs a new DataStore. See [DataStoreStage] for more API.
	@param robloxDataStore DataStore
	@param key string
]=]
function DataStore.new(robloxDataStore, key)
	local self = setmetatable(DataStoreStage.new(), DataStore)

	self._key = key or error("No key")
	self._robloxDataStore = robloxDataStore or error("No robloxDataStore")

--[=[
	Prop that fires when saving. Promise will resolve once saving is complete.
	@prop Saving Signal<Promise>
	@within DataStore
]=]
	self.Saving = Signal.new() -- :Fire(promise)
	self._maid:GiveTask(self.Saving)

	task.spawn(function()
		while self.Destroy do
			for _=1, CHECK_DIVISION do
				task.wait(AUTO_SAVE_TIME/CHECK_DIVISION)
				if not self.Destroy then
					break
				end
			end

			if not self.Destroy then
				break
			end

			-- Apply additional jitter on auto-save
			task.wait(math.random(1, JITTER))

			if not self.Destroy then
				break
			end

			self:Save()
		end
	end)

	return self
end

--[=[
	Returns the full path for the datastore
	@return string
]=]
function DataStore:GetFullPath()
	return ("RobloxDataStore@%s"):format(self._key)
end

--[=[
	Returns whether the datastore failed.
	@return boolean
]=]
function DataStore:DidLoadFail()
	if not self._loadPromise then
		return false
	end

	if self._loadPromise:IsRejected() then
		return true
	end

	return false
end

function DataStore:PromiseLoadSuccessful()
	return self._maid:GivePromise(self:_promiseLoad()):Then(function()
		return true
	end, function()
		return false
	end)
end

--[=[
	Saves all stored data.
	@return Promise
]=]
function DataStore:Save()
	if self:DidLoadFail() then
		warn("[DataStore] - Not saving, failed to load")
		return Promise.rejected("Load not successful, not saving")
	end

	if DEBUG_WRITING then
		print("[DataStore.Save] - Starting save routine")
	end

	-- Avoid constructing promises for every callback down the datastore
	-- upon save.
	return (self:_promiseInvokeSavingCallbacks() or Promise.resolved())
		:Then(function()
			if not self:HasWritableData() then
				-- Nothing to save, don't update anything
				if DEBUG_WRITING then
					print("[DataStore.Save] - Not saving, nothing staged")
				end
				return nil
			else
				return self:_saveData(self:GetNewWriter())
			end
		end)
end

--[=[
	Loads data. This returns the originally loaded data.
	@param keyName string
	@param defaultValue any?
	@return any?
]=]
function DataStore:Load(keyName, defaultValue)
	return self:_promiseLoad()
		:Then(function(data)
			return self:_afterLoadGetAndApplyStagedData(keyName, data, defaultValue)
		end)
end

function DataStore:_saveData(writer)
	local maid = Maid.new()

	local promise = Promise.new()
	promise:Resolve(maid:GivePromise(DataStorePromises.updateAsync(self._robloxDataStore, self._key, function(data)
		if promise:IsRejected() then
			-- Cancel if we have another request
			return nil
		end

		data = writer:WriteMerge(data or {})
		assert(data ~= DataStoreDeleteToken, "Cannot delete from UpdateAsync")

		if DEBUG_WRITING then
			print("[DataStore] - Writing", game:GetService("HttpService"):JSONEncode(data))
		end

		return data
	end, function(err)
		-- Might be caused by Maid rejecting state
		warn("[DataStore] - Failed to UpdateAsync data", err)
		return Promise.rejected(err)
	end)))

	self._maid._saveMaid = maid

	if self.Saving.Destroy then
		self.Saving:Fire(promise)
	end

	return promise
end

function DataStore:_promiseLoad()
	if self._loadPromise then
		return self._loadPromise
	end

	self._loadPromise = self._maid:GivePromise(DataStorePromises.getAsync(self._robloxDataStore, self._key)
		:Then(function(data)
			if data == nil then
				return {}
			elseif type(data) == "table" then
				return data
			else
				return Promise.rejected("Failed to load data. Wrong type '" .. type(data) .. "'")
			end
		end, function(err)
			-- Log:
			warn("[DataStore] - Failed to GetAsync data", err)
			return Promise.rejected(err)
		end))

	return self._loadPromise
end

return DataStore  -  Editar
  04:54:13.812    -  Editar
  04:54:13.812  ----- [2478] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.datastore.Server.Modules.DataStoreDeleteToken -----  -  Editar
  04:54:13.812  --[=[
	Token to use for deleting.
	@server
	@class DataStoreDeleteToken
]=]

local require = require(script.Parent.loader).load(script)

local Symbol = require("Symbol")

return Symbol.named("dataStoreDeleteToken")  -  Editar
  04:54:13.812    -  Editar
  04:54:13.812  ----- [2479] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.datastore.Server.Modules.DataStoreStage -----  -  Editar
  04:54:13.813  --[=[
	Provides a data storage facility with an ability to get sub-stores. So you can write
	directly to this store, overwriting all children, or you can have more partial control
	at children level. This minimizes accidently overwriting.
	The big cost here is that we may leave keys that can't be removed.

	@server
	@class DataStoreStage
]=]

local require = require(script.Parent.loader).load(script)

local BaseObject = require("BaseObject")
local DataStoreDeleteToken = require("DataStoreDeleteToken")
local DataStoreWriter = require("DataStoreWriter")
local Promise = require("Promise")
local PromiseUtils = require("PromiseUtils")
local Signal = require("Signal")
local Table = require("Table")

local DataStoreStage = setmetatable({}, BaseObject)
DataStoreStage.ClassName = "DataStoreStage"
DataStoreStage.__index = DataStoreStage

--[=[
	Constructs a new DataStoreStage to load from. Prefer to use DataStore because this doesn't
	have any way to retrieve this.
	@param loadName string
	@param loadParent DataStoreStage?
	@return DataStoreStage
]=]
function DataStoreStage.new(loadName, loadParent)
	local self = setmetatable(BaseObject.new(), DataStoreStage)

	-- LoadParent is optional, used for loading
	self._loadName = loadName
	self._loadParent = loadParent

	self._savingCallbacks = {} -- [func, ...]
	self._takenKeys = {} -- [name] = true
	self._stores = {} -- [name] = dataSubStore

	return self
end

-- Also returns nil for speedyness
function DataStoreStage:_promiseInvokeSavingCallbacks()
	if not next(self._savingCallbacks) then
		return nil
	end

	local removingPromises = {}
	for _, func in pairs(self._savingCallbacks) do
		local result = func()
		if Promise.isPromise(result) then
			table.insert(removingPromises, result)
		end
	end

	for _, substore in pairs(self._stores) do
		local promise = substore:_promiseInvokeSavingCallbacks()
		if promise then
			table.insert(removingPromises, promise)
		end
	end

	return PromiseUtils.all(removingPromises)
end

--[=[
	Adds a callback to be called before save. This may return a promise.
	@param callback function -- May return a promise
	@return function -- Call to remove
]=]
function DataStoreStage:AddSavingCallback(callback)
	assert(type(callback) == "function", "Bad callback")

	table.insert(self._savingCallbacks, callback)

	return function()
		self:RemoveSavingCallback(callback)
	end
end

--[=[
	Removes a saving callback from the data store stage
	@param callback function
]=]
function DataStoreStage:RemoveSavingCallback(callback)
	assert(type(callback) == "function", "Bad callback")

	local index = table.find(self._savingCallbacks, callback)
	if index then
		table.remove(self._savingCallbacks, index)
	end
end

--[=[
	Gets an event that will fire off whenever something is stored at this level
	@return Signal
]=]
function DataStoreStage:GetTopLevelDataStoredSignal()
	if self._topLevelStoreSignal then
		return self._topLevelStoreSignal
	end

	self._topLevelStoreSignal = Signal.new()
	self._maid:GiveTask(self._topLevelStoreSignal)
	return self._topLevelStoreSignal
end

--[=[
	Retrieves the full path of this datastore stage for diagnostic purposes.
	@return string
]=]
function DataStoreStage:GetFullPath()
	if self._loadParent then
		return self._loadParent:GetFullPath() .. "." .. tostring(self._loadName)
	else
		return tostring(self._loadName)
	end
end

--[=[
	Loads the data at the `name`.
	@param name string
	@param defaultValue T?
	@return Promise<T>
]=]
function DataStoreStage:Load(name, defaultValue)
	if not self._loadParent then
		error("[DataStoreStage.Load] - Failed to load, no loadParent!")
	end
	if not self._loadName then
		error("[DataStoreStage.Load] - Failed to load, no loadName!")
	end

	if self._dataToSave and self._dataToSave[name] ~= nil then
		if self._dataToSave[name] == DataStoreDeleteToken then
			return Promise.resolved(defaultValue)
		else
			return Promise.resolved(self._dataToSave[name])
		end
	end

	return self._loadParent:Load(self._loadName, {}):Then(function(data)
		return self:_afterLoadGetAndApplyStagedData(name, data, defaultValue)
	end)
end

-- Protected!
function DataStoreStage:_afterLoadGetAndApplyStagedData(name, data, defaultValue)
	if self._dataToSave and self._dataToSave[name] ~= nil then
		if self._dataToSave[name] == DataStoreDeleteToken then
			return defaultValue
		else
			return self._dataToSave[name]
		end
	elseif self._stores[name] then
		if self._stores[name]:HasWritableData() then
			local writer = self._stores[name]:GetNewWriter()
			local original = Table.deepCopy(data[name] or {})
			writer:WriteMerge(original)
			return original
		end
	end

	if data[name] == nil then
		return defaultValue
	else
		return data[name]
	end
end

--[=[
	Explicitely deletes data at the key
	@param name string
]=]
function DataStoreStage:Delete(name)
	if self._takenKeys[name] then
		error(("[DataStoreStage] - Already have a writer for %q"):format(name))
	end

	self:_doStore(name, DataStoreDeleteToken)
end

--[=[
	Queues up a wipe of all values. Data must load before it can be wiped.
]=]
function DataStoreStage:Wipe()
	return self._loadParent:Load(self._loadName, {})
		:Then(function(data)
			for key, _ in pairs(data) do
				if self._stores[key] then
					self._stores[key]:Wipe()
				else
					self:_doStore(key, DataStoreDeleteToken)
				end
			end
		end)
end

function DataStoreStage:Store(name, value)
	if self._takenKeys[name] then
		error(("[DataStoreStage] - Already have a writer for %q"):format(name))
	end

	if value == nil then
		value = DataStoreDeleteToken
	end

	self:_doStore(name, value)
end

--[=[
	Gets a sub-datastore that will write at the given name point
	@param name string
	@return DataStoreStage
]=]
function DataStoreStage:GetSubStore(name)
	assert(type(name) == "string", "Bad name")

	if self._stores[name] then
		return self._stores[name]
	end

	if self._takenKeys[name] then
		error(("[DataStoreStage.GetSubStore] - Already have a writer for %q"):format(name))
	end

	local newStore = DataStoreStage.new(name, self)
	self._takenKeys[name] = true
	self._maid:GiveTask(newStore)

	self._stores[name] = newStore

	return newStore
end

--[=[
	Whenever the ValueObject changes, stores the resulting value in that entry.
	@param name string
	@param valueObj Instance -- ValueBase object to store on
	@return MaidTask
]=]
function DataStoreStage:StoreOnValueChange(name, valueObj)
	assert(type(name) == "string", "Bad name")
	assert(typeof(valueObj) == "Instance", "Bad valueObj")

	if self._takenKeys[name] then
		error(("[DataStoreStage] - Already have a writer for %q"):format(name))
	end

	self._takenKeys[name] = true
	local conn = valueObj.Changed:Connect(function()
		self:_doStore(name, valueObj.Value)
	end)
	self._maid:GiveTask(conn)
	return conn
end

--[=[
	If these is data not yet written then this will return true
	@return boolean
]=]
function DataStoreStage:HasWritableData()
	if self._dataToSave then
		return true
	end

	for name, store in pairs(self._stores) do
		if not store.Destroy then
			warn(("[DataStoreStage] - Substore %q destroyed"):format(name))
			continue
		end

		if store:HasWritableData() then
			return true
		end
	end

	return false
end

--[=[
	Constructs a writer which provides a snapshot of the current data state to write
	@return DataStoreWriter
]=]
function DataStoreStage:GetNewWriter()
	local writer = DataStoreWriter.new()
	if self._dataToSave then
		writer:SetRawData(self._dataToSave)
	end

	for name, store in pairs(self._stores) do
		if not store.Destroy then
			warn(("[DataStoreStage] - Substore %q destroyed"):format(name))
			continue
		end

		if store:HasWritableData() then
			writer:AddWriter(name, store:GetNewWriter())
		end
	end

	return writer
end

-- Stores the data for overwrite.
function DataStoreStage:_doStore(name, value)
	assert(type(name) == "string" or type(name) == "number", "Bad name")
	assert(value ~= nil, "Bad value")

	local newValue
	if value == DataStoreDeleteToken then
		newValue = DataStoreDeleteToken
	elseif type(value) == "table" then
		newValue = Table.deepCopy(value)
	else
		newValue = value
	end

	if not self._dataToSave then
		self._dataToSave = {}
	end

	self._dataToSave[name] = newValue
	if self._topLevelStoreSignal then
		self._topLevelStoreSignal:Fire()
	end
end


return DataStoreStage  -  Editar
  04:54:13.813    -  Editar
  04:54:13.813  ----- [2480] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.datastore.Server.Modules.DataStoreWriter -----  -  Editar
  04:54:13.813  --[=[
	Captures a snapshot of data to write and then merges it with the original.
	@server
	@class DataStoreWriter
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")
local DataStoreDeleteToken = require("DataStoreDeleteToken")

local DataStoreWriter = {}
DataStoreWriter.ClassName = "DataStoreWriter"
DataStoreWriter.__index = DataStoreWriter

--[=[
	Constructs a new DataStoreWriter. In general, you will not use this API directly.

	@return DataStoreWriter
]=]
function DataStoreWriter.new()
	local self = setmetatable({}, DataStoreWriter)

	self._rawSetData = {}
	self._writers = {}

	return self
end

--[=[
	Sets the ray data to write
	@param data table
]=]
function DataStoreWriter:SetRawData(data)
	self._rawSetData = Table.deepCopy(data)
end

--[=[
	Adds a recursive child writer to use at the key `name`
	@param name string
	@param writer DataStoreWriter
]=]
function DataStoreWriter:AddWriter(name, writer)
	assert(type(name) == "string", "Bad name")
	assert(not self._writers[name], "Writer already exists for name")
	assert(writer, "Bad writer")

	self._writers[name] = writer
end

--[=[
	Merges the new data into the original value

	@param original table?
	@return table -- The original table
]=]
function DataStoreWriter:WriteMerge(original)
	original = original or {}

	for key, value in pairs(self._rawSetData) do
		if value == DataStoreDeleteToken then
			original[key] = nil
		else
			original[key] = value
		end
	end

	for key, writer in pairs(self._writers) do
		if self._rawSetData[key] ~= nil then
			warn(("[DataStoreWriter.WriteMerge] - Overwritting key %q already saved as rawData with a writer")
				:format(tostring(key)))
		end

		local result = writer:WriteMerge(original[key])
		if result == DataStoreDeleteToken then
			original[key] = nil
		else
			original[key] = result
		end
	end

	return original
end

return DataStoreWriter  -  Editar
  04:54:13.813    -  Editar
  04:54:13.813  ----- [2481] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.datastore.Server.PlayerDataStoreManager -----  -  Editar
  04:54:13.813  --[=[
	DataStore manager for player that automatically saves on player leave and game close.

	@server
	@class PlayerDataStoreManager
]=]

local require = require(script.Parent.loader).load(script)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local BaseObject = require("BaseObject")
local DataStore = require("DataStore")
local PromiseUtils = require("PromiseUtils")
local PendingPromiseTracker = require("PendingPromiseTracker")
local Maid = require("Maid")
local Promise = require("Promise")

local PlayerDataStoreManager = setmetatable({}, BaseObject)
PlayerDataStoreManager.ClassName = "PlayerDataStoreManager"
PlayerDataStoreManager.__index = PlayerDataStoreManager

--[=[
	Constructs a new PlayerDataStoreManager.
	@param robloxDataStore DataStore
	@param keyGenerator (player) -> string -- Function that takes in a player, and outputs a key
	@return PlayerDataStoreManager
]=]
function PlayerDataStoreManager.new(robloxDataStore, keyGenerator)
	local self = setmetatable(BaseObject.new(), PlayerDataStoreManager)

	self._robloxDataStore = robloxDataStore or error("No robloxDataStore")
	self._keyGenerator = keyGenerator or error("No keyGenerator")

	self._maid._savingConns = Maid.new()

	self._datastores = {} -- [player] = datastore
	self._removing = {} -- [player] = true
	self._pendingSaves = PendingPromiseTracker.new()
	self._removingCallbacks = {} -- [func, ...]

	self._maid:GiveTask(Players.PlayerRemoving:Connect(function(player)
		if self._disableSavingInStudio then
			return
		end

		self:_removePlayerDataStore(player)
	end))

	game:BindToClose(function()
		if self._disableSavingInStudio then
			return
		end

		self:PromiseAllSaves():Wait()
	end)

	return self
end

--[=[
	For if you want to disable saving in studio for faster close time!
]=]
function PlayerDataStoreManager:DisableSaveOnCloseStudio()
	assert(RunService:IsStudio())

	self._disableSavingInStudio = true
end

--[=[
	Adds a callback to be called before save on removal
	@param callback function -- May return a promise
]=]
function PlayerDataStoreManager:AddRemovingCallback(callback)
	table.insert(self._removingCallbacks, callback)
end

--[=[
	Callable to allow manual GC so things can properly clean up.
	This can be used to pre-emptively cleanup players.

	@param player Player
]=]
function PlayerDataStoreManager:RemovePlayerDataStore(player)
	self:_removePlayerDataStore(player)
end

--[=[
	@param player Player
	@return DataStore
]=]
function PlayerDataStoreManager:GetDataStore(player)
	assert(typeof(player) == "Instance", "Bad player")
	assert(player:IsA("Player"), "Bad player")

	if self._removing[player] then
		warn("[PlayerDataStoreManager.GetDataStore] - Called GetDataStore while player is removing, cannot retrieve")
		return nil
	end

	if self._datastores[player] then
		return self._datastores[player]
	end

	return self:_createDataStore(player)
end

--[=[
	Removes all player data stores, and returns a promise that
	resolves when all pending saves are saved.
	@return Promise
]=]
function PlayerDataStoreManager:PromiseAllSaves()
	for player, _ in pairs(self._datastores) do
		self:_removePlayerDataStore(player)
	end
	return self._maid:GivePromise(PromiseUtils.all(self._pendingSaves:GetAll()))
end

function PlayerDataStoreManager:_createDataStore(player)
	assert(not self._datastores[player], "Bad player")

	local datastore = DataStore.new(self._robloxDataStore, self:_getKey(player))

	self._maid._savingConns[player] = datastore.Saving:Connect(function(promise)
		self._pendingSaves:Add(promise)
	end)

	self._datastores[player] = datastore

	return datastore
end

function PlayerDataStoreManager:_removePlayerDataStore(player)
	assert(typeof(player) == "Instance", "Bad player")
	assert(player:IsA("Player"), "Bad player")

	local datastore = self._datastores[player]
	if not datastore then
		return
	end

	self._removing[player] = true

	local removingPromises = {}
	for _, func in pairs(self._removingCallbacks) do
		local result = func(player)
		if Promise.isPromise(result) then
			table.insert(removingPromises, result)
		end
	end

	PromiseUtils.all(removingPromises)
		:Then(function()
			return datastore:Save()
		end)
		:Finally(function()
			datastore:Destroy()
			self._removing[player] = nil
		end)

	-- Prevent double removal or additional issues
	self._datastores[player] = nil
	self._maid._savingConns[player] = nil
end

function PlayerDataStoreManager:_getKey(player)
	return self._keyGenerator(player)
end

return PlayerDataStoreManager  -  Editar
  04:54:13.813    -  Editar
  04:54:13.813  ----- [2482] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.datastore.Server.PlayerDataStoreService -----  -  Editar
  04:54:13.814  --[=[
	Centralized service using serviceBag. This will let other packages work with a single player datastore service.

	@server
	@class PlayerDataStoreService
]=]

local require = require(script.Parent.loader).load(script)

local PlayerDataStoreManager = require("PlayerDataStoreManager")
local DataStorePromises = require("DataStorePromises")
local Promise = require("Promise")
local Maid = require("Maid")

local PlayerDataStoreService = {}

--[=[
	Initializes the PlayerDataStoreService. Should be done via [ServiceBag.Init].
	@param serviceBag ServiceBag
]=]
function PlayerDataStoreService:Init(serviceBag)
	self._serviceBag = assert(serviceBag, "No serviceBag")

	self._maid = Maid.new()
	self._started = Promise.new()
	self._maid:GiveTask(self._started)

	self._dataStoreName = "PlayerData"
	self._dataStoreScope = "SaveData"
end

--[=[
	Initializes the datastore service for players. Should be done via [ServiceBag.Start].
]=]
function PlayerDataStoreService:Start()
	-- Give time for configuration
	self._started:Resolve()
end

--[=[
	Sets the name for the datastore to retrieve.

	:::info
	Must be done before start and after init.
	:::

	@param dataStoreName string
]=]
function PlayerDataStoreService:SetDataStoreName(dataStoreName)
	assert(type(dataStoreName) == "string", "Bad dataStoreName")
	assert(self._started, "Not initialized")
	assert(self._started:IsPending(), "Already started, cannot configure")

	self._dataStoreName = dataStoreName
end

--[=[
	Sets the scope for the datastore to retrieve.

	:::info
	Must be done before start and after init.
	:::

	@param dataStoreScope string
]=]
function PlayerDataStoreService:SetDataStoreScope(dataStoreScope)
	assert(type(dataStoreScope) == "string", "Bad dataStoreScope")
	assert(self._started, "Not initialized")
	assert(self._started:IsPending(), "Already started, cannot configure")

	self._dataStoreScope = dataStoreScope
end

--[=[
	Gets the datastore for the player.
	@param player Player
	@return Promise<DataStore>
]=]
function PlayerDataStoreService:PromiseDataStore(player)
	return self:PromiseManager()
		:Then(function(manager)
			return manager:GetDataStore(player)
		end)
end

--[=[
	Adds a removing callback to the manager.
	@param callback function -- May return a promise
	@return Promise
]=]
function PlayerDataStoreService:PromiseAddRemovingCallback(callback)
	return self:PromiseManager()
		:Then(function(manager)
			manager:AddRemovingCallback(callback)
		end)
end

--[=[
	Retrieves the manager
	@return PlayerDataStoreManager
]=]
function PlayerDataStoreService:PromiseManager()
	if self._dataStoreManagerPromise then
		return self._dataStoreManagerPromise
	end

	self._dataStoreManagerPromise = self._started
		:Then(function()
			return DataStorePromises.promiseDataStore(self._dataStoreName, self._dataStoreScope)
		end)
		:Then(function(dataStore)
			local manager = PlayerDataStoreManager.new(
				dataStore,
				function(player)
					return tostring(player.UserId)
				end)
			self._maid:GiveTask(manager)
			return manager
		end)

	return self._dataStoreManagerPromise
end

return PlayerDataStoreService  -  Editar
  04:54:13.814    -  Editar
  04:54:13.814  ----- [2483] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.datastore.Server.Utility.DataStorePromises -----  -  Editar
  04:54:13.814  --[=[
	Utility methods to interactive with Roblox datastores.
	@server
	@class DataStorePromises
]=]

local require = require(script.Parent.loader).load(script)

local Promise = require("Promise")
local DataStoreService = game:GetService("DataStoreService")

local DataStorePromises = {}

--[=[
	Promises a Roblox datastore object with the name and scope. Generally only fails
	when you haven't published the place.
	@param name string
	@param scope string
	@return Promise<DataStore>
]=]
function DataStorePromises.promiseDataStore(name, scope)
	assert(type(name) == "string", "Bad name")
	assert(type(scope) == "string", "Bad scope")

	return Promise.new(function(resolve, reject)
		local result = nil
		local ok, err = pcall(function()
			result = DataStoreService:GetDataStore(name, scope)
		end)
		if not ok then
			return reject(err)
		end
		return resolve(result)
	end)

end

--[=[
	Wraps :GetAsync() in a promise
	@param robloxDataStore DataStore
	@param key string
	@return Promise<T>
]=]
function DataStorePromises.getAsync(robloxDataStore, key)
	assert(typeof(robloxDataStore) == "Instance", "Bad robloxDataStore")
	assert(type(key) == "string", "Bad key")

	return Promise.spawn(function(resolve, reject)
		local result = nil
		local ok, err = pcall(function()
			result = robloxDataStore:GetAsync(key)
		end)
		if not ok then
			return reject(err)
		end
		return resolve(result)
	end)
end

--[=[
	Wraps :UpdateAsync() in a promise
	@param robloxDataStore DataStore
	@param key string
	@param updateFunc (T) -> T?
	@return Promise<boolean>
]=]

function DataStorePromises.updateAsync(robloxDataStore, key, updateFunc)
	assert(typeof(robloxDataStore) == "Instance", "Bad robloxDataStore")
	assert(type(key) == "string", "Bad key")
	assert(type(updateFunc) == "function", "Bad updateFunc")

	return Promise.spawn(function(resolve, reject)
		local result = nil
		local ok, err = pcall(function()
			result = { robloxDataStore:UpdateAsync(key, updateFunc) }
		end)
		if not ok then
			return reject(err)
		end
		if not result then
			return reject("No result loaded")
		end
		return resolve(unpack(result))
	end)
end

--[=[
	Wraps :SetAsync() in a promise
	@param robloxDataStore DataStore
	@param key string
	@param value string
	@return Promise<boolean>
]=]
function DataStorePromises.setAsync(robloxDataStore, key, value)
	assert(typeof(robloxDataStore) == "Instance", "Bad robloxDataStore")
	assert(type(key) == "string", "Bad key")

	return Promise.spawn(function(resolve, reject)
		local ok, err = pcall(function()
			robloxDataStore:SetAsync(key, value)
		end)
		if not ok then
			return reject(err)
		end
		return resolve(true)
	end)
end

--[=[
	Wraps :IncrementAsync() in a promise
	@param robloxDataStore DataStore
	@param key string
	@param delta number
	@return Promise<boolean>
]=]
function DataStorePromises.promiseIncrementAsync(robloxDataStore, key, delta)
	assert(typeof(robloxDataStore) == "Instance", "Bad robloxDataStore")
	assert(type(key) == "string", "Bad key")
	assert(type(delta) == "number" or delta == nil, "Bad delta")

	return Promise.spawn(function(resolve, reject)
		local ok, err = pcall(function()
			robloxDataStore:IncrementAsync(key, delta)
		end)
		if not ok then
			return reject(err)
		end
		return resolve(true)
	end)
end

--[=[
	Wraps :RemoveAsync() in a promise
	@param robloxDataStore DataStore
	@param key string
	@return Promise<boolean>
]=]
function DataStorePromises.removeAsync(robloxDataStore, key)
	assert(typeof(robloxDataStore) == "Instance", "Bad robloxDataStore")
	assert(type(key) == "string", "Bad key")

	return Promise.spawn(function(resolve, reject)
		local ok, err = pcall(function()
			robloxDataStore:RemoveAsync(key)
		end)
		if not ok then
			return reject(err)
		end
		return resolve(true)
	end)
end

return DataStorePromises  -  Editar
  04:54:13.814    -  Editar
  04:54:13.814  ----- [2484] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.math.Shared.Math -----  -  Editar
  04:54:13.814  --[=[
	Holds utilty math functions not available on Roblox's math library.
	@class Math
]=]

local Math = {}

--[=[
	Maps a number from one range to another.

	:::note
	Note the mapped value can be outside of the initial range,
	which is very useful for linear interpolation.
	:::

	```lua
	print(Math.map(0.1, 0, 1, 1, 0)) --> 0.9
	```

	@param num number
	@param min0 number
	@param max0 number
	@param min1 number
	@param max1 number
	@return number
]=]
function Math.map(num: number, min0: number, max0: number, min1: number, max1: number): number
	if max0 == min0 then
		error("Range of zero")
	end

	return (((num - min0)*(max1 - min1)) / (max0 - min0)) + min1
end

--[=[
	Interpolates betweeen two numbers, given an percent. The percent is
	a number in the range that will be used to define how interpolated
	it is between num0 and num1.

	```lua
	print(Math.lerp(-1000, 1000, 0.75)) --> 500
	```

	@param num0 number -- Number
	@param num1 number -- Second number
	@param percent number -- The percent
	@return number -- The interpolated
]=]
function Math.lerp(num0: number, num1: number, percent: number): number
	return num0 + ((num1 - num0) * percent)
end

--[=[
	Solving for angle across from c

	@param a number
	@param b number
	@param c number
	@return number? -- Returns nil if this cannot be solved for
]=]
function Math.lawOfCosines(a: number, b: number, c: number): number?
	local l = (a*a + b*b - c*c) / (2 * a * b)
	local angle = math.acos(l)
	if angle ~= angle then
		return nil
	end
	return angle
end

--[=[
	Round the given number to given precision

	```lua
	print(Math.round(72.1, 5)) --> 75
	```

	@param number number
	@param precision number? -- Defaults to 1
	@return number
]=]
function Math.round(number: number, precision: number?): number
	if precision then
		return math.floor((number/precision) + 0.5) * precision
	else
		return math.floor(number + 0.5)
	end
end

--[=[
	Rounds up to the given precision

	@param number number
	@param precision number
	@return number
]=]
function Math.roundUp(number: number, precision: number): number
	return math.ceil(number/precision) * precision
end

--[=[
	Rounds down to the given precision

	@param number number
	@param precision number
	@return number
]=]
function Math.roundDown(number: number, precision: number): number
	return math.floor(number/precision) * precision
end

return Math  -  Editar
  04:54:13.814    -  Editar
  04:54:13.814  ----- [2485] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.servicebag.Shared.ServiceBag -----  -  Editar
  04:54:13.814  --[=[
	Service bags handle recursive initialization of services, and the
	retrieval of services from a given source. This allows the composition
	of services without the initialization of those services becoming a pain,
	which makes refactoring downstream services very easy.

	This also allows multiple copies of a service to exist at once, although
	many services right now are not designed for this.

	```lua
	local serviceBag = ServiceBag.new()

	serviceBag:GetService({
		Init = function(self)
			print("Service initialized")
		end;
	})
	serviceBag:Init()
	serviceBag:Start()
	```

	@class ServiceBag
]=]

local require = require(script.Parent.loader).load(script)

local Signal = require("Signal")
local BaseObject = require("BaseObject")

--[=[
	@interface Service
	.Init: function?
	.Start: function?
	.Destroy: function?
	@within ServiceBag
]=]

--[=[
	@type ServiceType Service | ModuleScript
	@within ServiceBag
]=]

local ServiceBag = setmetatable({}, BaseObject)
ServiceBag.ClassName = "ServiceBag"
ServiceBag.__index = ServiceBag

--[=[
	Constructs a new ServiceBag

	@param parentProvider ServiceBag? -- Optional parent provider to find services in
	@return ServiceBag
]=]
function ServiceBag.new(parentProvider)
	local self = setmetatable(BaseObject.new(), ServiceBag)

	self._services = {}
	self._parentProvider = parentProvider

	self._serviceTypesToInitializeSet = {}
	self._initializedServiceTypeSet = {}
	self._initializing = false

	self._serviceTypesToStart = {}

	self._destroying = Signal.new()
	self._maid:GiveTask(self._destroying)

	return self
end

--[=[
	Returns whether the value is a serviceBag

	@param value ServiceBag?
	@return boolean
]=]
function ServiceBag.isServiceBag(value)
	return type(value) == "table"
		and value.ClassName == "ServiceBag"
end

--[=[
	Retrieves the service, ensuring initialization if we are in
	the initialization phase.

	@param serviceType ServiceType
	@return any
]=]
function ServiceBag:GetService(serviceType)
	if typeof(serviceType) == "Instance" then
		serviceType = require(serviceType)
	end

	assert(type(serviceType) == "table", "Bad serviceType definition")

	local service = self._services[serviceType]
	if service then
		self:_ensureInitialization(serviceType)
		return self._services[serviceType]
	else
		if self._parentProvider then
			return self._parentProvider:GetService(serviceType)
		end

		-- Try to add the service if we're still initializing services
		self:_addServiceType(serviceType)
		self:_ensureInitialization(serviceType)
		return self._services[serviceType]
	end
end

--[=[
	Returns whether the service bag has the service.
	@param serviceType ServiceType
	@return boolean
]=]
function ServiceBag:HasService(serviceType)
	if typeof(serviceType) == "Instance" then
		serviceType = require(serviceType)
	end

	if self._services[serviceType] then
		return true
	else
		return false
	end
end

--[=[
	Initializes the service bag and ensures recursive initialization
	can occur
]=]
function ServiceBag:Init()
	assert(not self._initializing, "Already initializing")
	assert(self._serviceTypesToInitializeSet, "Already initialized")
	self._initializing = true

	while next(self._serviceTypesToInitializeSet) do
		local serviceType = next(self._serviceTypesToInitializeSet)
		self._serviceTypesToInitializeSet[serviceType] = nil

		self:_ensureInitialization(serviceType)
	end

	self._serviceTypesToInitializeSet = nil
	self._initializing = false
end

--[=[
	Starts the service bag and all services
]=]
function ServiceBag:Start()
	assert(self._serviceTypesToStart, "Already started")
	assert(not self._initializing, "Still initializing")

	while next(self._serviceTypesToStart) do
		local serviceType = table.remove(self._serviceTypesToStart)
		local service = assert(self._services[serviceType], "No service")

		if service.Start then
			local current
			task.spawn(function()
				current = coroutine.running()
				service:Start()
			end)

			assert(coroutine.status(current) == "dead", "Starting service yielded")
		end
	end

	self._serviceTypesToStart = nil
end

--[=[
	Returns whether the service bag has fully started or not.
	@return boolean
]=]
function ServiceBag:IsStarted()
	return self._serviceTypesToStart == nil
end

--[=[
	Creates a scoped service bag, where services within the scope will not
	be accessible outside of the scope.

	@return ServiceBag
]=]
function ServiceBag:CreateScope()
	local provider = ServiceBag.new(self)

	self:_addServiceType(provider)

	-- Remove from parent provider
	self._maid[provider] = provider._destroying:Connect(function()
		self._maid[provider] = nil
		self._services[provider] = nil
	end)

	return provider
end

-- Adds a service to this provider only
function ServiceBag:_addServiceType(serviceType)
	if not self._serviceTypesToInitializeSet then
		error(("Already finished initializing, cannot add %q"):format(tostring(serviceType)))
		return
	end

	-- Already added
	if self._services[serviceType] then
		return
	end

	-- Construct a new version of this service so we're isolated
	local service = setmetatable({}, { __index = serviceType })
	self._services[serviceType] = service

	self:_ensureInitialization(serviceType)
end

function ServiceBag:_ensureInitialization(serviceType)
	if self._initializedServiceTypeSet[serviceType] then
		return
	end

	if self._initializing then
		self._serviceTypesToInitializeSet[serviceType] = nil
		self._initializedServiceTypeSet[serviceType] = true
		self:_initService(serviceType)
	elseif self._serviceTypesToInitializeSet then
		self._serviceTypesToInitializeSet[serviceType] = true
	else
		error("[ServiceBag._ensureInitialization] - Cannot initialize past initializing phase ")
	end
end

function ServiceBag:_initService(serviceType)
	local service = assert(self._services[serviceType], "No service")

	if service.Init then
		local current
		task.spawn(function()
			current = coroutine.running()
			service:Init(self)
		end)

		assert(coroutine.status(current) == "dead", "Initializing service yielded")
	end

	table.insert(self._serviceTypesToStart, serviceType)
end

--[=[
	Cleans up the service bag and all services that have been
	initialized in the service bag.
]=]
function ServiceBag:Destroy()
	local super = getmetatable(ServiceBag)

	self._destroying:Fire()

	local services = self._services
	local key, service = next(services)
	while service ~= nil do
		services[key] = nil
		if service.Destroy then
			service:Destroy()
		end
		key, service = next(services)
	end

	super.Destroy(self)
end

return ServiceBag  -  Editar
  04:54:13.815    -  Editar
  04:54:13.815  ----- [2486] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.teleportserviceutils.Server.TeleportServiceUtils -----  -  Editar
  04:54:13.815  --[=[
	@class TeleportServiceUtils
]=]

local require = require(script.Parent.loader).load(script)

local TeleportService = game:GetService("TeleportService")

local Promise = require("Promise")

local TeleportServiceUtils = {}

--[=[
	Wraps TeleportService:ReserveServer(placeId)
	@param placeId number
	@return Promise<string> -- Code
]=]
function TeleportServiceUtils.promiseReserveServer(placeId)
	assert(type(placeId) == "number", "Bad placeId")

	return Promise.spawn(function(resolve, reject)
		local accessCode
		local ok, err = pcall(function()
			accessCode = TeleportService:ReserveServer(placeId)
		end)
		if not ok then
			return reject(err)
		end

		return resolve(accessCode)
	end)
end

--[=[
	Wraps TeleportService:PromiseTeleport(placeId, players, teleportOptions)
	@param placeId number
	@param players { Player }
	@param teleportOptions TeleportOptions
	@return Promise<string> -- Code
]=]
function TeleportServiceUtils.promiseTeleport(placeId, players, teleportOptions)
	assert(type(placeId) == "number", "Bad placeId")
	assert(type(players) == "table", "Bad players")
	assert(typeof(teleportOptions) == "Instance" and teleportOptions:IsA("TeleportOptions") or teleportOptions == nil, "Bad options")

	return Promise.spawn(function(resolve, reject)
		local teleportAsyncResult
		local ok, err = pcall(function()
			teleportAsyncResult = TeleportService:TeleportAsync(placeId, players, teleportOptions)
		end)
		if not ok then
			return reject(err)
		end

		return resolve(teleportAsyncResult)
	end)
end

return TeleportServiceUtils  -  Editar
  04:54:13.815    -  Editar
  04:54:13.815  ----- [2487] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.uiobjectutils.Client.PlayerGuiUtils -----  -  Editar
  04:54:13.815  --[=[
	@class PlayerGuiUtils
]=]

local Players = game:GetService("Players")

local PlayerGuiUtils = {}

function PlayerGuiUtils.getPlayerGui()
	local localPlayer = Players.LocalPlayer
	if not localPlayer then
		error("No localPlayer")
	end

	return localPlayer:FindFirstChildOfClass("PlayerGui") or error("No PlayerGui")
end

return PlayerGuiUtils  -  Editar
  04:54:13.815    -  Editar
  04:54:13.815  ----- [2488] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.uiobjectutils.Client.UICornerUtils -----  -  Editar
  04:54:13.815  --[=[
	@class UICornerUtils
]=]

local UICornerUtils = {}

function UICornerUtils.fromScale(scale, parent)
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(scale, 0)
	uiCorner.Parent = parent
	return uiCorner
end

function UICornerUtils.fromOffset(offset, parent)
	local uiCorner = Instance.new("UICorner")
	uiCorner.CornerRadius = UDim.new(0, offset)
	uiCorner.Parent = parent
	return uiCorner
end

-- framePosition is top left corner
-- returns position, relativePosition, normal
function UICornerUtils.clampPositionToFrame(framePosition, frameSize, radius, point)
	assert(radius > 0, "Bad radius")
	assert(point, "Bad point")

	local px, py = point.x, point.y

	local fpx, fpy = framePosition.x, framePosition.y
	local fsx, fsy = frameSize.x, frameSize.y

	local minx = fpx + radius
	local maxx = fpx + fsx - radius

	local miny = fpy + radius
	local maxy = fpy + fsy - radius

	-- relative position to inner box
	local rpx, rpy

	if minx < maxx then
		rpx = math.clamp(px, minx, maxx)
	else
		rpx = minx
	end

	if miny < maxy then
		rpy = math.clamp(py, miny, maxy)
	else
		rpy = miny
	end

	local position = Vector2.new(rpx, rpy)

	-- project in direction of offset
	local direction = point - position
	if direction.magnitude == 0 then
		-- Shouldn't happen!
		return nil, nil
	end

	local normal = direction.unit
	local outsidePosition = position + normal*radius
	return outsidePosition, normal
end

return UICornerUtils  -  Editar
  04:54:13.815    -  Editar
  04:54:13.815  ----- [2489] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.uiobjectutils.Client.UIPaddingUtils -----  -  Editar
  04:54:13.816  --[=[
	Utility functions for UI padding
	@class UIPaddingUtils
]=]

local UIPaddingUtils = {}

function UIPaddingUtils.fromUDim(udim)
	local uiPadding = Instance.new("UIPadding")
	uiPadding.PaddingBottom = udim
	uiPadding.PaddingTop = udim
	uiPadding.PaddingLeft = udim
	uiPadding.PaddingRight = udim

	return uiPadding
end

function UIPaddingUtils.getTotalPadding(uiPadding)
	return UDim2.new(uiPadding.PaddingLeft + uiPadding.PaddingRight,
		uiPadding.PaddingBottom + uiPadding.PaddingTop)
end

function UIPaddingUtils.getTotalAbsolutePadding(uiPadding, absoluteSize)
	local padding = UIPaddingUtils.getTotalPadding(uiPadding)
	return Vector2.new(
		padding.X.Offset + padding.X.Scale*absoluteSize.x,
		padding.Y.Offset + padding.Y.Scale*absoluteSize.Y
	)
end

function UIPaddingUtils.getHorizontalPadding(uiPadding)
	return uiPadding.PaddingLeft + uiPadding.PaddingRight
end


return UIPaddingUtils  -  Editar
  04:54:13.816    -  Editar
  04:54:13.816  ----- [2490] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.remoting.Shared.GetRemoteEvent -----  -  Editar
  04:54:13.816  --[=[
	Provides getting named global [RemoteEvent] resources.
	@class GetRemoteEvent
]=]

--[=[
	Retrieves a global remote event from the store. On the server, it constructs a new one,
	and on the client, it waits for it to exist.

	:::tip
	Consider using [PromiseGetRemoteEvent] for a non-yielding version
	:::

	```lua
	-- server.lua
	local GetRemoteEvent = require("GetRemoteEvent")

	local remoteEvent = GetRemoteEvent("testing")
	remoteEvent.OnServerEvent:Connect(print)

	-- client.lua
	local GetRemoteEvent = require("GetRemoteEvent")

	local remoteEvent = GetRemoteEvent("testing")
	remoteEvent:FireServer("Hello") --> Hello (on the server)
	```

	:::info
	If the game is not running, then a mock remote event will be created
	for use in testing.
	:::

	@yields
	@function GetRemoteEvent
	@within GetRemoteEvent
	@param name string
	@return RemoteEvent
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local ResourceConstants = require("ResourceConstants")

if not RunService:IsRunning() then
	return function(name)
		local event = Instance.new("RemoteEvent")
		event.Archivable = false
		event.Name = "Mock" .. name

		return event
	end
elseif RunService:IsServer() then
	return function(name)
		assert(type(name) == "string", "Bad name")

		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_EVENT_STORAGE_NAME)
		if not storage then
			storage = Instance.new("Folder")
			storage.Name = ResourceConstants.REMOTE_EVENT_STORAGE_NAME
			storage.Archivable = false
			storage.Parent = ReplicatedStorage
		end

		local event = storage:FindFirstChild(name)
		if event then
			return event
		end

		event = Instance.new("RemoteEvent")
		event.Name = name
		event.Archivable = false
		event.Parent = storage

		return event
	end
else -- RunService:IsClient()
	return function(name)
		assert(type(name) == "string", "Bad name")

		return ReplicatedStorage:WaitForChild(ResourceConstants.REMOTE_EVENT_STORAGE_NAME):WaitForChild(name)
	end
end  -  Editar
  04:54:13.816    -  Editar
  04:54:13.816  ----- [2491] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.remoting.Shared.GetRemoteFunction -----  -  Editar
  04:54:13.816  --[=[
	Provides getting named global [RemoteFunction] resources.

	@class GetRemoteFunction
]=]

--[=[
	Retrieves a global remote function from the store. On the server, it constructs a new one,
	and on the client, it waits for it to exist.

	:::tip
	Consider using [PromiseGetRemoteFunction] for a non-yielding version
	:::

	```lua
	-- server.lua
	local GetRemoteFunction = require("GetRemoteFunction")

	local remoteFunction = GetRemoteFunction("testing")
	remoteFunction.OnServerInvoke = function(_player, text)
		return "HI " .. tostring(text)
	end

	-- client.lua
	local GetRemoteFunction = require("GetRemoteFunction")

	local remoteFunction = GetRemoteFunction("testing")
	print(remoteFunction:InvokeServer("Bob")) --> HI Bob
	```

	:::info
	If the game is not running, then a mock remote function will be created
	for use in testing.
	:::

	@yields
	@function GetRemoteFunction
	@within GetRemoteFunction
	@param name string
	@return RemoteFunction
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local ResourceConstants = require("ResourceConstants")

if not RunService:IsRunning() then
	return function(name)
		local func = Instance.new("RemoteFunction")
		func.Name = "Mock" .. name
		func.Archivable = false

		return func
	end
elseif RunService:IsServer() then
	return function(name)
		assert(type(name) == "string", "Bad name")

		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME)
		if not storage then
			storage = Instance.new("Folder")
			storage.Name = ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME
			storage.Archivable = false
			storage.Parent = ReplicatedStorage
		end

		local func = storage:FindFirstChild(name)
		if func then
			return func
		end

		func = Instance.new("RemoteFunction")
		func.Name = name
		func.Archivable = false
		func.Parent = storage

		return func
	end
else -- RunService:IsClient()
	return function(name)
		assert(type(name) == "string", "Bad name")

		return ReplicatedStorage:WaitForChild(ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME):WaitForChild(name)
	end
end  -  Editar
  04:54:13.816    -  Editar
  04:54:13.816  ----- [2492] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.remoting.Shared.PromiseGetRemoteEvent -----  -  Editar
  04:54:13.816  --[=[
	Retrieves a remote event as a promise
	@class PromiseGetRemoteEvent
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local GetRemoteEvent = require("GetRemoteEvent")
local Promise = require("Promise")
local ResourceConstants = require("ResourceConstants")

--[=[
	Like [GetRemoteEvent] but in promise form.

	@function PromiseGetRemoteEvent
	@within PromiseGetRemoteEvent
	@param name string
	@return Promise<RemoteEvent>
]=]
if not RunService:IsRunning() then
	-- Handle testing
	return function(name)
		return Promise.resolved(GetRemoteEvent(name))
	end
elseif RunService:IsServer() then
	return function(name)
		return Promise.resolved(GetRemoteEvent(name))
	end
else -- RunService:IsClient()
	return function(name)
		assert(type(name) == "string", "Bad name")

		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_EVENT_STORAGE_NAME)
		if storage then
			local obj = storage:FindFirstChild(name)
			if obj then
				return Promise.resolved(obj)
			end
		end

		return Promise.spawn(function(resolve, _)
			resolve(GetRemoteEvent(name))
		end)
	end
end  -  Editar
  04:54:13.817    -  Editar
  04:54:13.817  ----- [2493] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.remoting.Shared.PromiseGetRemoteFunction -----  -  Editar
  04:54:13.817  --[=[
	Retrieves a remote function as a promise
	@class PromiseGetRemoteFunction
]=]

local require = require(script.Parent.loader).load(script)

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local GetRemoteFunction = require("GetRemoteFunction")
local Promise = require("Promise")
local ResourceConstants = require("ResourceConstants")

--[=[
	Like [GetRemoteFunction] but in promise form.

	@function PromiseGetRemoteFunction
	@within PromiseGetRemoteFunction
	@param name string
	@return Promise<RemoteFunction>
]=]

if not RunService:IsRunning() then
	-- Handle testing
	return function(name)
		return Promise.resolved(GetRemoteFunction(name))
	end
elseif RunService:IsServer() then
	return function(name)
		return Promise.resolved(GetRemoteFunction(name))
	end
else -- RunService:IsClient()
	return function(name)
		assert(type(name) == "string", "Bad name")

		local storage = ReplicatedStorage:FindFirstChild(ResourceConstants.REMOTE_FUNCTION_STORAGE_NAME)
		if storage then
			local obj = storage:FindFirstChild(name)
			if obj then
				return Promise.resolved(obj)
			end
		end

		return Promise.spawn(function(resolve, _)
			resolve(GetRemoteFunction(name))
		end)
	end
end  -  Editar
  04:54:13.817    -  Editar
  04:54:13.817  ----- [2494] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.remoting.Shared.PromiseRemoteEventMixin -----  -  Editar
  04:54:13.817  --[=[
	Intended for classes that extend BaseObject only
	@class PromiseRemoteEventMixin
]=]

local require = require(script.Parent.loader).load(script)

local promiseChild = require("promiseChild")

local PromiseRemoteEventMixin = {}

--[=[
	Adds the remote function mixin to a class

	```lua
	local BaseObject = require("BaseObject")

	local Bird = setmetatable({}, BaseObject)
	Bird.ClassName = "Bird"
	Bird.__index = Bird

	require("PromiseRemoteEventMixin"):Add(Bird, "BirdRemoteEvent")

	function Bird.new(inst)
		local self = setmetatable(BaseObject.new(inst), Bird)

		self:PromiseRemoteEvent():Then(function(remoteEvent)
			self._maid:GiveTask(remoteEvent.OnClientEvent:Connect(function(...)
				self:_handleRemoteEvent(...)
			end)
		end)

		return self
	end
	```

	@param class { _maid: Maid }
	@param remoteEventName string
]=]
function PromiseRemoteEventMixin:Add(class, remoteEventName)
	assert(type(class) == "table", "Bad class")
	assert(type(remoteEventName) == "string", "Bad remoteEventName")
	assert(not class.PromiseRemoteEventMixin, "Class already has PromiseRemoteEventMixin defined")
	assert(not class._remoteEventName, "Class already has _remoteEventName defined")

	class.PromiseRemoteEvent = self.PromiseRemoteEvent
	class._remoteEventName = remoteEventName
end

--[=[
	Returns a promise that returns a remote event
	@return Promise<RemoteEvent>
]=]
function PromiseRemoteEventMixin:PromiseRemoteEvent()
	return self._maid:GivePromise(promiseChild(self._obj, self._remoteEventName))
end

return PromiseRemoteEventMixin  -  Editar
  04:54:13.817    -  Editar
  04:54:13.817  ----- [2495] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.remoting.Shared.PromiseRemoteFunctionMixin -----  -  Editar
  04:54:13.817  --[=[
	Intended for classes that extend BaseObject only
	@class PromiseRemoteFunctionMixin
]=]

local require = require(script.Parent.loader).load(script)

local promiseChild = require("promiseChild")

local PromiseRemoteFunctionMixin = {}

--[=[
	Adds the remote function mixin to a class

	```lua
	local BaseObject = require("BaseObject")

	local Bird = setmetatable({}, BaseObject)
	Bird.ClassName = "Bird"
	Bird.__index = Bird

	require("PromiseRemoteFunctionMixin"):Add(Bird, "BirdRemoteFunction")

	function Bird.new(inst)
		local self = setmetatable(BaseObject.new(inst), Bird)

		self:PromiseRemoteFunction():Then(function(remoteFunction)
			task.spawn(function()
				remoteFunction:InvokeServer() -- or whatever
			end)
		end)

		return self
	end
	```

	@param class { _maid: Maid }
	@param remoteFunctionName string
]=]
function PromiseRemoteFunctionMixin:Add(class, remoteFunctionName)
	assert(type(class) == "table", "Bad class")
	assert(type(remoteFunctionName) == "string", "Bad remoteFunctionName")
	assert(not class.PromiseRemoteFunctionMixin, "Class already has PromiseRemoteFunctionMixin defined")
	assert(not class._remoteFunctionName, "Class already has _remoteFunctionName defined")

	class.PromiseRemoteFunction = self.PromiseRemoteFunction
	class._remoteFunctionName = remoteFunctionName
end

--[=[
	Returns a promise that returns a remote function
	@return Promise<RemoteFunction>
]=]
function PromiseRemoteFunctionMixin:PromiseRemoteFunction()
	return self._maid:GivePromise(promiseChild(self._obj, self._remoteFunctionName))
end


return PromiseRemoteFunctionMixin  -  Editar
  04:54:13.817    -  Editar
  04:54:13.817  ----- [2496] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.remoting.Shared.ResourceConstants -----  -  Editar
  04:54:13.818  --[=[
	Holds constants for resource retrieval.
	@class ResourceConstants
	@private
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

return Table.readonly({
	REMOTE_EVENT_STORAGE_NAME = "RemoteEvents";
	REMOTE_FUNCTION_STORAGE_NAME = "RemoteFunctions";
})  -  Editar
  04:54:13.818    -  Editar
  04:54:13.818  ----- [2497] ServerScriptService.Scripts.Core.Products -----  -  Editar
  04:54:13.818  --[[
    SAVES PLAYERS PURCHASED PRODUCTS
    (incase of a data reset or ban)
--]]

--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local RNG = Random.new()
local FirebaseService = require(_L.ServerScriptService["__FIREBASE"])

--------|    Variables    |--------
local firebase = game:WaitForChild("ReplicatedStorage"):GetAttribute("FirebaseProducts")
local DS = firebase and FirebaseService:GetDataStore("PRODUCTS") or _L.DataStoreService:GetDataStore("PRODUCTS")

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

-- replaced with _G.SendWebhook
--[[function PurchasedWebhook(player,Product)
	_L.HttpService:PostAsync(_G.Webhook, _L.HttpService:JSONEncode({["username"] = "Product Logger", ["content"] = player.Name.." has purchased the "..Product.." Product for ".._L.Functions.GetPrice(_L.Directory.Products[Product].ID).." robux!" }))
end]]--

function GetPlayer(player)
	local data = nil
	local s, e = pcall(function()
		data = DS:GetAsync(tostring(player.UserId))
	end) 
	if not s then
		return nil
	end

	if data == nil then
		DS:SetAsync(tostring(player.UserId), _L.HttpService:JSONEncode({}))
		return {}
	end

	return _L.HttpService:JSONDecode(data)
end

function UpdatePlayer(player, newData)
	local data = GetPlayer(player)
	if data == nil then
		return
	end
	
	print(newData)
	local s, e = pcall(function()
		DS:UpdateAsync(tostring(player.UserId), function(oldData)
			oldData = _L.HttpService:JSONDecode(oldData)
			for i, v in pairs(newData) do
				oldData[i] = v
			end
			return _L.HttpService:JSONEncode(oldData)  
		end)
	end)

	if not s then
		return false
	end
	return true
end


function GetProductNameByID(ID)
	for name, data in pairs(_L.Directory.Products) do
		if data.ID == ID then
			return name
		end
	end
	return nil
end

function ProductPurchased(player, ID, Data)
	local pData = GetPlayer(player)
	print(pData)
	if pData then
		local n = GetProductNameByID(ID)
		n = tostring(n)
		if n then
			if pData[n] ~= nil then
				pData[n].Amount = pData[n].Amount + 1
			else
				pData[n] = {Amount = 1,Data = {ProductId = ID}}
			end
			UpdatePlayer(player, pData)
			local price = _L.Functions.GetPrice(ID, true)
			_G.SendWebhook({
				["username"] = "Product Logger",
				["content"] = player.Name.." has purchased the "..n.." Product for "..price.." robux!" 
			})
		end
	end
end

function Check(player, data)
	local pData = data or GetPlayer(player)
	if pData then
		for i, v in pairs(pData) do
			for _ = 1, v.Amount or 1 do
				_L.Directory.Products[i].Callback(player, v.Data)
			end
		end
	end
end

_L.Signal.Fired("Update Products"):Connect(Check)
_L.Signal.Fired("Product Bought"):Connect(ProductPurchased)
_L.Signal.Fired("Check Products"):Connect(Check)  -  Editar
  04:54:13.819    -  Editar
  04:54:13.819  ----- [2498] ServerScriptService.Scripts.Core.LazyFolder -----  -  Editar
  04:54:13.819  --[[
                                                           ,,,,,,
         ,,,,HH@@@@@@@[
         """"````"[                 [
         [                 [                     
         [     ,,,,                 @,     
              ]@     ]     ]     ]H@
              ]`          ]L     
                              ]      """
                                U               
         ]      HH@@@%            [     ]          ]
         ]           ]                 ]
         ]           ]U           `       ]U
          U     ``           L                       [
          [                [     ,        @L ,,,[
          [,,,@@@@@@
          """"````                    ,,,,,    ,,
               ,@@@,    @N,         
              @  `   [   [          @
              [           ]    [ ]  ]    "
              U           ]    ]  ]        ,    
                 @              ]  ]mm H
                                   `
              
           Incase I forget to put a certain object(s) in the correct place. - onex
           also useful for quick testing/debugging
--]]

--------------------------------------------------------------------------------------------------------------------------------------------------
local rep = game:GetService("ReplicatedStorage")
local stg = game:GetService("ServerStorage")
local wsp = game:GetService("Workspace")
local sgu = game:GetService("StarterGui")
local rpf = game:GetService("ReplicatedFirst")
--
local Directory      = wsp:FindFirstChild("__DIRECTORY")
local Worlds         = wsp:FindFirstChild("__WORLDS")
local Assets         = wsp:FindFirstChild("Assets")
local AdminCommands  = sgu:FindFirstChild("Admin Commands")
local Debug          = sgu:FindFirstChild("Debug")
local Freecam        = sgu:FindFirstChild("Freecam")
local Moderatorutil  = sgu:FindFirstChild("Moderator Util")
local __INTRO        = sgu:FindFirstChild("IntroGui") or sgu:FindFirstChild("Intro")
--------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------
if Directory then      Directory.Parent = rep     end
if Worlds then         Worlds.Parent = stg        end
if Assets then         Assets.Parent = rep        end
if AdminCommands then  AdminCommands.Parent = stg end
if Moderatorutil then  Moderatorutil.Parent = stg end
if Debug then          Debug.Parent = stg         end
if Freecam then        Freecam.Parent = stg       end
if __INTRO then        __INTRO.Parent = rpf       end
--------------------------------------------------------------------------------------------------------------------------------------------------
  -  Editar
  04:54:13.819    -  Editar
  04:54:13.819  ----- [2499] ServerScriptService.Scripts.Core.GlobalVariables -----  -  Editar
  04:54:13.819  --------|     Library     |--------

--------|     Setting     |--------

--------|    Reference    |--------
local HttpService = game:GetService("HttpService")

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function GetLibrary()
	local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
	while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end
	return _L
end

_G.Webhook = "https://webhook.lewisakura.moe/api/webhooks/1138243125178007632/9mcyuWshfRQv-Q1z5qnKKp1HTyfliCVxR43U2nakti3riPvUWd_uocvCTmHaPIQ-KXX2" --"https://discord.com/api/webhooks/1138243125178007632/9mcyuWshfRQv-Q1z5qnKKp1HTyfliCVxR43U2nakti3riPvUWd_uocvCTmHaPIQ-KXX2"
_G.SendWebhook = function(data)
	--[[
	DataFormat
	{
	["username"] = "Join Checker",
	["content"] = "This is a message."
	} 
	
	_G.SendWebhook({
		["username"] = "lol"; 
		["content"] = "wsg";
	})
	]]
	
	local json = HttpService:JSONEncode(data) 
	HttpService:PostAsync(_G.Webhook, json) 
end 

_G.UnlockHoverboard = function(player, hoverboard)
	local _L = GetLibrary()
	
	local save = _L.Saving.Get(player)
	if not save then
		_L.Print("[bold] COULDNT GET PLAYER "..player.Name.." SAVE [/bold]")
		return 
	end

	local search = _L.Functions.SearchArray(save.Hoverboards, hoverboard)
	if not search then
		table.insert(save.Hoverboards, hoverboard)
		save.EquippedHoverboard = hoverboard

		_L.Network.Fire("Hoverboard Unlocked", player, hoverboard)
	end
end

-- Global Default Data --
--[[
    Default data is held here to easily be changed
    and gotten from multiple scripts. - onex
--]]
_G.GetDefaultData = function(type)
	local _L = GetLibrary()
	
	if type == "player" then
		return {
			Banks = {},
			Invites = {},
			OutgoingInvites = {}
		}
	elseif type == "vote" then
		return {
			PlayerVote = nil
		}
	elseif type == "defaultstats" then
		return require(game.ReplicatedStorage.Library.Modules.DefaultStats)
	elseif type == "bank" then
		return {
			Storage = {
				Pets = {},
				Currency = {
					Diamonds = 0
				}
			},
			Owner = nil,
			BUID = nil,
			Tier = 1,
			Players = {},
			History = {},
			Banned = false
		}
	elseif type == "invite" then
		return {
			Sender = nil,
			BUID = nil,
			Timestamp = workspace:GetServerTimeNow()
		}
	elseif type == "outgoing invites" then
		return {
			Target = nil,
		}
	elseif type == "mail" then
		return {
			Inbox = {},
			Settings = {
				Rarities = {
					Basic = false,
					Rare = false,
					Epic = false,
					Legendary = false,
					Mythical = false,
					Secret = false,
					Event = false,
					Exclusive = false
				},
				OtherSettings = {
					HugesSetting = false,
					EnabledSetting = true,
					RequiredPetSetting = false,
					FriendsOnlySetting = false
				}
			}
		}
	elseif type == "dupe" then
		return {
			Pets = {},
			HasChecked = false,
			FirstTime = true,
			LastCheck = nil
		}
	end

	_L.Print("[bold] Failed to get default data "..type.." [/bold]")
	return nil
end

local hasLoaded = nil
_G.HasLoaded = function(player): boolean
	local _L = GetLibrary()
	--repeat wait() until _L.Network.Invoke("Has Loaded", player) == true
	--while _L.Network.Invoke("Has Loaded", player) ~= true do
	--	if not player or not player.Parent then
	--		break
	--	end
	--	task.wait()
	--end
	if not hasLoaded then
		while not hasLoaded do
			if not player or not player.Parent then break end
			hasLoaded = _L.Network.Invoke("Has Loaded", player)
			task.wait()
		end
	end	
	return true
end

local TimeLimit = 5
_G.ProcessPending = function(player, stop)
	local _L = GetLibrary()
	--print(stop)
	local event = stop and "Process Pending Stop" or "Process Pending Start"
	_L.Network.Fire(event, player)
	local _starttick = tick()
	task.spawn(function() -- incase smth is wrong...
		if not stop then
			while wait() do
				if tick() - _starttick > TimeLimit then
					_L.Network.Fire("Process Pending Stop", player)
				end
			end
		end	
	end)
end

_G.GetGameData = function()
	local GameID = game.PlaceId
	local GameDATA = HttpService:GetAsync(string.format("https://games.roproxy.com/v1/games/%s/favorites/count", 4491159178))
	GameDATA = HttpService:JSONDecode(GameDATA)
end

--- adfiowedf
local rng = Random.new()
local _base = [[~`1!2@3#4$5%6^7&8*9(0)-_=+QWERTYUIOP[{]}\|ASDFGHJKL;:"'ZXCVBNM,<.>/?]]
local default = 24
function GenerateRandomString(length)
	local _string = ""
	for i = 1, length or default do
		local l = rng:NextInteger(1, #_base)
		local int = string.sub(_base, l, l)
		_string = _string .. int
	end
	return _string
end
  -  Editar
  04:54:13.819    -  Editar
  04:54:13.819  ----- [2500] ServerScriptService.Scripts.Core.AdminCmdsServer [OLD] -----  -  Editar
  04:54:13.820  --[[
                                                           ,,,,,,
         ,,,,HH@@@@@@@[
         """"````"[                 [
         [                 [                     
         [     ,,,,                 @,     
              ]@     ]     ]     ]H@
              ]`          ]L     
                              ]      """
                                U               
         ]      HH@@@%            [     ]          ]
         ]           ]                 ]
         ]           ]U           `       ]U
          U     ``           L                       [
          [                [     ,        @L ,,,[
          [,,,@@@@@@
          """"````                    ,,,,,    ,,
               ,@@@,    @N,         
              @  `   [   [          @
              [           ]    [ ]  ]    "
              U           ]    ]  ]        ,    
                 @              ]  ]mm H
                                   `
              
           By: @localonex     
           
           Admin Commands system
--]]


--------|     Setting     |--------
local Hide = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890"

-- /e fling
local FlingVelocity = 75
local FlingTime = 1.5
-- /e shrink
local ShrinkAmount = 0.25
-- /e squash
local SquashAmount = 0.5

local Prefix = "/e"

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local AdminCmdsGui = _L.ServerStorage["Admin Commands"]
local FreeCamGui = _L.ServerStorage["Freecam"]
local Players = game:GetService("Players")
local IsStudio = _L.RunService:IsStudio()

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local Commands = {
	{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Force"} },
		desc = "Fling players around the map!",
		cmds = {"fling"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = {{"Player", "", "Player"}},
		desc = "Make players sit!",
		cmds = {"sit"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = {{"Player", "", "Player"}},
		desc = "Shrink a player!",
		cmds = {"shrink"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "ID"} },
		desc = "Make a player wear a hat!",
		cmds = {"hat"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },
		desc = "A camera that you can move around anywhere with!",
		cmds = {"freecam"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Username"} },
		desc = "Turn into anyone you want!",
		cmds = {"morph"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },
		desc = "Squish any player!",
		cmds = {"squash"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },
		desc = "Make any player become Sparkley!",
		cmds = {"sparkles"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Name"}, {"String", "", "Raritys"}, {"Number", "", "Amount"} },
		desc = "Create any pet!",
		cmds = {"pet"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"String", "", "Name"} }, --, {"String", "", "Raritys"} },
		desc = "Create a merch code!",
		cmds = {"merch"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},--[[{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },  
		desc = "Give someone a paintball gun!",
		cmds = {"paintball"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},]]{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },  
		desc = "Enable the FFlags gui.",
		cmds = {"fflags"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			return _L.FFlags.CanBypass(player)
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Type"} , {"Number", "", "Amount"} },  
		desc = "Mastery progress and stuff",
		cmds = {"mastery"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"string", "", "Area"} },  
		desc = "Teleport anywhere!",
		cmds = {"teleport"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },  
		desc = "Go up a rank!",
		cmds = {"rankup"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Type"} },  
		desc = "Spawn a comet!",
		cmds = {"comet"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },  
		desc = "Shutdown a server.",
		cmds = {"shutdown"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },  
		desc = "Reset a players stats.",
		cmds = {"reset"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Hoverboard"} },  
		desc = "Give someone a hoverboard!",
		cmds = {"hoverboards"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "World"} },  
		desc = "Go to any world",
		cmds = {"world"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Boost"}, {"Number", "", "Amount"} },  
		desc = "Give someone some boost(s)",
		cmds = {"boosts"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Gamepass"} },  
		desc = "Give someone a gamepass",
		cmds = {"gamepass"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Product"} },  
		desc = "Give someone a product",
		cmds = {"product"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Time"} },  
		desc = "Ban a player",
		cmds = {"ban"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },  
		desc = "Unban a player",
		cmds = {"unban"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },  
		desc = "Warn a player",
		cmds = {"warn"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} }, --, {"String", "", "Reason"} },  
		desc = "Kick a player from a server",
		cmds = {"kick"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone slots",
		cmds = {"slots"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},--[[{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = " ",
		cmds = {"rap"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},]]{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"String", "", "Message"} },  
		desc = "Announce a message to a server",
		cmds = {"announce"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"String", "", "Message"} },  
		desc = "Announce a message to every server",
		cmds = {"globalannounce"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Coins",
		cmds = {"coins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Diamonds",
		cmds = {"diamonds"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Fantasy Coins",
		cmds = {"fantasycoins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Tech Coins",
		cmds = {"techcoins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Rainbow Coins",
		cmds = {"rainbowcoins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Halloween Coins",
		cmds = {"halloweencandy"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Gingerbread",
		cmds = {"gingerbread"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Valentine Hearts",
		cmds = {"valentinehearts"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Clover Coins",
		cmds = {"clovercoins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Easter Coins",
		cmds = {"eastercoins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Lucky Coins",
		cmds = {"luckycoins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Yeet Coins",
		cmds = {"yeetcoins"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"Number", "", "Amount"} },  
		desc = "Give someone Yeet Orbs",
		cmds = {"yeetorbs"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = {{"Player", "", "Player"},{"Number", "", "Pressure"}},
		desc = "Expload a player!",
		cmds = {"explode"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = {{"Player", "", "Player"}},
		desc = "Bighead a player!",
		cmds = {"bighead"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers, Admins, Moderators, Partners"},
		developers = {"OneX"},
		arguments = {{"Player", "", "Player"}},
		desc = "Giant a player!",
		cmds = {"giant"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			if _L.Admins.IsAdmin(player) or player:GetRankInGroup(32485727) == 5 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = {{"Player", "", "Player"}},
		desc = "Kill a player!",
		cmds = {"kill"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"}, {"String", "", "Fruit"}, {"Number", "", "Amount"} },
		desc = "Give a player a Fruit!",
		cmds = {"givefruit"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},{
		permissions = {"OneX, Developers"},
		developers = {"OneX"},
		arguments = { {"Player", "", "Player"} },
		desc = "Give someone a firework launcher!",
		cmds = {"firework"},
		HasPermissions = function(player)			
			if not player then
				return false
			end

			local rank = player:GetRankInGroup(32604465)
			if rank == 254 or rank == 255 or rank == 100 then
				return true
			end

			return false
		end,
	},
}


--- TODO:
--- walkspeed, jumppower

--[[
/e water
/e gun
/e paintball
--]]

function Notification(player, _type)	
	local msg = " Successfully used command!"
	if _type == "error" then
		msg = " Command failed: (error)"
	elseif _type == "player" then
		msg = " Command failed: (Could not find player)"
	elseif _type == "incorrect" then
		msg = " Command failed: (Incorrect Usage)"
	elseif _type == "cant" then
		msg = " Command failed: (You cannot use this command)"
	elseif _type == "exist" then
		msg = " Command does not exist."
	end
	
	_L.Network.Fire("Admin Cmds Notification", player, msg)
end

function GetCommand(command)
	for i,v in ipairs(Commands) do
		if v.cmds[1] == command then
			return v
		end
	end
	return nil
end

function GetPetIdByName(name)
	local directory = game:GetService("ReplicatedStorage"):WaitForChild("__DIRECTORY")
	if directory then
		for _, Pet in pairs(directory.Pets:GetChildren()) do
			local PetData = Pet:FindFirstChildOfClass("ModuleScript")
			if PetData then
				local petname = require(PetData).name
				if not petname then
					return
				end
				if string.lower(string.gsub(petname, " ", "")) == string.lower(name) then
					return tostring(string.match(Pet.Name, "%d+"))
				end
			end
		end
	else
		return nil
	end
end


function GetDirectoryValue(dir, value)
	for name, data in pairs(dir) do
		local z = string.lower(string.gsub(name, " " , ""))
		print(z,value)
		if z == value then
			return name, data
		end
	end
	return nil
end

--- Majority of these Get(...) functions
--- were replaced with the GetDirectoryValue 
--- Function.

--[[function GetArea(area)
	for i,v in pairs(_L.Directory.Areas) do
		if string.lower(string.gsub(i, " " , "")) == area then
			return i, v
		end
	end
	return nil
end
function GetWorld(area)
	for i,v in pairs(_L.Directory.Worlds) do
		if string.lower(string.gsub(i, " " , "")) == area then
			return i, v
		end
	end
	return nil
end

function GetProduct(product)
	for i,v in pairs(_L.Directory.Products) do
		if string.lower(string.gsub(i, " " , "")) == product then
			return i, v
		end
	end
	return nil
end

function GetGamepass(product)
	for i,v in pairs(_L.Directory.Gamepasses) do
		if string.lower(string.gsub(i, " " , "")) == product then
			return i, v
		end
	end
	return nil
end

function GetHoverboard(hoverboard)
	for i,v in pairs(_L.Directory.Hoverboards) do
		if string.lower(string.gsub(i, " " , "")) == hoverboard then
			return i 
		end
	end
	if hoverboard == "all" then
		return "all"
	end
	
	return nil
end]]--

--- i have no idea why
--- i didnt do this
--- sooner.

function AdminPlayer(player)
	player.Chatted:Connect(function(msg)
		local split = string.split(string.lower(msg), " ", "")
		local UpperSplit = 		string.split(msg, " ", "")

		local prefix = split[1] or ""
		local cmd = split[2] or ""
		local target = string.split(msg, " ", "")[3] or ""
		
		if prefix ~= Prefix then
			return
		end
		
		if cmd == "cmds" then
			return
		end
		
		--- fling command
		if cmd == "fling" then
			local Command = GetCommand("fling")
			if not Command then
				Notification(player,"incorrect")
				return
			end
			
			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local force = split[4] or FlingVelocity
			force = tonumber(force)
			
			local function FlingPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end
				
				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end
								
				Humanoid["Sit"] = true
				
				local BodyVelocity = Instance.new("BodyVelocity", HumanoidRootPart)  
				BodyVelocity.Velocity = Vector3.new(-force,force,-force) 
				BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
				BodyVelocity.P = math.huge

				task.delay(FlingTime, function()
					BodyVelocity:Destroy()
				end)
			end
			
			local playerTarget = Players:FindFirstChild(target)
			if target == "me" then
				FlingPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(Players:GetPlayers()) do
					FlingPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						FlingPlayer(v)
					end
				end
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						FlingPlayer(v)
						break
					end
				end	
			elseif playerTarget then
				FlingPlayer(playerTarget)
			else
				Notification(player,"player")
				return
			end
			
			Notification(player)
			
			--- sit command
		elseif cmd == "sit" then
			local Command = GetCommand("sit")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function SitPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				Humanoid["Sit"] = true
			end

			if target == "me" then
				SitPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					SitPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						SitPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				SitPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						SitPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- shrink command
		elseif cmd == "shrink" then
			local Command = GetCommand("shrink")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function ShrinkPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				Humanoid.HeadScale.Value       = Humanoid.HeadScale.Value - ShrinkAmount
				Humanoid.BodyDepthScale.Value  = Humanoid.BodyDepthScale.Value - ShrinkAmount
				Humanoid.BodyWidthScale.Value  = Humanoid.BodyWidthScale.Value - ShrinkAmount
				Humanoid.BodyHeightScale.Value = Humanoid.BodyHeightScale.Value - ShrinkAmount
			end

			if target == "me" then
				ShrinkPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					ShrinkPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						ShrinkPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				ShrinkPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						ShrinkPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- hat command
		elseif cmd == "hat" then
			local Command = GetCommand("hat")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local hatid = split[4] or nil
			if not hatid then
				Notification(player,"incorrect")
				return
			end

			local function HatPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end
				
				local InsertService = game:GetService("InsertService")
				
				hatid = tonumber(hatid)
				_L.InsertService:LoadAsset(hatid):FindFirstChildOfClass("Accessory").Parent = Character
			end
			
			local Display = string.match("@", string.sub(target,1,1)) ~= nil or false
			if target == "me" then
				HatPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					HatPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						HatPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				HatPlayer(_L.Players:FindFirstChild(target))
			elseif Display then
				local DisplayName = string.gsub(target, "@", "")
				print(DisplayName)
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						print('z')
						HatPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- freecam command
		elseif cmd == "freecam" then
			local Command = GetCommand("freecam")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function FreecamPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end
			
				local newfreecam = FreeCamGui:Clone()
				newfreecam.Name = "__FREECAM"
				newfreecam.Parent = plyr:WaitForChild("PlayerGui")
			end

			if target == "me" then
				FreecamPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					FreecamPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						FreecamPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				FreecamPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						FreecamPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- morph command
		elseif cmd == "morph" then
			local Command = GetCommand("morph")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local Username = split[4] or nil
			if not Username then
				Notification(player,"error")
				return
			end
			
			local targetUserId = _L.Players:GetUserIdFromNameAsync(Username)
			if not targetUserId then
				Notification(player,"error")
				return
			end
			
			local function MorphPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				local Appearance = _L.Players:GetHumanoidDescriptionFromUserId(targetUserId)
				if not Appearance then
					Notification(player,"error")
					return
				end
				
				pcall(function()
					Humanoid:ApplyDescription(Appearance)
				end)
			end

			if target == "me" then
				MorphPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					MorphPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						MorphPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				MorphPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						MorphPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)
			
			--- squash command
		elseif cmd == "squash" then
			local Command = GetCommand("squash")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function SquashPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

			   Humanoid.BodyHeightScale.Value -= SquashAmount
			end

			if target == "me" then
				SquashPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					SquashPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						SquashPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				SquashPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						SquashPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- sparkles command
		elseif cmd == "sparkles" then
			local Command = GetCommand("sparkles")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function SquashPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				local Sparkles = Instance.new("Sparkles", HumanoidRootPart)
			end

			if target == "me" then
				SquashPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					SquashPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						SquashPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				SquashPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						SquashPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- pet command
		elseif cmd == "pet" then
			local Command = GetCommand("pet")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local id = split[4] or nil
			if not id then
				return
			end
			local raritys = split[5] or ""
			local amount = split[6] or 1
			local RarityTbl = {}
			--- g = gold | r = rainbow | d = darkmatter | h = hardcore | s = shiny
			local Special = { -- Custom fun things!
				["_"] = {
					variable = "s",
					stat = 100000000000000000000000000000
				},
				["1"] = {
					variable = "snk",
					stat = true
				}
			}
			local AllowedRaritys = {"g","r","d","h","s","_"}
			local Specifics = {["d"] = "dm", ["h"] = "hc", ["s"] = "sh"}
			for i = 1,#raritys do
				local rarity = string.sub(raritys,i,i)
				if table.find(AllowedRaritys,rarity) then
					if Special[rarity] then
						local spcial = Special[rarity]
						RarityTbl[spcial.variable] = spcial.stat
 						continue
					end
					if Specifics[rarity] then rarity = Specifics[rarity] end
					RarityTbl[rarity] = true
				end
			end
			
			if not _L.Directory.Pets[id] then
				id = GetPetIdByName(id)
				if not _L.Directory.Pets[id] then
					Notification(player,"error")
					return
				end
			end
			
			local function GivePlayerPet(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end
				
				for _ = 1, amount or 1 do
					_L.Pets.Create(plyr,id,RarityTbl)
				end	
			end

			if target == "me" then
				GivePlayerPet(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GivePlayerPet(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GivePlayerPet(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GivePlayerPet(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GivePlayerPet(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)
			
			--- merch command
		elseif cmd == "merch" then
			local Command = GetCommand("merch")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local id = split[3] or nil
			if not id then
				return
			end
			if not _L.Directory.Pets[id] then
				id = GetPetIdByName(id)
				if not _L.Directory.Pets[id] then
					Notification(player,"error")
					return
				end
			end
			
			print(id)
			_L.Signal.Invoke("Create Merch Code",player,id)
			

			Notification(player)
			
			--- fflags command
		elseif cmd == "fflags" then
			local Command = GetCommand("fflags")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			_L.Network.Fire("Open FFlags", player)

			Notification(player)		
			
			--- mastery command
		elseif cmd == "mastery" then
			local Command = GetCommand("mastery")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local masteryTypes = {
				["boosts"] = "Boosts",
				["chests"] = "Chests",
				["coinpiles"] = "Coin Piles",
				["converting"] = "Converting",
				["crates"] = "Crates",
				["darkmatter"] = "Dark Matter",
				["diamondsmine"] = "Diamonds Mine",
				["diamondpiles"] = "Diamond Piles",
				["eggs"] = "Eggs",
				["enchanting"] = "Enchanting",
				["freegifts"] = "Free Gifts",
				["fruits"] = "Fruits",
				["fusing"] = "Fusing",
				["goldeneggs"] = "Golden Eggs",
				["lootbags"] = "Lootbags",
				["presents"] = "Presents",
				["vaults&safes"] = "VaultsAndSafes",
				["vaultsandsafes"] = "VaultsAndSafes"
			}
			
			--local _type = split[4]
			--if not _type then
			--	return
			--end
			local m = split[4]
			if not m then
				Notification(player,"error")
				return
			end
			local mastery = masteryTypes[m]
			if not mastery then
				Notification(player,"error")
				return
			end
			local amount = tonumber(split[5]) or 1

			local function ProgressMastery(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end
				
				--local save = _L.Saving.Get(plyr)
				--if _type == "set" then
					
				--else 
					_L.Mastery.Progress(plyr, mastery, amount)
				--end
			end

			if target == "me" then
				ProgressMastery(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					ProgressMastery(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						ProgressMastery(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				ProgressMastery(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						ProgressMastery(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			--- teleport command
		elseif cmd == "teleport" then
			local Command = GetCommand("teleport")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local area = split[4]
			if not area then
				Notification(player,"error")
				return
			end
			local areadata = nil
			
			area, areadata = GetDirectoryValue(_L.Directory.Areas, area) --GetArea(area)
			print(area, areadata)
			if not area or not areadata then
				Notification(player,"error")
				return
			end

			local function TeleportPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				if _L.Worlds.HasArea(plyr, area) then
					_L.Network.Invoke("Force Teleport", plyr, area)
				end
			end

			if target == "me" then
				TeleportPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					TeleportPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						TeleportPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				TeleportPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						TeleportPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- rankup command
		elseif cmd == "rankup" then
			local Command = GetCommand("rankup")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
	
			local function RankUp(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				local nextRank = _L.Ranks.GetNextRank(plyr)
				if nextRank then
					_L.Ranks.Give(plyr, nextRank) 
				end
			end

			if target == "me" then
				RankUp(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					RankUp(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						RankUp(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				RankUp(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						RankUp(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- comet command
		elseif cmd == "comet" then
			local Command = GetCommand("comet")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			
			_L.Signal.Fire("Comets: Spawn", player)
			Notification(player)	
			
			--- shutdown command
		elseif cmd == "shutdown" then
			local Command = GetCommand("shutdown")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end


			task.spawn(function()
				game.Workspace:SetAttribute("Shutdown", true)
				task.wait(2)
				for i,v in ipairs(game.Players:GetPlayers()) do
					
					v:Kick("Server Shutdown")
				end
			end)
			
			
			Notification(player)	
			
			--- reset command
		elseif cmd == "reset" then
			local Command = GetCommand("reset")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function ResetPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Saving.Reset(plyr)
			end

			if target == "me" then
				ResetPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					ResetPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						ResetPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				ResetPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						ResetPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- hoverboards command
		elseif cmd == "hoverboards" then
			local Command = GetCommand("reset")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local hoverboard = split[4] == "all" and "all" or GetDirectoryValue(_L.Directory.Hoverboards, split[4]) --GetHoverboard(split[4])
			if not hoverboard then
				Notification(player,"error")
				return
			end
			
			local function UnlockHoverboard(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				if hoverboard == "all" then
					for i,v in ipairs(_L.Directory.Hoverboards) do
						_G.UnlockHoverboard(plyr, i)
					end
				else
					_G.UnlockHoverboard(plyr, hoverboard)
				end
			end

			if target == "me" then
				UnlockHoverboard(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					UnlockHoverboard(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						UnlockHoverboard(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				UnlockHoverboard(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						UnlockHoverboard(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)
			
			--- world command
		elseif cmd == "world" then
			local Command = GetCommand("world")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local world = split[4]
			if not world then
				Notification(player,"error")
				return
			end
			local worlddata = nil

			world, worlddata = GetDirectoryValue(_L.Directory.Worlds, world)  --GetWorld(world)
			print(world, worlddata)
			if not world or not worlddata or worlddata.disabled then
				Notification(player,"error")
				return
			end

			local function GoToWorld(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				if _L.Worlds.HasArea(plyr, worlddata.requiredArea or "Town") then
					_L.Network.Fire("Force Load World", plyr, world)
				end
			end

			if target == "me" then
				GoToWorld(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GoToWorld(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GoToWorld(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GoToWorld(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GoToWorld(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- boosts command
		elseif cmd == "boosts" then
			local Command = GetCommand("boosts")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local boosts = {["tripledamage"] = "Triple Damage", ["triplecoins"] = "Triple Coins", ["superlucky"] = "Super Lucky", ["ultralucky"] = "Ultra Lucky"}
			local boost = boosts[split[4]]
			if not boost then
				Notification(player,"error")
				return
			end
			local amount = split[5] or 1
			
			local function GiveBoost(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Boosts.Give(plyr, boost, amount)
			end

			if target == "me" then
				GiveBoost(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveBoost(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveBoost(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveBoost(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveBoost(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			--- gamepass command
		elseif cmd == "gamepass" then
			local Command = GetCommand("gamepass")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local gamepasses = {
				["lucky"] = "Lucky", 
				["autohatch"] = "Auto Hatch", 
				["mythicalhunter"] = "Mythical Hunter", 
				["shinyhunter"] = "Shiny Hunter", 
				["octupleeggopen"] = "Octuple Egg Open", 
				["vip"] = "VIP", 
				["superpetstorage"] = "Super Pet Storage", 
				["teleport"] = "Teleport", 
				["magiceggs"] = "Magic Eggs", 
				["hoverboard"] = "Hoverboard", 
				["tripleeggopen"] = "Triple Egg Open", 
				["15petsequipped"] = "15 Pets Equipped", 
				["secrethunter"] = "Secret Hunter", 
				["petstorage"] = "Pet Storage", 
				["skipeggopen"] = "Skip Egg Open", 
				["magnet"] = "Magnet", 
				["8petsequipped"] = "8 Pets Equipped"
			}
			local gamepass = GetDirectoryValue(_L.Directory.Gamepasses, split[4]) --GetGamepass(split[4]) --gamepasses[split[4]]
			if not gamepass then
				Notification(player,"error")
				return
			end

			local function GiveGamepass(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Gamepasses.Give(plyr, gamepass)
			end

			if target == "me" then
				GiveGamepass(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveGamepass(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveGamepass(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveGamepass(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveGamepass(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			--- product command
		elseif cmd == "product" then
			local Command = GetCommand("product")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			 
			local product, data = GetDirectoryValue(_L.Directory.Products, split[4]) --GetProduct(split[4])
			print(product, data)
			if not product or not data then
				Notification(player,"error")
				return
			end

			local function GiveProduct(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				data.Callback(plyr, {})
			end

			if target == "me" then
				GiveProduct(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveProduct(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveProduct(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveProduct(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveProduct(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--- ban command
		elseif cmd == "ban" then
			local Command = GetCommand("ban")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local userid = _L.Players:GetUserIdFromNameAsync(UpperSplit[3])
			if not userid then
				Notification(player,"player")
				return
			end
			
			_L.Bans.Ban(player, userid, player, "Cmds-"..os.time())

			Notification(player)		
			
			--- warn command
		elseif cmd == "warn" then
			local Command = GetCommand("warn")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local userid = _L.Players:GetUserIdFromNameAsync(UpperSplit[3])
			if not userid then
				Notification(player,"player")
				return
			end

			_L.Bans.Warn(player, userid, player, "Cmds-"..os.time())

			Notification(player)		
			
			--- unban command
		elseif cmd == "unban" then
			local Command = GetCommand("unban")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local userid = _L.Players:GetUserIdFromNameAsync(UpperSplit[3])
			if not userid then
				Notification(player,"player")
				return
			end

			_L.Bans.Clear(player, userid, player, "Cmds-"..os.time())

			Notification(player)		
			
			
			--- kick command
		elseif cmd == "kick" then
			local Command = GetCommand("kick")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			if target == "me" then
				player:Kick("Kicked by "..player.Name)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					v:Kick("Kicked by "..player.Name)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						v:Kick("Kicked by "..player.Name)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				_L.Players:FindFirstChild(target):Kick("Kicked by "..player.Name)
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						v:Kick("Kicked by "..player.Name)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			
			--- slots command
		elseif cmd == "slots" then
			local Command = GetCommand("slots")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local amount = split[4] or 1
			
			local function GiveSlots(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Slots(player, amount)
			end

			if target == "me" then
				GiveSlots(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveSlots(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveSlots(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveSlots(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveSlots(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			--- announce command
		elseif cmd == "announce" then
			local Command = GetCommand("announce")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			msg = string.sub(msg, 12, #msg)

			for i,v in ipairs(_L.Players:GetPlayers()) do
				_L.Network.Fire("Notification", v, msg, {time = 15, color = Color3.fromRGB(78, 244, 252),  force = true})
			end

			Notification(player)		
			
			--- globalannounce command
		elseif cmd == "globalannounce" then
			local Command = GetCommand("globalannounce")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			msg = string.sub(msg, 17, #msg)

			_L.MessagingService:PublishAsync("Global: Notification", {msg = msg, player = {Name = player.Name}})

			Notification(player)		
			
			
			--- kill command
		elseif cmd == "kill" then
			local Command = GetCommand("kill")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function Kill(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				Humanoid.Health = 0
			end

			if target == "me" then
				Kill(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					Kill(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						Kill(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				Kill(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						Kill(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)
			
			
			--- coins command
		elseif cmd == "coins" then
			local Command = GetCommand("coins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)
			
			
			
			--- diamonds command
		elseif cmd == "diamonds" then
			local Command = GetCommand("diamonds")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Diamonds")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)
			
			--- fantasycoins command
		elseif cmd == "fantasycoins" then
			local Command = GetCommand("fantasycoins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Fantasy Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			--- techcoins command
		elseif cmd == "techcoins" then
			local Command = GetCommand("techcoins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Tech Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			--- rainbowcoins command
		elseif cmd == "rainbowcoins" then
			local Command = GetCommand("rainbowcoins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Rainbow Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			--- halloweencandy command
		elseif cmd == "halloweencandy" then
			local Command = GetCommand("halloweencandy")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Halloween Candy")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			--- gingerbread command
		elseif cmd == "gingerbread" then
			local Command = GetCommand("gingerbread")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Gingerbread")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			
			--- valentinehearts command
		elseif cmd == "valentinehearts" then
			local Command = GetCommand("valentinehearts")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Valentine Hearts")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			
			
			--- clovercoins command
		elseif cmd == "clovercoins" then
			local Command = GetCommand("clovercoins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Clover Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			
			
			--- eastercoins command
		elseif cmd == "eastercoins" then
			local Command = GetCommand("eastercoins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Easter Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			--- luckycoins command
		elseif cmd == "luckycoins" then
			local Command = GetCommand("luckycoins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Lucky Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			
			
			--- yeetcoins command
		elseif cmd == "yeetcoins" then
			local Command = GetCommand("yeetcoins")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Yeet Coins")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)			
			
			
			--- yeetorbs command
		elseif cmd == "yeetorbs" then
			local Command = GetCommand("yeetorbs")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local Amount = split[4] or 1

			local function GiveCurrency(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Give.Currency(plyr, Amount, "Yeet Orbs")
			end

			if target == "me" then
				GiveCurrency(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveCurrency(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveCurrency(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveCurrency(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveCurrency(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			
			
			
			--- bighead command
		elseif cmd == "bighead" then
			local Command = GetCommand("bighead")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function BigHeadPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				Humanoid.HeadScale.Value = Humanoid.HeadScale.Value + ShrinkAmount
			end

			if target == "me" then
				BigHeadPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					BigHeadPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						BigHeadPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				BigHeadPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						BigHeadPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			
			--- giant command
		elseif cmd == "giant" then
			local Command = GetCommand("giant")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function GiantPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				Humanoid.HeadScale.Value       = Humanoid.HeadScale.Value + 1
				Humanoid.BodyDepthScale.Value  = Humanoid.BodyDepthScale.Value + 1
				Humanoid.BodyWidthScale.Value  = Humanoid.BodyWidthScale.Value + 1
				Humanoid.BodyHeightScale.Value = Humanoid.BodyHeightScale.Value + 1
			end

			if target == "me" then
				GiantPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiantPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiantPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiantPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiantPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			
			--- givefruit command
		elseif cmd == "givefruit" then
			local Command = GetCommand("givefruit")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local fruits = {
				["rainbow"] = "Rainbow", 
				["pineapple"] = "Pineapple", 
				["apple"] = "Apple", 
				["pear"] = "Pear", 
				["orange"] = "Orange", 
				["banana"] = "Banana" 
			}
			
			local fruit = fruits[split[4]]
			if not fruit then
				Notification(player,"error")
				return
			end
			local amount = split[5] or 1
			
			
			local function GiveFruit(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				 _L.Fruit.Give(plyr, fruit, amount)
			end

			if target == "me" then
				GiveFruit(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					GiveFruit(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						GiveFruit(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				GiveFruit(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						GiveFruit(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			--- explode command
		elseif cmd == "explode" then
			local Command = GetCommand("explode")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end
			
			local pressure = split[4] or 500000
			
			local function ExploadPlayer(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				local explosion = Instance.new("Explosion")
				explosion.Position = HumanoidRootPart.Position
				explosion.Parent = HumanoidRootPart
				explosion.BlastPressure = pressure
			end

			if target == "me" then
				ExploadPlayer(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					ExploadPlayer(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						ExploadPlayer(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				ExploadPlayer(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						ExploadPlayer(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)		
			
			--- firework command
		elseif cmd == "firework" then
			local Command = GetCommand("firework")
			if not Command then
				Notification(player,"incorrect")
				return
			end

			if not Command.HasPermissions(player) then
				Notification(player,"cant")
				return 
			end

			local function EquipFireworkLauncher(plyr)
				local Character = plyr.Character
				if not Character then
					Notification(player,"error")
					return
				end

				local Humanoid, HumanoidRootPart = Character:WaitForChild("Humanoid"), Character:WaitForChild("HumanoidRootPart")
				if not Humanoid or not HumanoidRootPart then
					Notification(player,"error")
					return
				end

				_L.Signal.Fire("FireworkLauncher_Equip", plyr)
			end

			if target == "me" then
				EquipFireworkLauncher(player)
			elseif target == "all" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					EquipFireworkLauncher(v)
				end
			elseif target == "others" then
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.UserId ~= player.UserId then
						EquipFireworkLauncher(v)
					end
				end
			elseif _L.Players:FindFirstChild(target) then
				EquipFireworkLauncher(_L.Players:FindFirstChild(target))
			elseif string.match("@", string.sub(target,1,1)) ~= nil then
				local DisplayName = string.gsub(target, "@", "")
				for i,v in ipairs(_L.Players:GetPlayers()) do
					if v.DisplayName == DisplayName then
						EquipFireworkLauncher(v)
						break
					end
				end
			else
				Notification(player,"player")
				return
			end

			Notification(player)	
			
			--------------------------------------------------------------------------------------------------------------
			
		else
			Notification(player, "exist")
		end
	end)
end

function GetLockedString(_string)
	for i = 1, #Hide do
		_string = string.gsub(_string, string.sub(Hide, i, i), "_")
	end
	return _string
end

function GetCommands(player)
	local PlayerCommands = {}
	local LockedCommands = {}
	
	for i,v in ipairs(Commands) do
		if v.HasPermissions(player) then
			table.insert(PlayerCommands, v)
		else
			local insertTable = {}
			insertTable["permissions"] = v.permissions
			insertTable["developers"] = v.developers
			insertTable["arguments"] = {}
			insertTable["desc"] = GetLockedString(v.desc)
			insertTable["cmds"] = {GetLockedString(v.cmds[1])}
			table.insert(LockedCommands, insertTable)
		end
	end
	
	PlayerCommands = PlayerCommands or {}
	LockedCommands = LockedCommands or {}
	Prefix = Prefix or "/e"
	
   
	return PlayerCommands, LockedCommands, Prefix
end

_L.Network.Invoked("Get BIG Admin Commands").OnInvoke = GetCommands

--- Give admin GUI to player
function GiveGui(player)
	wait() --- prevents console errors
	if player then
		local adminGui = game.ServerStorage:FindFirstChild("Admin Commands"):Clone()
		adminGui.Parent = player
		--local freecamGui = game.ServerStorage:FindFirstChild("Freecam"):Clone()
		--freecamGui.Parent = player
	end
end


--- Player added function
local function PlayerAdded(player) 
	GiveGui(player)
	AdminPlayer(player)
end  


--- Players in server
for _, player in ipairs(game.Players:GetPlayers()) do  
	PlayerAdded(player)  
end   

game.Players.PlayerAdded:Connect(PlayerAdded)


coroutine.wrap(function()
	(function()
		local s, v43 = pcall(function()
			return _L.MessagingService:SubscribeAsync("Global: Notification", function(data)
				if data then
					local GlobalData = data.Data
					local msg = GlobalData.msg
					local o = data.Sent
					for i, v in ipairs(game.Players:GetPlayers()) do
						local save  = _L.Saving.Get(v)
						if save then
							if not save.Debug[o..msg] then 
								save.Debug[o..msg] = true
								_L.Network.Fire("Notification", v, msg, {time = 15, color = Color3.fromRGB(78, 244, 252),  force = true})
							end
						end
					end
				end;
			end);
		end);
		if not s then
			print("Failed to connect to live global msg updates.");
		end;
	end)();
end)();  -  Editar
  04:54:13.820    -  Editar
  04:54:13.820  ----- [2501] ServerScriptService.Scripts.Core.Logs -----  -  Editar
  04:54:13.820  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local rng = Random.new()

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Signal.Fired("Banned Player"):Connect(function(plr)   
	_G.SendWebhook({
		["username"] = "Ban Logger",
		["content"] = plr.Name .. " was banned!"
	}, "ban")
end)

--if _L.RunService:IsStudio() then
--	zazazazza = {}
--	game:GetService("ScriptContext").Error:Connect(function(errormessage, stacktrace, faultyscript)		 
--		if zazazazza[errormessage] then
--			return
--		end
--		_L.HttpService:PostAsync(_G.Webhook, _L.HttpService:JSONEncode({["username"] = "Error Logger", ["content"] = "```lua\n"..errormessage.."\n```" }))
--		zazazazza[errormessage] = true
--	end)
--end
  -  Editar
  04:54:13.820    -  Editar
  04:54:13.820  ----- [2502] ServerScriptService.Scripts.Core.TrackPlayerDeath -----  -  Editar
  04:54:13.821  local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()
_L.Signal.Fired("Player Added"):Connect(function(player)
	local function onCharacterAdded(character)
		local humanoid = character:WaitForChild("Humanoid", 5)
		if not humanoid then
			return
		end

		humanoid.Died:Connect(function()
			player.CharacterAdded:Connect(function()
				task.wait(1) -- wait a second for character to be fully loaded
				_L.Network.Fire("Reset Player", player) 
			end)
		end)
	end

	player.CharacterAdded:Connect(onCharacterAdded)
	
	do 
		local alreadyExistingCharacter = player.Character
		if alreadyExistingCharacter then
			onCharacterAdded(alreadyExistingCharacter)
		end
	end
end)  -  Editar
  04:54:13.821    -  Editar
  04:54:13.821  ----- [2503] ServerScriptService.Scripts.Core.HttpCheck -----  -  Editar
  04:54:13.821  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--- Send a test http request to test if HttpService is enabled
if httpEnabled == nil then 
	httpEnabled = pcall(function()  game:GetService("HttpService"):GetAsync("https://google.com")  end)
end

--  HttpService is disabled!
if not httpEnabled then
	_L.Print("HTTP ISNT ENABLED SOMETHINGS WONT WORK", true)
end  -  Editar
  04:54:13.821    -  Editar
  04:54:13.821  ----- [2504] ServerScriptService.Scripts.Core.AdminCmdsServer [OLD] -----  -  Editar
  04:54:13.821  --- Kinda made this shitty but its better than the old system ig
--- Fully scripted by: OneX

--- Should probably remake this system one day. (9/13/2023)
--- 100% gonna remake this gay script soon (9/20/2023)

--------|     Setting     |--------
local Prefix = "/e"
local HiddenStrings = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890"
local DefaultUID = 4437812925

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
local Commands = {}
--local NotificationTypes = {
--	["success"] = " Successfully used command!",
--}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Adds a command to the main Commands table.
--- example: AddCommand({ ["cmd"] = "example", ["perms"] = "OneX", ["devs"] = "OneX", ["desc"] = "This is an example!", ["arguments"] = {{"Player", nil, "Player"}}, ["hasPerms"] = {"Group", 32604465, {255, 254}} })
function AddCommand(data)
	local function GroupFunction(plr, d1, d2)
		if d2 then
			local rank = plr:GetRankInGroup(d1)
			if not rank then
				return nil
			end
			if _L.Functions.SearchArray(d2, rank) then
				return true
			else
				return false
			end
		else
			local isInGroup = plr:IsInGroup(d1)
			if not isInGroup then
				return false
			end
			return true
		end
	end
	
	local cmd = data["cmd"] 
	local perms = data["perms"] or "OneX"
	local devs = data["devs"] or "OneX"
	local desc = data["desc"] or "Forgot to put description lmao"
	local arguements = data["arguments"] or {{"Player", nil, "Player"}}
	local func = data["func"]

	--local hasPerms = function(plr)
	--	if plr then
	--		local s = data["hasPerms"] or {"Group", 32604465, {255, 254}}
	--		local set = s[1] or "Group"
	--		local d1 = s[2] or 32604465
	--		local d2 = s[3] or nil
	--		if set == "GroupAdmin" then
	--			return GroupFunction(plr, d1, d2) or _L.Admins.IsAdmin(plr) == true
	--	    elseif set == "Group" then
	--			return GroupFunction(plr, d1, d2)
	--		elseif set == "Admin" then
	--			return _L.Admins.IsAdmin(plr) == true
	--		end
 	--	else
	--		return nil
	--	end
	--end
	
	if not func then
		print("no function for cmd: "..cmd)
		return
	end
	
	local function permissions()
		
	end
	
	local n = {
		permissions = {perms},
		developers = {devs},
		arguments = arguements,
		desc = desc,
		cmds = {cmd},
		func = func,
		hasPerms = function(plr)
			if plr then
				if plr.UserId == -1 or plr.UserId == -2 or plr.UserId == -3 then
					return true
				end
				local s = data["hasPerms"] or {"Group", 32604465, {255, 254}}
				local set = s[1] or "Group"
				local d1 = s[2] or 32604465
				local d2 = s[3] or nil
				if set == "GroupAdmin" then
					return GroupFunction(plr, d1, d2) or _L.Admins.IsAdmin(plr) == true
				elseif set == "Group" then
					return GroupFunction(plr, d1, d2)
				elseif set == "Admin" then
					return _L.Admins.IsAdmin(plr) == true
				elseif set == "FFlags" then
					return _L.FFlags.CanBypass(plr) == true	
				elseif set == "Gamepass" then
					return _L.MarketplaceService:UserOwnsGamePassAsync(plr.UserId, 258612097) --_L.Gamepasses
				elseif set == "BoosterVIP" then
					
				elseif set == "VIP" then
	
				end
			else
				return nil
			end
		end
	}
	if data["noplayer"] then
		n["noplayer"] = true
	end
	table.insert(Commands, n)
end

--- Fires a remote function to client to show a notification after smth happens when you use a admin cmd
--- example: Notification(plr, " Successfully used command!")
function Notification(plr, notification)  --, isBasic)
	--local notification = ""
	--if isBasic then
	--	if notType == "success" then
	--		notification = " Successfully used command!"
	--	end
	--end
	if not notification then
        print("Notification is nil - AdminCmds")	
	end	
	_L.Network.Fire("Admin Cmds Notification", plr, notification)
end

--- Get command data with just the name
function GetCmd(cmd)
	for _, cmdData in ipairs(Commands) do
		local CMD = cmdData["cmds"][1]
		if CMD and CMD == cmd then
			return cmdData
		end
	end
	return nil
end

--- Gets a player by display name
--- example: GetPlrByDisplay("@OneX")
function GetPlrByDisplay(display)
	local player = nil
	display = string.gsub(display, "@", "")
	for _, plr in ipairs(_L.Players:GetPlayers()) do
		if plr.DisplayName == display then
			player = plr
			break
		end
	end 
	return player
end

--- Gets certain directory data by a value
--- example: GetPlrByDisplay(_L.Directory.Areas, "techentry")
function GetDirValue(dir, value)
	if not dir or not value then
		print("GetDirValue: 1/2 of args are nil")
		return
	end
	
	for n, d in pairs(dir) do
		if string.lower(string.gsub(n, " " , "")) == value then
			return n, d
		end
	end
end

--- Gets pet id by name
--- example: GetPetIdByName("hugecat") -- would return the ID
function GetPetIdByName(name)
	local directory = game:GetService("ReplicatedStorage"):WaitForChild("__DIRECTORY")
	if directory then
		for _, Pet in pairs(directory.Pets:GetChildren()) do
			local PetData = Pet:FindFirstChildOfClass("ModuleScript")
			if PetData then
				local petname = require(PetData).name
				if not petname then
					return
				end
				if string.lower(string.gsub(petname, " ", "")) == string.lower(name) then
					return tostring(string.match(Pet.Name, "%d+"))
				end
			end
		end
	else
		return nil
	end
end


-- TODO: 
--[[
/e comet
/e rap
/e water
/e gun
/e paintball
--]]
------------------------------------------------------------------------------------------------------------------------------------------

AddCommand({
	["cmd"] = "fling",
	["desc"] = "Fling people around!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Force"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local force = tonumber(s[4]) or 100
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		Humanoid["Sit"] = true
		local BodyVelocity = Instance.new("BodyVelocity", HRP)  
		BodyVelocity.Velocity = Vector3.new(-force,force,-force) 
		BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
		BodyVelocity.P = math.huge

		task.delay(1.5, function()
			BodyVelocity:Destroy()
		end)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "sit",
	["desc"] = "Make people sit!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		Humanoid["Sit"] = true
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "shrink",
	["desc"] = "Shrink people and make them small!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Scale"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local scale = s[4] or 0.5
		scale = tonumber(scale)
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		Humanoid.HeadScale.Value       = Humanoid.HeadScale.Value - scale
		Humanoid.BodyDepthScale.Value  = Humanoid.BodyDepthScale.Value - scale
		Humanoid.BodyWidthScale.Value  = Humanoid.BodyWidthScale.Value - scale
		Humanoid.BodyHeightScale.Value = Humanoid.BodyHeightScale.Value - scale
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "hat",
	["desc"] = "Give people hats!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "ID"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local id = s[4]
		if not id then
			return false, " Command failed: (Incorrect Usage)"
		end
		id = tonumber(id)
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.InsertService:LoadAsset(id):FindFirstChildOfClass("Accessory").Parent = Character
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "freecam",
	["desc"] = "Enable a free camera that you can move around with!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		local newfreecam = _L.ServerStorage["Freecam"]:Clone()
		newfreecam.Name = "__FREECAM"
		newfreecam.Parent = plr:WaitForChild("PlayerGui")
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "morph",
	["desc"] = "Morph people into other people!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Username"}},
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local u = s[4]
		if not u then
			return false, " Command failed: (Incorrect Usage)"
		end
		
		local uid = _L.Players:GetUserIdFromNameAsync(u)
		if not uid then
			return false, " Command failed: (Failed to get plr Userid)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		local Appearance = _L.Players:GetHumanoidDescriptionFromUserId(uid)
		if not Appearance then
			return false, " Command failed: (Failed to get appearance)"
		end

		pcall(function()
			Humanoid:ApplyDescription(Appearance)
		end)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "squash",
	["desc"] = "Squash people!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Scale"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local scale = s[4] or 0.5
		scale = tonumber(scale)
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		Humanoid.BodyHeightScale.Value -= scale
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "sparkles",
	["desc"] = "Make people sparkley!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		Instance.new("Sparkles", HRP)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "bighead",
	["desc"] = "Give people big heads!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Scale"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local scale = s[4] or 0.5
		scale = tonumber(scale)
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end 
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		Humanoid.HeadScale.Value = Humanoid.HeadScale.Value + scale
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "giant",
	["desc"] = "Make people grow bigger!",
	["perms"] = "OneX, Developers, Admins, Moderators, Partners",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Scale"} },
	["hasPerms"] = {"GroupAdmin", 32485727, {5}},
	["func"] = function(plr, s, s1, msg)
		local scale = s[4] or 0.5
		scale = tonumber(scale)

		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		Humanoid.HeadScale.Value       = Humanoid.HeadScale.Value + scale
		Humanoid.BodyDepthScale.Value  = Humanoid.BodyDepthScale.Value + scale
		Humanoid.BodyWidthScale.Value  = Humanoid.BodyWidthScale.Value + scale
		Humanoid.BodyHeightScale.Value = Humanoid.BodyHeightScale.Value + scale
		
		return true
	end,
})
AddCommand({
	["cmd"] = "walkspeed",
	["desc"] = "Make people walk faster/slower!",
	["perms"] = "OneX, Developers, Admins, Moderators",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Speed"} },
	["hasPerms"] = {"Admin"},
	["func"] = function(plr, s, s1, msg)
		local value = s[4] or 16

		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		Humanoid["WalkSpeed"] = value

		return true
	end,
})
--
AddCommand({
	["cmd"] = "jumppower",
	["desc"] = "Make people jump higher/lower!",
	["perms"] = "OneX, Developers, Admins, Moderators",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Power"} },
	["hasPerms"] = {"Admin"},
	["func"] = function(plr, s, s1, msg)
		local value = s[4] or 200

		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		Humanoid["JumpPower"] = value

		return true
	end,
})
--
AddCommand({
	["cmd"] = "respawn",
	["desc"] = "Respawn a player!",
	["perms"] = "OneX, Developers, Admins, Moderators",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin"},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		plr:LoadCharacter()

		return true
	end,
})
--
AddCommand({
	["cmd"] = "invisible",
	["desc"] = "Make a player invisible!",
	["perms"] = "OneX, Developers, Admins, Moderators",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Transparency"} },
	["hasPerms"] = {"Admin"},
	["func"] = function(plr, s, s1, msg)
		local Transparency = s[4] or 1
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		for i, v in pairs(Character:GetChildren()) do
			if v:IsA("Part") or v:IsA("MeshPart") then
				v.Transparency = Transparency
			end
		end

		return true
	end,
})
--
AddCommand({
	["cmd"] = "visible",
	["desc"] = "Make a player visible!",
	["perms"] = "OneX, Developers, Admins, Moderators",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin"},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		for i, v in pairs(Character:GetChildren()) do
			if v:IsA("Part") or v:IsA("MeshPart") then
				v.Transparency = 0
			end
		end

		return true
	end,
})
--
AddCommand({
	["cmd"] = "freeze",
	["desc"] = "Freeze a player!",
	["perms"] = "OneX, Developers, Admins, Moderators",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin"},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, false)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, false)

		return true
	end,
})
--
AddCommand({
	["cmd"] = "unfreeze",
	["desc"] = "Unfreeze a player!",
	["perms"] = "OneX, Developers, Admins, Moderators",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin"},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Running, true)

		return true
	end,
})
--
AddCommand({
	["cmd"] = "explode",
	["desc"] = "Explode players!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Pressure"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local pressure = s[4] or 500000
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		local explosion = Instance.new("Explosion")
		explosion.Position = HRP.Position
		explosion.Parent = HRP
		explosion.BlastPressure = pressure
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "kill",
	["desc"] = "Kill players!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		Humanoid.Health = 0
	
		return true
	end,
})
--
AddCommand({
	["cmd"] = "firework",
	["desc"] = "Give people a firework launcher!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		pcall(function()
			_L.Signal.Fire("FireworkLauncher_Equip", plr)
		end)
		
		return true
	end,
})
--AddCommand({
--	["cmd"] = "teleport",
--	["desc"] = "Teleport people to any area they own!",
--	["perms"] = "OneX, Developers, Admins",
--	["devs"] = "OneX",
--	["arguments"] = { {"Player", "", "Player"}, {"string", "", "Area"} },
--	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
--	["func"] = function(plr, s, s1, msg)
--		local a = s[4] 
--		if not a then
--			return false, " Command failed: (Incorrect Usage)"
--		end
--		
--		local a, ad = GetDirValue(_L.Directory.Areas, a)
--		if not a or not ad then
--			return false, " Command failed: (Something went wrong)"
--		end
--		
--		local Character = plr["Character"]
--		if not Character then
--			return false, " Command failed: (Failed to get Character)"
--		end
--		local Humanoid = Character:WaitForChild("Humanoid")
--		local HRP = Character:WaitForChild("HumanoidRootPart")
--		if not Humanoid then
--			return false, " Command failed: (Failed to get Humanoid)"
--		end
--		if not HRP then
--			return false, " Command failed: (Failed to get HRP)"
--		end
--		
--		if _L.Worlds.HasArea(plr, a) then
--			_L.Network.Invoke("Force Teleport", plr, a)
--		end
--		
--		return true
--	end,
--})
--
AddCommand({
	["cmd"] = "teleport",
	["desc"] = "Teleport players to other players!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local targetName = s1[4] 
		if not targetName then
			return false, " Command failed: (Incorrect Usage)"
		end 
		
		local isDisplay = targetName:find("@") ~= nil
		local plrTarget = _L.Players:FindFirstChild(targetName)
		
		if isDisplay then
			plrTarget = GetPlrByDisplay(targetName)
			if not plrTarget then
				return  " Command failed: (Could not find player)"
			end
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		pcall(function()
			_L.Network.Fire("Teleport To Player", plr, plrTarget)
		end)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "goto",
	["desc"] = "Go to players!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local targetName = s1[4] 
		if not targetName then
			return false, " Command failed: (Incorrect Usage)"
		end 

		local isDisplay = targetName:find("@") ~= nil
		local plrTarget = _L.Players:FindFirstChild(targetName)

		if isDisplay then
			plrTarget = GetPlrByDisplay(targetName)
			if not plrTarget then
				return  " Command failed: (Could not find player)"
			end
		end

		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end

		pcall(function()
			_L.Network.Fire("Teleport To Player", plr, plrTarget)
		end)

		return true
	end,
})
--
AddCommand({
	["cmd"] = "world",
	["desc"] = "Teleport people to any world they own!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"string", "", "World"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local w = s[4] 
		if not w then
			return false, " Command failed: (Incorrect Usage)"
		end 

		local w, wd = GetDirValue(_L.Directory.Worlds, w)
		if not w or not wd then
			return false, " Command failed: (Something went wrong)"
		end
		if wd["disabled"] == true then
			return false, " Command failed: (World is disabled)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		if _L.Worlds.HasArea(plr, wd.requiredArea or "Town") then
			_L.Network.Fire("Force Load World", plr, w)
		end
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "shutdown",
	["desc"] = "Shutdown a server.",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["noplayer"] = true,
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		game.Workspace:SetAttribute("Shutdown", true)
		task.delay(2, function()
			for _, p in ipairs(game.Players:GetPlayers()) do
				p:Kick("Server Shutdown")
			end
		end)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "reset",
	["desc"] = "Reset peoples progress!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Saving.Reset(plr)
		_L.Network.Fire("Notification", plr, "Your data has been reset.", {
			["time"] = 3,
			["color"] = Color3.fromRGB(252, 0, 4), 
			["force"] = true
		})
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "ban",
	["desc"] = "Permanently ban people!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local uid = _L.Players:GetUserIdFromNameAsync(s1[3])
		if not uid then
			return false, " Command failed: (Failed to get userid)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Bans.Ban(DefaultUID, uid, nil, "Cmds-"..os.time())
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "unban",
	["desc"] = "Unban people!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local uid = _L.Players:GetUserIdFromNameAsync(s1[3])
		if not uid then
			return false, " Command failed: (Failed to get userid)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Bans.Clear(DefaultUID, uid, nil, "Cmds-"..os.time())
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "warn",
	["desc"] = "Ban people for two days!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local uid = _L.Players:GetUserIdFromNameAsync(s1[3])
		if not uid then
			return false, " Command failed: (Failed to get userid)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Bans.Warn(DefaultUID, uid, nil, "Cmds-"..os.time())
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "kick",
	["desc"] = "Kick people from a server!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		plr:Kick("Kicked Rejoin!")
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "announce",
	["desc"] = "Announce a message to a server!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"String", "", "Message"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["noplayer"] = true,
	["func"] = function(plr, s, s1, msg)
		msg = string.sub(msg, 12, #msg)
		for _, pl in ipairs(_L.Players:GetPlayers()) do
			_L.Network.Fire("Notification", pl, msg, {
				time = 15, 
				color = Color3.fromRGB(78, 244, 252), 
				force = true
			})
		end
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "globalannounce",
	["desc"] = "Announce a message to every server!",
	["perms"] = "OneX, Developers, Admins",
	["devs"] = "OneX",
	["arguments"] = { {"String", "", "Message"} },
	["hasPerms"] = {"Admin", 32604465, {255,254,100,3}},
	["noplayer"] = true,
	["func"] = function(plr, s, s1, msg)
		msg = string.sub(msg, 19, #msg)
		_L.MessagingService:PublishAsync("Global: Notification", {msg = msg, player = {Name = plr.Name}})
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "fflags",
	["desc"] = "Enable FFlags gui!",
	["perms"] = "OneX, Developers",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"FFlags"},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Network.Fire("Open FFlags", plr)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "pet",
	["desc"] = "Give people pets!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Pet"}, {"String", "", "Raritys"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local id = s[4]
		local raritys = s[5] or ""
		local amount = s[6] or 1
		local RarityTbl = {}
		if not id then
			return nil, " Command failed: (Incorrect Usage)"
		end
		
		local Special = { -- Custom fun things!
			["_"] = {
				variable = "s",
				stat = 100000000000000000000000000000
			},
			["1"] = {
				variable = "snk",
				stat = true
			}
		}
		local AllowedRaritys = {"g","r","d","h","s","_"}
		local Specifics = {["d"] = "dm", ["h"] = "hc", ["s"] = "sh"}
		for i = 1,#raritys do
			local rarity = string.sub(raritys,i,i)
			if table.find(AllowedRaritys,rarity) then
				if Special[rarity] then
					local spcial = Special[rarity]
					RarityTbl[spcial.variable] = spcial.stat
					continue
				end
				if Specifics[rarity] then rarity = Specifics[rarity] end
				RarityTbl[rarity] = true
			end
		end
		
		if not _L.Directory.Pets[id] then
			id = GetPetIdByName(id)
			if not _L.Directory.Pets[id] then
				return nil, " Command failed: (Failed to get pet id)"
			end
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		for _ = 1, amount or 1 do
			_L.Pets.Create(plr,id,RarityTbl)
		end	
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "merch",
	["desc"] = "Create merch codes!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"String", "", "Pet"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	--["noplayer"] = true,
	["func"] = function(plr, s, s1, msg)  
		local id = s[4]
		if not id then
			return
		end
		if not _L.Directory.Pets[id] then
			id = GetPetIdByName(id)
			if not _L.Directory.Pets[id] then
				return false, " Command failed: (Failed to get pet id)"
			end
		end
		
		local s = _L.Signal.Invoke("Create Merch Code",plr,id)
		
		return s, " Command failed: (Something went wrong)"
	end,
})
--
AddCommand({
	["cmd"] = "mastery",
	["desc"] = "Give people mastery progress!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Mastery"} , {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local m = s[4]
		if not m then
			return false, " Command failed: (Incorrect Usage)"
		end
		local mastery, md = GetDirValue(_L.Directory.Mastery, m)
		if not mastery then
			return false, " Command failed: (Failed to get mastery directory)"
		end
		local amount = tonumber(s[5]) or 1
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Mastery.Progress(plr, mastery, amount)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "rankup",
	["desc"] = "Make people rank up!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		local nextRank = _L.Ranks.GetNextRank(plr)
		if nextRank then
			_L.Ranks.Give(plr, nextRank) 
		end
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "hoverboards",
	["desc"] = "Give people hoverboards!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Hoverboard"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local hoverboard = s[4] == "all" and "all" or GetDirValue(_L.Directory.Hoverboards, s[4])  
		if not hoverboard then
			return false, " Command failed: (Failed to get hoverboard)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		if hoverboard == "all" then
			for i,v in pairs(_L.Directory.Hoverboards) do
				_G.UnlockHoverboard(plr, i)
			end
		else
			_G.UnlockHoverboard(plr, hoverboard)
		end
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "boosts",
	["desc"] = "Give people boosts!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Boost"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local boosts = {["tripledamage"] = "Triple Damage", ["triplecoins"] = "Triple Coins", ["superlucky"] = "Super Lucky", ["ultralucky"] = "Ultra Lucky"}
		local amount = s[5] or 1
		local b = s[4]
		if not b then
			return false, " Command failed: (Incorrect Usage)"
		end
		local boost = boosts[b]
		if not boost then
			return false, " Command failed: (Something went wrong)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end 
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Boosts.Give(plr, boost, amount)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "gamepass",
	["desc"] = "Give people gamepasses!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Gamepass"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local gamepass, gd = GetDirValue(_L.Directory.Gamepasses, s[4])  
		if not gamepass or not gd then
			return false, " Command failed: (Incorrect Usage)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Gamepasses.Give(plr, gamepass)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "product",
	["desc"] = "Give people products!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Product"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local product, pd = GetDirValue(_L.Directory.Products, s[4])  
		if not product or not pd then
			return false, " Command failed: (Incorrect Usage)"
		end
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end 
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		pd.Callback(plr, {})
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "slots",
	["desc"] = "Give people inventory slots!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false,  " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end 
		
		_L.Give.Slots(plr, s[4] or 1)
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "coins",
	["desc"] = "Give people coins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Coins")
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "diamonds",
	["desc"] = "Give people diamonds!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Diamonds")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "fantasycoins",
	["desc"] = "Give people fantasycoins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Fantasy Coins")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "techcoins",
	["desc"] = "Give people techcoins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Tech Coins")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "rainbowcoins",
	["desc"] = "Give people rainbowcoins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Rainbow Coins")
		
		return true
	end,
})
--
AddCommand({
	["cmd"] = "halloweencandy",
	["desc"] = "Give people halloweencandy!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Halloween Candy")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "gingerbread",
	["desc"] = "Give people gingerbread!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Gingerbread")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "valentinehearts",
	["desc"] = "Give people valentinehearts!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Valentine Hearts")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "clovercoins",
	["desc"] = "Give people clovercoins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Clover Coins")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "eastercoins",
	["desc"] = "Give people eastercoins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Easter Coins")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "questpoints",
	["desc"] = "Give people questpoints!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Quest Points")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "luckycoins",
	["desc"] = "Give people luckycoins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Lucky Coins")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "yeetcoins",
	["desc"] = "Give people yeetcoins!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Yeet Coins")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "yeetorbs",
	["desc"] = "Give people yeetorbs!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Yeet Orbs")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "stars",
	["desc"] = "Give people stars!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Give.Currency(plr, s[4] or 1, "Stars")

		return true
	end,
})
--
AddCommand({
	["cmd"] = "givefruit",
	["desc"] = "Give people fruits!",
	["perms"] = "OneX",
	["devs"] = "OneX",
	["arguments"] = { {"Player", "", "Player"}, {"String", "", "Fruit"}, {"Number", "", "Amount"} },
	["hasPerms"] = {"Group", 32604465, {255,254}},
	["func"] = function(plr, s, s1, msg)
		local f = s[4]
		if not f then
			return false, " Command failed: (Incorrect Usage)"
		end
		local fruit = GetDirValue(_L.Directory.Fruits, f)
		if not fruit then
			return false, " Command failed: (Failed to get Fruit)"
		end
		local amount = s[5] or 1
		
		local Character = plr["Character"]
		if not Character then
			return false, " Command failed: (Failed to get Character)"
		end
		local Humanoid = Character:WaitForChild("Humanoid")
		local HRP = Character:WaitForChild("HumanoidRootPart")
		if not Humanoid then
			return false, " Command failed: (Failed to get Humanoid)"
		end
		if not HRP then
			return false, " Command failed: (Failed to get HRP)"
		end
		
		_L.Fruit.Give(plr, fruit, amount)
		
		return true
	end,
})
--

------------------------------------------------------------------------------------------------------------------------------------------

function AdminPlayer(plr)
	plr.Chatted:Connect(function(msg)
		local s = string.split(string.lower(msg), " ", "")
		local s1 = string.split(msg, " ", "")
		local prefix = s[1]
		local cmd = s[2]
		local targetName = s1[3] or ""
		
		if prefix ~= Prefix or not cmd then
			return
		end
		
		local cmdData = GetCmd(cmd)
		if not cmdData then
			return Notification(plr, " Command does not exist.")
		end
		
		if not cmdData.hasPerms(plr) then
			return Notification(plr, " Command failed: (You cannot use this command)")
		end
		
		local isDisplay = targetName:find("@") ~= nil
		local plrTarget = _L.Players:FindFirstChild(targetName)
		local success, response = false, nil
		local ignore = false
		if cmdData["noplayer"] then
			success, response = cmdData.func(nil, s, s1, msg)
			ignore = true
		end
		
		if not ignore then
			if isDisplay then
				plrTarget = GetPlrByDisplay(targetName)
				if not plrTarget then
					return Notification(plr, " Command failed: (Could not find player)")
				end
				success, response = cmdData.func(plrTarget, s, s1, msg)
			elseif plrTarget then
				success, response = cmdData.func(plrTarget, s, s1, msg)
			elseif targetName == "me" then
				success, response = cmdData.func(plr, s, s1, msg)
			elseif targetName == "all" then
				for _, plyr in ipairs(_L.Players:GetPlayers()) do
					success, response = cmdData.func(plyr, s, s1, msg)	
				end
			else
				return Notification(plr, " Command failed: (Could not find player)")
			end
		end	
		
		if response then
			Notification(plr, response)
		end
		
		if success then
			Notification(plr, " Successfully used command!")
		end	
	end)
end

coroutine.wrap(function()
	(function()
		local s = pcall(function()
			return _L.MessagingService:SubscribeAsync("Global: Notification", function(d)
				if d then
					local data = d.Data
					local msg = data.msg
					local o = d.Sent
					for i, v in ipairs(game.Players:GetPlayers()) do
						_L.Network.Fire("Notification", v, msg, {time = 15, color = Color3.fromRGB(78, 244, 252), force = true})
					end
				end
			end)
		end)
		if not s then
			print("Failed to connect to live global notification updates.")
		end
	end)()
end)()

------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------

function GetLockedString(_string)
	for i = 1, #HiddenStrings do
		_string = string.gsub(_string, string.sub(HiddenStrings, i, i), "_")
	end
	return _string
end

function GetCommands(player)
	local PlayerCommands = {}
	local LockedCommands = {}
	
	for i,v in ipairs(Commands) do
		if v.hasPerms(player) then
			table.insert(PlayerCommands, v)
		else
			local insertTable = {}
			insertTable["permissions"] = v.permissions
			insertTable["developers"] = v.developers
			insertTable["arguments"] = {}
			insertTable["desc"] = GetLockedString(v.desc)
			insertTable["cmds"] = {GetLockedString(v.cmds[1])}
			table.insert(LockedCommands, insertTable)
		end
	end

	PlayerCommands = PlayerCommands or {}
	LockedCommands = LockedCommands or {}
	Prefix = Prefix or "/e"

	return PlayerCommands, LockedCommands, Prefix
end

_L.Network.Invoked("Get BIG Admin Commands").OnInvoke = GetCommands


--- Give admin GUI to player
function GiveGui(player)
	wait() --- prevents console errors
	if player then
		local adminGui = game.ServerStorage:FindFirstChild("Admin Commands"):Clone()
		adminGui.Parent = player
	end
end


--- Player added function
local function PlayerAdded(player) 
	GiveGui(player)
	AdminPlayer(player)
end  


--- Players in server
for _, player in ipairs(game.Players:GetPlayers()) do  
	PlayerAdded(player)  
end   

game.Players.PlayerAdded:Connect(PlayerAdded)  -  Editar
  04:54:13.821    -  Editar
  04:54:13.822  ----- [2505] ServerScriptService.Scripts.Core.BIG Games Detection -----  -  Editar
  04:54:13.822  --------|     Setting     |--------
local notifyEnabled = true
local ping = "<@1037898275229020250>" --"@everyone"

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
local roles = {
	["Fan"] = false;
	["Partner"] = true;
	["Tester"] = true;
	["Affiliate"] = true;
	["Community Manager"] = true;
	["Developer"] = true;
	["Manager"] = true;
	["Owner"] = true;
}
local staffRoles = {
	["Moderator"] = true;
	["Admin"] = true;
	["Community Manager"] = true;
	["Developer"] = true;
	["Manager"] = true;
	["Owner"] = true;
}
local groupId = 2703304
local staffGroupId = 5060810

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function notifyPlayer(plr, role, group)
	if notifyEnabled then
		_G.HasLoaded(plr)
		_L.Network.Fire("Notification", plr, "Detected that you're in the \""..group.."\" group ranked as \""..role.."\".", {time = 5, color = Color3.fromRGB(255, 0, 0), force = true})
	end
end

function getGameLink(id)
	return "https://www.roblox.com/games/"..tostring(id)
end

function sendWebook(plr, role, isStaffGroup)
	local groupName = isStaffGroup and "BIG Games Staff" or "BIG Games"
	local gameLink = getGameLink(game.PlaceId)
	notifyPlayer(plr, role, groupName)
	_G.SendWebhook({
		["username"] = "BIG Games Detection",
		["content"] = ping.."\n **Username:** "..plr.Name.."\n **GameLink:** "..gameLink.."\n **Role:** "..role.."\n **Group:** "..groupName
		---"@everyone "..plr.Name.." has joined "..gameLink.." and is roled "..role.." in the "..groupName.." group!"
	})
end

_L.Signal.Fired("Player Added"):Connect(function(plr)
	local isInGroup, isInStaffGroup = plr:IsInGroup(groupId), plr:IsInGroup(staffGroupId)
	local groupRank, staffGroupRank = plr:GetRankInGroup(groupId), plr:GetRankInGroup(staffGroupId)
	local groupRole, staffGroupRole = plr:GetRoleInGroup(groupId), plr:GetRoleInGroup(staffGroupId)
	if isInStaffGroup and staffGroupRole and staffRoles[staffGroupRole] then
		sendWebook(plr, staffGroupRole, true)
	elseif isInGroup and groupRole and roles[groupRole] then
		sendWebook(plr, groupRole, false)
	end
end)  -  Editar
  04:54:13.822    -  Editar
  04:54:13.822  ----- [2506] ServerScriptService.Scripts.Core.DataReset [OLD] -----  -  Editar
  04:54:13.822  --- New version: ServerScriptService.Scripts.Core.SavingNotify

--[[
                                                           ,,,,,,
         ,,,,HH@@@@@@@[
         """"````"[                 [
         [                 [                     
         [     ,,,,                 @,     
              ]@     ]     ]     ]H@
              ]`          ]L     
                              ]      """
                                U               
         ]      HH@@@%            [     ]          ]
         ]           ]                 ]
         ]           ]U           `       ]U
          U     ``           L                       [
          [                [     ,        @L ,,,[
          [,,,@@@@@@
          """"````                    ,,,,,    ,,
               ,@@@,    @N,         
              @  `   [   [          @
              [           ]    [ ]  ]    "
              U           ]    ]  ]        ,    
                 @              ]  ]mm H
                                   `
              
           By: @localonex     
--]]


--------|     Setting     |--------
local Message = "Your data has been reset! Apologies! ~ OneX"

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local RNG = Random.new()

--------|    Variables    |--------
local DS = _L.DataStoreService:GetDataStore("BIGData")

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function UpdateProfile(player)
	local success = pcall(function()
		return DS:SetAsync("user:"..tostring(player.UserId),_L.Settings.StatsVersion)
	end)
	
	if not success then
		print("FAILED TO UPDATE PROFILE")
		return nil
	end
end

function GetProfile(player)
	local success, response = pcall(function()
		return DS:GetAsync("user:"..tostring(player.UserId))
	end)
	
	if success then
		if response then
			return response
		else
			return UpdateProfile(player)
		end
	end
	
	print("FAILED TO GET PLAYER: "..player.Name)
	return nil
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	_G.HasLoaded(player)
	local StatsVersion = GetProfile(player)
	if StatsVersion then
		if StatsVersion ~= _L.Settings.StatsVersion then
			_L.Network.Fire("Message", player, Message)
			UpdateProfile(player)
			_L.Signal.Fire("Check Products",player)
		end
	end
end)  -  Editar
  04:54:13.822    -  Editar
  04:54:13.822  ----- [2507] ServerScriptService.Scripts.Core.StatsReset -----  -  Editar
  04:54:13.822  --------|     Setting     |--------
local resetReason = ""

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
local db = _L.DataStoreService:GetDataStore("Saves")

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

if resetReason == "" then
	resetReason= "Unknown."
end

function getCurrentStatsVersion()
	return _L.Settings.StatsVersion
end

function update(plr)
	if not pcall(function()
			local v = getCurrentStatsVersion()
			db:SetAsync(tostring(plr.UserId), v)
		end) then
		return nil
	end
end

function get(plr)
	local s, r = pcall(function()
		return db:GetAsync(tostring(plr.UserId))
	end)
	
	if not s then
		return nil
	end
	
	if r == nil then
		pcall(function()
			update(plr)
		end)
		return getCurrentStatsVersion()
	end
	
	return r
end

_L.Signal.Fired("Player Added"):Connect(function(plr)
	local v = get(plr)
	if v then
		local stats = getCurrentStatsVersion()
		if v ~= stats then
			update(plr)
			coroutine.wrap(function()
				pcall(function()
					_L.Signal.Fire("Check Products", plr)
					_G.HasLoaded(plr) _L.Network.Fire("Notification", plr, "Global data has been reset.. :(", {time = 10, color = Color3.fromRGB(255, 0, 0), force = true})
					_L.Network.Fire("Notification", plr, "Reason: "..resetReason, {time = 10, color = Color3.fromRGB(255, 0, 0), force = true})
				end)
			end)()
		end
	end
end)  -  Editar
  04:54:13.822    -  Editar
  04:54:13.822  ----- [2508] ServerScriptService.Scripts.Core.AdminCmdsServer -----  -  Editar
  04:54:13.823  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
local commands = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--[[ 
     PERM TYPE DIRECTORY
     
     1 = Admin
     2 = Partner
     3 = Gamepass
     4 = Owner
     5 = FFlags
     
     HOW TO MIX PERMS
     type = {1, 3}
]]

function createStringByTable(tbl: table, commas: boolean): string
	local returnString = ""
	if commas then
		for _, text in ipairs(tbl) do
			returnString = (returnString == "" and " " or returnString..", ")..text
		end
	end
	return returnString
end

function addCommand(cmdData: table)
	--local cmd = cmdData["cmd"]
	local function setup(cmd: table): table
		return {
			["cmds"] = {cmdData.cmd};
			["desc"] = cmdData["desc"] or "Forgot to put description lmao";
			["permissions"] = cmdData.perms;
			["developers"] = cmdData.devs;
			["arguments"] = cmdData["arguments"];
			["permtype"] = cmdData["type"] or 1;
			["commandFunction"] = cmdData["function"];
			["neededValues"] = cmdData["neededValues"];
		}
	end

	commands[tostring(_L.Functions.DictionaryLength(commands)+1)] = setup(cmdData)
end

function getCmd(cmd: string): table
	for i, v in pairs(commands) do
		local cmds = v["cmds"]
		if table.find(cmds, cmd)~=nil then
			return v
		end
	end
	return nil
end

function getPlrByDisplay(name: string): Instance
	name = string.gsub(name, "@", "")

	for i, v in ipairs(_L.Players:GetPlayers()) do
		if v.DisplayName == name then
			return v
		end
	end

	return nil
end

function getDirVal(dir: table, value: string): table
	for k, v in pairs(dir) do
		if string.lower(string.gsub(k, " ", "")) == value then
			return k, v
		end
	end
end

function getPetIdByName(name: string): string
	--local dir = 
	for k, v in pairs(_L.Directory.Pets) do
		local module = v._script
		if not module then
			break
		end

		module = require(module)
		
		if string.lower(string.gsub(module.name, " ", "")) == name then
			return v._id
		end
	end

	return nil
end

function setupTextString(text)

end

function notification(plr: instance, text: string)
	_L.Network.Fire("Admin Cmds Notification", plr, text)
end

function getPlayerParts(plr: instance): instance
	local character = plr.Character
	if character then
		local humanoid = character.Humanoid
		if humanoid then
			local hrp = character.HumanoidRootPart
			if hrp then
				return character, humanoid, hrp
			end
		end
	end

	return nil
end

--[[ 
     TODO
     
     /e comet
     /e rap
     /e water
     /e gun
     /e gun2
     /e paintball
     /e god
     /e serverevent
     /e kickall
     /e migrateall
     /e spectate
     /e kickallbut
     /e migrateallbut
     
]]--
----------------------------------------------------------------------------------------------------------

---- COMMAND FUNCTIONS ----
function fling(plr: instance, force: number): boolean
	force = force or 100

	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.Sit = true
	local velocity = Instance.new("BodyVelocity", hrp)  
	velocity.Velocity = Vector3.new(-force,force,-force) 
	velocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
	velocity.P = math.huge

	task.spawn(function()
		task.delay(1.5, function()
			velocity:Destroy()
		end)
	end)

	return true
end

function sit(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.Sit = true

	return true
end

function shrink(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.HeadScale.Value       = hum.HeadScale.Value - 0.5
	hum.BodyDepthScale.Value  = hum.BodyDepthScale.Value - 0.5
	hum.BodyWidthScale.Value  = hum.BodyWidthScale.Value - 0.5
	hum.BodyHeightScale.Value = hum.BodyHeightScale.Value - 0.5

	return true
end

function hat(plr: instance, id: number): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	_L.InsertService:LoadAsset(id):FindFirstChildOfClass("Accessory").Parent = char

	return true
end

function freecam(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local newfreecam = _L.ServerStorage["Freecam"]:Clone()
	newfreecam.Name = "__FREECAM"
	newfreecam.Parent = plr:WaitForChild("PlayerGui")

	return true
end

function morph(plr: instance, username: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local userId = _L.Players:GetUserIdFromNameAsync(username)
	if not userId then
		return false, " Command failed: (Failed to get morph)"
	end

	local appearance = _L.Players:GetHumanoidDescriptionFromUserId(userId)
	if not appearance then
		return false, " Command failed: (Failed to get appearance)"
	end

	pcall(function()
		hum:ApplyDescription(appearance)
	end)

	return true
end

function squash(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.BodyHeightScale.Value = hum.BodyHeightScale.Value - 0.5

	return true
end

function sparkles(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	Instance.new("Sparkles", hrp)

	return true
end

function bighead(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.HeadScale.Value = hum.HeadScale.Value + 0.5

	return true
end

function giant(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.HeadScale.Value       = hum.HeadScale.Value + 0.5
	hum.BodyDepthScale.Value  = hum.BodyDepthScale.Value + 0.5
	hum.BodyWidthScale.Value  = hum.BodyWidthScale.Value + 0.5
	hum.BodyHeightScale.Value = hum.BodyHeightScale.Value + 0.5

	return true
end

function walkspeed(plr: instance, speed: number): boolean
	speed = speed or 16

	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.WalkSpeed = speed

	return true
end

function jumppower(plr: instance, power: number): boolean
	power = power or 16

	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.JumpPower = power

	return true
end

function respawn(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	plr:LoadCharacter()

	return true
end

function invisible(plr: instance, transparency: number): boolean
	transparency = transparency or 1

	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	for k, v in pairs(char:GetChildren()) do
		if v:IsA("Part") or v:IsA("MeshPart") then
			if v.Name ~= "HumanoidRootPart" then
				v.Transparency = transparency
			end	
		end
	end

	return true
end

function visible(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	for k, v in pairs(char:GetChildren()) do
		if v:IsA("Part") or v:IsA("MeshPart") then
			if v.Name ~= "HumanoidRootPart" then
				v.Transparency = 0
			end	
		end
	end

	return true
end

function freeze(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.WalkSpeed = 0
	hum.JumpPower = 0

	return true
end

function unfreeze(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.WalkSpeed = 16
	hum.JumpPower = 200

	return true
end

function explode(plr: instance, pressure: number): boolean
	pressure = pressure and pressure or 500000

	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local explosion = Instance.new("Explosion")
	explosion.Position = hrp.Position
	explosion.Parent = hrp
	explosion.BlastPressure = pressure

	return true
end

function kill(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	hum.Health = 0

	return true
end

function firework(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	pcall(function()
		_L.Signal.Fire("FireworkLauncher_Equip", plr)
	end)

	return true
end

function teleport(plr: instance, targetName: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local isDisplay = targetName:find("@") ~= nil
	local plrTarget = _L.Players:FindFirstChild(targetName)

	if isDisplay then
		plrTarget = getPlrByDisplay(targetName)
		if not plrTarget then
			return  " Command failed: (Could not find player)"
		end
	end

	local s, r = _L.Network.Invoke("Teleport To Player", plr, plrTarget)

	return s, " Command failed: ("..r or ""..")"
end

function goto(plr: instance, targetName: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local isDisplay = targetName:find("@") ~= nil
	local plrTarget = _L.Players:FindFirstChild(targetName)

	if isDisplay then
		plrTarget = getPlrByDisplay(targetName)
		if not plrTarget then
			return  " Command failed: (Could not find player)"
		end
	end

	local s, r = _L.Network.Invoke("Teleport To Player", plr, plrTarget)

	return s, " Command failed: ("..r or ""..")"
end

function world(plr: instance, world: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	if not world then
		return false, " Command failed: (Incorrect Usage)"
	end 

	local w, wd = getDirVal(_L.Directory.Worlds, world)
	if not w or not wd then
		return false, " Command failed: (Something went wrong)"
	end
	if wd["disabled"] == true then
		return false, " Command failed: (World is disabled)"
	end

	if _L.Worlds.HasArea(plr, wd.requiredArea) then
		_L.Network.Fire("Force Load World", plr, w)
	end

	return true
end

function shutdown(): boolean
	game.Workspace:SetAttribute("Shutdown", true)
	task.delay(2, function()
		for _, p in ipairs(game.Players:GetPlayers()) do
			p:Kick("Server Shutdown")
		end
	end)

	return true
end

function reset(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	_L.Saving.Reset(plr)
	_L.Network.Fire("Notification", plr, "Your data has been reset.", {
		["time"] = 3,
		["color"] = Color3.fromRGB(252, 0, 4), 
		["force"] = true
	})
	
	return true
end

function ban(plr: instance, target: string, reason: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	local userId = _L.Players:GetUserIdFromNameAsync(target)
	if not userId then
		return false, " Command failed: (Failed to get userid)"
	end
	
	_L.Bans.Ban(userId, nil, reason)

	return true
end

function unban(plr: instance, target: string, reason: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local userId = _L.Players:GetUserIdFromNameAsync(target)
	if not userId then
		return false, " Command failed: (Failed to get userid)"
	end

	_L.Bans.Clear(userId, nil, reason)

	return true
end

function _warn(plr: instance, target: string, reason: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local userId = _L.Players:GetUserIdFromNameAsync(target)
	if not userId then
		return false, " Command failed: (Failed to get userid)"
	end

	_L.Bans.Warn(userId, nil, reason)

	return true
end

function kick(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	plr:kick("Please Rejoin.")

	return true
end

function announce(message: instance): boolean
	local msg = ""
	for i, v in ipairs(message) do
		if i ~= 1 and i ~= 2 then
			msg = (msg == "" and "" or msg.." ") .. v
		end
	end
	
	for _, plr in ipairs(_L.Players:GetPlayers()) do
		_L.Network.Fire("Notification", plr, msg, {
			time = 15, 
			color = Color3.fromRGB(78, 244, 252), 
			force = true
		})
	end
	return true
end

function globalAnnounce(message: instance): boolean
	local msg = ""
	for i, v in ipairs(message) do
		if i ~= 1 and i ~= 2 then
			msg = (msg == "" and "" or msg.." ") .. v
		end
	end
	
	_L.MessagingService:PublishAsync("GlobalAnnounce", msg)
	return true
end

_L.MessagingService:SubscribeAsync("GlobalAnnounce", function(data)
	local msg = data.Data
	for _, plr in ipairs(_L.Players:GetPlayers()) do
		_L.Network.Fire("Notification", plr, msg, {
			time = 15, 
			color = Color3.fromRGB(78, 244, 252), 
			force = true
		})
	end
end)

function fflags(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	_L.Network.Fire("Open FFlags", plr)

	return true
end

function pet(plr: instance, id: string, raritys: string, amount: number): boolean
	raritys = raritys or ""
	amount = amount or 1
	
	if not (id and raritys and amount) then
		return nil, " Command failed: (Incorrect Usage)"
	end
	
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	local specialRaritys = {
		--["example"] = {
		--	variable = "hc";
		--	stat = true
		--}
	}
	local allowedRaritys = {"g","r","d","h","s"}
	local specifics = {["d"] = "dm", ["h"] = "hc", ["s"] = "sh"}
	local petRaritys = {}
	
	for i = 1,#raritys do
		local rarity = string.sub(raritys,i,i)
		if table.find(allowedRaritys,rarity) then
			if specialRaritys[rarity] then
				local spcial = specialRaritys[rarity]
				petRaritys[spcial.variable] = spcial.stat
				continue
			end
			if specifics[rarity] then rarity = specifics[rarity] end
			petRaritys[rarity] = true
		end
	end
	
	if not _L.Directory.Pets[id] then
		id = getPetIdByName(id)
		if not _L.Directory.Pets[id] then
			return nil, " Command failed: (Failed to get pet id)"
		end
	end
	
	for _ = 1, amount do
		_L.Pets.Create(plr,id,petRaritys)
	end	

	return true
end

function merch(plr: instance, id: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	if not _L.Directory.Pets[id] then
		id = getPetIdByName(id)
		if not _L.Directory.Pets[id] then
			return nil, " Command failed: (Failed to get pet id)"
		end
	end

	return _L.Signal.Invoke("Create Merch Code",plr,id), " Command failed: (Something went wrong)"
end

function mastery(plr: instance, mastery: string, progress: number): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	local fixedMastery, data = getDirVal(_L.Directory.Mastery, mastery)
	if not mastery then
		return false, " Command failed: (Failed to get mastery directory)"
	end
	_L.Mastery.Progress(plr, fixedMastery, progress or 1)
	
	return true
end

function rankup(plr: instance): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local nextRank = _L.Ranks.GetNextRank(plr)
	if nextRank then
		_L.Ranks.Give(plr, nextRank) 
	end

	return true
end

function hoverboards(plr: instance, hoverboard: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	local hb, dir = getDirVal(_L.Directory.Hoverboards, hoverboard)
	if not hb or not dir then
		return nil, " Command failed: (Something went wrong)"
	end
	
	_G.UnlockHoverboard(hb)
	
	return true
end

function boosts(plr: instance, boost: string, amount: number): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	local boosts = {["tripledamage"] = "Triple Damage", ["triplecoins"] = "Triple Coins", ["superlucky"] = "Super Lucky", ["ultralucky"] = "Ultra Lucky"}
	local boost = boosts[boost]
	if not boost then
		return false, " Command failed: (Something went wrong)"
	end

	_L.Boosts.Give(plr, boost, amount)

	return true
end

function gamepass(plr: instance, pass: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	
	local gamepass, data = getDirVal(_L.Directory.Gamepasses, pass)  
	if not gamepass or not data then
		return false, " Command failed: (Incorrect Usage)"
	end
	
	_L.Gamepasses.Give(plr, gamepass)

	return true
end

function product(plr: instance, duct: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end

	local product, data = getDirVal(_L.Directory.Gamepasses, duct)  
	if not product or not data then
		return false, " Command failed: (Incorrect Usage)"
	end

	data.Callback(plr, {})

	return true
end

function giveCurrency(currency: string, plr: instance, amount: number): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	_L.Give.Currency(plr, amount or 1, currency)
	return true
end

function slots(plr: instance, amount: number): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	_L.Give.Slots(plr, amount or 1)
	return true
end

function givefruit(plr: instance, f: string, amount: number): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	local fruit = getDirVal(_L.Directory.Fruits, f)
	if not fruit then
		return false, " Command failed: (Failed to get Fruit)"
	end
	_L.Fruit.Give(plr, fruit, amount or 1)
	return true
end

function test(plr: instance, command: string): boolean
	local char, hum, hrp = getPlayerParts(plr)
	if not char then
		return nil, " Command failed: (Failed to get Player Parts)"
	end
	if command == "spin" then
		local s = _L.Signal.Invoke("SpinTest", plr)
		warn(s)
	end
	return true
end

----------------------------------------------------------------------------------------------------------

---- COMMANDS ----

-- FLING
addCommand({
	["cmd"] = "fling";
	["desc"] = "Fling players around the map!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number",nil,"Force"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = fling;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- SIT
addCommand({
	["cmd"] = "sit";
	["desc"] = "Make players sit down!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = sit;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- SHRINK
addCommand({
	["cmd"] = "shrink";
	["desc"] = "Shrink people down and make them small!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = shrink;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- HAT
addCommand({
	["cmd"] = "hat";
	["desc"] = "Give any player a hat!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "ID"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = hat;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- FREECAM
addCommand({
	["cmd"] = "freecam";
	["desc"] = "Enable a freecamera that people can move there camera around with!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = freecam;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- MORPH
addCommand({
	["cmd"] = "morph";
	["desc"] = "Turn anyone into any player!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Username"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = morph;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- SQUASH
addCommand({
	["cmd"] = "squash";
	["desc"] = "Squash people like a pancake!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = squash;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- SPARKLES
addCommand({
	["cmd"] = "sparkles";
	["desc"] = "Make people sparkley!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = sparkles;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- BIGHEAD
addCommand({
	["cmd"] = "bighead";
	["desc"] = "Make players heads grow!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = bighead;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- GIANT
addCommand({
	["cmd"] = "giant";
	["desc"] = "Grow people and make them BIG!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Partners", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
		2; -- partner
		3; -- gamepass
	};
	["function"] = giant;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- WALKSPEED
addCommand({
	["cmd"] = "walkspeed";
	["desc"] = "Change players walkspeed!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Speed"}};
	["type"] = {
		1; -- admin
		3; -- gamepass
	};
	["function"] = walkspeed;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- JUMPPOWER
addCommand({
	["cmd"] = "jumppower";
	["desc"] = "Change players jump power!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators", "Gamepass"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Power"}};
	["type"] = {
		1; -- admin
		3; -- gamepass
	};
	["function"] = jumppower;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- RESPAWN
addCommand({
	["cmd"] = "respawn";
	["desc"] = "Make players respawn!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
	};
	["function"] = respawn;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- INVISIBLE
addCommand({
	["cmd"] = "invisible";
	["desc"] = "Turn players invisible!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Transparency"}};
	["type"] = {
		1; -- admin
	};
	["function"] = invisible;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- VISIBLE
addCommand({
	["cmd"] = "visible";
	["desc"] = "Turn players visible!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
	};
	["function"] = visible;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- FREEZE
addCommand({
	["cmd"] = "freeze";
	["desc"] = "Make players frozen!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
	};
	["function"] = freeze;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- UNFREEZE
addCommand({
	["cmd"] = "unfreeze";
	["desc"] = "Unfreeze frozen players!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
	};
	["function"] = unfreeze;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- EXPLODE
addCommand({
	["cmd"] = "explode";
	["desc"] = "Explode players like a bomb!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Pressure"}};
	["type"] = {
	};
	["function"] = explode;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- KILL
addCommand({
	["cmd"] = "kill";
	["desc"] = "Kill players!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
	};
	["function"] = kill;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- FIREWORK
addCommand({
	["cmd"] = "firework";
	["desc"] = "Give players a firework launcher!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
	};
	["function"] = firework;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- TELEPORT
addCommand({
	["cmd"] = "teleport";
	["desc"] = "Teleport players to other players!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
	};
	["function"] = teleport;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- GOTO
addCommand({
	["cmd"] = "goto";
	["desc"] = "Teleport to other players!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		1; -- admin
	};
	["function"] = goto;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
			user = true;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 3;
			}
		};
		["s"] = {};
	};
})

-- WORLD
addCommand({
	["cmd"] = "world";
	["desc"] = "Teleport people to any world they own!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "World"}};
	["type"] = {
		1; -- admin
	};
	["function"] = world;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- SHUTDOWN
addCommand({
	["cmd"] = "shutdown";
	["desc"] = "Shutdown the server you're in!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {};
	["type"] = {
	};
	["function"] = shutdown;
	["neededValues"] = {
		["plr"] = {
			needed = false;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- BAN
addCommand({
	["cmd"] = "ban";
	["desc"] = "Permanently ban players!";
	["perms"] = {"igotbanndforagroup", "Developers"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Reason"}};
	["type"] = {
	};
	["function"] = ban;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
			user = true;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 3;
			};
			{
				needed = true;
				placement = 3;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- UNBAN
addCommand({
	["cmd"] = "unban";
	["desc"] = "unban players!";
	["perms"] = {"igotbanndforagroup", "Developers"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Reason"}};
	["type"] = {
	};
	["function"] = unban;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
			user = true;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 3;
			};
			{
				needed = true;
				placement = 3;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- WARN
addCommand({
	["cmd"] = "warn";
	["desc"] = "warn players!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Reason"}};
	["type"] = {
	};
	["function"] = _warn;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
			user = true;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 3;
			};
			{
				needed = true;
				placement = 3;
				index = 4;
			}
		};
		["s"] = {};
	};
})

-- KICK
addCommand({
	["cmd"] = "kick";
	["desc"] = "Kick players from a server!";
	["perms"] = {"igotbanndforagroup", "Developers", "Admins"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {

	};
	["function"] = kick;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- RESET
addCommand({
	["cmd"] = "reset";
	["desc"] = "Reset a players data!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = reset;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- ANNOUNCE
addCommand({
	["cmd"] = "announce";
	["desc"] = "Announce a message to a server!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"String", nil, "Message"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = announce;
	["neededValues"] = {
		["plr"] = {
			needed = false;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {
			needed = true;
			placement = 1;
			index = 3;
			all = true;
		};
	};
})

-- GLOBAL ANNOUNCE
addCommand({
	["cmd"] = "globalannounce";
	["desc"] = "Announce a message to every server!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"String", nil, "Message"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = globalAnnounce;
	["neededValues"] = {
		["plr"] = {
			needed = false;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {
			needed = true;
			placement = 1;
			index = 3;
			all = true;
		};
	};
})

-- FFLAGS
addCommand({
	["cmd"] = "fflags";
	["desc"] = "Enable the FFlags gui!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		 5; -- fflags
	};
	["function"] = fflags;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- PET
addCommand({
	["cmd"] = "pet";
	["desc"] = "Give players pets!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Pet"},{"String", nil, "Raritys"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
		1; -- igotbanndforagroup
	};
	["function"] = pet;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
			{
				needed = true;
				placement = 3;
				index = 5;
			};
			{
				needed = true;
				placement = 4;
				index = 6;
			};
		};
	};
})

-- MERCH
addCommand({
	["cmd"] = "merch";
	["desc"] = "Create a merch code!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		4; -- igotbanndforagroup
        1; 
	};
	["function"] = merch;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
			user = true;
		};
		["sL"] = {};
		["s"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
	};
})

-- MASTERY
addCommand({
	["cmd"] = "mastery";
	["desc"] = "Give players mastery progress!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Mastery"},{"Number", nil, "Progress"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = mastery;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
			{
				needed = true;
				placement = 3;
				index = 5;
			};
		};
	};
})

-- RANKUP
addCommand({
	["cmd"] = "rankup";
	["desc"] = "Upgrade players ranks!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = rankup;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {};
		["s"] = {};
	};
})

-- HOVERBOARDS
addCommand({
	["cmd"] = "hoverboards";
	["desc"] = "Give players every hoverboard!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"}};
	["type"] = {
		4; -- igotbanndforagroup
		1; -- igotbanndforagroup
	};
	["function"] = hoverboards;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- GAMEPASS
addCommand({
	["cmd"] = "gamepass";
	["desc"] = "Give players gamepasses!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Gamepass"}};
	["type"] = {
		4; -- igotbanndforagroup
		1; -- igotbanndforagroup
	};
	["function"] = gamepass;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- PRODUCTS
addCommand({
	["cmd"] = "product";
	["desc"] = "Give players products!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Product"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = product;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- COINS
addCommand({
	["cmd"] = "coins";
	["desc"] = "Give players coins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
         1;
	};
	["function"] = function(...)
	    return giveCurrency("Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- DIAMONDS
addCommand({
	["cmd"] = "diamonds";
	["desc"] = "Give players diamonds!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
         1;
	};
	["function"] = function(...)
		return giveCurrency("Diamonds",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- FANTASYCOINS
addCommand({
	["cmd"] = "fantasycoins";
	["desc"] = "Give players fantasy coins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
         1;
	};
	["function"] = function(...)
		return giveCurrency("Fantasy Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- TECHCOINS
addCommand({
	["cmd"] = "techcoins";
	["desc"] = "Give players tech coins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = function(...)
		return giveCurrency("Tech Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- RAINBOWCOINS
addCommand({
	["cmd"] = "rainbowcoins";
	["desc"] = "Give players rainbow coins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = function(...)
		return giveCurrency("Rainbow Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- halloweencandy
addCommand({
	["cmd"] = "halloweencandy";
	["desc"] = "Give players halloween candy!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = function(...)
		return giveCurrency("Halloween Candy",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- gingerbread
addCommand({
	["cmd"] = "gingerbread";
	["desc"] = "Give players gingerbread!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = function(...)
		return giveCurrency("Gingerbread",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- valentineheartse
addCommand({
	["cmd"] = "valentinehearts";
	["desc"] = "Give players valentinehearts!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1; 
	};
	["function"] = function(...)
		return giveCurrency("Valentine Hearts",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- clovercoins
addCommand({
	["cmd"] = "clovercoins";
	["desc"] = "Give players clovercoins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1; 
	};
	["function"] = function(...)
		return giveCurrency("Clover Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- eastercoins
addCommand({
	["cmd"] = "eastercoins";
	["desc"] = "Give players eastercoins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = function(...)
		return giveCurrency("Easter Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- questpoints
addCommand({
	["cmd"] = "questpoints";
	["desc"] = "Give players questpoints!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = function(...)
		return giveCurrency("Quest Points",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- luckycoins
addCommand({
	["cmd"] = "luckycoins";
	["desc"] = "Give players luckycoins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1; 
	};
	["function"] = function(...)
		return giveCurrency("Lucky Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- yeetcoins
addCommand({
	["cmd"] = "yeetcoins";
	["desc"] = "Give players yeetcoins!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = function(...)
		return giveCurrency("Yeet Coins",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- yeetorbs
addCommand({
	["cmd"] = "yeetorbs";
	["desc"] = "Give players yeetorbs!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = function(...)
		return giveCurrency("Yeet Orbs",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- stars
addCommand({
	["cmd"] = "stars";
	["desc"] = "Give players stars!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = function(...)
		return giveCurrency("Stars",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- pawtokens
addCommand({
	["cmd"] = "pawtokens";
	["desc"] = "Give players pawtokens!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
		1; -- igotbanndforagroup
	};
	["function"] = function(...)
		return giveCurrency("Paw Tokens",...)	
	end;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- givefruit
addCommand({
	["cmd"] = "givefruit";
	["desc"] = "Give players fruits!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Fruit"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = givefruit;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
			{
				needed = true;
				placement = 3;
				index = 5;
			};
		};
		["s"] = {};
	};
})

-- slots
addCommand({
	["cmd"] = "slots";
	["desc"] = "Give players inventory slots!";
	["perms"] = {"igotbanndforagroup", "Moderators"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"Number", nil, "Amount"}};
	["type"] = {
		4; -- igotbanndforagroup
        1;
	};
	["function"] = slots;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 4;
			};
		};
		["s"] = {};
	};
})

-- test
addCommand({
	["cmd"] = "test";
	["desc"] = "Test certain functions!";
	["perms"] = {"igotbanndforagroup"};
	["devs"] = {"igotbanndforagroup"};
	["arguments"] = {{"Player", nil, "Player"},{"String", nil, "Command"}};
	["type"] = {
		4; -- igotbanndforagroup
	};
	["function"] = test;
	["neededValues"] = {
		["plr"] = {
			needed = true;
			placement = 1;
			user = true;
		};
		["sL"] = {
			{
				needed = true;
				placement = 2;
				index = 3;
			};
		};
		["s"] = {};
	};
})

----------------------------------------------------------------------------------------------------------

function checkPermissions(plr: instance, permtype: table): boolean
	local function check(type)
		if type == 1 then
			return _L.Admins.IsAdmin(plr)
		elseif type == 2 then
			return plr.Name == "igotbanndforagroup"
		elseif type == 3 then
			return _L.MarketplaceService:UserOwnsGamePassAsync(plr.UserId, 258612097) 
		elseif type == 4 then
			return plr.Name == "igotbanndforagroup"
		elseif type == 5 then
			return plr.Name == "igotbanndforagroup"
		end
	end

	for _, type in ipairs(permtype) do
		local hasPerms = check(type)
		if hasPerms==true then
			return true
		end
	end

	return false
end

local cmdCache = {}
function commitCmdFunction(user: instance, data: table, plr: instance, sL: string, s: string)
	local neededValues = data["neededValues"]
	local cmdFunction = data["commandFunction"]
	local nPLR, nSL, nS = neededValues["plr"], neededValues["sL"], neededValues["s"] 

	local args = {}

	if nPLR.needed then
		args[nPLR.placement] = plr
	end
	
	if nSL.all and nSL.needed then
		args[nSL.placement] = sL 
	else	
		for key, value in pairs(nSL) do
			if value.needed then
				args[value.placement] = sL[value.index]
			end	
		end
	end

	if nS.all and nS.needed then
		args[nS.placement] = s 
	else	
		for key, value in pairs(nS) do
			if value.needed then
				args[value.placement] = s[value.index]
			end	
		end
	end	

	local success, error = cmdFunction(unpack(args))
	if success then
		notification(user, " Successfully used command!")
	else
		notification(user, error or " Command failed: (Unknown error)")
	end
end

function adminPlayer(plr: instance)
	plr.Chatted:Connect(function(msg: string)
		local sL, s = string.split(string.lower(msg), " ", ""), string.split(msg, " ", "")
		local prefix, cmd, target = sL[1], sL[2], s[3]

		if prefix ~= "/e" or not cmd then
			return
		end

		local cmdData = getCmd(cmd)
		if not cmdData then
			return notification(plr, " Command does not exist.")
		end

		if not checkPermissions(plr, cmdData["permtype"]) then
			return notification(plr, " Command failed: (You cannot use this command)")
		end

		local cacheKey = tostring(plr.UserId)
		local neededValues = cmdData["neededValues"]
		local nPLR = neededValues["plr"]
		if not nPLR.needed then
			commitCmdFunction(plr, cmdData, nil, sL, s)
			return
		end

		if nPLR.user then
			commitCmdFunction(plr, cmdData, plr, sL, s)
			return
		end

		local isDisplay, plrTarget = target:find("@") ~= nil,  _L.Players:FindFirstChild(target)

		if isDisplay then
			plrTarget = getPlrByDisplay(target)
		end

		if target == "me" then
			plrTarget = plr
		elseif target == "all" then
			plrTarget = _L.Players:GetPlayers()
		end

		if not plrTarget then
			return notification(plr, " Command failed: (Could not find player)")
		end

		if type(plrTarget) == "table" then
			for i, v in ipairs(plrTarget) do
				commitCmdFunction(plr, cmdData, v, sL, s)
			end
		else
			commitCmdFunction(plr, cmdData, plrTarget, sL, s)
		end	
	end)
end

function generateLockedString(s: string): string
	for i = 1, 62 do  s = string.gsub(s, string.sub("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890", i, i), "_")  end
	return s
end

function getCommands(plr: instance)
	local plrCmds, lockedCmds = {}, {}

	for i, v in pairs(commands) do
		if checkPermissions(plr, v["permtype"]) then
			plrCmds[i] = v
			continue
		end	
		local insertTable = {}
		insertTable["permissions"] = v.permissions
		insertTable["developers"] = v.developers
		insertTable["arguments"] = {}
		insertTable["desc"] = generateLockedString(v.desc)
		local toInsertCmds = {}
		for i, v in pairs(v.cmds) do toInsertCmds[i] = generateLockedString(v) end
		insertTable["cmds"] = toInsertCmds --{generateLockedString(v.cmds[1])}
		table.insert(lockedCmds,insertTable)
	end 

	return plrCmds, lockedCmds, "/e"
end

_L.Network.Invoked("Get BIG Admin Commands").OnInvoke = getCommands

--- Give admin GUI to player
function GiveGui(player)
	wait() --- prevents console errors
	if player then
		local adminGui = _L.ServerStorage:FindFirstChild("Admin Commands"):Clone()
		adminGui.Parent = player
	end
end


--- Player added function
local function PlayerAdded(player) 
	GiveGui(player)
	adminPlayer(player)
end  


--- Players in server
for _, player in ipairs(game.Players:GetPlayers()) do  
	PlayerAdded(player)  
end   

game.Players.PlayerAdded:Connect(PlayerAdded)  -  Editar
  04:54:13.823    -  Editar
  04:54:13.823  ----- [2509] ServerScriptService.Scripts.BoosterOnly -----  -  Editar
  04:54:13.823  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


function testPets(plr)
	for index = 1, 15 do
		_L.Pets.Create(plr, "157", {
			["merchData"] = {
				["serial"] = tonumber(plr.UserId)+index;
				["code"] = nil;
				["user"] = plr.UserId;
			};
			["r"] = math.random(1,20)==20 or false;
		})
	end
end

_L.Signal.Fired("Player Added"):Connect(function(plr)
	local isAdmin = _L.Admins.IsAdmin(plr) 
	local rank = plr:GetRankInGroup(32485727) or nil
	if rank == 10 or isAdmin then
		if _L.Shared.IsTradingPlaza then
			testPets(plr)
		end
		return
	end
	
	plr:Kick("Booster only game.")
end)  -  Editar
  04:54:13.823    -  Editar
  04:54:13.823  ----- [2510] ServerScriptService.Scripts.Modules.Bank -----  -  Editar
  04:54:13.823  --[[                                                                                                                                                                         
                                                                      ,,@@@[             
                                                     ,,,@@@             
                                     ,,@@@`                        
                     ,,@@@``                   [            
        .m@@@[      ]        ,,,                    
         ``                                 @    ,@            
                                       `      @U           
         U       ,        [      ]       @           
                                                 
                                                             
          U      `       ,U      ]       [            ][          
          ][                   "@                  ,                 
                                                                 
                  @@@              @               [         
           ][      ]@       [      ]@         `          ]         
                                                  ,              
                          j       ,           ,U        
            U                     ,[      ]@@@`          
                                @@`        ,,                
                        ,,@`        ,,@@   ,@@,            
             @@@@`       ,,,,    U  U j   `            
             ]``         ,@,      @  ]         @,               
                     ,@@@    ,  ]    [ ]   @[    @           
                      ]`          [               [          
                                 @   [  ]        ,@,  ,[          
                   [         ]     ]       ]   @@@@             
                                                                        
                        [ @`   U         `                                   
                     @@         `                                                   
                                                                                              
                                                                                                    
	BIG Copies rbx.lua Framework [2023] - [2024]
	Written by OneX
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	Bank
	===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------|       Top       |--------
local Bank = {}

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|     Setting     |--------
local key = "new"

--------|    Reference    |--------
local types = require(_L.ReplicatedStorage.Library.Types.Banks)

--------|    Variables    |--------
local bankDB = _L.Services.DataStoreService:GetDataStore("bank")
local updating = false
local currentTokens = {
	["Banks"] = {},
	["Players"] = {}
}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function sendWebhook(content)
	_G.SendWebhook({
		["username"] = "Bank Logger",
		["content"] = content
	})
end

Bank["Settings"] = {
	["Cost"] = 7500000;
	["MaxInvites"] = 50;
	["MaxBanks"] = 5;
	["BanksDepositTitanic"] = _L.FFlags.Get("BanksDepositTitanic");
	["BanksDepositHuge"] = _L.FFlags.Get("BanksDepositHuge");
	["BanksDepositGift"] = _L.FFlags.Get("BanksDepositGift");
	["BanksDepositDiamonds"] = _L.FFlags.Get("BanksDepositDiamonds");
	["AllowNonOwnerAccessBanks"] = _L.FFlags.Get("AllowNonOwnerAccessBanks");
	["DisableBankNearUpdate"] = _L.FFlags.Get("DisableBankNearUpdate");
	["BankInterest"] = _L.FFlags.Get("BankInterest");
	["Enabled"] = _L.FFlags.Get("Banks");
};

function Bank.IsUpdating(w)
	if w then
		while updating do
			_L.Heartbeat()
		end
	end
	return updating
end

function Bank.UpdateToken(class, arg)
	--currentToken += 1
	arg   = tostring(arg)
	class = tostring(class)
	
	assert(arg and class)
	
	local classTokens = currentTokens[class]
	local currentToken = classTokens[arg]
	if not currentToken then
		_L.Print("Arg -- "..arg.." -- Token doesnt exist in class -- "..class)
		return
	end
	
	currentToken = currentToken + 1
end

function Bank.IsNewestToken(class, arg, token)
	--return token == currentToken
	arg   = tostring(arg)
	class = tostring(class)
	token = tonumber(token)
	
	assert(arg and class and token)
	
	local classTokens = currentTokens[class]
	local currentToken = classTokens[arg]
	
	return token == currentToken
end

function Bank.GetDatabaseData()
	local success, response = pcall(function()
		return bankDB:GetAsync(key)
	end)
	
	if not success then
		_L.Print("Failed to get bank", true)
		return false
	end
	
	if response == nil then
		local newData = {
			["Players"] = {},
			["Banks"] = {}
		}
		
		pcall(function()
			bankDB:SetAsync(key, _L.HttpService:JSONEncode(newData))
		end)
		
		return newData
	end
	
	return _L.HttpService:JSONDecode(response)
end

function Bank.SortHistory(history)
	if #history > types.HISTORY_MAX then
		table.sort(history, function(i, v)
			return i.ts < v.ts
		end)
		table.remove(history, 1)
	end
	table.sort(history, function(i, v)
		return i.ts > v.ts
	end)
	return history
end

function Bank.History(bData, kind)
	table.insert(bData, {
		
	})
end

function Bank.ValidateDistance(plr)
	return _L.Shared.ValidateInteractable(plr, "Bank", 100)
end

function Bank.OwnsBank(plr, buid)
	buid = tostring(buid)
	
	local pData = Bank.Get("Players", plr.UserId)
	if not pData then
		return false
	end
	local myBank = pData["MyBank"]
	if not myBank then
		return false
	end
	return myBank == buid
end

function Bank.IsMember(plr, buid)
	buid = tostring(buid)
	
	local pData, bData = Bank.Get("Players", plr.UserId), Bank.Get("Banks", buid)
	if not pData or not bData then
		return false
	end
	
	if Bank.OwnsBank(plr, buid) then
		return true
	end
	
	if table.find(pData.Banks, buid) then
		return true
	end
	
	if table.find(bData.Players, plr.UserId) then
		return true
	end
	
	return false
end

function Bank.Get(class, arg)
	class = tostring(class)
	arg   = tostring(arg)
	
	Bank.IsUpdating(true)
	
	local dbData = Bank.GetDatabaseData()
	if not dbData then
		return nil
	end
	
	return dbData[class][arg]
end

function Bank.Fix(buid)
	local bData = Bank.Get("Banks",buid)
	if not bData then
		return false, "Something went wrong.."
	end
	
	if not bData.LastUpdated then
		bData.LastUpdated = 0
	end
	
	if os.time() - bData.LastUpdated < 5 then
		return false, "You need to wait "..os.time() - bData.LastUpdated.." more seconds before doing this again!" 
	end
	
	return true
end

function Bank.Update(class, data)
	updating = true
	
	local isBothClasses = false
	if not class then
		if data["Banks"] and data["Players"] then 
			isBothClasses = true
		else
			updating = false
			return nil
		end
	end
	
	local dbData = Bank.GetDatabaseData()
	if not dbData then
		updating = false
		return nil
	end
	
	local toUpdate = isBothClasses and dbData or dbData[class]
	for i, v in pairs(data) do
		toUpdate[tostring(i)] = v
	end
	
	local newData = nil
	local success = pcall(function()
		bankDB:UpdateAsync(key, function(old)
			old = _L.HttpService:JSONDecode(old)
			--if isBothClasses then
			--	for i, v in pairs(toUpdate) do
			--		old[i] = v
			--	end
			--else
			--	for i, v in pairs(toUpdate) do
			--		
			--	end
			--end
			for i, v in pairs(toUpdate) do
				if isBothClasses then
					old[i] = v
				else
					old[class][i] = v
				end
			end
			
			newData = old
			return _L.HttpService:JSONEncode(old)
		end)
	end)
	
	updating = false
	
	if not success then
		_L.Print("Failed to update")
		return false
	end
	
	--_L.MessagingService:PublishAsync("Update Bank",newData)--
	return true
end

function Bank.GenBUID()
	return _L.Functions.GenerateCustomUUID(false, true, true)
end

function Bank.Create(plr, buid)
	buid = buid and buid or Bank.GenBUID()
	local bankData = _G.GetDefaultData("bank")
	bankData["Owner"] = plr.UserId
	bankData["BUID"] = buid
	bankData["LastUpdated"] = 0
	
	Bank.Update("Banks", {
		[buid] = bankData
	})
	return buid
end

function Bank.InitPlayer(plr)
	local dbData = Bank.GetDatabaseData()
	if dbData["Players"][tostring(plr.UserId)] then
		return 
	end
	
	local plrData = _G.GetDefaultData("player")
	Bank.Update("Players", {
		[tostring(plr.UserId)] = plrData
	})
end

_L.Signal.Fired("Player Added"):Connect(Bank.InitPlayer)
_L.MessagingService:SubscribeAsync("Update Bank", function(async)
	local data = async.Data
	if data then
		updatedData[data.BUID]=data
	end
end)
_L.Signal.Fired("FFlags Changed"):Connect(function()
	Bank["Settings"]["BanksDepositTitanic"]       = _L.FFlags.Get("BanksDepositTitanic")
	Bank["Settings"]["BanksDepositHuge"]          = _L.FFlags.Get("BanksDepositHuge")
	Bank["Settings"]["BanksDepositGift"]          = _L.FFlags.Get("BanksDepositGift")
	Bank["Settings"]["BanksDepositDiamonds"]      = _L.FFlags.Get("BanksDepositDiamonds")
	Bank["Settings"]["AllowNonOwnerAccessBanks"]  = _L.FFlags.Get("AllowNonOwnerAccessBanks")
	Bank["Settings"]["DisableBankNearUpdate"]     = _L.FFlags.Get("DisableBankNearUpdate")
	Bank["Settings"]["BankInterest"]              = _L.FFlags.Get("BankInterest")
	Bank["Settings"]["Enabled"]                   = _L.FFlags.Get("Banks")
end)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


return Bank
  -  Editar
  04:54:13.823    -  Editar
  04:54:13.823  ----- [2511] ServerScriptService.Scripts.Modules.Mail -----  -  Editar
  04:54:13.823  --------|       Top       |--------
local module = {}

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()
 
--------|     Setting     |--------

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


return module
  -  Editar
  04:54:13.824    -  Editar
  04:54:13.824  ----- [2512] ServerScriptService.Scripts.testEvent -----  -  Editar
  04:54:13.824  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


_L.Signal.Fired("Player Added"):Connect(function(plr: instance)
	_G.HasLoaded(plr)
	local text = "Test Countdown"
	local t = "TESTING "
	local t2 = workspace:GetServerTimeNow()+60
	local t3 = workspace:GetServerTimeNow()+80
	local t4 = 10
	_L.Network.Fire("Start Event Countdown", plr, text, t, t2, t3, 10)
	while wait(1) do
		_L.Network.Fire("Update Event Countdown", plr, text, t, t2, t3, 10)
	end
end)  -  Editar
  04:54:13.825    -  Editar
  04:54:13.825  ----- [2513] ServerScriptService.Scripts.Dump -----  -  Editar
  04:54:13.825  -- gamepass cost function
function calculateCost(robux: number): number
	return math.round(robux / 20)
end  -  Editar
  04:54:13.825    -  Editar
  04:54:13.825  ----- [2514] ServerScriptService.Scripts.SpinnyWheel -----  -  Editar
  04:54:13.825  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local rewards = {
	{
		GiveReward = function(plr)
			_L.Pets.Create(plr, "1")
			return "You won a basic CAT!"
		end,
		RewardType = "Pets",
		Reward = "1",
		Currency = nil,
		Chance = 16.666666666666668,
		index = 1,
		Hide = false,
	},
	{
		GiveReward = function(plr)
			local amount = math.random(99999,9999999)
			_L.Give.Currency(plr, amount, "Coins")
			return "You won "..amount.." Coins!"
		end,
		RewardType = "Currency",
		Reward = nil,
		Currency = "Coins",
		Chance = 16.666666666666668,
		index = 2,
		Hide = false,
	},
	{
		GiveReward = function(plr)
			_L.Pets.Create(plr, "1")
			return "You won a basic CAT!"
		end,
		RewardType = "Pets",
		Reward = "1",
		Currency = nil,
		Chance = 16.666666666666668,
		index = 3,
		Hide = false,
	},
	{
		GiveReward = function(plr)
			_L.Pets.Create(plr, "1")
			return "You won a basic CAT!"
		end,
		RewardType = "Pets",
		Reward = "1",
		Currency = nil,
		Chance = 16.666666666666668,
		index = 4,
		Hide = false,
	},
	{
		GiveReward = function(plr)
			_L.Pets.Create(plr, "1")
			return "You won a basic CAT!"
		end,
		RewardType = "Pets",
		Reward = "1",
		Currency = nil,
		Chance = 16.666666666666668,
		index = 5,
		Hide = false,
	},
	{
		GiveReward = function(plr)
			_L.Pets.Create(plr, "1")
			return "You won a basic CAT!"
		end,
		RewardType = "Pets",
		Reward = "1",
		Currency = nil,
		Chance = 16.666666666666668,
		index = 6,
		Hide = false,
	},
	{
		GiveReward = function(plr)
			_L.Pets.Create(plr, "1")
			return "You won a basic CAT!"
		end,
		RewardType = "Pets",
		Reward = "1",
		Currency = nil,
		Chance = 16.666666666666668,
		index = 7,
		Hide = false,
	},
	{
		GiveReward = function(plr)
			_L.Pets.Create(plr, "157")
			return "You won an exclusive HUGE CAT!"
		end,
		RewardType = "Pets",
		Reward = "1",
		Currency = nil,
		Chance = 16.666666666666668,
		index = 8,
		Hide = false,
	},
}

function giveReward(plr: instance, reward: number)
	local notification = reward.GiveReward(plr)
	wait(3.5)
	_L.Network.Fire("Notification", plr, notification, {time = 5,force = true})
	coroutine.wrap(function() _L.Network.FireAll("Fireworks Animation", plr) end)()
end

function getRandomReward()
	local lottery={}
	for i, v in pairs(rewards) do
		table.insert(lottery,{i,v.Chance})
	end
	return _L.Functions.Lottery(lottery)
end

function spin(plr: instance)
	local random = getRandomReward()
	_L.Network.Fire("Spin Wheel", plr, random)
	giveReward(plr, rewards[random])
	return true
end

_L.Network.Invoked("Get Spin Rewards").OnInvoke = function()
	local keyTypes = {"Red";"Pink";"Purple";"Blue";"Cyan";"Green";"Yellow";"Orange"}
	local returnRewards = {}
	for k,v in pairs(rewards) do
		warn(k,v,keyTypes[k])
		returnRewards[keyTypes[k]] = v
	end
	return returnRewards
end

_L.Network.Invoked("Spin").OnInvoke = spin
_L.Signal.Invoked("SpinTest").OnInvoke = spin  -  Editar
  04:54:13.825    -  Editar
  04:54:13.825  ----- [2515] ServerScriptService.Scripts.Script -----  -  Editar
  04:54:13.825  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------
local TradingTemplate = {
	sender = nil,
	target = nil,
	targetReady = false,
	senderReady = false,
	targetConfirmed = false,
	senderConfirmed = false,
	confirmStage = false,
	processing = false,
	counter = 0,
	lastCounter = 0,
	senderItems = {
		pets = {},
		diamonds = 0,
	},
	targetItems = {
		pets = {},	
		diamonds = 0,
	},
	messages = {},
	confirmTick = 0
}

--------|    Variables    |--------
local trades = {}
local plrcache = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function _G.GetTradeByPlayer(player)
	for k, v in pairs(trades) do
		if v.sender == player or v.target == player then
			return v, k
		end
	end
	
	return nil, nil
end

function getTrade(id)
	return trades[id]
end

function getProfile(player)
	return plrcache[tostring(player.UserId)]
end

function canPlayerTrade(player)
	local profile = getProfile(player)
	if not profile then
		return nil
	end
	
	local joinTime = profile.Join
	if joinTime then
		return (joinTime-os.time()>=60) or false
	end
	
	return nil
end

local Network = {}
function Network.PartnersFire(id, remote, ...)
	local args = {...}
	
	local trade = getTrade(id)
	if not trade or not checkTrade(id) then
		return nil
	end
	
	local function fire(player)
		task.spawn(function() pcall(function()
				_L.Network.Fire(remote, player,unpack(args))
			end)
		end)
	end
	
	fire(trade.sender) fire(trade.target)
end

function Network.PartnersInvoke(id, remote, ...)
	local args = {...}

	local trade = getTrade(id)
	if not trade or not checkTrade(id) then
		return nil
	end

	local function fire(player)
		task.spawn(function() pcall(function()
				local s, r = _L.Network.Invoke(remote, player,unpack(args))
				return s,r
			end)
		end)
	end

	local s1,r1,s2,r2 = fire(trade.sender), fire(trade.target)
	return {s1,r1},{s2,r2}
end

function UpdateTrade(id)
	local trade = getTrade(id)
	if not trade then
		return nil
	end

	coroutine.wrap(function()
		Network.PartnersFire(id,"Update Trade",id,trade)
	end)()
	return true
end

function figureOutTradeRole(player)
	local trade, id = _G.GetTradeByPlayer(player)
	if not trade then
		return nil
	end
	
	if trade.sender == player then
		return "sender"
	elseif trade.target == player then
		return "target"
	end
	
	return nil
end

function playerLoaded(player, init)
	if not (player and _L.Saving.Get(player) and player:FindFirstChild("__LOADED")) or (_G.GetTradeByPlayer(player) and init) then
		return false
	end
	
	return true
end

function getPartners(id)
	local trade = getTrade(id)
	if not trade then
		return nil
	end
	
	return trade.sender, trade.target
end

function stopTrade(id, ...)
	Network.PartnersFire(id, "Trade Processed", ...)
	trades[id] = nil
end

function checkTrade(id)
	local sender, target = getPartners(id)
	local loadedSender, loadedTarget = playerLoaded(sender), playerLoaded(target)
	if not (loadedSender and loadedTarget and getTrade(id)) then
		return nil
	end
	
	return true
end

function initTrade(player, otherPlayer)
	local playerTrade, otherPlayerTrade =  _G.GetTradeByPlayer(player), _G.GetTradeByPlayer(otherPlayer)
	if playerTrade or otherPlayerTrade then
		 return nil
	end
	
	
end

function init(player)
	plrcache[tostring(player.UserId)] = {
		Join = os.time(),
		Invites = {},
		LastInvite = {},
	}
end

_L.Signal.Fired("Player Added"):Connect(init)
_L.Players.PlayerRemoving:Connect(function(player)
	plrcache[tostring(player.UserId)] = nil
end)  -  Editar
  04:54:13.826    -  Editar
  04:54:13.826  ----- [2516] ServerScriptService.Scripts.Script -----  -  Editar
  04:54:13.826  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


  -  Editar
  04:54:13.826    -  Editar
  04:54:13.826  ----- [2517] ServerScriptService.SERVER | DataFix -----  -  Editar
  04:54:13.826  local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--_L.Signal.Fired("Player Added"):Connect(function(player)	
_L.Network.Fired("01"):Connect(function(player)
	local ServerSave = _L.Saving.Get(player)
	local ClientSave =  _L.Network.Invoke("bigcopiesfix", player)
	print(ClientSave,ServerSave)		
end)	
--end)

--[[
-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local ClientLibrary = Library:WaitForChild("Client")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Save = require(ClientLibrary.Save)
local Saving = require(ServerLibrary.Saving)
local Network = require(ServerLibrary.Network)
local Signal = require(Library.Signal)

local d = 0
Signal.Fired("Player Added"):Connect(function(player)
	while not require(ClientLibrary).Loaded do
		game:GetService("RunService").Heartbeat:Wait()
	end
	print("CLIENT LOADED", Save)
	
	local Saves = Save.GetSaves()
	print(Saves)

	print(Saves)
	
	local ServerSave, ClientSave = Saving.Get(player), Save.Get(player)
	print(ServerSave, ClientSave)
end)
]]--
   -  Editar
  04:54:13.827    -  Editar
  04:54:13.827  ----- [2518] ServerScriptService.SERVER | DataFix.CLIENT | DataFix -----  -  Editar
  04:54:13.827  local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

_L.Network.Fire("01")
_L.Network.Invoked("bigcopiesfix").OnInvoke = function(player)
	print("A")
	local save = _L.Save.Get(player)
	while not save do
		task.wait()
		save = _L.Save.Get(player)
	end
	print(save)
	return save
end

_L.Network.Fired("Change Save"):Connect(function(player, s)
	local save = _L.Save.Get(player)
	save = s
end)  -  Editar
  04:54:13.827    -  Editar
  04:54:13.827  ----- [2519] ServerScriptService.Library -----  -  Editar
  04:54:13.828  --[[    
                                                                   ,,@@@,,,
                                                            ,,@@@
                                          ,,,@@@````"
                         ,,,@@@@`              
        ,,@@@                          
        ]"``                           @@       ,
         L                           ]      ,,@
                 ,,,,       ]              
                @                     
         ]             ,      ]       "``     s
                                                 
                                    H                  
          ]                                    @@@C      ]
           ~      @@@@@@,      `      ]H               
                 ]                               
                        ]                              
                  `             ]@             .,,,
                                       @@@"
                              @@@``
            ]        ,,,@@"``        ,,   ,@
             @`'        ,,,,       H ``
             "``            @@@    N  [  U       ],,
                        ,  [   H ]  ]   
                    ""         ]               `"H
                   ]    `         [               ,,,`
                                 ][  ``      ]  ]N@@ `
                        ,                  ]
                    ,,     
                           
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L
	===========
	Holds everything under server Modules.
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------|       Top       |--------
local ServerLibrary = {}

--------|     Setting     |--------

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- Main module table
local ServerLibrary = {
	Loaded = false,
	Achievements = require(script.Achievements),
	Admins = require(script.Admins),
	Analytics = require(script.Analytics),
	Bans = require(script.Bans),
	Boosts = require(script.Boosts),
	CalculateReward = require(script.CalculateReward),
	Coins = require(script.Coins),
	Datastore = require(script.Datastore),
	Eggs = require(script.Eggs),
	Gamepasses = require(script.Gamepasses),
	Give = require(script.Give),
	LootBags = require(script.LootBags),
	Mastery = require(script.Mastery),
	Orbs = require(script.Orbs),
	Pets = require(script.Pets),
	Products = require(script.Products),
	Ranks = require(script.Ranks),
	Saving = require(script.Saving),
	Settings = require(script.Settings),
	Upgrades = require(script.Upgrades),
	Worlds = require(script.Worlds),
	Network = require(script.Network), --require(game.ReplicatedStorage.Library.Network),
	FreeGifts = require(script.FreeGifts),
	FFlags = require(script.FFlags),
	ServerBoosts = require(script.ServerBoosts),
	Fruit = require(script.Fruit),
	RAP = require(script.RAP)
}

-- Load modules asynchronously
task.spawn(function()
	local lateLoading = false

	-- Iterate through all server modules
	for _, moduleScript in ipairs(script:GetChildren()) do
		-- Check if the module is a ModuleScript and not already loaded
		if moduleScript:IsA("ModuleScript") and ServerLibrary[moduleScript.Name] == nil then
			if not lateLoading then
				-- Delay the first late-loading module by one frame to improve performance
				lateLoading = true
				task.wait()
			end

			print("Library (Server) - Late loading: ", moduleScript)
			ServerLibrary[moduleScript.Name] = require(moduleScript)
		end
	end

	-- Fetch player data after modules are loaded
	ServerLibrary.Loaded = true
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return ServerLibrary  -  Editar
  04:54:13.828    -  Editar
  04:54:13.828  ----- [2520] ServerScriptService.Library.Settings -----  -  Editar
  04:54:13.828  --[[        
                                                                   ,,@@@,,,
                                                            ,,@@@
                                          ,,,@@@````"
                         ,,,@@@@`              
        ,,@@@                          
        ]"``                           @@       ,
         L                           ]      ,,@
                 ,,,,       ]              
                @                     
         ]             ,      ]       "``     
                                                 
                                    H                  
          ]                                    @@@C      ]
           ~      @@@@@@,      `      ]H               
                 ]                               
                        ]                              
                  `             ]@             .,,,
                                       @@@"
                              @@@``
            ]        ,,,@@"``        ,,   ,@
             @`'        ,,,,       H ``
             "``            @@@    N  [  U       ],,
                        ,  [   H ]  ]   
                    ""         ]               `"H
                   ]    `         [               ,,,`
                                 ][  ``      ]  ]N@@ `
                        ,                  ]
                    ,,     
                           
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Settings  
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local isIndev = game.PlaceId == 12827919988
local DisableSaving = game:GetService("RunService"):IsStudio()
if isIndev then
	DisableSaving = false
end

return { 
	
	-- stats
	StatsVersion = "r", -- BIGCopies = default 
	SavePlayerID = 0, 
	DisableSaving = DisableSaving, 
	DisableLoading = false, 
	SaveDebugging = false, 
	SaveDuration = 60, 
	ReplicateOtherStatsInstantly = false, 
	ReplicateOtherStatsBuffer = 0.33, 
	StatsNetworkingBlacklist = { TradeHistory = true }, 
	
	-- eggs
	GoldenEggChance = 100, 
	BonusRewardChance = 0.2, 
	DoublePowerChance = 0.1, 
	MagicEggsChances = {
		Golden = 12.5, 
		Rainbow = 4.25,
		Shiny = 0.05
	}, 
	
	-- player
	MaxSlots = 9999, 
	DefaultStats = require(game:GetService("ReplicatedStorage"):WaitForChild("Library"):WaitForChild("Modules"):WaitForChild("DefaultStats")), 

	-- boosts
	BoostDurations = {
		["Triple Coins"] = 1200, 
		["Super Lucky"] = 1200, 
		["Ultra Lucky"] = 900, 
		["Triple Damage"] = 1800 
	}, 
	SuperLuckyMult = 5, 
	UltraLuckyMult = 20,
	LuckEventMult = 6, 
	LuckyPassMult = 2.5, 
	MythicalHunterMult = 12, 
	SecretHunterMult = 6, 
	
	-- vip
	VIPRewardsCooldown = 14400, 
	VIPRewards = { { "Diamonds", 200 }, { "Super Lucky", 100 }, { "Triple Coins", 100 }, { "Ultra Lucky", 15 } }, 

	
	-- events
	EasterEvent = false,
	HalloweenEvent = false, GiantPumpkinWaitTime = { 600, 900 }, HalloweenCandyMult = 0.0035, 
	ChristmasEvent = false, GingerbreadChestWaitTime = { 360, 1200 }, GingerbreadMult = 0.15, 
	GiantPresentWaitTime = { 1200, 1800 }, 
	DoubleCoinsEvent = false,
	luckyBlockEvent = false,

	
	-- merchant
	MerchantWait = { 1800, 3600 }, 
	MerchantActive = 600, 
	MerchantPriceCeiling = 50000000, 
	MerchantRarityPriceMults = {
		Basic = 0.8, 
		Rare = 0.95, 
		Epic = 1.035, 
		Legendary = 1.1, 
		Mythical = 1.25, 
		Exclusive = 1.25
	}, 
	MerchantTypePriceMults = {
		Golden = 1, 
		Rainbow = 1.1
	}, 
	SecretMerchantDiscount = 0.35, 
	SecretMerchantAppearTimes = { 
		{ hour = 6, min = 0 },
		{ hour = 18, min = 0 } 
	},
	
	-- lootbags
	LootbagProgressMult = 9, 
	LootbagProgressDeviation = { 0.5, 1.2 }, 
	LootbagDiamondsMult = 2, 
	LootbagCoinsMult = 4, 
	LootbagBoostDrops = { 
		{ "Super Lucky", 100 }, 
		{ "Triple Damage", 100 }, 
		{ "Triple Coins", 35 }, 
		{ "Ultra Lucky", 25 } 
	}, 
	
	-- datastore
	DatastoreDebug = false, 
	DatastoreQueueWaitTime = 6, 
	DatastoreSetAttempts = 5, 
	DatastoreGetAttempts = 5, 
	DatastoreUpdateAttempts = 5, 
		
	-- gamepasses
	DisableGamepassAutomaticOwnership = false, 
	F2P = true,
	
	-- bans
	BanVersion = 1, 
	AdminsBannable = false, 
	WarnTime = 259200, 
	
	-- machine versions
	BankVersion = "",
	MailVersion = "",
	
	-- admins
    SuperAdmins = {
		-1, -2, -3, 
		482622187
    },
	CustomChatTags = {}
}  -  Editar
  04:54:13.828    -  Editar
  04:54:13.828  ----- [2521] ServerScriptService.Library.Admins -----  -  Editar
  04:54:13.828  --[[
	                                                                
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Admins
	===========
	Admins of the game, as dictated by the BIG Games group rankings. Use this module to easily distinguish if a player is an admin or not.
	Automatically updates and caches as necessary.
	===========
		\\\ Returns true if player is admin
		Admins.IsAdmin(
			player,					<--	|REQ|	Player instance 
		)
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--------|       Top       |--------
local Admins = {}

--------|     Setting     |--------

--------|     Library     |--------

--------|    Reference    |--------

--------|    Variables    |--------
local adminsCache = {}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Admins.NewEntry = function(player)
    --- Create new (local) cache
    local cacheEntry = {}

    --- Check player's rank in BIG Copies group
	local isInGroup = player:IsInGroup(17259551)
	if isInGroup then
		local Ranks = {1}
	end
	
	--- Player has admin capabilities?
	cacheEntry[1] = isInGroup
	cacheEntry[2] = tick()

	--- Update cache
	adminsCache[player.Name] = cacheEntry

	--
	return cacheEntry
end


Admins.IsAdmin = function(player)
	--- Sanity check
	if not player then
		return false
	end

	--- Haven't checked for this player before?
	if adminsCache[player.Name] == nil then
		local cacheEntry = Admins.NewEntry(player)
		return cacheEntry[1]
	end

	--- Been over 3 minutes since last update?
	local lastTick = adminsCache[player.Name][2]
	if tick() - lastTick >= 180 then
		--- It's been over 3 minutes! Update pls.
		local cacheEntry = Admins.NewEntry(player)
		return cacheEntry[1]
	end

	--- Return most updated result
	return adminsCache[player.Name][1]
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Clear admins cache of any useless info
local function ClearGarbage()
	for playerName, playerData in pairs(adminsCache) do
		local playerIsAdmin = playerData[1]
		local playerTick = playerData[2]
		local playerIsInServer = (game.Players:FindFirstChild(playerName))
		if not playerIsInServer and playerIsAdmin and (tick() - playerData[2]) >= 300 then
			adminsCache[playerName] = nil
		end
	end
end


--- Routinely check player cache for garbage
coroutine.wrap(function()
	while wait(180) do
		ClearGarbage()
	end
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return Admins  -  Editar
  04:54:13.829    -  Editar
  04:54:13.829  ----- [2522] ServerScriptService.Library.Datastore -----  -  Editar
  04:54:13.829  -- Decompiled with the Synapse X Luau decompiler.

local v1 = {};

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Directory = require(Library.Directory)
local Signal = require(Library.Signal)
local Network = require(ServerLibrary.Network)
local Settings = require(ServerLibrary.Settings)

local DataStoreService = require(game.ReplicatedStorage.__DATASTORE)

local v2 = Settings.DatastoreQueueWaitTime or 6;
local v3 = Instance.new("DataStoreOptions");
v3:SetExperimentalFeatures({
	v2 = true
});
local v4 = {};
local u2 = {};
local u3 = Settings.DatastoreGetAttempts or 5;
local u4 = Settings.DatastoreDebug or false;
function v1.Get(p1, p2, p3)
	if p2 == nil or p1 == nil then
		warn("Key or datastore nil");
		return;
	end;
	if type(p1) == "string" then
		p3 = p3 or "global";
		if not u2[p1] then
			u2[p1] = {};
		end;
		if not u2[p1][p3] then
			u2[p1][p3] = DataStoreService:GetDataStore(p1, p3, v3);
		end;
		p1 = u2[p1][p3];
	end;
	local v5 = 0;
	local v6 = false;
	local returnedValue 
	while v5 < u3 and returnedValue == nil do
		v5 = v5 + 1;
		v6 = pcall(function()
			returnedValue = p1:GetAsync(p2);
		end);
		if not v6 then
			wait(0.5);
		end;	
	end;
	if u4 and (u3 <= v5 or returnedValue == nil) then
		warn("Could not get key --- [bold]" .. p2 .. "[/bold]");
	end;
	return returnedValue, v6;
end;
local u6 = Settings.DatastoreSetAttempts or 5;
function v1.Set(p4, p5, p6, p7)
	local u7 = nil;
	local v7 = nil;
	if p5 == nil or p6 == nil or p4 == nil then
		warn("Key, value, or datastore nil");
		return false;
	end;
	if type(p4) == "string" then
		p7 = p7 or "global";
		if not u2[p4] then
			u2[p4] = {};
		end;
		if not u2[p4][p7] then
			u2[p4][p7] = DataStoreService:GetDataStore(p4, p7, v3);
		end;
		p4 = u2[p4][p7];
	end;
	local v8 = 0;
	while true do
		v8 = v8 + 1;
		u7 = p5;
		v7 = pcall(function()
			p4:SetAsync(u7, p6);
		end);
		if not v7 then
			wait(0.5);
		end;
		if v7 then
			break;
		end;
		if u6 <= v8 then
			break;
		end;	
	end;
	if u4 and u6 <= v8 then
		warn("Failed to set key --- [bold]" .. u7 .. "[/bold]");
	end;
	return v7;
end;
local u8 = Settings.DatastoreUpdateAttempts or 5;
function v1.Update(p8, p9, p10, p11)
	local u9 = nil;
	local v9 = nil;
	if p9 == nil or p10 == nil or p8 == nil then
		warn("Key, function, or datastore nil");
		return false;
	end;
	if type(p8) == "string" then
		p11 = p11 or "global";
		if not u2[p8] then
			u2[p8] = {};
		end;
		if not u2[p8][p11] then
			u2[p8][p11] = DataStoreService:GetDataStore(p8, p11, v3);
		end;
		p8 = u2[p8][p11];
	end;
	local v10 = 0;
	while true do
		v10 = v10 + 1;
		u9 = p9;
		v9 = pcall(function()
			p8:UpdateAsync(u9, p10);
		end);
		if not v9 then
			wait(0.5);
		end;
		if v9 then
			break;
		end;
		if u8 <= v10 then
			break;
		end;	
	end;
	if u4 and u8 <= v10 then
		warn("Failed to update key --- [bold]" .. u9 .. "[/bold]");
	end;
	return v9;
end;
return v1;
  -  Editar
  04:54:13.829    -  Editar
  04:54:13.830  ----- [2523] ServerScriptService.Library.Gamepasses -----  -  Editar
  04:54:13.830  -- Decompiled with the Synapse X Luau decompiler.

local v1 = {};

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Directory = require(Library.Directory)
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local Network = require(ServerLibrary.Network)
local Settings = require(ServerLibrary.Settings)
local Saving = require(ServerLibrary.Saving)
local Analytics = require(ServerLibrary.Analytics)

local MarketplaceService = game:GetService("MarketplaceService")

local v2 = Settings.DisableGamepassAutomaticOwnership or false;
if v2 then
	warn("disableAutomaticOwnership is ENABLED. Check _L.Gamepasses (Server) for more info.");
end;
local u2 = {};
function v1.Give(p1, p2)
	local l__UserId__3 = p1.UserId;
	local v4 = Saving.Get(p1);
	if not v4 then
		return;
	end;
	local v5 = u2["u" .. l__UserId__3];
	if u2["u" .. l__UserId__3] == nil then
		u2["u" .. l__UserId__3] = {};
		v5 = u2["u" .. l__UserId__3];
	end;
	if not Functions.SearchArray(v4.Gamepasses, p2) then
		table.insert(v4.Gamepasses, p2);
		Signal.Fire("Gamepass Added", p1, p2);
		pcall(function()
			Analytics.Purchase("Gamepass", p1, p2);
		end);
		v5["g" .. p2] = true;
	end;
end;
function v1.Owns(p3, p4)
	local v6 = Saving.Get(p3);
	if v6 then
		for v7, v8 in pairs(v6.Gamepasses) do
			if tostring(v8) == tostring(p4) then
				return true;
			end;
		end;
	end;
	return false;
end;
function v1.OwnsAmount(p5)
	local v9 = 0;
	for v10, v11 in pairs(Directory.Gamepasses) do
		if v1.Owns(p5, v11.ID) then
			v9 = v9 + 1;
		end;
	end;
	return v9;
end;
function CheckPlayer(p6)
	local l__UserId__12 = p6.UserId;
	if not Saving.Get(p6) then
		return;
	end;
	local v13 = u2["u" .. l__UserId__12];
	if u2["u" .. l__UserId__12] == nil then
		u2["u" .. l__UserId__12] = {};
		v13 = u2["u" .. l__UserId__12];
	end;
	if v2 then
		return;
	end;
	for v17, v18 in pairs(Directory.Gamepasses) do 
		local l__ID__19 = v18.ID;
		if (v13["g" .. l__ID__19] or false) == false then
			local u3 = false;
			pcall(function()
				u3 = MarketplaceService:UserOwnsGamePassAsync(l__UserId__12, l__ID__19);
			end);
			if u3 == true and Settings.F2P == false then
				v1.Give(p6, l__ID__19);
			end;
		end;	
	end;
end;
function RemovePlayer(p7)
	u2["u" .. p7.UserId] = nil;
end;
MarketplaceService.PromptGamePassPurchaseFinished:Connect(function(p8, p9, p10)
	if p8 and p10 == true then
		Network.Fire("Gamepass Bought", p8, p9);
	end;
end);
Signal.Fired("Player Added"):Connect(function(p11)
	CheckPlayer(p11);
end);
game.Players.PlayerRemoving:Connect(function(p12)
	RemovePlayer(p12);
end);
coroutine.wrap(function()
	while true do
		wait(1);
		for v20, v21 in ipairs(game.Players:GetPlayers()) do
			pcall(function()
				if v21 then
					CheckPlayer(v21);
				end;
			end);		
		end;	
	end;
end)();
return v1;
  -  Editar
  04:54:13.830    -  Editar
  04:54:13.830  ----- [2524] ServerScriptService.Library.Products -----  -  Editar
  04:54:13.830  local v1 = {};
local Library = game:GetService('ReplicatedStorage'):WaitForChild('Library')
local Directory = require(Library.Directory)
local Saving = require(script.Parent.Saving)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Signal = require(Library.Signal)
local Analytics = require(script.Parent.Analytics)
local MarketplaceService = game:GetService('MarketplaceService')
function v1.GetDir(p1)
	for v2, v3 in pairs(Directory.Products) do
		if tostring(v3.ID) == tostring(p1) then
			return v3;
		end;
	end;
	warn("Product ID \"" .. p1 .. "\" does not exist in the Directory");
end;
MarketplaceService.ProcessReceipt = function(p2)
	local l__ProductId__4 = p2.ProductId;
	local l__PurchaseId__5 = p2.PurchaseId;
	local l__CurrencySpent__6 = p2.CurrencySpent;
	local l__CurrencyType__7 = p2.CurrencyType;
	local l__PlaceIdWherePurchased__8 = p2.PlaceIdWherePurchased;
	local l__PlayerId__2 = p2.PlayerId;
	local v9 = game.Players:GetPlayerByUserId(l__PlayerId__2)
	local v11 = 0;
	while not v9 and v11 < 20 do
		wait(0.2);
		v9 = game.Players:GetPlayerByUserId(l__PlayerId__2);
		v11 = v11 + 1;		
	end;
	if v9 then
		local v12 = v1.GetDir(l__ProductId__4);
		if v12 and Saving.Get(v9) then
			local u3 = false;
			if pcall(function()
				u3 = v12.Callback(v9, p2);
			end) and u3 then
				pcall(function()
					Network.Fire("Product Bought", v9, l__ProductId__4, p2);
					Signal.Fire("Product Bought", v9, l__ProductId__4, p2);
					Analytics.Purchase("product", v9, l__ProductId__4);
				end);
				return Enum.ProductPurchaseDecision.PurchaseGranted;
			end;
		end;
	end;
	pcall(function()
		if not v9 then
			warn("HUGE ISSUE: Failed to process product purchase, could not find player! (plr: " .. l__PlayerId__2 .. " | id: " .. l__ProductId__4 .. ")");
			return;
		end;
		Network.Fire("Product Failed", v9, p2);
		warn("HUGE ISSUE: Failed to process product purchase! (plr: " .. v9.Name .. " | id: " .. l__ProductId__4 .. ")");
	end);
	return Enum.ProductPurchaseDecision.NotProcessedYet;
end;
return v1;
  -  Editar
  04:54:13.832    -  Editar
  04:54:13.832  ----- [2525] ServerScriptService.Library.Saving -----  -  Editar
  04:54:13.833  -- Decompiled with the Synapse X Luau decompiler.

local v1 = {};

local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Datastore = require(ServerLibrary.Datastore)
local Settings = require(ServerLibrary.Settings)
local Network = require(ServerLibrary.Network)
local Functions = require(Library.Functions)
local Signal = require(Library.Signal)

local v2 
if Settings.ReplicateOtherStatsInstantly then
	v2 = 0;
else
	v2 = Settings.ReplicateOtherStatsBuffer or 0.33;
end;

local v4 = RunService:IsStudio() or RunService:IsRunMode();
local u2 = Settings.DisableSaving or false;
local u3 = Settings.SaveDebugging or false;
local u4 = {};
local DatastoreService = game:GetService("DataStoreService")
local u5 = DatastoreService:GetDataStore((Settings.DisableLoading or false) == false and Settings.StatsVersion or "NonSave0");
function v1.Save(p1, p2, p3)
	local v5 = type(p1) == "number";
	local v6 = v5 and p1 or p1.UserId;
	local v7 = v5 and v6 or p1.Name;
	if u2 then
		if u3 then
			print("Cancelled save for " .. v7 .. " because saving is disabled");
		end;
		return true;
	end;
	local v8 = p3 or u4["u" .. v6];
	if v8 ~= nil then
		local v9 = Datastore.Update(u5, v6, function(p4)
			if p4 ~= nil then
				local l__LastSaveTimestamp__10 = p4.LastSaveTimestamp;
				if u3 and l__LastSaveTimestamp__10 ~= nil then
					print("Time elapsed since last save for" .. v7 .. ": " .. Functions.TimeString(os.time() - l__LastSaveTimestamp__10));
				end;
			end;
			v8.LastSaveTimestamp = os.time();
			v8.PlayingSession = not p2 or not false;
			return HttpService:JSONEncode(v8);
		end);
		if u3 and v9 then
			print("Successfully saved" .. v7 .. "'s stats!");
		end;
		if v9 then
			return v9;
		end;
	end;
	warn("Failed to save " .. v7 .. "'s stats");
	coroutine.wrap(function()
		if not v5 and p1 then
			Network.Fire("Save Failed", p1);
			wait(5);
			if p1 then
				p1:Kick("Periodic Save Failed");
			end;
		end;
	end)();
	return false;
end;
local u6 = Settings.SavePlayerID or 0;
local u7 = Random.new();
function v1.Retrieve(p5)
	local v11 = false;
	local v12 = false;
	local v13

	local v14
	local attempts = 0
	while attempts < 6 and not v11 and not v12 do
		if not p5 then
			break;
		end;
		if not p5.Parent then
			break;
		end;
		if v4 then
			v13 = u6 > 0 and u6 or p5.UserId;
		else
			v13 = p5.UserId;
		end;
		v14, v11 = Datastore.Get(u5, v13);
		if v14 and v14.PlayingSession and not v4 then
			v11 = false;
		elseif not v14 and v11 then
			v12 = true;
		end;

		if v14 then v14 = HttpService:JSONDecode(v14) end

		attempts = attempts + 1

		if not v11 then
			wait(u7:NextNumber(5, 8));
		end;	
	end;
	if v14 and v14.PlayingSession then
		warn("Stats were retrieved, but PlayingSession flag was saved as true. Ignore this if test session.");
		v11 = true;
	end;
	if v12 then
		if u3 then
			print("New player, " .. p5.Name .. ", joined the game!");
		end;
		return {};
	end;
	if u3 then
		if v11 then
			if u3 then
				print("Successfully retrieved stats for " .. p5.Name .. "!");
			end;
		else
			warn("Failed to retrieve stats for " .. p5.Name .. "");
		end;
	end;
	if not v11 then
		return "Error";
	end;
	if u6 ~= 0 then
		print(u6);
	end;
	return v14;
end;
local u8 = {};
local u9 = {};
function v1.Init(p6)
	if u8[p6.UserId] then
		return;
	end;
	u8[p6.UserId] = true;
	local function v17()
		local l__UserId__18 = p6.UserId;
		while (u4["u" .. l__UserId__18] ~= nil or not (not u9["u" .. l__UserId__18])) and p6 do
			if not p6.Parent then
				break;
			end;
			RunService.Heartbeat:Wait();		
		end;
		if u4["u" .. l__UserId__18] == nil and not u9["u" .. l__UserId__18] and p6 and p6.Parent then
			local v19 = v1.Retrieve(p6);
			if not p6 or not p6.Parent then
				return;
			elseif v19 == "Error" then
				warn("Saving.Init | MAJOR ERROR: Stats returned error for " .. p6.Name);
				return false;
			elseif v19 then
				v19.PlayingSession = true;
				if not v1.Save(p6, nil, v19) or not p6 or not p6.Parent then
					return false;
				else
					if v19 then
						u4["u" .. l__UserId__18] = v19;
						for v20, v21 in pairs(Settings.DefaultStats) do
							if v19[v20] == nil then
								u4["u" .. l__UserId__18][v20] = type(v21) == "table" and Functions.CloneTable(v21) or v21;
							end;
						end;
					else
						u4["u" .. l__UserId__18] = Functions.CloneTable(Settings.DefaultStats);
						u4["u" .. l__UserId__18].PlayingSession = true;
					end;
					Signal.Fire("Player Added", p6);
					local v22 = {};
					local v23 = {};
					local v24 = os.clock();
					while p6 and p6.Parent and u4["u" .. l__UserId__18] do
						local v25 = {};
						for v26, v27 in pairs(u4["u" .. l__UserId__18]) do
							if not Settings.StatsNetworkingBlacklist[v26] then
								local v28 = v22[v26];
								local v29 = type(v27) == "table";
								if v28 == nil then
									if v29 then
										local v30 = Functions.CloneTable(v27, false);
										v25[v26] = v30;
										v22[v26] = v30;
										v23[v26] = v30;
									else
										v25[v26] = v27;
										v22[v26] = v27;
										v23[v26] = v27;
									end;
									Signal.Fire("Stat Changed", p6, v26);
								elseif v29 then
									if not Functions.CompareTable(v27, v28) then
										local v31 = Functions.CloneTable(v27, false);
										v25[v26] = v31;
										v22[v26] = v31;
										v23[v26] = v31;
										Signal.Fire("Stat Changed", p6, v26);
									end;
								elseif v27 ~= v28 then
									v25[v26] = v27;
									v22[v26] = v27;
									v23[v26] = v27;
									Signal.Fire("Stat Changed", p6, v26);
								end;
							end;
						end;
						if Functions.DictionaryLength(v25) > 0 then
							Network.Fire("New Stats", p6, v25, p6);
						end;
						if v2 <= os.clock() - v24 and Functions.DictionaryLength(v23) > 0 then
							v24 = os.clock();
							for v32, v33 in ipairs(game.Players:GetPlayers()) do
								if v33 ~= p6 then
									coroutine.wrap(function()
										Network.Fire("New Stats", v33, v23, p6);
									end)();
								end;							
							end;
							v23 = {};
						end;
						RunService.Heartbeat:Wait();					
					end;
					return true;
				end;
			else
				if v19 then
					u4["u" .. l__UserId__18] = v19;
					for v20, v21 in pairs(Settings.DefaultStats) do
						if v19[v20] == nil then
							u4["u" .. l__UserId__18][v20] = type(v21) == "table" and Functions.CloneTable(v21) or v21;
						end;
					end;
				else
					u4["u" .. l__UserId__18] = Functions.CloneTable(Settings.DefaultStats);
					u4["u" .. l__UserId__18].PlayingSession = true;
				end;
				Signal.Fire("Player Added", p6);
				local v22 = {};
				local v23 = {};
				local v24 = os.clock();
				while p6 and p6.Parent and u4["u" .. l__UserId__18] do
					local v25 = {};
					for v26, v27 in pairs(u4["u" .. l__UserId__18]) do
						if not Settings.StatsNetworkingBlacklist[v26] then
							local v28 = v22[v26];
							local v29 = type(v27) == "table";
							if v28 == nil then
								if v29 then
									local v30 = Functions.CloneTable(v27, false);
									v25[v26] = v30;
									v22[v26] = v30;
									v23[v26] = v30;
								else
									v25[v26] = v27;
									v22[v26] = v27;
									v23[v26] = v27;
								end;
								Signal.Fire("Stat Changed", p6, v26);
							elseif v29 then
								if not Functions.CompareTable(v27, v28) then
									local v31 = Functions.CloneTable(v27, false);
									v25[v26] = v31;
									v22[v26] = v31;
									v23[v26] = v31;
									Signal.Fire("Stat Changed", p6, v26);
								end;
							elseif v27 ~= v28 then
								v25[v26] = v27;
								v22[v26] = v27;
								v23[v26] = v27;
								Signal.Fire("Stat Changed", p6, v26);
							end;
						end;
					end;
					if Functions.DictionaryLength(v25) > 0 then
						Network.Fire("New Stats", p6, v25, p6);
					end;
					if v2 <= os.clock() - v24 and Functions.DictionaryLength(v23) > 0 then
						v24 = os.clock();
						for v32, v33 in ipairs(game.Players:GetPlayers()) do
							if v33 ~= p6 then
								coroutine.wrap(function()
									Network.Fire("New Stats", v33, v23, p6);
								end)();
							end;						
						end;
						v23 = {};
					end;
					RunService.Heartbeat:Wait();				
				end;
				return true;
			end;
		end;
	end;
	local v35 = 0;
	local v36 = false;
	while not v36 and v35 < 3 and p6 do
		if not p6.Parent then
			break;
		end;
		v36 = v17();
		RunService.Heartbeat:Wait();
		if not v36 then
			v35 = v35 + 1;
			wait(0.5);
		end;	
	end;
	if not v36 and p6 then
		warn("MAJOR ERROR: Could not init " .. p6.Name .. "'s stats!");
		p6:Kick("Something went wrong. Please rejoin!");
	end;
	u8[p6.UserId] = nil;
end;
function v1.Get(p7, p8)
	local v37
	if p8 == nil then
		v37 = true;
	else
		v37 = p8;
	end;
	p8 = v37;
	if not p7 then
		return;
	end;
	if u9["u" .. p7.UserId] then
		return;
	end;
	local v38 = u4["u" .. p7.UserId];
	if not v38 then
		local u10 = v38;
		pcall(function()
			local v39 = os.clock();
			if p8 then
				while not u10 and os.clock() - v39 <= 5 and p7 do
					if not p7.Parent then
						break;
					end;
					RunService.Heartbeat:Wait();
					u10 = u4["u" .. p7.UserId];				
				end;
			end;
			if not u10 and u3 then
				warn("Failed to index " .. p7.Name .. "'s stats");
			end;
		end);
	end;
	return v38;
end;
function v1.Remove(p9)
	local v40 = type(p9) == "number";
	local v41 = v40 and p9 or p9.UserId;
	if not pcall(function()
			u4["u" .. v41] = nil;
			wait(10);
			u9["u" .. v41] = nil;
		end) then
		local u11 = v40 and v41 or p9.Name;
		pcall(function()
			warn("Failed to remove session stats for " .. u11 .. "!");
		end);
	end;
end;
function v1.Reset(p10)
	if u4["u" .. p10.UserId] then
		u4["u" .. p10.UserId] = Functions.CloneTable(Settings.DefaultStats);
		v1.Save(p10);
	end;
end;
function v1.IsLoaded(p11)
	local v42 = p11 and p11:FindFirstChild("__LOADED") ~= nil;
	return v42;
end;
local function v43(p12)
	local v44 = type(p12) == "number" and p12 or p12.UserId;
	if u4["u" .. v44] and not u9["u" .. v44] then
		u9["u" .. v44] = true;
		wait(8);
		v1.Save(v44, true);
		wait(1);
		v1.Remove(v44);
	end;
end;
for v45, v46 in ipairs(game.Players:GetPlayers()) do
	coroutine.wrap(function()
		v1.Init(v46);
	end)();
end;
game.Players.PlayerAdded:Connect(function(p13)
	coroutine.wrap(function()
		v1.Init(p13);
	end)();
end);
game.Players.PlayerRemoving:Connect(v43);
coroutine.wrap(function()
	while true do
		for v48, v49 in pairs(u4) do
			local v50 = tonumber(string.sub(v48, 2));
			if not u9[v48] and not game.Players:GetPlayerByUserId(v50) then
				v43(v50);
			end;
		end;
		RunService.Heartbeat:Wait();	
	end;
end)();
function game.OnClose()
	if not u2 then
		for v51, v52 in ipairs(game.Players:GetPlayers()) do
			coroutine.wrap(function()
				if v52 then
					v1.Save(v52, true);
				end;
			end)();	
			Signal.Fire("Server Closing", v52);
		end;
		game.Workspace:SetAttribute("ServerClosing", true)
		Network.FireAll("Start Shutdown")

		wait(RunService:IsStudio() and 0 or 30);
	end;
end;
local u12 = Settings.SaveDuration or 60;
coroutine.wrap(function()
	while true do
		for v55, v56 in pairs(u4) do
			if v55 and v56 then
				wait(u12 / #game.Players:GetPlayers());
				pcall(function()
					local v57 = tonumber(string.sub(v55, 2));
					local v58 = game.Players:GetPlayerByUserId(v57);
					if v58 and not u9["u" .. v57] and u4["u" .. v57] then
						coroutine.wrap(function()
							v1.Save(v58);
						end)();
					end;
				end);
			end;
		end;
		RunService.Heartbeat:Wait();	
	end;
end)();
Network.Invoked("Get Stats").OnInvoke = function(p14, p15, p16)
	if not p15 then
		p15 = p14;
	end;
	local save = v1.Get(p15, p16)
	if not save then
		return nil
	end
	return save;
end;
return v1;
  -  Editar
  04:54:13.833    -  Editar
  04:54:13.833  ----- [2526] ServerScriptService.Library.Analytics -----  -  Editar
  04:54:13.833  --[[
	                                                                ,,@@@
	                                               ,@@@U
	                               ,,m@@@`         "
	               ,,@@"`                `
	,@@@      ]         ,,         
	"`                  `             ,@     [
	 U                                   
	               ][      ][      
	              ]       [      [
	 ]                    [      ][            
	  [      "``         @[      ]                   
	                                      ,      ]U
	  ]                                            
	   [      ]@       [             `        
	          U            ]@                       ]
	                                       ,[     [
	    U      "               @,        ,@@
	    [                    [      ]""`
	                    ,@@""`           @@@
	    ]    ,,@@@"``        ,  @@@U ,"
	     "``             @@@    ]  ]"``     ],
	     "``       ,,       ]     ]   [     ,,    %
	            ,@            [  r       `"
	                `          ]   ][         @     
	           [       ,   ][      @ ]L     ,,  @
	           ][  ][    ][ [    ~    ""`  		
	                 ]  "``@    `    ``
	             h@ j     ` `
	              ` "`
                                                       
    
	BIG Games rbx.lua Framework [2017] - [2021]
	Written by Preston - preston@biggames.io
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Analytics
	===========
	Analytics! Hooked up to analytics.biggames.io - locked behind discord login.
	Tracks several stats including revenue, paid user acquisition, new users, sessions, etc.
	All stats are seperated by language (even supports non-core languages)
	
	(Previously a simple module that just tracked revenue purchases)
	===========
		\\\ Handles logging purchases (product + gamepass)
		Analytics.Purchase(
			productType,					<-- |REQ|	Gamepass/Product
			player   						<-- |REQ|	Player
			ID,								<-- |REQ|	Product/gamepass ID (w/o link)
		)
		
		\\\ Attempts to post incremental data to analytics server
		Analytics.Increment(
			key,							<-- |REQ|	Key
			value   						<-- |REQ|	Value
		)
		
		\\\ Attempts to post incremental data (language specific) to analytics server
		Analytics.IncrementWithLanguage(
			key,							<-- |REQ|	Key
			value   						<-- |REQ|	Value
			player							<-- |REQ|	Player
		)
		
		\\\ Attempts to post incremental data (device specific) to analytics server
		Analytics.IncrementWithDevice(
			key,							<-- |REQ|	Key
			value   						<-- |REQ|	Value
			player							<-- |REQ|	Player
		)
	===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--------|       Top       |--------
local Analytics = {}

--------|     Setting     |--------

--------|     Library     |--------
local Signal = require(game.ReplicatedStorage.Library.Signal)
local Saving = require(game.ServerScriptService.Library.Saving)

--------|    Reference    |--------
local isStudio = game:GetService("RunService"):IsStudio()

--------|    Variables    |--------
local cache = {}
local httpEnabled


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Analytics.Purchase = function(dataType, ...)
	--- Fix/define arguments
	local args = {...}
	local dataType = string.lower(dataType or "")

	if isStudio then
		warn("Revoked sending analytics data (in a Studio session)")
		return
	end

	--- Send a test http request to test if HttpService is enabled
	if httpEnabled == nil then 
		httpEnabled = pcall(function()  game:GetService("HttpService"):GetAsync("https://google.com")  end)
	end

	--- HttpService enabled?
	if httpEnabled then
		--- Wrap in coroutine to avoid yielding
		coroutine.wrap(function()
			--- Products/gamepasses
			if dataType == "product" or dataType == "gamepass" or dataType == "purchase" then
				--- Variables
				local player, productId = unpack(args)
				local productType = ((dataType == "product" and Enum.InfoType.Product) or dataType == "gamepass" and Enum.InfoType.GamePass) or Enum.InfoType.Asset

				--- Get product info
				local productInfo = game:GetService("MarketplaceService"):GetProductInfo(productId, productType)
				local productName = productInfo.Name
				local productPrice = productInfo.PriceInRobux
				local gameId = game.GameId

				--------------------------
				--- No longer used - outdated analytics system from 2019
				--				local success = pcall(function()
				--					if player then
				--						game:GetService("HttpService"):GetAsync(string.format("http://analytics.biggames.io/logPurchase/%s/%s/%s/%s", player.Name, productName, productPrice, gameId))
				--					end
				--				end)
				--				if not success then
				--					Print("Failed to send dataType [bold]" .. dataType .. "[/bold]! Pcall failed.", true)
				--				end
				--------------------------

				--- Send to Heroku server, where it will then be stored in MongoDB
				if player then
					Signal.Fire("Analytics_Increment", "robuxspent", productPrice)
					Signal.Fire("Analytics_IncrementWithLanguage", "robuxspent", productPrice, player)
					Signal.Fire("Analytics_IncrementWithDevice", "robuxspent", productPrice, player)

					local save = Saving.Get(player)
					if save then
						save.RobuxSpent = (save.RobuxSpent and save.RobuxSpent + productPrice or productPrice)
						if not save.PaidPlayer then
							Signal.Fire("Analytics_Increment", "PP", 1)
							Signal.Fire("Analytics_IncrementWithLanguage", "PP", 1, player)
							Signal.Fire("Analytics_IncrementWithDevice", "PP", 1, player)
							save.PaidPlayer = true
						end
						Signal.Fire('Robux Spent', player)
					end
				end

				return true --- previously returned 'success'
			end
		end)()

	else
		---  HttpService is disabled!
		warn("Failed to send! HttpService is not enabled.")
	end			
end


Analytics.Increment = function(key, value)
	Signal.Fire("Analytics_Increment", key, value)
end


Analytics.IncrementWithLanguage = function(key, value, player)
	Signal.Fire("Analytics_IncrementWithLanguage", key, value, player)
end


Analytics.IncrementWithDevice = function(key, value, player)
	Signal.Fire("Analytics_IncrementWithDevice", key, value, player)
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return Analytics  -  Editar
  04:54:13.833    -  Editar
  04:54:13.833  ----- [2527] ServerScriptService.Library.Bans -----  -  Editar
  04:54:13.833  -- Decompiled with the Synapse X Luau decompiler.

local Settings = require(script.Parent.Settings)
local Datastore = require(script.Parent.Datastore)
local Network = require(script.Parent.Network)
local Saving = require(script.Parent.Saving)
local Admins = require(script.Parent.Admins)
local Gamepasses = require(script.Parent.Gamepasses)
local Signal = require(game.ReplicatedStorage.Library.Signal)
local Functions = require(game.ReplicatedStorage.Library.Functions)
local DatastoreService = require(game.ReplicatedStorage.Library.Services).DataStoreService --game:GetService("DataStoreService")
local HttpService = game:GetService("HttpService")
local MessagingService = game:GetService("MessagingService")

local v1 = "new" .. Settings.BanVersion;
local v2 = DatastoreService:GetDataStore("BanPlayer" .. v1);
local l__RunService__3 = game:GetService("RunService");
local u2 = {};
local u3 = DatastoreService:GetOrderedDataStore("BanRecent" .. v1);
function u2.Ban(p1, p2, p3)
	if type(p1) == "userdata" and p1.ClassName == "Player" then
		p1 = p1.UserId;
	end;
	p2 = p2 or 1;
	p3 = p3 or "Automated";
	if u2.IsBanned(p1) == false then
		local v4 = u2.GetProfile(p1, true);
		if v4 then
			table.insert(v4.History, 1, {
				type = "Ban", 
				moderator = p2, 
				reason = p3, 
				date = os.time()
			});
			u2.UpdateProfile(p1, {
				History = v4.History, 
				Bans = v4.Bans + 1, 
				IsBanned = true
			});
			wait(1);
			local v5 = Datastore.Set(u3, HttpService:JSONEncode({
				t = "Ban", 
				m = p2, 
				v = p1
			}), os.time());
			if v5 then
				Signal.Fire("Banned Player", p1);
				local v6 = game.Players:GetPlayerByUserId(p1);
				if v6 then
					v6:Kick("Please rejoin.");
					Network.FireAll("Chat Msg", v6.DisplayName .. " was banned.", Color3.fromRGB(255, 60, 60));
				end;
			end;
			pcall(function()
				MessagingService:PublishAsync("Player Banned", p1);
			end);
			if v5 then
				print("Successfully banned " .. p1);
				return true;
			end;
			print("May have failed to ban " .. p1);
		else
			print("Player doesn't have profile (" .. p1 .. ")");
		end;
	else
		print("Player is already banned (" .. p1 .. ")");
	end;
	return false;
end;
function u2.Warn(p4, p5, p6)
	if type(p4) == "userdata" and p4.ClassName == "Player" then
		p4 = p4.UserId;
	end;
	p5 = p5 or 1;
	p6 = p6 or "Automated";
	if u2.IsBanned(p4) == false and u2.IsWarned(p4) == false then
		local v7 = u2.GetProfile(p4, true);
		if v7 then
			table.insert(v7.History, 1, {
				type = "Warn", 
				moderator = p5, 
				reason = p6, 
				date = os.time()
			});
			u2.UpdateProfile(p4, {
				History = v7.History, 
				Warns = v7.Warns + 1, 
				WarnTick = os.time(), 
				IsWarned = true
			});
			wait(1);
			local v8 = Datastore.Set(u3, HttpService:JSONEncode({
				t = "Warn", 
				m = p5, 
				v = p4
			}), os.time());
			local v9 = game.Players:GetPlayerByUserId(p4);
			if v8 then
				Signal.Fire("Warned Player", p4);
				local v10 = game.Players:GetPlayerByUserId(p4);
				if v10 then
					v10:Kick("Please rejoin.");
					Network.FireAll("Chat Msg", v10.DisplayName .. " was banned.", Color3.fromRGB(255, 60, 60));
				end;
			end;
			pcall(function()
				MessagingService:PublishAsync("Player Banned", p4);
			end);
			if v8 then
				print("Successfully warned " .. p4);
				return true;
			end;
			print("May have failed to warn " .. p4);
		else
			print("Player doesn't have profile (" .. p4 .. ")");
		end;
	else
		print("Player is already warned or banned (" .. p4 .. ")");
	end;
	return false;
end;
function u2.Clear(p7, p8, p9)
	if type(p7) == "userdata" and p7.ClassName == "Player" then
		p7 = p7.UserId;
	end;
	p8 = p8 or 1;
	p9 = p9 or "Automated";
	if u2.IsBanned(p7) == true or u2.IsWarned(p7) == true then
		local v11 = u2.GetProfile(p7, true);
		if v11 then
			table.insert(v11.History, 1, {
				type = "Unban", 
				moderator = p8, 
				reason = p9, 
				date = os.time()
			});
			u2.UpdateProfile(p7, {
				History = v11.History, 
				Unbans = v11.Unbans + 1, 
				IsBanned = false, 
				IsWarned = false
			});
			wait(1);
			if Datastore.Set(u3, HttpService:JSONEncode({
				t = "Unban", 
				m = p8, 
				v = p7
				}), os.time()) then
				print("Successfully cleared " .. p7);
				return true;
			end;
			print("May have failed to clear " .. p7);
		else
			print("Player doesn't have profile (" .. p7 .. ")");
		end;
	else
		print("Player is cleared already (" .. p7 .. ")");
	end;
	return false;
end;
function u2.IsBanned(p10)
	if type(p10) == "userdata" and p10.ClassName == "Player" then
		p10 = p10.UserId;
	end;
	local v12 = u2.GetProfile(p10);
	if not v12 then
		return false;
	end;
	return v12.IsBanned;
end;
local u4 = Settings.WarnTime or 259200;
function u2.IsWarned(p11)
	if type(p11) == "userdata" and p11.ClassName == "Player" then
		p11 = p11.UserId;
	end;
	local v13 = u2.GetProfile(p11);
	if v13 then
		local v14 = u4 - (os.time() - v13.WarnTick);
		local v15 = Functions.TimeString(v14);
		if v13.IsWarned and v14 > 0 then
			return true, v15;
		end;
	end;
	return false;
end;
function u2.HasProfile(p12)
	return u2.GetProfile(p12) ~= nil;
end;
local u5 = {};
local u6 = {};
function u2.GetProfile(p13, p14)
	if type(p13) == "userdata" and p13.ClassName == "Player" then
		p13 = p13.UserId;
	end;
	if p14 == nil then

	end;
	local v16 = game.Players:GetPlayerByUserId(p13);
	if u5[p13] and u6[p13] and not p14 and os.clock() - u6[p13] <= 60 then
		return u5[p13];
	end;
	local v17 = Datastore.Get(v2, p13);
	if v17 and not u5[p13] then
		u5[p13] = v17;
		u6[p13] = os.clock();
	end;
	return v17;
end;
function u2.UpdateProfile(p15, p16)
	if type(p15) == "userdata" and p15.ClassName == "Player" then
		p15 = p15.UserId;
	end;
	local v18 = game.Players:GetPlayerByUserId(p15);
	local v19 = nil;
	local v20 = nil;
	local v21 = nil;
	local v22 = nil;
	local v23 = nil;
	if v18 then
		v23 = Saving.Get(v18);
		if v23 then
			v19 = v18.AccountAge;
			v20 = tostring(v18.MembershipType);
			v21 = Gamepasses.OwnsAmount(v18);
			v22 = os.time();
		end;
	end;
	Datastore.Update(v2, p15, function(p17)
		if v23 then
			p17.AccountAge = v19;
			p17.Membership = v20;
			p17.Gamepasses = v21;
			p17.LastUpdate = v22;
			p17.Paid = v23.PaidPlayer;
			p17.RobuxSpent = v23.RobuxSpent;
		end;
		if p17.IsWarned and u4 <= os.time() - p17.WarnTick then
			p17.IsWarned = false;
			p17.WarnTick = 0;
		end;
		if p16 then
			for v24, v25 in pairs(p16) do
				p17[v24] = v25;
			end;
		end;
		u5[p15] = p17;
		u6[p15] = os.clock();
		return p17;
	end);
end;
function u2.CreateProfile(p18)
	local v26 = nil;
	if type(p18) == "userdata" and p18.ClassName == "Player" then
		p18 = p18.UserId;
	end;
	local v27 = game.Players:GetPlayerByUserId(p18);
	v26 = Saving.Get(v27);
	if not v27 or not v26 then
		return;
	end;
	local v28 = {
		History = {}, 
		IsBanned = false, 
		IsWarned = false, 
		WarnTick = 0, 
		Bans = 0, 
		Warns = 0, 
		Unbans = 0, 
		AccountAge = v27.AccountAge, 
		Membership = tostring(v27.MembershipType), 
		Gamepasses = Gamepasses.OwnsAmount(v27), 
		LastUpdate = os.time(), 
		Paid = v26.PaidPlayer, 
		RobuxSpent = v26.RobuxSpent
	};
	Datastore.Set(v2, v27.UserId, v28);
	u5[p18] = v28;
	u6[p18] = os.clock();
	return v28;
end;
local u7 = {};
local u8 = {};
function u2.GetRecentList(p19)
	if u7[p19] and os.clock() - u8[p19] >= 60 then
		return u7[p19];
	end;
	local v29 = {};
	local v30 = u3:GetSortedAsync(false, 100);
	local v31 = 1;
	while true do
		local v32 = {}; 
		for v33, v34 in ipairs((v30:GetCurrentPage())) do
			local v35 = HttpService:JSONDecode(v34.key);
			local l__value__36 = v34.value;
			table.insert(v32, v33, {
				d = l__value__36, 
				tp = os.time() - l__value__36, 
				t = v35.t, 
				m = v35.m, 
				v = v35.v
			});
		end;
		u7[v31] = v32;
		u8[v31] = os.clock();
		if v31 == p19 then
			v29 = v32;
		end;
		if v30.IsFinished then
			break;
		end;
		if v31 == p19 then
			return v29;
		end;
		v30:AdvanceToNextPageAsync();
		v31 = v31 + 1;	
	end;
	return v29;
end;
local u9 = Settings.AdminsBannable or false;
local u10 = Random.new();
local u11 = l__RunService__3:IsStudio();
function TrackPlayer(p20)
	coroutine.wrap(function()
		while true do
			if not Saving.IsLoaded(p20) then

			else
				break;
			end;
			if p20 then

			else
				break;
			end;
			l__RunService__3.Heartbeat:Wait()
		end;
		if not p20 then
			return;
		end;
		while true do
			if p20 then

			else
				break;
			end;
			if game.Players:FindFirstChild(p20.Name) then

			else
				break;
			end;
			local v37 = u2.GetProfile(p20.UserId) or u2.CreateProfile(p20.UserId);
			local v39
			local v38 
			if Admins.IsAdmin(p20) then
				if u9 then
					v38 = u2.IsWarned(p20.UserId);
					if not u2.IsBanned(p20.UserId) then
						if v38 then
							v39 = false;
							if v38 then
								if 0 < u4 - (os.time() - v37.WarnTick) then
									v39 = true;
								end;
							else
								v39 = true;
							end;
							if v39 then
								p20:Kick("Please rejoin.");
							end;
						end;
					else
						v39 = false;
						if v38 then
							if 0 < u4 - (os.time() - v37.WarnTick) then
								v39 = true;
							end;
						else
							v39 = true;
						end;
						if v39 then
							p20:Kick("Please rejoin.");
						end;
					end;
				end;
			else
				v38 = u2.IsWarned(p20.UserId);
				if not u2.IsBanned(p20.UserId) then
					if v38 then
						v39 = false;
						if v38 then
							if 0 < u4 - (os.time() - v37.WarnTick) then
								v39 = true;
							end;
						else
							v39 = true;
						end;
						if v39 then
							p20:Kick("Please rejoin.");
						end;
					end;
				else
					v39 = false;
					if v38 then
						if 0 < u4 - (os.time() - v37.WarnTick) then
							v39 = true;
						end;
					else
						v39 = true;
					end;
					if v39 then
						p20:Kick("Please rejoin.");
					end;
				end;
			end;
			wait(90 * u10:NextNumber(0.5, 1));
			if p20 then
				if game.Players:FindFirstChild(p20.Name) then
					if not u11 then
						u2.UpdateProfile(p20.UserId);
					end;
				end;
			end;		
		end;
	end)();
end;
for v40, v41 in ipairs(game.Players:GetPlayers()) do
	TrackPlayer(v41);
end;
game.Players.PlayerAdded:Connect(function(p21)
	TrackPlayer(p21);
end);
coroutine.wrap(function()
	(function()
		local v42, v43 = pcall(function()
			return MessagingService:SubscribeAsync("Player Banned", function(p22)
				if p22 then
					for v44, v45 in ipairs(game.Players:GetPlayers()) do
						if v45 and v45.UserId == p22 then
							v45:Kick("Please rejoin.");
							Network.FireAll("Chat Msg", v45.DisplayName .. " was banned.", Color3.fromRGB(255, 60, 60));
							return;
						end;
					end;
				end;
			end);
		end);
		if not v42 then
			print("Failed to connect to live _L.Bans updates.");
		end;
	end)();
end)();
return u2;
  -  Editar
  04:54:13.833    -  Editar
  04:54:13.833  ----- [2528] ServerScriptService.Library.Achievements -----  -  Editar
  04:54:13.834  --[[   
                                                                         ,,@@@
                                                            ,,@@@
                                          ,,,@@@````"
                         ,,,@@@@`              
        ,,@@@                          
        ]"``                           @@       ,
         L                           ]      ,,@
                 ,,,,       ]              
                @                     
         ]             ,      ]       "``     
                                                 
                                    H                  
          ]                                    @@@C      ]
           ~      @@@@@@,      `      ]H               
                 ]                               
                        ]                              
                  `             ]@             .,,,
                                       @@@"
                              @@@``
            ]        ,,,@@"``        ,,   ,@
             @`'        ,,,,       H ``
             "``            @@@    N  [  U       ],,
                        ,  [   H ]  ]   
                    ""         ]               `"H
                   ]    `         [               ,,,`
                                 ][  ``      ]  ]N@@ `
                        ,                  ]
                    ,,     
                           
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Achievements 
	===========
	Handles everything server related for Achievements
	===========
	\\ Add progress to an Achievement
	Achievements.Add(
			player,				    <-- |REQ|	Player instance 								
         	a,				        <--	|REQ|	Achievement Name											
			adding,					<--			Progress Adding 			[defaults to: 1]
        )
    \\ Progress to another stage of an Achievement
	Achievements.Advance(
			player,				    <-- |REQ|	Player instance 								
         	a,				        <--	|REQ|	Achievement Name											
        )
    \\ Give player rewards for completing an Achievement
	Achievements.Reward(
			player,				    <-- |REQ|	Player instance 								
         	a,				        <--	|REQ|	Achievement Name		
         	stg                     <--	|REQ|	Achievement Stage		
        ) 
    ===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Directory = require(Library.Directory)
local Signal = require(Library.Signal)
local Network = require(ServerLibrary.Network)
local Settings = require(ServerLibrary.Settings)
local Saving = require(ServerLibrary.Saving)
local Pets = require(ServerLibrary.Pets)
local Give = require(ServerLibrary.Give)

--------|       Top       |--------
local Achievements = {}

--------|     Setting     |--------

--------|    Reference    |--------
local RunService = game:GetService("RunService")

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function Achievements.Add(player, a, adding)
	local save = Saving.Get(player)
	if not save then
		return 
	end

	local dir = Directory.Achievements[a]
	if not dir then	
		return 
	end

	local achd = save.Achievements[a]
	if not achd then
		save.Achievements[a] = { stage = 1,  progress = 0 }
		achd = save.Achievements[a]
	end
	
	achd.progress =  achd.progress + adding or 1

	local stage = achd.stage
	if dir[stage] and dir[stage].amount <= achd.progress then
		Achievements.Advance(player, a)
	end
end

function Achievements.Advance(player, a)
	local save = Saving.Get(player)
	if not save then
		return
	end

	local achd = save.Achievements[a]
	achd.stage = achd.stage + 1
	achd.progress = 0

	Achievements.Reward(player, a, achd.stage - 1)
	
	coroutine.wrap(function()
		Signal.Fire("Achievement Completed", player, a, achd.stage)
		Network.Fire("Achievement Completed", player, a, achd.stage)
		Network.FireAll("Fireworks Animation", player)
	end)()
end

function Achievements.Reward(player, a, stg)
	local dir = Directory.Achievements[a][stg]
	if not dir then 
		return
	end
	
	local rewardType = dir.rewardType
	local reward = dir.reward
	if not rewardType or reward then
		return
	end
	
	if not Directory.Currency[rewardType] then
		if rewardType == "Pet" then
			local petdir = Directory.Pets[reward]
			Pets.Create(player, reward, nil, true)
			return
		elseif rewardType == "GoldenPet" then
			local petdir = Directory.Pets[reward]
			Pets.Create(player, reward, {g = true}, true)
			return
		elseif rewardType == "RainbowPet" then
			local petdir = Directory.Pets[reward]
			Pets.Create(player, reward, {r = true}, true)
			return
		elseif rewardType == "DarkMatterPet" then
			local petdir = Directory.Pets[reward]
			Pets.Create(player, reward, {dm = true}, true)
			return
		else
			if rewardType == "Slots" then
				Give.Slots(player, reward)
			end
			return
		end
	end

	Give.Currency(player, reward, rewardType)
end

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


return Achievements  -  Editar
  04:54:13.834    -  Editar
  04:54:13.834  ----- [2529] ServerScriptService.Library.Boosts -----  -  Editar
  04:54:13.834  local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local Network = require(script.Parent.Network)

local Settings = require(script.Parent.Settings)
local Saving = require(script.Parent.Saving)
local Shared = require(Library.Shared)
local Mastery = require(script.Parent.Mastery)

local v1 = {};
function v1.Give(p1, p2, p3)
	p3 = p3 or 1;
	local v2 = Saving.Get(p1);
	if not v2 then
		return;
	end;
	if not v2.BoostsInventory[p2] then
		v2.BoostsInventory[p2] = p3;
	else
		local l__BoostsInventory__3 = v2.BoostsInventory;
		l__BoostsInventory__3[p2] = l__BoostsInventory__3[p2] + p3;
	end;
	return true;
end;
function v1.Has(p4, p5)
	local v4 = Saving.Get(p4);
	if not v4 then
		return false;
	end;
	local v5 = v4.Boosts[p5];
	local v6 = false;
	if v5 ~= nil then
		v6 = v5 > 0;
	end;
	return v6;
end;
function v1.Activate(p6, p7)
	local v7 = Saving.Get(p6);
	if not v7 then
		return;
	end;
	if Shared.IsTradingPlaza then
		Network.Fire("Notification", p6, "Boosts are disabled in the Trading Plaza.", {
			color = Color3.fromRGB(255, 62, 62)
		});
		return;
	end;
	local v8 = v7.BoostsInventory[p7];
	if not v8 or not (v8 > 0) then
		return;
	end;
	local l__BoostsInventory__9 = v7.BoostsInventory;
	l__BoostsInventory__9[p7] = l__BoostsInventory__9[p7] - 1;
	if v7.BoostsInventory[p7] <= 0 then
		v7.BoostsInventory[p7] = nil;
	end;
	local v10 = Settings.BoostDurations[p7] or 1800;
	if Mastery.HasPerk(p6, "Boosts", 4) then
		v10 = v10 * 1.5;
	elseif Mastery.HasPerk(p6, "Boosts", 3) then
		v10 = v10 * 1.25;
	elseif p7 == "Triple Damage" and Mastery.HasPerk(p6, "Boosts", 1) then
		v10 = v10 * 1.25;
	elseif p7 == "Triple Coins" and Mastery.HasPerk(p6, "Boosts", 2) then
		v10 = v10 * 1.25;
	end;
	if not v7.Boosts[p7] then
		v7.Boosts[p7] = v10;
	else
		local l__Boosts__11 = v7.Boosts;
		l__Boosts__11[p7] = l__Boosts__11[p7] + v10;
	end;
	coroutine.wrap(function()
		Network.Fire("Boost Activated", p6, p7, v10);
	end)();
	Mastery.Progress(p6, "Boosts", 180);
	return true;
end;
function UpdateBoosts(p8)
	if Shared.IsTradingPlaza then
		return;
	end;
	local v12 = Saving.Get(p8);
	if not v12 then
		return;
	end;
	for v16, v17 in pairs(v12.Boosts) do
		if v17 <= 0 then
			v12.Boosts[v16] = nil;
			Network.Fire("Boost Ended", p8, v16);
		else
			v12.Boosts[v16] = v12.Boosts[v16] - 1;
			Mastery.Progress(p8, "Boosts", 1);
		end;	
	end
end;
function Track(p9)
	coroutine.wrap(function()
		while true do
			if p9 then

			else
				break;
			end;
			if p9.Parent then

			else
				break;
			end;
			UpdateBoosts(p9);
			Functions.Wait(1);		
		end;
	end)();
end;
Signal.Fired("Player Added"):Connect(function(p10)
	Track(p10);
end);
Network.Fired("Activate Boost"):Connect(function(p11, p12)
	v1.Activate(p11, p12);
end);
return v1;
  -  Editar
  04:54:13.834    -  Editar
  04:54:13.834  ----- [2530] ServerScriptService.Library.CalculateReward -----  -  Editar
  04:54:13.834  local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Settings = require(script.Parent.Settings)
local Saving = require(script.Parent.Saving)
local Directory = require(Library.Directory)
local Pets = require(script.Parent.Pets)
local Give = require(script.Parent.Give)
local Shared = require(Library.Shared)
local Mastery = require(script.Parent.Mastery)
local Boosts = require(script.Parent.Boosts)
local Upgrades = require(script.Parent.Upgrades)
local ServerBoosts = require(script.Parent.ServerBoosts)

local RNG = Random.new();

return function(player, p2, p3, p4, p5)
	local v2 = Saving.Get(player);
	if not v2 then
		return;
	end;
	p5 = p5 or {};
	if p3 == "Diamonds" then
		p5.disableScaling = true;
	end;
	if p3 == "Best" then
		if v2["Cartoon Coins"] ~= 0 then
			p3 = "Cartoon Coins";
		elseif v2["Rainbow Coins"] ~= 0 then
			p3 = "Rainbow Coins";
		elseif v2["Tech Coins"] ~= 0 then
			p3 = "Tech Coins";
		elseif v2["Fantasy Coins"] ~= 0 then
			p3 = "Fantasy Coins";
		else
			p3 = "Coins";
		end;
	end;
	
	local v3 = {};
	for v4, v5 in ipairs(p4) do
		local v6, v7 = Pets.Get(v5);
		if v6 and v7 and v7 == player then
			v3[v5] = v6;
		end;
	end;
	
	local v12
	if not p5.avgPetLevel then
		local v8 = 0;
		local v9 = 0;
		for v10, v11 in pairs(v3) do
			v8 = v8 + v11.s;
			v9 = v9 + 1;
		end;
		v12 = v8 / v9;
		if v12 ~= v12 then
			v12 = 0;
		end;
	else
		v12 = p5.avgPetLevel;
	end;
	
    local v13
    if ServerBoosts.IsActive(player, "Triple Coins") and Boosts.Has(player, "Triple Coins") then
        v13 = 6;
    elseif ServerBoosts.IsActive(player, "Triple Coins") then
        v13 = 3
	elseif Boosts.Has(player, "Triple Coins") then
		v13 = 3;
	else
		v13 = 1;
    end;
	
	local v14
	if Settings.DoubleCoinsEvent then
		v14 = 2;
	else
		v14 = 1;
    end;
    
    local dir = Directory.Fruits["Pear"]
    local m = require(script.Parent.Fruit).Get(player, dir) or 0
	local EE=require(script.Parent.Fruit).GetBonus(player, dir)--dir.Bonus(m)
    if tonumber(EE) and EE < 1 and EE > 0 then
        EE = EE + 1
    end

    local dir2 = Directory.Fruits["Orange"]
    local m2 = require(script.Parent.Fruit).Get(player, dir2) or 0
	local EE2=require(script.Parent.Fruit).GetBonus(player, dir2)--dir.Bonus(m2)
    if tonumber(EE2) and EE2 < 1 and EE2 > 0 then
        EE2 = EE2 + 1
    end
    if p3 ~= "Diamonds" then
        if m >= 1 then
            v14 = v14 + ( EE2 or 0 )
        end
    else
        if m2 >= 1 then
            v14 = v14 + ( EE or 0 )
        end
    end
    
	local v15 = math.clamp(v2.FriendsBoost, 1, 10);
	local v16 = Upgrades.Get(player, "Halloween More Candy");
	local u3 = 1 + 0.15 * Upgrades.Get(player, "Halloween More Diamonds") + 0.15 * Upgrades.Get(player, "More Diamonds");
	local u4 = 1;
	
	(function()
		local v17 = 0;
		for v18, v19 in pairs(v3) do
			local v20, v21 = Shared.HasPower(v19, "Diamonds");
			if v20 then
				v17 = v17 + (Shared.GetPowerDir("Diamonds", v21).value - 1);
			end;
		end;
		u3 = u3 + math.min(v17, 5);
	end)();
	
	(function()
		if p5.coinModelName and p5.coinModelName == "Present" then
			local v22 = 0;
			for v23, v24 in pairs(v3) do
				local v25, v26 = Shared.HasPower(v24, "Presents");
				if v25 then
					v22 = v22 + (Shared.GetPowerDir("Presents", v26).value - 1);
				end;
			end;
			u4 = u4 + v22;
		end;
	end)();
	
	(function()
		if p3 == "Coins" or p3 == "Fantasy Coins" or p3 == "Tech Coins" or p3 == "Rainbow Coins" or p3 == "Cartoon Coins" then
			local v27 = 0;
			for v28, v29 in pairs(v3) do
				local v30, v31 = Shared.HasPower(v29, p3);
				if v30 then
					v27 = v27 + (Shared.GetPowerDir(p3, v31).value - 1);
				end;
			end;
			u4 = u4 + v27;
		end;
	end)();
	
	(function()
		local v32 = 0;
		for v33, v34 in pairs(v3) do
			local v35, v36 = Shared.HasPower(v34, "Royalty");
			if v35 then
				v32 = v32 + 1;
			end;
		end;
		u3 = u3 + math.min(v32, 5);
	end)();
	
	(function()
		if p5.coinModelName and string.find(p5.coinModelName, "Chest") then
			if Mastery.HasPerk(player, "Chests", 5) then
				u4 = u4 * 2;
				return;
			end;
			if Mastery.HasPerk(player, "Chests", 4) then
				u4 = u4 * 1.5;
				return;
			end;
			if Mastery.HasPerk(player, "Chests", 2) then
				u4 = u4 * 1.25;
				return;
			end;
			if Mastery.HasPerk(player, "Chests", 1) then
				u4 = u4 * 1.15;
			end;
		end;
	end)();
	
	(function()
		if p5.coinModelName and (p5.coinModelName == "Coins" or p5.coinModelName == "Tiny Coins" or p5.coinModelName == "Large Coins") then
			if Mastery.HasPerk(player, "Coin Piles", 5) then
				u4 = u4 * 3;
				return;
			end;
			if Mastery.HasPerk(player, "Coin Piles", 4) then
				u4 = u4 * 2;
				return;
			end;
			if Mastery.HasPerk(player, "Coin Piles", 2) then
				u4 = u4 * 1.5;
				return;
			end;
			if Mastery.HasPerk(player, "Coin Piles", 1) then
				u4 = u4 * 1.25;
			end;
		end;
	end)();
	
	(function()
		if p5.coinModelName and p5.coinModelName == "Present" then
			if Mastery.HasPerk(player, "Presents", 5) then
				u4 = u4 * 2;
				return;
			end;
			if Mastery.HasPerk(player, "Presents", 4) then
				u4 = u4 * 1.6;
				return;
			end;
			if Mastery.HasPerk(player, "Presents", 2) then
				u4 = u4 * 1.35;
				return;
			end;
			if Mastery.HasPerk(player, "Presents", 1) then
				u4 = u4 * 1.15;
			end;
		end;
	end)();
	
	(function()
		if p5.coinModelName and p5.coinModelName == "Crate" then
			if Mastery.HasPerk(player, "Crates", 5) then
				u4 = u4 * 2.25;
				return;
			end;
			if Mastery.HasPerk(player, "Crates", 4) then
				u4 = u4 * 1.75;
				return;
			end;
			if Mastery.HasPerk(player, "Crates", 2) then
				u4 = u4 * 1.4;
				return;
			end;
			if Mastery.HasPerk(player, "Crates", 1) then
				u4 = u4 * 1.25;
			end;
		end;
	end)();
	
	(function()
		if p5.coinModelName and (p5.coinModelName == "Safe" or p5.coinModelName == "Vault") then
			if Mastery.HasPerk(player, "VaultsAndSafes", 5) then
				u4 = u4 * 2;
				return;
			end;
			if Mastery.HasPerk(player, "VaultsAndSafes", 4) then
				u4 = u4 * 1.6;
				return;
			end;
			if Mastery.HasPerk(player, "VaultsAndSafes", 2) then
				u4 = u4 * 1.35;
				return;
			end;
			if Mastery.HasPerk(player, "VaultsAndSafes", 1) then
				u4 = u4 * 1.15;
			end;
		end;
	end)();
	
	(function()
		if p5.coinModelName and string.find(p5.coinModelName, "Diamonds") then
			if Mastery.HasPerk(player, "Diamond Piles", 4) then
				u4 = u4 * 3;
				return;
			end;
			if Mastery.HasPerk(player, "Diamond Piles", 3) then
				u4 = u4 * 2;
				return;
			end;
			if Mastery.HasPerk(player, "Diamond Piles", 2) then
				u4 = u4 * 1.5;
				return;
			end;
			if Mastery.HasPerk(player, "Diamond Piles", 1) then
				u4 = u4 * 1.2;
			end;
		end;
	end)();
	
	local v37
	if not p5.disableScaling then
		local hardcoreDecrease = Shared.IsHardcore and 10000000000000 or 1
		v37 = math.max(math.round((p2 ^ 0.75 * math.max(math.sqrt(math.max(v12/hardcoreDecrease, 1)), 1)) ^ 0.6), 1);
		local v38 = Directory.Currency[p3].Multiplier or 1
		if v38 then
			v37 = v37 * v38;
		end;
	else
		v37 = RNG:NextInteger(3, 5);
	end;
	
	local v39 = math.max(math.round(v37), 1);
	if p5.coinInfo then
		local v40 = Directory.Coins[p5.coinInfo.name];
		local v41 = p5.coinInfo.breakType == "Break" and v40.orbsBreak or v40.orbsRandom;
		if p3 ~= "Diamonds" then
			if not p5.disableScaling then
				v39 = v39 * (Directory.Areas[p5.coinInfo.area].mult * (v40.totalMult + v41.rewardMult));
			else
				v39 = v39 * (v40.totalMult + v41.rewardMult);
			end;
		else
			v39 = v39 * v40.diamondsMult;
		end;
	end;
	
	if p3 == "Diamonds" then
		v39 = v39 * u3;
	elseif p3 == "Halloween Candy" then
		v39 = v39 ^ 0.45 * Settings.HalloweenCandyMult * (4 + 0.4 * v16);
	elseif p3 == "Gingerbread" then
		v39 = v39 ^ 0.45 * Settings.GingerbreadMult;
	elseif p3 == "Coins" or p3 == "Fantasy Coins" or p3 == "Tech Coins" or p3 == "Rainbow Coins" or p3 == "Cartoon Coins" then
		v39 = v39 * u4;
	end;
	
	if p3 ~= "Diamonds" then
		v39 = v39 * v13 * v14 * v15;
	end;
	
	if v39 ~= v39 then
		v39 = 1;
	end
		
	return math.max(math.round(v39), 1);
end;
  -  Editar
  04:54:13.834    -  Editar
  04:54:13.834  ----- [2531] ServerScriptService.Library.Coins -----  -  Editar
  04:54:13.834  local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local Datastore = require(script.Parent.Datastore)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Settings = require(script.Parent.Settings)
local Saving = require(script.Parent.Saving)
local RunService = game:GetService("RunService")
local Heartbeat = function(p1)  
	for index1 = 1, p1 or 1 do
		RunService.Heartbeat:Wait();
	end
end
local Directory = require(Library.Directory)
local Pets = require(script.Parent.Pets)
local Shared = require(Library.Shared)
local Mastery = require(script.Parent.Mastery)
local Boosts = require(script.Parent.Boosts)
local Upgrades = require(script.Parent.Upgrades)
local Orbs = require(script.Parent.Orbs)
local CalculateReward = require(script.Parent.CalculateReward)
local Achievements = require(script.Parent.Achievements)
local LootBags = require(script.Parent.LootBags)
local Eggs = require(script.Parent.Eggs)
local Worlds = require(script.Parent.Worlds)
local Ranks = require(script.Parent.Ranks)
local ServerBoosts = require(script.Parent.ServerBoosts)
local Give = require(script.Parent.Give)
local RNG = Random.new()

local diamondMineMastery = 75

local v1 = {};
local l____WORLDS__2 = game.ServerStorage:WaitForChild("__WORLDS");
local u3 = {};
local u4 = Random.new();
local u5 = 1;
local u6 = {};
function v1.Create(p1, p2, p3, manual, ID)
	local worldDir =  Directory.Worlds[p1]
	local v2 = worldDir.spawns[p2];
	local l__settings__3 = v2.settings;
	local u7 = 0;
	local l__MAP__8 = l____WORLDS__2:FindFirstChild(p1):FindFirstChild("MAP");
	local l__area__9 = l__settings__3.area;
	local function u10(p4)
		u7 = u7 + 1;
		if u7 > 100 then
			warn("Coin spacing algo timeout");
			return true;
		end;
		for v4, v5 in pairs(u3[p1][p2]) do
			local l__Size__6 = Directory.Coins[v5.n].model.Size;
			if (p4 - v5.p).Magnitude - math.max(l__Size__6.X, l__Size__6.Z) / 2 < 10 then
				return false;
			end;
		end;
		return true;
	end;
	
	local Spawns = l__MAP__8:FindFirstChild("Spawns"):FindFirstChild(p2)
	if not Spawns then
		return 
	end
	
	local v10 = Spawns:GetChildren();
	local v11 = nil;
	local v12 = nil;
	local v13 = nil;
	local v14 = nil;
	local v15 = 0;
	while not v11 do
		v15 = v15 + 1;
		if v15 >= 100 then
			warn("Failed to calc position for new coin " .. l__area__9);
			return;
		end;
		v12 = v10[u4:NextInteger(1, #v10)];
		local l__Size__16 = v12.Size;
		v14 = math.floor(u4:NextNumber() * 1000) / 1000;
		v13 = v12.CFrame.p + Vector3.new(u4:NextNumber(-l__Size__16.X + 5, l__Size__16.X - 5), l__Size__16.Y, u4:NextNumber(-l__Size__16.Z + 5, l__Size__16.Z - 5)) / 2;
		if u10(v13) then
			v11 = true;
		end;		
	end;
	local v7 = v12
	local v8=v13
	local v9=v14
	if not v2 then
		warn("Coin spawn '" .. v7.Name .. "' is missing");
		return;
	end;
	local v17 = {};
	local v18 = 0;
	for v19, v20 in pairs(u3[p1][p2]) do
		if v20.h > 0 then
			v18 = v18 + 1;
			if not v17[v20.n] then
				v17[v20.n] = 1;
			else
				local l__n__21 = v20.n;
				v17[l__n__21] = v17[l__n__21] + 1;
			end;
		end;
	end;
	
	if l__settings__3.manualSpawn and not manual then
		return nil
	end
	
	local v22 = Functions.CloneTable(v2.coins);
	for v23, v24 in ipairs(v22) do
		local v25 = v24[1];
		if v17[v25] then
			v24[2] = v24[2] * math.max(1 - (v17[v25] / v18 + 0.33), 0.065);
		end;
	end;
	if not p3 then
		p3 = Functions.Lottery(unpack(v22));
	end;
	
	coroutine.wrap(function()
		if worldDir.luckyBlockEnabled and Settings.luckyBlockEvent then
			local randomLuckyBlock = {
				{"None", 85};
				{"Purple Lucky Block", 30};
				{"Orange Lucky Block", 10};
				{"Red Lucky Block", 3};
				{"Rainbow Lucky Block", 0.5};
			}
			local luckyBlock = Functions.Lottery(randomLuckyBlock)
			if luckyBlock and luckyBlock ~= "None" then
				if not string.match(p2, "Chest") then
					p3 = luckyBlock
				end	
			end
		end
	end)()
	
	local v27 = Directory.Coins[p3];
	if not v27 then
		warn(tostring(p3) .. " directory does not exist");
		return;
	end;
	local v28 = v27.health;
	if v27.scaleHealth then
		v28 = v28 * (l__settings__3.healthMult or 1);
    end;
    
    local hasMult = RNG:NextInteger(1,15)
    local specialMult = nil
    
	if hasMult == 15 then
        local lot = Functions.Lottery({ 
            {  3, 85 }, 
            {  5, 35 }, 
            { 10,  4 },
            { 25,  3.5 }, 
            { 50,  1.25 },
            --{ 75,  0.50 },
            { 100, 0.15 } 
        }) 
        
        if lot then
            lot = tonumber(lot)

            specialMult = {
                l = { {
                    t = v27.currencyType == "Diamonds" and 2 or 1,
                    m = lot
                } }
            }
            
    
        end
    end
    
	u3[p1][p2][tostring(u5)] = {
		n = p3, 
		p = Vector3.new(math.round(v8.X * 100) / 100, v8.Y, math.round(v8.Z * 100) / 100), 
		r = v9, 
		h = v28, 
		mh = v28, 
		w = p1, 
		a = l__area__9, 
		pets = {}, 
		petsFarming = {}, 
        d = false,
		b = specialMult,
		id = tostring(u5)
    };
    
	u6[tostring(u5)] = {};
	u5 = u5 + 1;
	return u5, Vector3.new(math.round(v8.X * 100) / 100, v8.Y, math.round(v8.Z * 100) / 100);
end;
function v1.CreateComet(p1, p2, p3, ID, pos)
	local v2 = Directory.Worlds[p1].spawns[p2];
	local l__settings__3 = v2.settings;
	local u7 = 0;
	local l__MAP__8 = l____WORLDS__2:FindFirstChild(p1):FindFirstChild("MAP");
	local l__area__9 = l__settings__3.area;
	local function u10(p4)
		u7 = u7 + 1;
		if u7 > 100 then
			warn("Coin spacing algo timeout");
			return true;
		end;
		for v4, v5 in pairs(u3[p1][p2]) do
			local l__Size__6 = Directory.Coins[v5.n].model.Size;
			if (p4 - v5.p).Magnitude - math.max(l__Size__6.X, l__Size__6.Z) / 2 < 10 then
				return false;
			end;
		end;
		return true;
	end;

	local Spawns = l__MAP__8:FindFirstChild("Spawns"):FindFirstChild(p2)
	if not Spawns then
		return 
	end

	local v10 = Spawns:GetChildren();
	local v11 = nil;
	local v12 = nil;
	local v13 = nil;
	local v14 = nil;
	local v15 = 0;
	while not v11 do
		v15 = v15 + 1;
		if v15 >= 100 then
			warn("Failed to calc position for new coin " .. l__area__9);
			return;
		end;
		v12 = v10[u4:NextInteger(1, #v10)];
		local l__Size__16 = v12.Size;
		v14 = math.floor(u4:NextNumber() * 1000) / 1000;
		v13 = v12.CFrame.p + Vector3.new(u4:NextNumber(-l__Size__16.X + 5, l__Size__16.X - 5), l__Size__16.Y, u4:NextNumber(-l__Size__16.Z + 5, l__Size__16.Z - 5)) / 2;
		if u10(v13) then
			v11 = true;
		end;		
	end;
	local v7 = v12
	local v8=v13
	local v9=v14
	if not v2 then
		warn("Coin spawn '" .. v7.Name .. "' is missing");
		return;
	end;
	local v17 = {};
	local v18 = 0;
	for v19, v20 in pairs(u3[p1][p2]) do
		if v20.h > 0 then
			v18 = v18 + 1;
			if not v17[v20.n] then
				v17[v20.n] = 1;
			else
				local l__n__21 = v20.n;
				v17[l__n__21] = v17[l__n__21] + 1;
			end;
		end;
	end;

	local v22 = Functions.CloneTable(v2.coins);
	for v23, v24 in ipairs(v22) do
		local v25 = v24[1];
		if v17[v25] then
			v24[2] = v24[2] * math.max(1 - (v17[v25] / v18 + 0.33), 0.065);
		end;
	end;
	if not p3 then
		p3 = Functions.Lottery(unpack(v22));
	end;

	local v27 = Directory.Coins[p3];
	if not v27 then
		warn(tostring(p3) .. " directory does not exist");
		return;
	end;
	local v28 = v27.health;
	if v27.scaleHealth then
		v28 = v28 * (l__settings__3.healthMult or 1);
	end;


	u3[p1][p2][tostring(ID)] = {
		n = p3, 
		p = pos, 
		r = v9, 
		h = v28, 
		mh = v28, 
		w = p1, 
		a = l__area__9, 
		pets = {}, 
		petsFarming = {}, 
		d = false,
		b = nil,
		id = ID
	};

	u6[tostring(ID)] = {};
	u5 = u5 + 1;
	return ID 
end;
function v1.GenID()
	u5 = u5 + 1;
	return u5
end;
function v1.GenPos(p1, p2, p3)
	local v2 = Directory.Worlds[p1].spawns[p2];
	local l__settings__3 = v2.settings;
	local u7 = 0;
	local l__MAP__8 = l____WORLDS__2:FindFirstChild(p1):FindFirstChild("MAP");
	local l__area__9 = l__settings__3.area;
	local function u10(p4)
		u7 = u7 + 1;
		if u7 > 100 then
			warn("Coin spacing algo timeout");
			return true;
		end;
		for v4, v5 in pairs(u3[p1][p2]) do
			local l__Size__6 = Directory.Coins[v5.n].model.Size;
			if (p4 - v5.p).Magnitude - math.max(l__Size__6.X, l__Size__6.Z) / 2 < 10 then
				return false;
			end;
		end;
		return true;
	end;

	local Spawns = l__MAP__8:FindFirstChild("Spawns"):FindFirstChild(p2)
	if not Spawns then
		return 
	end

	local v10 = Spawns:GetChildren();
	local v11 = nil;
	local v12 = nil;
	local v13 = nil;
	local v14 = nil;
	local v15 = 0;
	while not v11 do
		v15 = v15 + 1;
		if v15 >= 100 then
			warn("Failed to calc position for new coin " .. l__area__9);
			return;
		end;
		v12 = v10[u4:NextInteger(1, #v10)];
		local l__Size__16 = v12.Size;
		v14 = math.floor(u4:NextNumber() * 1000) / 1000;
		v13 = v12.CFrame.p + Vector3.new(u4:NextNumber(-l__Size__16.X + 5, l__Size__16.X - 5), l__Size__16.Y, u4:NextNumber(-l__Size__16.Z + 5, l__Size__16.Z - 5)) / 2;
		if u10(v13) then
			v11 = true;
		end;		
	end;
	local v8=v13

	return Vector3.new(math.round(v8.X * 100) / 100, v8.Y, math.round(v8.Z * 100) / 100);
end;
local x11 = {};
local times = {};
function v1.Remove(p5)
	p5 = tostring(p5);
	for v29, v30 in pairs(u3) do
		for v31, v32 in pairs(v30) do
			if v32[p5] then
				v1.NetworkEvent(p5, "Remove");
				if u6[p5] then
					u6[p5] = nil;
				end;
				if x11[p5] then
					x11[p5] = nil;
				end;
				v32[p5] = nil;
				if Directory.Worlds[v29].spawns[v31].settings.respawnCooldown then
					times[v31] = os.clock();
				end;
				return;
			end;
		end;
	end;
end;
function v1.Destroyed(p6)
	local v33 = v1.Get(p6);
	if not v33 then
		return;
	end;
	if v33.d then
		return;
	end;
	v33.d = true;
	local v34 = {};
	for v35, v36 in ipairs(v33.pets) do
		local v37, v38 = Pets.Get(v36);
		if v37 and v38 and not v34[v38] then
			v34[v38] = true;
		end;
	end;
	for v39, v40 in pairs(v34) do
		v1.Rewards(p6, v39);
	end;
	v1.Remove(p6);
end;
function v1.Damage(p7, p8)
	p7 = tostring(p7);
	local v41, v42 = Pets.Get(p8);
	if not v41 then
		return;
	end;
	local v43 = v1.Get(p7);
	if not v43 then
		return;
	end;
	if not Functions.SearchArray(v43.pets, p8) then
		warn("Pet is not allowed to farm coin -- " .. p7);
		return;
	end;
	local PET, OWNER = Pets.Get(p8)
	local v44 = Shared.ComputePetStrength(PET)  --Shared.ComputePetStrength(p8);

	if Shared.IsHardcore then
		v44 = v44 / Shared.HardcorePetMult
	else
		v44 = v44
	end
	local v45 = u6[p7];
	local l__h__46 = v43.h;
	local v47 = u4:NextNumber() <= 0.2;
	local v48 = v47 and v44 * 3 or v44;
	if not v48 then
		warn("Failed to calculate pet damage");
		return;
	end;
	if not v45[v42.Name] then
		v45[v42.Name] = {};
	end;
	if not v45[v42.Name][p8] then
		v45[v42.Name][p8] = { 0, 0 };
	end;
	local dmg = v48 <= v43.h and v48 or v48 - v43.h;
	local cmodel = Directory.Coins[v43.n];
	(function()
		local v49, v50 = Shared.HasPower(v41, "Strength");
		if v49 then
			dmg = dmg * Shared.GetPowerDir("Strength", v50).value;
		end;
	end)();
	(function()
		local v51 = 1;
		for v52, v53 in pairs(v45) do
			for v54, v55 in pairs(v53) do
				local v56 = Pets.Get(v54);
				if v56 then
					local v57, v58 = Shared.HasPower(v56, "Teamwork");
					if v57 then
						v51 = v51 + (Shared.GetPowerDir("Teamwork", v58).value - 1);
					end;
				end;
			end;
		end;
		dmg = dmg * v51;
	end)();
	(function()
		if string.find(cmodel.model.Name, "Chest") then
			local v59, v60 = Shared.HasPower(v41, "Chests");
			if v59 then
				dmg = dmg * Shared.GetPowerDir("Chests", v60).value;
			end;
		end;
	end)();
	(function()
		local v61, v62 = Shared.HasPower(v41, "Royalty");
		if v61 then
			local v63 = Shared.GetPowerDir("Royalty", v62);
			dmg = dmg * 2;
		end;
	end)();
	(function()
		if Boosts.Has(v42, "Triple Damage") then
			dmg = dmg * 3;
        end;
        if ServerBoosts.IsActive(v42, "Triple Damage")  then
            dmg = dmg * 3;
		end;
		if ServerBoosts.IsActive(v42, "Super Breaker")  then
			dmg = dmg * 25;
		end;
        local dir = Directory.Fruits["Apple"]
        local m = require(script.Parent.Fruit).Get(v42, dir) or 0
		local EE=require(script.Parent.Fruit).GetBonus(v42, dir)--dir.Bonus(m)
        if tonumber(EE) and EE < 1 then
            EE = EE + 1
        end
        
        if m >= 1 then
            dmg = dmg * ( EE or 1 ) 
        end    
	end)();
	dmg = math.min(dmg, math.round(v43.mh / 3 + 0.5));
	dmg = math.max(math.round(dmg), 0);
	local v64 = v45[v42.Name][p8];
	v64[1] = v64[1] + (dmg <= v43.h and dmg or v43.h);
	local v65 = v45[v42.Name][p8];
	v65[2] = v65[2] + (v48 <= v43.h and v48 or v43.h);
	v43.h = math.max(v43.h - dmg, 0);
	v1.NetworkEvent(p7, "Health");
	v1.NetworkEvent(p7, "Special Bonus");
	v1.NetworkEvent(p7, "Damage", dmg, v47, v42);
	if v43.h > 0 then
		v1.Rewards(p7, v42);
	end;
	Ranks.Progress(v42, v48);
	--[[if Directory.Worlds[Saving.Get(OWNER).World]=="Diamond Mine" then
		
	end]]--
    LootBags.Progress(v42, v48 / 45, v43.p, {
        blastRadius = math.clamp((cmodel.model.Size.Magnitude / 20) ^ 0.9, 1, 8)
    }, v43.n);
	if v43.h <= 0 then
		v1.Destroyed(p7);
	end;
end;
function v1.Get(p9)
	p9 = tostring(p9);
	for v66, v67 in pairs(u3) do
		for v68, v69 in pairs(v67) do
			if v69[p9] then
				return v69[p9];
			end;
		end;
	end;
end;
local plyrcoindat2 = {};
local function cfunc(p10, p11)
	local v70 = nil;
	local v71 = nil;
	local v72 = u6[p10][p11.Name];
	if not v72 then
		return;
	end;
	local v73 = 0;
	local v74 = 0;
	local v75 = {};
	for v76, v77 in pairs(v72) do
		local v78, v79 = Pets.Get(v76);
		if v78 and v79 == p11 then
			v73 = v73 + v77[1];
			v74 = v74 + v77[2];
			table.insert(v75, v78.s);
		end;
	end;
	table.sort(v75, function(p12, p13)
		return p13 < p12;
	end);
	v71 = 0;
	v70 = 0;
	for v80 = 1, math.min(#v75, 4) do
		v70 = v70 + 1;
		v71 = v71 + v75[v80];
	end;
	return v73, v70, v71 / v70, v74; -- DEBUG : v73, local v82 / v81, v74
end;
function v1.Rewards(p14, p15)
	local v83 = nil;
	local v84 = nil;
	local v85 = nil;
	p14 = tostring(p14);
	local v86 = Saving.Get(p15, false);
	if not v86 then
		return;
	end;
	local v87 = v1.Get(p14);
	if not v87 then
		return;
	end;
	local v88 = u6[p14];
	if not v88 or not v88[p15.Name] then
		return;
	end;
	if v86.World ~= v87.w then
		return;
	end;
	if not x11[p14] then
		x11[p14] = {};
	end;
	local v89 = x11[p14];
	local l__n__90 = v87.n;
	local v91 = Directory.Coins[l__n__90];
	local l__a__92 = v87.a;
	local v93 = Directory.Areas[l__a__92];
	v83 = v87.h;
	local v94 = math.clamp((v91.model.Size.Magnitude / 20) ^ 0.9, 1, 8);
	local v95 = Upgrades.Get(p15, "More Diamonds");
	local v96 = 1;
	if v91.modelHasStages then
		local v97 = v83 / v87.mh;
		if v97 <= 0 then
			v96 = 4;
		elseif v97 <= 0.33 then
			v96 = 3;
		elseif v97 <= 0.66 then
			v96 = 2;
		else
			v96 = 1;
		end;
	elseif v83 <= 0 then
		v96 = 4;
	end;
	local v98 = v96 == 4;
	if v98 then
		if plyrcoindat2[p15] then
			plyrcoindat2[p15] = plyrcoindat2[p15] + 1;
		else
			plyrcoindat2[p15] = 1;
		end;
	end;
	local v99 = nil;
	local v100 = nil;
	local v101 = nil;
	v85, v99, v100, v101 = cfunc(p14, p15);
	v84 = function()
		return u4:NextNumber(5, 8) / v91.orbsRandom.speedMult / math.clamp(v99 / 2, 1, 3);
	end;
	local v102 = v89[p15];
	if not v102 then
		v89[p15] = {
			stage = v96, 
			incr = {
				lastTick = os.clock(), 
				lastTickGoal = v84(), 
				lastDamage = v85
			}
		};
		return;
	end;
	local rewardchance = Settings.BonusRewardChance;
	(function()
		local v103 = 0;
		for v104, v105 in pairs(v87.pets) do
			local v106 = Pets.Get(v105);
			if v106 then
				local v107, v108 = Shared.HasPower(v106, "Charm");
				if v107 then
					v103 = v103 + (Shared.GetPowerDir("Charm", v108).value - 1);
				end;
			end;
		end;
		rewardchance = rewardchance + v103;
	end)();
	local l__currencyType__18 = v91.currencyType;
	local l__p__19 = v87.p;
	local l__Name__20 = v91.model.Name;
    if v102.stage ~= v96 and v96 > 1 then
          
		(function()
			local l__orbsBreak__109 = v91.orbsBreak;
			v102.stage = v96;
			local v110 = {
				name = l__n__90, 
				area = l__a__92, 
				breakType = "Break"
			};
			local v111 = CalculateReward(p15, v85 / 8, l__currencyType__18, v87.pets, {
				coinInfo = v110, 
				avgPetLevel = v100
			});
			local v112 = CalculateReward(p15, v85 / 8, "Diamonds", v87.pets, {
				coinInfo = v110, 
				avgPetLevel = v100, 
				disableScaling = true
			});
			local v113 = 1 + v96 / 8;
			local v114 = u4:NextInteger(3 * v113 * l__orbsBreak__109.amountMult, 5 * v113 * l__orbsBreak__109.amountMult);
			local u20 = math.max(math.round(v111 / v114 ^ 0.75), 1);
			
			local mult = v87.b and v87.b.l[1].m or 1
			local multiply = 1
			
			if mult >= 50 then
				local lol = mult / 2
				mult = lol
				multiply = lol
			end
			
			u20 = u20 * multiply
			
            coroutine.wrap(function()
                for i = 1, v87.b and mult or 1 do
                    for v115 = 1, v114 do
                        Orbs.Add(p15, l__p__19, l__currencyType__18, u20, {
                            BlastRadius = v94
                        });
                        Functions.Wait(u4:NextNumber(0, math.min(v115 / 250, 0.075)));
                    end;
                end
			end)();
			coroutine.wrap(function()
                Orbs.Add(p15, l__p__19, "Diamonds", v112, {
                    BlastRadius = v94
                });
            end)();
            --[[coroutine.wrap(function()
                local v116 = u4:NextInteger(3, 10);
                local v117 = math.max(math.round(CalculateReward(p15, v85 / 8, "Easter Coins", v87.pets, {
                    coinInfo = v110, 
                    avgPetLevel = v100
                }) / v116 ^ 0.75), 1);
                for v118 = 1, v116 do
                    Orbs.Add(p15, l__p__19, "Easter Coins", v117, {
                        BlastRadius = v94
                    });
                    Functions.Wait(u4:NextNumber(0, math.min(v118 / 30, 0.075)));
                end;
            end)();]]--
            if v98 then
                if u4:NextNumber() <= rewardchance then
                    local v119 = u4:NextInteger(20, 30);
					local u22 = math.max(math.round(v112 * u4:NextNumber(0.7, 1)), 1);
					local u23 = math.max(math.round(u20 / v119 ^ 0.7), 1);
					coroutine.wrap(function()
						Orbs.Add(p15, l__p__19, "Diamonds", u22);
						for v120 = 1, v119 do
							Orbs.Add(p15, l__p__19, l__currencyType__18, u23);
							Functions.Wait(u4:NextNumber(0, math.min(v120 / 250, 0.075)));
						end;
					end)();
					coroutine.wrap(function()
						Network.Fire("Coin Bonus", p15, l__p__19);
					end)();
				end;
				if v85 / v87.mh >= 0.1 then
					Achievements.Add(p15, "Mine Coins", 1);
					if l__Name__20 == "Large Coins" or l__Name__20 == "Tiny Coins" or l__Name__20 == "Coins" then
						local v121
						if l__Name__20 == "Large Coins" then
							v121 = 100;
						elseif l__Name__20 == "Coins" then
							v121 = 75;
						else
							v121 = false;
							if l__Name__20 == "Tiny Coins" then
								v121 = 50;
							end;
						end;
						Mastery.Progress(p15, "Coin Piles", v121);
					elseif l__Name__20 == "Present" then
						Mastery.Progress(p15, "Presents", 125);
						Achievements.Add(p15, "Presents", 1);
					elseif l__Name__20 == "Crate" then
						Mastery.Progress(p15, "Crates", 75);
						Achievements.Add(p15, "Crates", 1);
					elseif l__Name__20 == "Vault" then
						Mastery.Progress(p15, "VaultsAndSafes", 150);
						Achievements.Add(p15, "Vaults", 1);
					elseif l__Name__20 == "Safe" then
						Mastery.Progress(p15, "VaultsAndSafes", 75);
						Achievements.Add(p15, "Safes", 1);
					elseif l__Name__20 == "Diamonds" or l__Name__20 == "Tiny Diamonds" then
						Mastery.Progress(p15, "Diamond Piles", 125);
					elseif string.find(l__Name__20, "Chest") then
						Mastery.Progress(p15, "Chests", 75);
						Achievements.Add(p15, "Chests", 1);
						if l__Name__20 == "Magma Chest" then
							Achievements.Add(p15, "Magma Chest", 1);
						elseif l__Name__20 == "Grand Heaven Chest" then
							Achievements.Add(p15, "Grand Heaven Chest", 1);
						elseif l__Name__20 == "Giant Tech Chest" then
							Achievements.Add(p15, "Giant Tech Chest", 1);
						elseif l__Name__20 == "Giant Steampunk Chest" then
							Achievements.Add(p15, "Giant Steampunk Chest", 1);
						elseif l__Name__20 == "Giant Hacker Chest" then
							Signal.Fire("Hacker Portal Progress", p15, 1, 1);
						end;
					end;
				end;
				
				coroutine.wrap(function()
					local save = Saving.Get(p15)
					if save then
						local world = Shared.IsHardcore and save.Hardcore.World or save.World
						if world == "Diamond Mine" then
							Mastery.Progress(p15, "Diamond Mine", diamondMineMastery)
						end
					end
				end)()
				
				coroutine.wrap(function()
					if l__Name__20 == "Massive Comet" then
						Signal.Fire("Comets: Broken",p15, v87.id, true)
					elseif l__Name__20 == "Mini Comet" then
						Signal.Fire("Comets: Broken",p15, v87.id, false)
					end
				end)()
				
				-- normal 50
				-- rainbow 250
				
                coroutine.wrap(function()
                    if l__Name__20 == "Apple" then            
                        local save = Saving.Get(p15)
                        if not save then
                            return
                        end

                        local fruitData = save.Fruits["Apple"] or nil
                        if not fruitData then
                            fruitData = {
                                Amount = 0,
                                LastUpdated = Shared.ComputeSaveAge(save)
                            }
                        end
                        
                        local amount = fruitData.Amount + 1
                        fruitData.Amount = amount
                        
                        Network.Fire("Update Fruit", p15, "Apple", fruitData)
						Signal.Fire("Update: Fruit", p15, "Apple", fruitData)
						
						Mastery.Progress(p15, "Fruits", 50)
                    end
                    if l__Name__20 == "Banana" then            
                        local save = Saving.Get(p15)
                        if not save then
                            return
                        end

                        local fruitData = save.Fruits["Banana"] or nil
                        if not fruitData then
                            fruitData = {
                                Amount = 0,
                                LastUpdated = Shared.ComputeSaveAge(save)
                            }
                        end

                        local amount = fruitData.Amount + 1
                        fruitData.Amount = amount

                        Network.Fire("Update Fruit", p15, "Banana", fruitData)
						Signal.Fire("Update: Fruit", p15, "Banana", fruitData)
						
						Mastery.Progress(p15, "Fruits", 50)
                    end
                    if l__Name__20 == "Pear" then            
                        local save = Saving.Get(p15)
                        if not save then
                            return
                        end

                        local fruitData = save.Fruits["Pear"] or nil
                        if not fruitData then
                            fruitData = {
                                Amount = 0,
                                LastUpdated = Shared.ComputeSaveAge(save)
                            }
                        end

                        local amount = fruitData.Amount + 1
                        fruitData.Amount = amount
                        
                        Network.Fire("Update Fruit", p15, "Pear", fruitData)
						Signal.Fire("Update: Fruit", p15, "Pear", fruitData)
						
						Mastery.Progress(p15, "Fruits", 50)
                    end
                    if l__Name__20 == "Orange" then            
                        local save = Saving.Get(p15)
                        if not save then
                            return
                        end

                        local fruitData = save.Fruits["Orange"] or nil
                        if not fruitData then
                            fruitData = {
                                Amount = 0,
                                LastUpdated = Shared.ComputeSaveAge(save)
                            }
                        end

                        local amount = fruitData.Amount + 1
                        fruitData.Amount = amount

                        Network.Fire("Update Fruit", p15, "Orange", fruitData)
						Signal.Fire("Update: Fruit", p15, "Orange", fruitData)
						
						Mastery.Progress(p15, "Fruits", 50)
                    end
                    if l__Name__20 == "Pineapple" then            
                        local save = Saving.Get(p15)
                        if not save then
                            return
                        end

                        local fruitData = save.Fruits["Pineapple"] or nil
                        if not fruitData then
                            fruitData = {
                                Amount = 0,
                                LastUpdated = Shared.ComputeSaveAge(save)
                            }
                        end

                        local amount = fruitData.Amount + 1
                        fruitData.Amount = amount
                        
                        Network.Fire("Update Fruit", p15, "Pineapple", fruitData)
						Signal.Fire("Update: Fruit", p15, "Pineapple", fruitData)
						
						Mastery.Progress(p15, "Fruits", 50)
                    end
                    if l__Name__20 == "Rainbow Fruit" then
                        for i, v in pairs(Directory.Fruits) do
                            if i == "Rainbow" then continue end
                            local save = Saving.Get(p15)
                            if not save then
                                return
                            end

                            local fruitData = save.Fruits[i] or nil
                            if not fruitData then
                                fruitData = {
                                    Amount = 0,
                                    LastUpdated = Shared.ComputeSaveAge(save)
                                }
                            end

                            local amount = fruitData.Amount + 1
                            fruitData.Amount = amount

                            Network.Fire("Update Fruit", p15, i, fruitData)
							Signal.Fire("Update: Fruit", p15, i, fruitData)
						end
						Mastery.Progress(p15, "Fruits", 250)
                    end
				end)()
				
				--[[
				;{ 
				{ { "Small Currency", 0.06666666666666667 }, 30 }, 
				{ { "Med Currency", 0.3333333333333333 }, 25 }, 
				{ { "Big Currency", 1 }, 6.25 }, 
				{ { "Random Zone Egg" }, 70 }, 
				{ { "Small Diamonds", 0.06666666666666667 }, 25 }, 
				{ { "Med Diamonds", 0.3333333333333333 }, 12.5 }, 
				{ { "Big Diamonds", 1 }, 3.125 }, 
				{ { "Small Boosters", 1 }, 20 }, 
				{ { "Med Boosters", 5 }, 5 }, 
				{ { "Big Boosters", 15 }, 1.25 },
				{ { "Open Egg", "Lucky Egg" }, 20 } 
				;} 
				
				]]
				
				local function calculateCurrency(quan, factor)
					local m = RNG:NextNumber(9999999, 9999999999)
					--if quan == "Big" then
					--	return m * factor
					--elseif quan == "Med" then
					--	return m * factor
					--end
					return m * factor
				end
				
				local function calculateDiamonds(quan, factor)
					local m = RNG:NextNumber(99999, 99999999)
					--if quan == "Big" then
					--	return m * factor
					--elseif quan == "Med" then
					--	return m * factor
					--end
					return m * factor
				end
				
				local function calculateBoost(quan, factor)
					local boostOdds = {
						["Triple Coins"] = 75;
						["Triple Damage"] = 50;
						["Super Lucky"] = 95;
						["Ultra Lucky"] = 15;
					}
					
					local boost = Functions.Lottery(boostOdds)
					return boost, factor
				end
				
				local function getWorldEggs(world)
					local areas = {}
					local eggs = {}
					for k, v in pairs(Directory.Areas) do
						if v.world == world then
							table.insert(areas, k)
						end
					end
					for k, v in pairs(Directory.Eggs) do
						if table.find(areas, v.area) then
							table.insert(eggs, {k, 100})
						end
					end
					return eggs
				end
				
				coroutine.wrap(function() 
					local save = Saving.Get(p15)
					if save then
						local world = (Shared.IsHardcore and save.Hardcore or save).World
						
						if v91.luckyBlockRewards then
							local rewards = Functions.Lottery(v91.luckyBlockRewards)
							if rewards then
								local reward, arg = unpack(rewards)
								local quan, type, e = unpack(string.split(reward, " "))
								
								local notificationRewards = {} 
								if type == "Currency" then
									local amount = calculateCurrency(quan, arg)
									local mainCurrency 
									if amount then
										local worldDir = Directory.Worlds[world]
										if worldDir then
											mainCurrency = worldDir.mainCurrency
											if mainCurrency then
												Give.Currency(p15, amount, mainCurrency)
												table.insert(notificationRewards, {worldDir.mainCurrency, amount})
											end
										end
									end
									local rarity = quan == "Small" and "Epic" or quan == "Med" and "Legendary" or quan == "Large" and "Mythical" or "???"
									Network.Fire("Notification", p15, "You got a "..string.lower(mainCurrency).." "..rarity.." drop!", {
										color = Color3.fromRGB(255, 255, 255), 
									})
								elseif type == "Diamonds" then
									local amount = calculateDiamonds(quan, arg)
									if amount then
										Give.Currency(p15, amount, "Diamonds")
										table.insert(notificationRewards, {"Diamonds", amount})
									end
									local rarity = quan == "Small" and "Epic" or quan == "Med" and "Legendary" or quan == "Large" and "Mythical" or "???"
									Network.Fire("Notification", p15, "You got a "..rarity.." Diamonds drop!", {
										color = Color3.fromRGB(255, 255, 255), 
									})
								elseif type == "Boosters" then
									local boost, amount = calculateBoost(quan, arg)
									if boost then
										Boosts.Give(p15, boost, amount)
										table.insert(notificationRewards, {boost, amount})
									end
									
								elseif quan == "Random" then
									if type == "Zone" then
										if e == "Egg" then
											local eggs = getWorldEggs(world)
											if eggs then
												local egg = Functions.Lottery(eggs)
												if egg then
													Eggs.Open(p15, egg, 1, nil, nil, egg, true)
												end
											end
										end
									end	
								elseif quan == "Open" then
									if type == "Egg" then 
										if Directory.Eggs[arg] then
											Eggs.Open(p15, arg, 1, nil, nil, arg, true)
										end	
									end
								end
								
								coroutine.wrap(function()
									Network.Fire("Rewards Redeemed", p15, notificationRewards)
								end)()
							end
						end
					end
				end)()
				
				if v91.eggReward then
					Eggs.Open(p15, v91.eggReward, v91.eggamount);
				end;
				
				Signal.Fire("Mined Coin", p15);
			end;
		end)();

		local v122 = v101;
		if string.find(l__Name__20, "Chest") and Mastery.HasPerk(p15, "Chests", 3) then
			v122 = v122 * 2.5;
		elseif l__Name__20 == "Crate" and Mastery.HasPerk(p15, "Crates", 3) then
			v122 = v122 * 2.5;
		elseif l__Name__20 == "Present" and Mastery.HasPerk(p15, "Presents", 3) then
			v122 = v122 * 2.5;
		elseif (l__Name__20 == "Coins" or l__Name__20 == "Tiny Coins" or l__Name__20 == "Large Coins") and Mastery.HasPerk(p15, "Coin Piles", 3) then
			v122 = v122 * 2.5;
		elseif (l__Name__20 == "Vault" or l__Name__20 == "Safe") and Mastery.HasPerk(p15, "VaultsAndSafes", 3) then
			v122 = v122 * 2.5;
		elseif string.find(l__Name__20, "Diamonds") and Mastery.HasPerk(p15, "Diamond Piles", 3) then
			v122 = v122 * 2.5;
		end;
        LootBags.Progress(p15, v122, l__p__19, {
            blastRadius = v94
        }, v87.n);
	end;
    
	if v102.incr.lastTickGoal <= os.clock() - v102.incr.lastTick then
		(function()
			v102.incr.lastTick = os.clock();
			v102.incr.lastTickGoal = v84();
			local v122 = math.max(v85 - v102.incr.lastDamage, 0);
			v102.incr.lastDamage = v85;
			if v122 > 0 then
				local v123 = {
					name = l__n__90, 
					area = l__a__92, 
					breakType = "Random"
				};
				local v124 = CalculateReward(p15, v122 / 2, "Diamonds", v87.pets, {
					coinInfo = v123, 
					avgPetLevel = v100, 
					disableScaling = true
				} );
				local v125 = u4:NextInteger(1, math.max(v99, 3) * v91.orbsRandom.amountMult);
				local u23 = math.max(math.round(CalculateReward(p15, v122 / 2, l__currencyType__18, v87.pets, {
					coinInfo = v123, 
					avgPetLevel = v100
				} ) / v125 ^ 0.75), 1);
				coroutine.wrap(function()
					for v126 = 1, v125 do
						Orbs.Add(p15, l__p__19, l__currencyType__18, u23, {
							BlastRadius = v94
						});
						Functions.Wait(u4:NextNumber(0, math.min(v126 / 250, 0.075)));
					end;
				end)();
				coroutine.wrap(function()
					if u4:NextNumber() < 0.125 + v95 * 0.05 then
						Orbs.Add(p15, l__p__19, "Diamonds", v124, {
							BlastRadius = v94
						});
					end;
				end)();
                --[[coroutine.wrap(function()
                    local Rand = u4:NextInteger(1, 3)
                    local Calc = CalculateReward(p15, v122 / 10, "Easter Coins", v87.pets, {
                        coinInfo = v123, 
                        avgPetLevel = v100, 
                        disableScaling = true
                    })
                    for v129 = 1, Rand do
                        Orbs.Add(p15, l__p__19, "Easter Coins", Calc, {
                            BlastRadius = v94
                        });
                        Functions.Wait(u4:NextNumber(0, math.min(v129 / 290, 0.075)));
                    end
                end)()]]--
			end;
		end)();
	end;
end;
function v1.Farm(p16, p17, p18)
	if not Saving.Get(p18, false) then
		return;
	end;
	local v130, v131 = Pets.Get(p17);
	if not v130 then
		return;
	end;
	if not v131 or p18 and v131 ~= p18 then
		return;
	end;
	local v132 = v1.Get(p16);
	if not v132 then
		return;
	end;
	if not Functions.SearchArray(v132.pets, p17) then
		return;
	end;
	if Functions.SearchArray(v132.petsFarming, p17) then
		return;
	end;
	table.insert(v132.petsFarming, p17);
	local u24 = v130;
	local u25 = v131;
	-- DEBUG
	coroutine.wrap(function()
		while (function()
				return v1.Get(p16) and (Functions.SearchArray(v132.pets, p17) and (Functions.SearchArray(v132.petsFarming, p17) and v132.h > 0));
			end)() and (function()
				local v133, v134 = Pets.Get(p17);
				u24 = v133;
				u25 = v134;
				return u24 and (u25 and Pets.IsEquipped(p18, u24.uid)) --u24.e);
			end)() do
			v1.Damage(p16, p17);
			wait(0.5);		
		end;
	end)()
end;
function v1.Join(p19, p20, p21)
	if not Pets then
		return
	end
	if not Saving.Get(p21, false) then
		return;
	end;
	local v135, v136 = Pets.Get(p20);
	if not v135 then
		warn("Failed to get pet id -- " .. p20);
	end;
	if not v136 or p21 and v136 ~= p21 then
		return;
	end;
	local v137 = v1.Get(p19);
	if not v137 then
		return;
	end;
	local v138 = Directory.Coins[v137.n];
	local v139 = #v137.pets;
	if not Worlds.HasArea(v136, v137.a)then
		return;
	end;
	if Functions.SearchArray(v137.pets, p20) then
		return;
	end;
	for v140, v141 in pairs(u3) do
		for v142, v143 in pairs(v141) do
			for v144, v145 in pairs(v143) do
				if Functions.SearchArray(v145.pets, p20) and not v1.Leave(v144, p20, p21) then
					return;
				end;
			end;
		end;
	end;
	table.insert(v137.pets, p20);
	v1.NetworkEvent(p19, "Pets");
	return true;
end;
function v1.Leave(p22, p23, p24)
	if not Saving.Get(p24, false) then
		return;
	end;
	local v146, v147 = Pets.Get(p23);
	if not v146 then
		return;
	end;
	if not v147 or p24 and v147 ~= p24 then
		return;
	end;
	local v148 = v1.Get(p22);
	if not v148 then
		return;
	end;
	for v149, v150 in ipairs(v148.pets) do
		if v150 == p23 then
			table.remove(v148.pets, v149);
			break;
		end;
	end;
	for v151, v152 in ipairs(v148.petsFarming) do
		if v152 == p23 then
			table.remove(v148.petsFarming, v151);
			break;
		end;
	end;
	v1.NetworkEvent(p22, "Pets");
	return true;
end;
function v1.Update()
    for v153, v154 in ipairs(l____WORLDS__2:GetChildren()) do
        local l__Name__155 = v154.Name;
        if Directory.Worlds[l__Name__155] then
            local l__spawns__156 = Directory.Worlds[l__Name__155].spawns;
            if l__spawns__156 and not u3[l__Name__155] then
                u3[l__Name__155] = {};
                for v157, v158 in pairs(l__spawns__156) do
                    u3[l__Name__155][v157] = {};
                end;
            end;
        end
    end;
    for v159, v160 in pairs(u3) do
		if not Shared.IsTradingPlaza or v159 == "Trading Plaza" then
			local v161 = Directory.Worlds[v159];
			for v165, v166 in pairs(v160) do
				local v167 = times[v165];
				local l__maxCoins__168 = v161.spawns[v165].settings.maxCoins;
				local v169 = Functions.DictionaryLength(v166);
				if v169 < l__maxCoins__168 and (not v167 or not (os.clock() - v167 < 10)) then
					for v170 = 1, l__maxCoins__168 - v169 do
						v1.Create(v159, v165);
						Heartbeat();
					end;
				end;
			end
		end;
	end;
end;
function v1.NetworkEvent(p25, p26, ...)
	local v171 = { ... };
	local v172 = v1.Get(p25);
	if v172 and v172.w then
		for v173, v174 in ipairs((Worlds.GetNetworkList(v172.w))) do
			coroutine.wrap(function()
				if p26 == "Pets" then
					Network.Fire("Update Coin Pets", v174, p25, v172.pets);
					return;
				end;
				if p26 == "Health" then
					Network.Fire("Update Coin Health", v174, p25, v172.h);
					return;
				end;
				if p26 == "Remove" then
					Network.Fire("Remove Coin", v174, p25);
					return;
				end;
				if p26 == "Damage" then
					local v175, v176, v177 = unpack(v171);
					Network.Fire("Damage Coin", v174, p25, v175, v176, v177);
				end;
				if p26 == "Special Bonus" then
					return;
				end;
			end)();
		end;
	end
end;
Network.Invoked("Join Coin").OnInvoke = function(p27, p28, p29)
	if type(p29) ~= "table" then
		return v1.Join(p28, p29);
	end;
	local v178 = {};
	for v179, v180 in ipairs(p29) do
		v178[v180] = v1.Join(p28, v180, p27);
	end;
	return v178;
end;
Network.Invoked("Leave Coin").OnInvoke = function(p30, p31, p32)
	if type(p32) ~= "table" then
		return v1.Leave(p31, p32);
	end;
	local v181 = {};
	for v182, v183 in ipairs(p32) do
		v181[v183] = v1.Leave(p31, v183, p30);
	end;
	return v181;
end;
Network.Fired("Farm Coin"):Connect(function(p33, p34, p35)
	--print('aaa',p34,p35,p33)
	v1.Farm(p34, p35, p33);
end);
Network.Invoked("Get Coins").OnInvoke = function(p36)
	local v184 = Saving.Get(p36, false);
	if not v184 then
		return;
	end;
	local l__World__185 = v184.World;
	local v186 = {};
	if u3[l__World__185] then
		for v187, v188 in pairs(u3[l__World__185]) do
			for v189, v190 in pairs(v188) do
				v186[v189] = v190;
			end;
		end;
	end;

	return v186;
end;
Network.Invoked("Coins: Get Test").OnInvoke = function(p1,p6)
	local v184 = Saving.Get(p1, false);
	if not v184 then
		return;
	end;

	local l__World__185 = v184.World;
	local v186 = {};
	if u3[l__World__185] then
		for v187, v188 in pairs(u3[l__World__185]) do
			for v189, v190 in pairs(v188) do
				v186[v189] = v190;
			end;
		end;
	end;

	return v186[p6];
end
local function u26(p37)
	for v191, v192 in pairs(u3) do
		for v193, v194 in pairs(v192) do
			for v195, v196 in pairs(v194) do
				if Functions.SearchArray(v196.pets, p37) then
					local v197 = v1.Leave(v195, p37);
					return;
				end;
			end;
		end;
	end;
end;
Signal.Fired("Pet Unequipped"):Connect(function(p38, p39)
	u26(p38);
end);
Signal.Fired("Pet Deleted"):Connect(function(p40, p41)
	u26(p40);
end);
coroutine.wrap(function()
	while true do
		v1.Update();
		wait(1);	
	end;
end)();
-- DEBUG
function GarbageCleanup()
	local v198 = 0;
	for v202, v203 in pairs(u3) do
		for v207, v208 in pairs(v203) do
			for v212, v213 in pairs(v208) do
				local v214 = #v213.pets - -1;
				for i = 1, #v213.pets do
					if (v198 + 1) % 25 == 0 then
						Heartbeat();
					end;
					local v215 = v213.pets[v214];
					local v216, v217 = Pets.Get(v215);
					local v218 = Saving.Get(v217, false);
					if v216 then
						if v217 then
							if Pets.IsEquipped(v217,v216.uid) then --v216.e then
								if v218 then
									if v218.World ~= v202 then
										table.remove(v213.pets, v214);
										for v222, v223 in ipairs(v213.petsFarming) do
											if v223 == v215 then
												table.remove(v213.petsFarming, v222);
												break;
											end;
										end
									end;
								else
									table.remove(v213.pets, v214);
									for v222, v223 in ipairs(v213.petsFarming) do
										if v223 == v215 then
											table.remove(v213.petsFarming, v222);
											break;
										end;
									end
								end;
							else
								table.remove(v213.pets, v214);
								for v222, v223 in ipairs(v213.petsFarming) do
									if v223 == v215 then
										table.remove(v213.petsFarming, v222);
										break;
									end;
								end
							end;
						else
							table.remove(v213.pets, v214);
							for v222, v223 in ipairs(v213.petsFarming) do
								if v223 == v215 then
									table.remove(v213.petsFarming, v222);
									break;
								end;
							end
						end;
					else
						table.remove(v213.pets, v214);
						for v222, v223 in ipairs(v213.petsFarming) do
							if v223 == v215 then
								table.remove(v213.petsFarming, v222);
								break;
							end;
						end
					end;
				end
			end			
		end
		---
	end
end;
game.Players.PlayerRemoving:Connect(function(p42)
	GarbageCleanup();
end);
coroutine.wrap(function()
	while true do
		GarbageCleanup();
		wait(1);	
	end;
end)();
function LogCheater(p43)
	Datastore.Update("Autofarm_" .. Settings.StatsVersion, "V1", function(p44)
		if not p44 then
			p44 = {};
		end;
		if not Functions.SearchArray(p44, p43.Name) then
			table.insert(p44, p43.Name);
		end;
		return p44;
	end);
end;
local u27 = {};
coroutine.wrap(function()
	local function u28(p45)
		if u27[p45] then
			u27[p45] = u27[p45] + 1;
		else
			u27[p45] = 1;
		end;
		if u27[p45] >= 3 then
			p45:Kick();
		end;
	end;
	coroutine.wrap(function()
		while true do
			wait(1);
			for v224, v225 in pairs(plyrcoindat2) do
				if v225 >= 12 then
					u28(v224);
				end;
			end;
			plyrcoindat2 = {};		
		end;
	end)();
	coroutine.wrap(function()
		while true do
			wait(60);
			u27 = {};		
		end;
	end)();
	game.Players.PlayerRemoving:Connect(function(p46)
		u27[p46] = nil;
		plyrcoindat2[p46] = nil;
	end);
end)();
return v1;
  -  Editar
  04:54:13.835    -  Editar
  04:54:13.835  ----- [2532] ServerScriptService.Library.Eggs -----  -  Editar
  04:54:13.835  local Library = game:GetService("ReplicatedStorage"):WaitForChild("Library")
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local Network = require(game:GetService("ServerScriptService"):WaitForChild("Library").Network)

local Settings = require(script.Parent.Settings)
local Saving = require(script.Parent.Saving)
local Gamepasses = require(script.Parent.Gamepasses)
local Directory = require(Library.Directory)
local Pets = require(script.Parent.Pets)
local Shared = require(Library.Shared)
local Mastery = require(script.Parent.Mastery)
local Boosts = require(script.Parent.Boosts)
local Upgrades = require(script.Parent.Upgrades)
local Achievements = require(script.Parent.Achievements)
local Worlds = require(script.Parent.Worlds)
local ServerBoosts = require(script.Parent.ServerBoosts)
local Fruit = require(script.Parent.Fruit)
local Variables = require(game.ReplicatedStorage.Library.Variables)

local Eggs = {}
local luckyID = Directory.Gamepasses.Lucky.ID
local mythicalHunterID = Directory.Gamepasses["Mythical Hunter"].ID
local magicEggsID = Directory.Gamepasses["Magic Eggs"].ID
local RNG = Random.new()
local tripleHatchID = Directory.Gamepasses["Triple Egg Open"].ID
local u12 = {}
local rarityData = {
	["Basic"] =      {"Basic", "Rare", "Epic", "Legendary", "Mythical", "Secret", "Event", "Exclusive"},
	["Rare"] =       {"Rare", "Epic", "Legendary", "Mythical", "Secret", "Event", "Exclusive"},
	["Epic"] =       {"Epic", "Legendary", "Mythical", "Secret", "Event", "Exclusive"},
	["Legendary"] =  {"Legendary", "Mythical", "Secret", "Event", "Exclusive"},
	["Mythical"] =   {"Mythical", "Secret", "Event", "Exclusive"},
	["Secret"] =     {"Secret", "Event", "Exclusive"},
	["Event"] =      {"Event", "Exclusive"},
	["Exclusive"] =  {"Exclusive"}
}

function isOnlyExclusives(drops)
	local isExclusive = true
	for i, v in pairs(drops) do
		if not isExclusive then
			break
		end
		
		local petId, petChance = unpack(drops)
		local petDir = Directory.Pets[petId]
		if petDir then
			if petDir.rarity ~= "Exclusive" or petDir.rarity ~= "Event" then
				isExclusive = false
				break
			end
		end
	end
	
	return isExclusive
end

function Eggs.Open(plr, egg, amountOpening, customDrops, customPetData, giftEggId, isAnimation)
	--giftEggId = typeof(giftEggId) == "string" and giftEggId or giftEggId == true and "Cracked Egg" or nil
	if giftEggId == true then
		giftEggId = "Cracked Egg"
	end
	egg = egg and egg or customDrops and "Cracked Egg" or nil
	
	local save = Saving.Get(plr)
	if not save then
		return
	end
	
	local eggDir = Directory.Eggs[egg]
	local isGolden = eggDir.isGolden
	local eggDrops = eggDir.drops
	if type(eggDrops) == "string" then
		eggDrops = Directory.Eggs[eggDrops].drops
	end	
	
	local isExclusiveEgg = isOnlyExclusives(eggDrops)

	if not isExclusiveEgg then
		if Shared.IsHardcore and save.Hardcore.World == "Dog" or save.World == "Dog" then
			table.insert(eggDrops, {"623", 0.0001})
		end
		table.insert(eggDrops, {"6969", 0.001})
	end	

	for i, v in pairs(eggDrops) do
		if v[3] == true and Shared.IsHardcore then
			table.insert(eggDrops, v)
		end
	end

	local drops = Functions.CloneTable(customDrops and customDrops or eggDrops)
	local ownsMythicalHunter = Gamepasses.Owns(plr, mythicalHunterID)
	local ownsMagicEggs = Gamepasses.Owns(plr, magicEggsID)
	local legendaryPetsMult = Upgrades.Get(plr, "Halloween Legendary Pets")
	local mythicalPetsMult = Upgrades.Get(plr, "Halloween Mythical Pets")
    local masteryEggPerk = isGolden and "Golden Eggs" or "Eggs" 
	local fruitDir = Directory.Fruits["Banana"]
	local banana = Fruit.Get(plr, Directory.Fruits["Banana"])
	local bonus = Fruit.GetBonus(plr, fruitDir)
	if tonumber(bonus) and (bonus < 1 and bonus > 0) then
		bonus = bonus + 1
	end
	
	local boostOdds = 0
	if Boosts.Has(plr, "Super Lucky") then
		boostOdds = boostOdds + Settings.SuperLuckyMult or 0
	end
	if Boosts.Has(plr, "Ultra Lucky") then
		boostOdds = boostOdds + Settings.UltraLuckyMult or 0
	end
	if Gamepasses.Owns(plr, luckyID) then
		boostOdds = boostOdds + Settings.LuckyPassMult or 0
	end
	if ServerBoosts.IsActive(plr, "Super Lucky") then
		boostOdds = boostOdds + Settings.SuperLuckyMult or 0
	end
	if ServerBoosts.IsActive(plr, "Insane Luck") then
		boostOdds = boostOdds + 25
	end
	if banana >= 1 then
		boostOdds = boostOdds + (bonus or 0)
	end

	local function increaseOdds(odds)
		local overallChance = 0
		for key, drop in pairs(drops) do
			local petId, petChance = unpack(drop)
			overallChance = overallChance + petChance
		end
		for key, drop in pairs(drops) do
			local petId, petChance = unpack(drop)
			if petChance / overallChance <= 0.05 then
				local dropData = drops[key]
				dropData[2] = dropData[2] * odds
			end
		end
	end
	
	local function increaseRarityOdds(rarity, odds)
		for key, drop in pairs(drops) do
			local petId, petChance = unpack(drop)
			if Directory.Pets[petId].rarity == rarity then
				local dropData = drops[key]
				dropData[2] = dropData[2] * odds
			end
		end
	end
	
	local function addBoostedOdds()
		if boostOdds > 0 then
			increaseOdds(boostOdds)
		end
		if ownsMythicalHunter then
			increaseRarityOdds("Mythical", Settings.MythicalHunterMult)
		end
		if legendaryPetsMult > 0 then
			increaseRarityOdds("Legendary", 1 + legendaryPetsMult * 0.2)
		end
		if mythicalPetsMult > 0 then
			increaseRarityOdds("Mythical", 1 + mythicalPetsMult * 0.2)
		end
		if Mastery.HasPerk(plr, masteryEggPerk, 3) then
			increaseOdds(2)
			return
		end
		if Mastery.HasPerk(plr, masteryEggPerk, 1) then
			increaseOdds(1.33)
		end
	end
	
	if not isExclusiveEgg and not eggDir.disableBoostedOdds then
		addBoostedOdds()
	end
	
	local function hatchPet()
		local petHatched, v1, v2, key = Functions.Lottery(unpack(drops))
		local petDir = Directory.Pets[petHatched]
		if not petDir then
			warn("Pet does not exist (" .. petHatched .. " from egg " .. egg .. ")")
			return false
		end
		
		local golden = false
		local rainbow = false
		local shiny = false
		local canBeGold = false
		local canBeRainbow = false
		local goldHatchOdds = eggDir.goldenChance and eggDir.goldenChance or Settings.MagicEggsChances.Golden
		local rainbowHatchOdds = eggDir.rainbowChance and eggDir.rainbowChance or Settings.MagicEggsChances.Rainbow
		local shinyHatchOdds = Settings.MagicEggsChances.Shiny
		
		if Mastery.HasPerk(plr, masteryEggPerk, 5) then
			if isGolden then
				canBeRainbow = true
				rainbowHatchOdds = rainbowHatchOdds * 1.2
			else
				canBeGold = true
				goldHatchOdds = goldHatchOdds * 1.2
			end
		end
		
		if ownsMagicEggs then
			canBeRainbow = true
			canBeGold = true
		end
		
		if canBeGold or canBeRainbow then
			local chance = RNG:NextNumber() * 100
			if chance <= rainbowHatchOdds and canBeRainbow then
				rainbow = true
			elseif chance <= goldHatchOdds and canBeGold then
				golden = true
			end
		end
		
		if not rainbow and isGolden and RNG:NextNumber(0, 100) <= Settings.GoldenEggChance then
			golden = true
		end
		
		if RNG:NextNumber(0, 100) <= shinyHatchOdds then
			shiny = true
		end
		
		--if isExclusiveEgg and not  then
		--	golden = false
		--	rainbow = false
		--end
		
		local petData = {}
		if rainbow then
			petData.r = true
		elseif golden then
			petData.g = true
		end
		if shiny then
			petData.sh = true
		end
		
		if customPetData then
			local ce = customPetData[key]
			if ce then
				for k, v in pairs(ce) do
					petData[k] = true
				end
			end
		end
		
		if Shared.IsHardcore and eggDir.hardcoreEnabled then
			if petDir.rarity ~= "Event" and petDir.rarity ~= "Exclusive" then
				petData.hc = true
			else
				petData.hc = false
			end
		end
		
		local uid, returnedPetData = Pets.Create(plr, petHatched, petData, nil, nil, nil, true)
		if not uid then
			return false
		end
		
		Signal.Fire("Hatched Pet", plr, egg, returnedPetData)
		
		local rarity = petDir.rarity
		coroutine.wrap(function()
			Functions.Wait(3)
			if not isAnimation then
				RareHatchChatMessage(uid, petData)
			end	
			if petDir.titanic then
				Achievements.Add(plr, "Titanic Pets", 1)
			end
			if rarity == "Rare" then
				Achievements.Add(plr, "Rare Pets", 1)
				return
			end
			if rarity == "Epic" then
				Achievements.Add(plr, "Epic Pets", 1)
				return
			end
			if rarity == "Legendary" then
				Achievements.Add(plr, "Legendary Pets", 1)
				return
			end
			if rarity == "Mythical" then
				Achievements.Add(plr, "Mythical Pets", 1)
				return
			end
			if rarity == "Secret" then
				Achievements.Add(plr, "Secret Pets", 1)
				return
			end
			if rarity == "Exclusive" then
				Achievements.Add(plr, "Exclusive Pets", 1)
			end
		end)()
		return returnedPetData, key
	end
	
	local plrPosition = plr.Character.HumanoidRootPart.Position
	
	local chances = {}
	local hatchedPets = {}
	local positionData = {}
	for index = 1, amountOpening do
		local hatchedPetData, key = hatchPet()
		if hatchedPetData then
			local petId, petChance = unpack(drops[key])
			chances[index] = petChance
			table.insert(hatchedPets, hatchedPetData)
			table.insert(positionData, plrPosition + Vector3.new(0, math.rad(index), 0))
		end
	end

	local autoDeleteEnabled = Network.Invoke("Auto Delete Enabled", plr)
	coroutine.wrap(function()
		task.delay(3.5, function()
			if autoDeleteEnabled then
				local toDelete = {}
				local save = Saving.Get(plr) 
				if save and save.AutoDelete then
					for _, pet in ipairs(hatchedPets) do
						local dir = Directory.Pets[pet.id]
						local rarity = dir.rarity
						local alwaysKeepSettings = save.AutoHatchSettings.AlwaysKeep

						local function allowDelete()
							local delete = true

							if pet.sh then
								local set = rarityData[alwaysKeepSettings.ShinyPets]
								if set then
									if table.find(set, rarity) then
										delete = false
									end
								end
							end

							if pet.r then
								local set = rarityData[alwaysKeepSettings.RainbowPets]
								if set then
									if table.find(set, rarity) then
										delete = false
									end
								end
							end

							if pet.g then
								local set = rarityData[alwaysKeepSettings.GoldPets]
								if set then
									if table.find(set, rarity) then
										delete = false
									end
								end
							end

							return delete
						end

						if save.AutoDelete[rarity] then
							local allowDelete = allowDelete()
							if allowDelete then
								table.insert(toDelete, pet.uid)
							end
						end
					end
				end

				if #toDelete > 0 then
					local success, response = Signal.Invoke("Delete Several Pets", plr, toDelete)
					if not success then
						Network.Fire("Message", "Error:  " .. response)
					end
				end
			end
		end)
	end)()
	
	if isAnimation then
		local positions = Network.Invoke("Exclusive Eggs: Compute Positions", plr, amountOpening, positionData)
		Network.FireAll("Exclusive Eggs: Animation", plr, plrPosition, giftEggId, hatchedPets, positions, chances)
	else	
		Network.Fire("Open Egg", plr, egg, hatchedPets)
	end	
	
	if giftEggId ~= "Cracked Egg" then
		local giftDir = Directory.Pets[giftEggId]
		if giftDir and giftDir.isGift then
			if giftDir.giftCallback then
				giftDir.giftCallback(plr, nil)
			end
		end
	end
	
	return true
end

function Eggs.Buy(p7, p8, p9, octuple)
	local v42 = Saving.Get(p7)
	local v43 = Directory.Eggs[p8]
	if not v42 or not v43 then
		return false
	end
	local v44
	if octuple then
		v44 = 8
	elseif p9 then
		v44 = 3
	else
		v44 = 1
	end
	local cost = Shared.IsHardcore and v43.hardcoreCost and v43.hardcoreCost or v43.cost
	local v45 = cost * v44
	local l__currency__46 = v43.currency
	local l__area__47 = v43.area
	local l__areaRequired__48 = v43.areaRequired
	local l__areaEggsRequired__49 = v43.areaEggsRequired
	if not v43.hatchable or v43.disabled then
		return false
	end

	local cur = Shared.IsHardcore and v42.HardcoreCurrency[l__currency__46] or v42[l__currency__46]

	local v50 
	if v43.isGolden then
		v50 = "Golden Eggs"
	else
		v50 = "Eggs"
	end
	if Mastery.HasPerk(p7, v50, 4) then
		local v51
		if v43.isGolden then
			v51 = 0.85
		else
			v51 = 0.8
		end
		v45 = v45 * v51
	elseif Mastery.HasPerk(p7, v50, 2) then
		local v52
		if v43.isGolden then
			v52 = 0.95
		else
			v52 = 0.9
		end
		v45 = v45 * v52
	end
	local v53 = math.round(v45)
	if not Gamepasses.Owns(p7, tripleHatchID) and p9 then
		return false, "You do not own Triple Eggs Gamepass"
	end
	if not v42.OwnsOctupleEggs and octuple then
		return false, "You do not own Octuple Eggs Gamepass"
	end
	local v54, v55 = Eggs.IsUnlocked(p7, p8)
	if not v54 then
		return false, v55
	end
	if cur < v53 then
		return false, "You need " .. Functions.Commas(v53 - cur) .. " more " .. l__currency__46 .. " to buy this egg!"
	end
	if v42.MaxSlots <= #v42.Pets + (v44 - 1) then
		return false, "Your inventory is full!"
	end
	if u12[p7] then
		return false, "You are doing this too quickly!"
	end
	coroutine.wrap(function()
		u12[p7] = true
		Functions.Wait(0.75)
		u12[p7] = nil
	end)()
	if not Eggs.Open(p7, p8, v44) then
		return
	end

	if Shared.IsHardcore then
		v42.HardcoreCurrency[l__currency__46] = v42.HardcoreCurrency[l__currency__46] - v53
	else
		v42[l__currency__46] = v42[l__currency__46] - v53
	end

	if not v42.EggsOpened[p8] then
		v42.EggsOpened[p8] = 0
	end
	local l__EggsOpened__56 = v42.EggsOpened
	l__EggsOpened__56[p8] = l__EggsOpened__56[p8] + v44
	Achievements.Add(p7, "Open Eggs", v44)
	if v43.isGolden then
		Mastery.Progress(p7, "Golden Eggs", v44 * 75)
	else
		Mastery.Progress(p7, "Eggs", v44 * 75)
	end
	return true
end

function Eggs.IsUnlocked(p10, p11)
	local v57 = nil
	local v58 = Saving.Get(p10)
	v57 = Directory.Eggs[p11]
	if not v58 or not v57 then
		return false
	end
	local l__area__59 = v57.area
	local l__eggRequired__60 = v57.eggRequired
	local l__eggRequiredOpenAmount__61 = v57.eggRequiredOpenAmount
	if v57.areaRequired and not Worlds.HasArea(p10, l__area__59) then
		return false, "You must have the " .. l__area__59 .. " Area unlocked."
	end
	if l__eggRequired__60 and l__eggRequired__60 ~= "" and l__eggRequired__60 ~= p11 and not Eggs.IsUnlocked(p10, l__eggRequired__60) then
		return false, "You must have the " .. Directory.Eggs[l__eggRequired__60].displayName .. " unlocked."
	end
	if l__eggRequiredOpenAmount__61 and l__eggRequiredOpenAmount__61 > 0 and l__eggRequired__60 and l__eggRequired__60 ~= "" then
		local v62 = v58.EggsOpened[l__eggRequired__60]
		if not v62 or v62 < l__eggRequiredOpenAmount__61 then
			return false, "You need to open " .. l__eggRequiredOpenAmount__61 - v62 .. " more " .. Directory.Eggs[l__eggRequired__60].displayName .. "."
		end
	end
	return true
end

local messaging = game:GetService("MessagingService")
function RareHatchChatMessage(uid, extraData)
	local pet, owner = Pets.Get(uid)
	if not pet or not pet.id or not owner then
		return
	end

	local msg, color, announce = Shared.HatchMessage(pet, owner)

	if announce then
		if pet.rarity == "Exclusive" and Directory.Pets[pet.id].titanic then
			messaging:PublishAsync("Titanic Hatched", {msg = msg, color = color, hatchedby = owner.Name})
		end

		Network.FireAll("Chat Msg", msg, color)
	end    
end

messaging:SubscribeAsync("Titanic Hatched", function(data)
	if data then		
		local chatd = data.Data
		if game.Players:FindFirstChild(chatd.hatchedby) then return end
		Network.FireAll("Chat Msg", '[Global] '..chatd.msg, chatd.color)
	end
end)

Network.Invoked("Buy Egg").OnInvoke = function(p14, p15, p16, octuple)
	if not Shared.ValidateEgg(p14, p15, 100) then
		return false, "You're too far from the egg!"
	end

	return Eggs.Buy(p14, p15, p16, octuple)
end

return Eggs
  -  Editar
  04:54:13.835    -  Editar
  04:54:13.835  ----- [2533] ServerScriptService.Library.Quests -----  -  Editar
  04:54:13.835  -- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local Library = ReplicatedStorage:WaitForChild("Library")
local ServerLibrary = ServerScriptService:WaitForChild("Library")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Directory = require(Library.Directory);
local Saving = require(ServerLibrary.Saving);
local questTypes = require(Types.Quests);
local Shared = require(Library.Shared);
local Functions = require(Library.Functions);
local Network = require(ServerLibrary.Network);
local Signal = require(Library.Signal)
local Give = require(ServerLibrary.Give)

local Quests = {
	Directory = Directory.Quests
};

function Quests.Get(plr, p1, p2)
	assert(Directory.Areas[p1]);
	assert(Directory.Quests[p1][p2]);
	local save = Saving.Get(plr);
	if not save then
		return Quests.DefaultData;
	end;
	local v6 = Shared.IsHardcore and save.HardcoreQuests or save.Quests; 
	local v7 = v6[p1];
	if not v7 then
		return Quests.DefaultData;
	end;
	local v8 = v7[p2];
	if v8 then
		return v8;
	end;
	return Quests.DefaultData;
end;
function Quests.GetPoints()
	local v9 = Saving.Get();
	if not v9 then
		return 0;
	end;
	return v9["Quest Points"] or 0;
end;
Network.Fired("Quests: Update"):Connect(function(p5, p6, p7)
	local v18 = Saving.Get();
	if not v18 then
		return;
	end;
	local v19 = v18.Quests;
	if Shared.IsHardcore then
		v19 = v18.HardcoreQuests;
	end;
	local v20 = v19[p5];
	if not v20 then
		v20 = {};
		v19[p5] = v20;
	end;
	assert(v20);
	v20[p6] = p7;
end);

function Quests.Update(plr, area, quest, adding)
	assert(Directory.Areas[area]);
	assert(Directory.Quests[area][quest]);
	adding = adding or 1

	local questData = Quests.Directory[area][quest]
	if not questData then
		return nil
	end

	local questData = Quests.Get(plr, area, quest)
	if not questData then
		return nil
	end

	local tierData = questTypes.Tiers[questData.Tier]
	if not tierData then
		return nil
	end

	--- this quest has already been completed!
	if questData.c then
		return true
	end

	questData.v = questData.v + adding

	local updateData = {}
	if questData.v >= questData.Amount then
		questData.c = true
		Give.Currency(plr, tierData.Points, "Quest Points")
	end

	Network.Fire("Quests: Update", plr, area, quest, questData)
end

function Quests.Complete()

end

--function Quests.Check(plr, arg, extraData) 
--	local areasData = {}
-- 	for i, v in pairs(Quests.Directory) do
--		areasData[i] = v
--	end
--	
--	local checkQuests = {}
--	for i, v in pairs(areasData) do
--		if v[arg] then
--			if arg == "Eggs" then
--				local eggData = v.Egg
--				if eggData then
--					for index, value in pairs(eggData) do
--						local d = extraData[index]
--						if d then
--							if d == value then
--								checkQuests[i] = v
--							end
--						end
--					end
--				end
--				return
--			end
--			
--		end
--	end
--	
--	warn(checkQuests)
--end

function Quests.Check(plr, quest, extraData)
	local dir = Quests.Directory
	
	--for i, v in pairs(dir) do
	--	local v2 = i:find("2") ~= nil
	--	if v2 then
	--		
	--	end
	--end
	
	local checkedQuests = {}
	for area, areaQuestData in pairs(dir) do
		for questName, questData in pairs(areaQuestData) do
			if quest == questName then
				
			end
		end
	end
	
	return checkedQuests
end

Signal.Fired("Quests: Complete"):Connect(function(p8, p9, p10)
	assert(Directory.Quests[p9][p10]);
end);

return Quests;
